<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="geolocation=()">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">

    <!-- Supabase Integration for Chat -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // ============================================
        // SUPABASE CLIENT INITIALIZATION
        // ============================================
        const SUPABASE_URL = 'https://kwssgfanbntfjdclchfi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3c3NnZmFuYm50ZmpkY2xjaGZpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzNjM4ODUsImV4cCI6MjA3MDkzOTg4NX0.zPKcOwWdWu3-7ii19c2ep6g2i-kCTaUBZablTYDgZwA';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        window.supabaseClient = supabaseClient; // Store globally to prevent duplicate initialization

        // ============================================
        // CLOUDFLARE UPLOAD FUNCTIONS
        // ============================================
        const CLOUDFLARE_UPLOAD_ENDPOINT = 'https://nlis-image-upload.kiggundumuhamad.workers.dev';
        const CLOUDFLARE_BASE_URL = 'https://data.geospatialnetworkug.xyz/';

        async function uploadToCloudflare(file, folder, filename) {
            try {
                if (!file) throw new Error('No file provided');
                if (file.size > 20 * 1024 * 1024) throw new Error('File size exceeds 20MB limit');

                const fullPath = `${folder}/${filename}`;
                const response = await fetch(`${CLOUDFLARE_UPLOAD_ENDPOINT}/${fullPath}`, {
                    method: 'PUT',
                    body: file,
                    headers: { 'Content-Type': file.type }
                });

                if (!response.ok) throw new Error(`Upload failed: ${response.statusText}`);
                const result = await response.json();
                return result.previewUrl || `${CLOUDFLARE_BASE_URL}${fullPath}`;
            } catch (error) {
                console.error('[CLERK] Upload error:', error);
                throw error;
            }
        }

        async function uploadPassportPhoto(file, parcelId, ownerType, ownerNumber) {
            const folder = ownerType === 'previous'
                ? 'images/owners_photo/passports/previous'
                : 'images/owners_photo/passports/individual';
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `${parcelId}_owner${ownerNumber || ''}_${timestamp}.jpg`;
            return await uploadToCloudflare(file, folder, filename);
        }

        async function uploadSalesAgreement(file, parcelId, docType) {
            const folder = docType === 'previous'
                ? 'images/owners_photo/agreements/previous'
                : 'images/owners_photo/agreements/sales';
            const timestamp = new Date().toISOString().split('T')[0];
            const ext = file.name.split('.').pop();
            const filename = `${parcelId}_${docType}_agreement_${timestamp}.${ext}`;
            return await uploadToCloudflare(file, folder, filename);
        }

        async function uploadSpecialDocument(file, parcelId, docType) {
            let folder;
            switch (docType) {
                case 'death_certificate':
                    folder = 'images/owners_photo/inheritance/death_certificates';
                    break;
                case 'will':
                    folder = 'images/owners_photo/inheritance/wills';
                    break;
                case 'gift_deed':
                    folder = 'images/owners_photo/agreements/gift_deeds';
                    break;
                case 'court_order':
                    folder = 'images/owners_photo/agreements/court_orders';
                    break;
                case 'incorporation':
                    folder = 'images/owners_photo/company_docs/incorporation';
                    break;
                case 'board_resolution':
                    folder = 'images/owners_photo/company_docs/resolutions';
                    break;
                case 'sales_agreement':
                    folder = 'images/owners_photo/agreements/sales';
                    break;
                default:
                    folder = 'images/owners_photo/other';
            }

            const timestamp = new Date().toISOString().split('T')[0];
            const ext = file.name.split('.').pop();
            const filename = `${parcelId}_${docType}_${timestamp}.${ext}`;
            return await uploadToCloudflare(file, folder, filename);
        }

        // ============================================
        // LAND CLERK SYSTEM - CORE FUNCTIONS
        // ============================================

        async function checkClerkRole() {
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) {
                    document.getElementById('clerkBtn').style.display = 'none';
                    return false;
                }

                const userRole = user.user_metadata?.role || user.app_metadata?.role;
                if (userRole === 'LAND_CLERK' || userRole === 'ADMIN') {
                    document.getElementById('clerkBtn').style.display = 'inline-flex';
                    return true;
                } else {
                    document.getElementById('clerkBtn').style.display = 'none';
                    return false;
                }
            } catch (error) {
                console.error('[CLERK] Role check error:', error);
                document.getElementById('clerkBtn').style.display = 'none';
                return false;
            }
        }

        function openClerkModal() {
            document.getElementById('clerkModal').style.display = 'flex';
            loadClerkTab('register');
        }

        function closeClerkModal() {
            document.getElementById('clerkModal').style.display = 'none';
        }

        function loadClerkTab(tabName) {
            const content = document.getElementById('clerkContent');

            switch (tabName) {
                case 'register':
                    // Reset state and start from step 1
                    registrationState.currentStep = 1;
                    renderCurrentStep();
                    break;

                case 'transfer':
                    renderTransferTab(content);
                    break;

                case 'search':
                    renderSearchTab(content);
                    break;
            }
        }

        // ============================================
        // PHASE 2: REGISTRATION STATE & WORKFLOW
        // ============================================
        const registrationState = {
            currentStep: 1,
            totalSteps: 6,
            data: {
                parcelId: '',
                ownershipType: '',
                district: '',
                county: '',
                subcounty: '',
                parish: '',
                village: '',
                companyName: '',
                companyRegNumber: '',
                acquisitionType: '',
                previousOwners: [],
                newOwners: [],
                uploadedDocuments: []
            }
        };

        function renderCurrentStep() {
            const content = document.getElementById('clerkContent');
            switch (registrationState.currentStep) {
                case 1: renderStep1ParcelID(content); break;
                case 2: renderStep2Location(content); break;
                case 3: renderStep3Company(content); break;
                case 4: renderStep4PreviousOwner(content); break;
                case 5: renderStep5NewOwner(content); break;
                case 6: renderStep6Review(content); break;
            }
        }

        function goToStep(stepNumber) {
            if (stepNumber < 1 || stepNumber > registrationState.totalSteps) return;
            registrationState.currentStep = stepNumber;
            renderCurrentStep();
            updateProgressBar();
        }

        function updateProgressBar() {
            const steps = document.querySelectorAll('.clerk-step');
            steps.forEach((step, index) => {
                step.classList.remove('active', 'completed');
                if (index + 1 < registrationState.currentStep) {
                    step.classList.add('completed');
                } else if (index + 1 === registrationState.currentStep) {
                    step.classList.add('active');
                }
            });
        }

        // STEP 1: Parcel ID
        function renderStep1ParcelID(content) {
            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step active">1. Parcel ID</div>
                    <div class="clerk-step">2. Location</div>
                    <div class="clerk-step">3. Company</div>
                    <div class="clerk-step">4. Previous Owner</div>
                    <div class="clerk-step">5. New Owner</div>
                    <div class="clerk-step">6. Review</div>
                </div>
                <h3>Step 1: Identify Parcel</h3>
                <div class="clerk-form-group">
                    <label>Parcel ID <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="parcelIdInput" 
                        value="${registrationState.data.parcelId}" 
                        placeholder="BLB-001234, UT36N-123, UT36S-123">
                    <small style="color: #6b7280; display: block; margin-top: 4px;">
                        Enter the parcel ID from BLB-UNTITLED, UNTITLED UTM ZONE 36S, or UNTITLED UTM ZONE 36N layers
                    </small>
                    <div id="parcelValidation" style="margin-top: 8px;"></div>
                </div>
                <div class="clerk-form-group">
                    <label>Ownership Type <span class="required">*</span></label>
                    <select class="clerk-select" id="ownershipTypeSelect">
                        <option value="">Select...</option>
                        <option value="INDIVIDUAL" ${registrationState.data.ownershipType === 'INDIVIDUAL' ? 'selected' : ''}>Individual</option>
                        <option value="JOINT" ${registrationState.data.ownershipType === 'JOINT' ? 'selected' : ''}>Joint (up to 5 owners)</option>
                        <option value="COMPANY" ${registrationState.data.ownershipType === 'COMPANY' ? 'selected' : ''}>Company</option>
                    </select>
                </div>
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="closeClerkModal()">Cancel</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="validateAndProceedStep1()">Next Step →</button>
                </div>
            `;
            setTimeout(() => {
                const input = document.getElementById('parcelIdInput');
                if (input) input.addEventListener('blur', validateParcelID);
            }, 100);
        }

        async function validateParcelID() {
            const parcelId = document.getElementById('parcelIdInput').value.trim();
            const validationDiv = document.getElementById('parcelValidation');
            if (!parcelId) { validationDiv.innerHTML = ''; return false; }

            validationDiv.innerHTML = '<small style="color: #2563eb;">⏳ Checking parcel...</small>';
            try {
                const { data: existing } = await supabaseClient
                    .from('land_registrations')
                    .select('parcel_id')
                    .eq('parcel_id', parcelId)
                    .single();

                if (existing) {
                    validationDiv.innerHTML = '<small style="color: #ef4444;">❌ This parcel is already registered</small>';
                    return false;
                }

                const isValidFormat = /^(BLB|UT36N|UT36S)-\d+$/.test(parcelId);
                if (!isValidFormat) {
                    validationDiv.innerHTML = '<small style="color: #ef4444;">❌ Invalid parcel ID format</small>';
                    return false;
                }

                validationDiv.innerHTML = '<small style="color: #10b981;">✅ Parcel available for registration</small>';
                return true;
            } catch (error) {
                console.error('Parcel validation error:', error);
                validationDiv.innerHTML = '<small style="color: #6b7280;">⚠️ Could not verify parcel</small>';
                return true;
            }
        }

        async function validateAndProceedStep1() {
            const parcelId = document.getElementById('parcelIdInput').value.trim();
            const ownershipType = document.getElementById('ownershipTypeSelect').value;

            if (!parcelId) { alert('Please enter a Parcel ID'); return; }
            if (!ownershipType) { alert('Please select an Ownership Type'); return; }

            const isValid = await validateParcelID();
            if (!isValid) return;

            registrationState.data.parcelId = parcelId;
            registrationState.data.ownershipType = ownershipType;
            goToStep(2);
        }

        // STEP 2: Location
        function renderStep2Location(content) {
            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step completed">1. Parcel ID</div>
                    <div class="clerk-step active">2. Location</div>
                    <div class="clerk-step">3. Company</div>
                    <div class="clerk-step">4. Previous Owner</div>
                    <div class="clerk-step">5. New Owner</div>
                    <div class="clerk-step">6. Review</div>
                </div>
                <h3>Step 2: Location Details</h3>
                <div class="clerk-form-group">
                    <label>District <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="districtInput" 
                        value="${registrationState.data.district}" 
                        placeholder="e.g., Kampala, Wakiso, Mukono">
                </div>
                <div class="clerk-form-group">
                    <label>County <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="countyInput" 
                        value="${registrationState.data.county}" 
                        placeholder="e.g., Kyadondo, Busiro">
                </div>
                <div class="clerk-form-group">
                    <label>Subcounty <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="subcountyInput" 
                        value="${registrationState.data.subcounty}" 
                        placeholder="e.g., Makindye, Nansana">
                </div>
                <div class="clerk-form-group">
                    <label>Parish <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="parishInput" 
                        value="${registrationState.data.parish}" 
                        placeholder="e.g., Kibuye, Katwe">
                </div>
                <div class="clerk-form-group">
                    <label>Village <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="villageInput" 
                        value="${registrationState.data.village}" 
                        placeholder="e.g., Nsambya, Kabalagala">
                </div>
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="goToStep(1)">← Back</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="validateAndProceedStep2()">Next Step →</button>
                </div>
            `;
        }

        async function loadDistricts() {
            try {
                const { data, error } = await supabaseClient
                    .from('uganda_admin_boundaries')
                    .select('district')
                    .order('district');

                if (error) throw error;
                const select = document.getElementById('districtSelect');
                const districts = [...new Set(data.map(d => d.district))];

                districts.forEach(district => {
                    const option = document.createElement('option');
                    option.value = district;
                    option.textContent = district;
                    if (district === registrationState.data.district) option.selected = true;
                    select.appendChild(option);
                });

                if (registrationState.data.district) loadCounties();
            } catch (error) {
                console.error('Error loading districts:', error);
            }
        }

        async function loadCounties() {
            const district = document.getElementById('districtSelect').value;
            const countySelect = document.getElementById('countySelect');
            countySelect.innerHTML = '<option value="">Select County...</option>';
            countySelect.disabled = !district;
            if (!district) return;

            try {
                const { data, error } = await supabaseClient
                    .from('uganda_admin_boundaries')
                    .select('county')
                    .eq('district', district)
                    .order('county');

                if (error) throw error;
                const counties = [...new Set(data.map(d => d.county))];
                counties.forEach(county => {
                    const option = document.createElement('option');
                    option.value = county;
                    option.textContent = county;
                    if (county === registrationState.data.county) option.selected = true;
                    countySelect.appendChild(option);
                });

                if (registrationState.data.county) loadSubcounties();
            } catch (error) {
                console.error('Error loading counties:', error);
            }
        }

        async function loadSubcounties() {
            const district = document.getElementById('districtSelect').value;
            const county = document.getElementById('countySelect').value;
            const subcountySelect = document.getElementById('subcountySelect');
            subcountySelect.innerHTML = '<option value="">Select Subcounty...</option>';
            subcountySelect.disabled = !county;
            if (!county) return;

            try {
                const { data, error } = await supabaseClient
                    .from('uganda_admin_boundaries')
                    .select('subcounty')
                    .eq('district', district)
                    .eq('county', county)
                    .order('subcounty');

                if (error) throw error;
                const subcounties = [...new Set(data.map(d => d.subcounty))];
                subcounties.forEach(subcounty => {
                    const option = document.createElement('option');
                    option.value = subcounty;
                    option.textContent = subcounty;
                    if (subcounty === registrationState.data.subcounty) option.selected = true;
                    subcountySelect.appendChild(option);
                });

                if (registrationState.data.subcounty) loadParishes();
            } catch (error) {
                console.error('Error loading subcounties:', error);
            }
        }

        async function loadParishes() {
            const district = document.getElementById('districtSelect').value;
            const county = document.getElementById('countySelect').value;
            const subcounty = document.getElementById('subcountySelect').value;
            const parishSelect = document.getElementById('parishSelect');
            parishSelect.innerHTML = '<option value="">Select Parish...</option>';
            parishSelect.disabled = !subcounty;
            if (!subcounty) return;

            try {
                const { data, error } = await supabaseClient
                    .from('uganda_admin_boundaries')
                    .select('parish')
                    .eq('district', district)
                    .eq('county', county)
                    .eq('subcounty', subcounty)
                    .order('parish');

                if (error) throw error;
                const parishes = [...new Set(data.map(d => d.parish))];
                parishes.forEach(parish => {
                    const option = document.createElement('option');
                    option.value = parish;
                    option.textContent = parish;
                    if (parish === registrationState.data.parish) option.selected = true;
                    parishSelect.appendChild(option);
                });

                if (registrationState.data.parish) loadVillages();
            } catch (error) {
                console.error('Error loading parishes:', error);
            }
        }

        async function loadVillages() {
            const district = document.getElementById('districtSelect').value;
            const county = document.getElementById('countySelect').value;
            const subcounty = document.getElementById('subcountySelect').value;
            const parish = document.getElementById('parishSelect').value;
            const villageSelect = document.getElementById('villageSelect');
            villageSelect.innerHTML = '<option value="">Select Village...</option>';
            villageSelect.disabled = !parish;
            if (!parish) return;

            try {
                const { data, error } = await supabaseClient
                    .from('uganda_admin_boundaries')
                    .select('village')
                    .eq('district', district)
                    .eq('county', county)
                    .eq('subcounty', subcounty)
                    .eq('parish', parish)
                    .order('village');

                if (error) throw error;
                const villages = [...new Set(data.map(d => d.village))];
                villages.forEach(village => {
                    const option = document.createElement('option');
                    option.value = village;
                    option.textContent = village;
                    if (village === registrationState.data.village) option.selected = true;
                    villageSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading villages:', error);
            }
        }

        function validateAndProceedStep2() {
            const district = document.getElementById('districtInput').value.trim();
            const county = document.getElementById('countyInput').value.trim();
            const subcounty = document.getElementById('subcountyInput').value.trim();
            const parish = document.getElementById('parishInput').value.trim();
            const village = document.getElementById('villageInput').value.trim();

            if (!district || !county || !subcounty || !parish || !village) {
                alert('Please complete all location fields');
                return;
            }

            registrationState.data.district = district;
            registrationState.data.county = county;
            registrationState.data.subcounty = subcounty;
            registrationState.data.parish = parish;
            registrationState.data.village = village;

            // Skip Step 3 if not a company
            if (registrationState.data.ownershipType === 'COMPANY') {
                goToStep(3);
            } else {
                goToStep(4);
            }
        }

        // ============================================
        // LAND CLERK PHASE 2: STEPS 3-6 COMPLETE IMPLEMENTATION
        // ============================================
        // Replace lines 523-535 in webmap.html with this code

        // STEP 3: Company Info (only for COMPANY ownership)
        function renderStep3Company(content) {
            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step completed">1. Parcel ID</div>
                    <div class="clerk-step completed">2. Location</div>
                    <div class="clerk-step active">3. Company</div>
                    <div class="clerk-step">4. Previous Owner</div>
                    <div class="clerk-step">5. New Owner</div>
                    <div class="clerk-step">6. Review</div>
                </div>
                <h3>Step 3: Company Information</h3>
                <div class="clerk-form-group">
                    <label>Company Name <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="companyNameInput" 
                        value="${registrationState.data.companyName}" 
                        placeholder="e.g., ABC Limited">
                </div>
                <div class="clerk-form-group">
                    <label>Company Registration Number <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="companyRegNumberInput" 
                        value="${registrationState.data.companyRegNumber}" 
                        placeholder="e.g., 123456">
                </div>
                <div class="clerk-form-group">
                    <label>Certificate of Incorporation</label>
                    <input type="file" class="clerk-input" id="incorporationCertFile" accept=".pdf,.jpg,.jpeg,.png">
                    <small style="color: #6b7280; display: block; margin-top: 4px;">PDF, JPG, or PNG (max 20MB)</small>
                </div>
                <div class="clerk-form-group">
                    <label>Board Resolution</label>
                    <input type="file" class="clerk-input" id="boardResolutionFile" accept=".pdf,.jpg,.jpeg,.png">
                    <small style="color: #6b7280; display: block; margin-top: 4px;">PDF, JPG, or PNG (max 20MB)</small>
                </div>
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="goToStep(2)">← Back</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="validateAndProceedStep3()">Next Step →</button>
                </div>
            `;
        }

        async function validateAndProceedStep3() {
            const companyName = document.getElementById('companyNameInput').value.trim();
            const companyRegNumber = document.getElementById('companyRegNumberInput').value.trim();

            if (!companyName || !companyRegNumber) {
                alert('Please enter company name and registration number');
                return;
            }

            registrationState.data.companyName = companyName;
            registrationState.data.companyRegNumber = companyRegNumber;

            // Upload documents if provided
            const incorporationFile = document.getElementById('incorporationCertFile').files[0];
            const boardResolutionFile = document.getElementById('boardResolutionFile').files[0];

            try {
                if (incorporationFile) {
                    const url = await uploadSpecialDocument(incorporationFile, registrationState.data.parcelId, 'incorporation');
                    registrationState.data.uploadedDocuments.push({ type: 'incorporation', url });
                }
                if (boardResolutionFile) {
                    const url = await uploadSpecialDocument(boardResolutionFile, registrationState.data.parcelId, 'board_resolution');
                    registrationState.data.uploadedDocuments.push({ type: 'board_resolution', url });
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Document upload failed. You can continue and upload later.');
            }

            goToStep(4);
        }

        // STEP 4: Previous Owner
        function renderStep4PreviousOwner(content) {
            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step completed">1. Parcel ID</div>
                    <div class="clerk-step completed">2. Location</div>
                    <div class="clerk-step ${registrationState.data.ownershipType === 'COMPANY' ? 'completed' : ''}">3. Company</div>
                    <div class="clerk-step active">4. Previous Owner</div>
                    <div class="clerk-step">5. New Owner</div>
                    <div class="clerk-step">6. Review</div>
                </div>
                <h3>Step 4: Previous Owner Details</h3>
                <div class="clerk-form-group">
                    <label>How was the land acquired? <span class="required">*</span></label>
                    <select class="clerk-select" id="acquisitionTypeSelect" onchange="updatePreviousOwnerFields()">
                        <option value="">Select...</option>
                        <option value="PURCHASE">Purchase (Sales Agreement)</option>
                        <option value="GIFT">Gift (Gift Deed)</option>
                        <option value="INHERITANCE">Inheritance (Death Certificate + Will)</option>
                        <option value="COURT_ORDER">Court Order</option>
                        <option value="FIRST_REGISTRATION">First Registration (No previous owner)</option>
                    </select>
                </div>
                <div id="previousOwnerFields"></div>
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="goToStep(${registrationState.data.ownershipType === 'COMPANY' ? 3 : 2})">← Back</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="validateAndProceedStep4()">Next Step →</button>
                </div>
            `;
        }

        function updatePreviousOwnerFields() {
            const acquisitionType = document.getElementById('acquisitionTypeSelect').value;
            const fieldsDiv = document.getElementById('previousOwnerFields');

            if (acquisitionType === 'FIRST_REGISTRATION') {
                fieldsDiv.innerHTML = '<p style="color: #6b7280; margin-top: 12px;">No previous owner information required for first registration.</p>';
                return;
            }

            if (!acquisitionType) {
                fieldsDiv.innerHTML = '';
                return;
            }

            let documentLabel = 'Sales Agreement';
            if (acquisitionType === 'GIFT') documentLabel = 'Gift Deed';
            else if (acquisitionType === 'INHERITANCE') documentLabel = 'Death Certificate + Will';
            else if (acquisitionType === 'COURT_ORDER') documentLabel = 'Court Order';

            fieldsDiv.innerHTML = `
                <div class="clerk-form-group">
                    <label>Previous Owner Name <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="previousOwnerName" placeholder="Full name">
                </div>
                <div class="clerk-form-group">
                    <label>Previous Owner NIN</label>
                    <input type="text" class="clerk-input" id="previousOwnerNIN" placeholder="National ID Number">
                </div>
                <div class="clerk-form-group">
                    <label>Previous Owner Phone</label>
                    <input type="text" class="clerk-input" id="previousOwnerPhone" placeholder="+256...">
                </div>
                <div class="clerk-form-group">
                    <label>${documentLabel} <span class="required">*</span></label>
                    <input type="file" class="clerk-input" id="previousOwnerDocFile" accept=".pdf,.jpg,.jpeg,.png">
                    <small style="color: #6b7280; display: block; margin-top: 4px;">PDF, JPG, or PNG (max 20MB)</small>
                </div>
            `;
        }

        async function validateAndProceedStep4() {
            const acquisitionType = document.getElementById('acquisitionTypeSelect').value;

            if (!acquisitionType) {
                alert('Please select how the land was acquired');
                return;
            }

            registrationState.data.acquisitionType = acquisitionType;

            if (acquisitionType !== 'FIRST_REGISTRATION') {
                const name = document.getElementById('previousOwnerName').value.trim();
                const nin = document.getElementById('previousOwnerNIN').value.trim();
                const phone = document.getElementById('previousOwnerPhone').value.trim();
                const docFile = document.getElementById('previousOwnerDocFile').files[0];

                if (!name) {
                    alert('Please enter previous owner name');
                    return;
                }

                if (!docFile) {
                    alert('Please upload the required document');
                    return;
                }

                registrationState.data.previousOwners = [{
                    name,
                    nin,
                    phone,
                    relationship: acquisitionType
                }];

                // Upload document
                try {
                    let docType = 'sales_agreement';
                    if (acquisitionType === 'GIFT') docType = 'gift_deed';
                    else if (acquisitionType === 'INHERITANCE') docType = 'death_certificate';
                    else if (acquisitionType === 'COURT_ORDER') docType = 'court_order';

                    const url = await uploadSpecialDocument(docFile, registrationState.data.parcelId, docType);
                    registrationState.data.uploadedDocuments.push({ type: docType, url });
                } catch (error) {
                    console.error('Upload error:', error);
                    alert('Document upload failed. You can continue and upload later.');
                }
            }

            goToStep(5);
        }

        // STEP 5: New Owner(s)
        function renderStep5NewOwner(content) {
            const ownerCount = registrationState.data.ownershipType === 'JOINT' ?
                (registrationState.data.newOwners.length || 1) : 1;

            let ownersHTML = '';
            for (let i = 0; i < ownerCount; i++) {
                const owner = registrationState.data.newOwners[i] || {};
                ownersHTML += `
                    <div style="border: 1px solid #e5e7eb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                        <h4 style="margin-top: 0;">Owner ${i + 1}</h4>
                        <div class="clerk-form-group">
                            <label>Full Name <span class="required">*</span></label>
                            <input type="text" class="clerk-input" id="owner${i}Name" 
                                value="${owner.name || ''}" placeholder="Full name">
                        </div>
                        <div class="clerk-form-group">
                            <label>NIN <span class="required">*</span></label>
                            <input type="text" class="clerk-input" id="owner${i}NIN" 
                                value="${owner.nin || ''}" placeholder="National ID Number">
                        </div>
                        <div class="clerk-form-group">
                            <label>Phone <span class="required">*</span></label>
                            <input type="text" class="clerk-input" id="owner${i}Phone" 
                                value="${owner.phone || ''}" placeholder="+256...">
                        </div>
                        <div class="clerk-form-group">
                            <label>Passport Photo <span class="required">*</span></label>
                            <input type="file" class="clerk-input" id="owner${i}Photo" accept="image/*">
                            <small style="color: #6b7280; display: block; margin-top: 4px;">JPG or PNG (max 20MB)</small>
                        </div>
                    </div>
                `;
            }

            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step completed">1. Parcel ID</div>
                    <div class="clerk-step completed">2. Location</div>
                    <div class="clerk-step ${registrationState.data.ownershipType === 'COMPANY' ? 'completed' : ''}">3. Company</div>
                    <div class="clerk-step completed">4. Previous Owner</div>
                    <div class="clerk-step active">5. New Owner</div>
                    <div class="clerk-step">6. Review</div>
                </div>
                <h3>Step 5: New Owner(s) Details</h3>
                ${ownersHTML}
                ${registrationState.data.ownershipType === 'JOINT' && ownerCount < 5 ? `
                    <button class="clerk-btn clerk-btn-secondary" onclick="addAnotherOwner()" style="margin-bottom: 16px;">
                        + Add Another Owner (${ownerCount}/5)
                    </button>
                ` : ''}
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="goToStep(4)">← Back</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="validateAndProceedStep5()">Next Step →</button>
                </div>
            `;
        }

        function addAnotherOwner() {
            if (registrationState.data.newOwners.length < 5) {
                registrationState.data.newOwners.push({});
                renderStep5NewOwner(document.getElementById('clerkContent'));
            }
        }

        async function validateAndProceedStep5() {
            const ownerCount = registrationState.data.ownershipType === 'JOINT' ?
                (registrationState.data.newOwners.length || 1) : 1;

            const owners = [];

            for (let i = 0; i < ownerCount; i++) {
                const name = document.getElementById(`owner${i}Name`).value.trim();
                const nin = document.getElementById(`owner${i}NIN`).value.trim();
                const phone = document.getElementById(`owner${i}Phone`).value.trim();
                const photoFile = document.getElementById(`owner${i}Photo`).files[0];

                if (!name || !nin || !phone) {
                    alert(`Please complete all fields for Owner ${i + 1}`);
                    return;
                }

                if (!photoFile && !registrationState.data.newOwners[i]?.photoUrl) {
                    alert(`Please upload passport photo for Owner ${i + 1}`);
                    return;
                }

                const owner = { name, nin, phone, ownerType: 'NEW', ownerNumber: i + 1 };

                // Upload photo
                if (photoFile) {
                    try {
                        const url = await uploadPassportPhoto(photoFile, registrationState.data.parcelId, 'individual', i + 1);
                        owner.photoUrl = url;
                        registrationState.data.uploadedDocuments.push({ type: 'passport_photo', url, ownerNumber: i + 1 });
                    } catch (error) {
                        console.error('Photo upload error:', error);
                        alert(`Photo upload failed for Owner ${i + 1}. You can continue and upload later.`);
                    }
                }

                owners.push(owner);
            }

            registrationState.data.newOwners = owners;
            goToStep(6);
        }

        // STEP 6: Review & Submit
        function renderStep6Review(content) {
            const { data } = registrationState;

            content.innerHTML = `
                <div class="clerk-progress">
                    <div class="clerk-step completed">1. Parcel ID</div>
                    <div class="clerk-step completed">2. Location</div>
                    <div class="clerk-step ${data.ownershipType === 'COMPANY' ? 'completed' : ''}">3. Company</div>
                    <div class="clerk-step completed">4. Previous Owner</div>
                    <div class="clerk-step completed">5. New Owner</div>
                    <div class="clerk-step active">6. Review</div>
                </div>
                <h3>Step 6: Review & Submit</h3>
                <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin-top: 0;">Parcel Information</h4>
                    <p><strong>Parcel ID:</strong> ${data.parcelId}</p>
                    <p><strong>Ownership Type:</strong> ${data.ownershipType}</p>
                    <p><strong>Location:</strong> ${data.village}, ${data.parish}, ${data.subcounty}, ${data.county}, ${data.district}</p>
                </div>
                ${data.ownershipType === 'COMPANY' ? `
                    <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                        <h4 style="margin-top: 0;">Company Information</h4>
                        <p><strong>Company Name:</strong> ${data.companyName}</p>
                        <p><strong>Registration Number:</strong> ${data.companyRegNumber}</p>
                    </div>
                ` : ''}
                <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin-top: 0;">Acquisition</h4>
                    <p><strong>Type:</strong> ${data.acquisitionType}</p>
                    ${data.previousOwners.length > 0 ? `<p><strong>Previous Owner:</strong> ${data.previousOwners[0].name}</p>` : ''}
                </div>
                <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin-top: 0;">New Owner(s)</h4>
                    ${data.newOwners.map((owner, i) => `
                        <p><strong>Owner ${i + 1}:</strong> ${owner.name} (NIN: ${owner.nin}, Phone: ${owner.phone})</p>
                    `).join('')}
                </div>
                <div style="background: #eff6ff; padding: 16px; border-radius: 8px; border-left: 4px solid #2563eb; margin-bottom: 16px;">
                    <p style="margin: 0;"><strong>Ready to submit?</strong> This will create a new land registration record in the database.</p>
                </div>
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="clerk-btn clerk-btn-secondary" onclick="goToStep(5)">← Back</button>
                    <button class="clerk-btn clerk-btn-primary" onclick="submitRegistration()" id="submitBtn">
                        <i class="fas fa-check"></i> Submit Registration
                    </button>
                </div>
            `;
        }

        async function submitRegistration() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) throw new Error('Not authenticated');

                const { data } = registrationState;

                // Insert land registration
                const { data: registration, error: regError } = await supabaseClient
                    .from('land_registrations')
                    .insert({
                        parcel_id: data.parcelId,
                        registration_type: 'NEW',
                        ownership_type: data.ownershipType,
                        district: data.district,
                        county: data.county,
                        sub_county: data.subcounty,
                        parish: data.parish,
                        village: data.village,
                        company_name: data.companyName || 'N/A',
                        company_address: 'N/A',
                        company_phone: 'N/A',
                        company_email: 'N/A',
                        ursb_number: data.companyRegNumber || 'N/A',
                        acquisition_method: data.acquisitionType || 'FIRST_REGISTRATION',
                        acquisition_date: new Date().toISOString().split('T')[0],
                        number_of_owners: data.newOwners.length,
                        registered_by: user.id,
                        status: 'ACTIVE'
                    })
                    .select()
                    .single();

                if (regError) throw regError;

                // Insert owners (NEW OWNERS as CURRENT)
                for (const owner of data.newOwners) {
                    const { error: ownerError } = await supabaseClient.from('land_owners').insert({
                        registration_id: registration.id,
                        owner_type: 'CURRENT',
                        owner_category: 'INDIVIDUAL',
                        owner_number: owner.ownerNumber,
                        full_name: owner.name,
                        contact_phone: owner.phone,
                        contact_email: owner.email || null,
                        address: owner.address || null,
                        passport_photo_url: owner.photoUrl
                    });
                    if (ownerError) {
                        console.error('Owner insert error:', ownerError);
                        throw ownerError;
                    }
                }

                // Insert previous owners
                for (const prevOwner of data.previousOwners) {
                    const { error: prevOwnerError } = await supabaseClient.from('land_owners').insert({
                        registration_id: registration.id,
                        owner_type: 'PREVIOUS',
                        owner_category: 'INDIVIDUAL',
                        full_name: prevOwner.name,
                        contact_phone: prevOwner.phone,
                        address: prevOwner.relationship || null
                    });
                    if (prevOwnerError) {
                        console.error('Previous owner insert error:', prevOwnerError);
                        throw prevOwnerError;
                    }
                }

                // Insert documents
                for (const doc of data.uploadedDocuments) {
                    const { error: docError } = await supabaseClient.from('land_documents').insert({
                        registration_id: registration.id,
                        document_type: doc.type,
                        document_category: doc.category || 'GENERAL',
                        file_url: doc.url,
                        file_name: doc.name || 'document.pdf',
                        file_size_bytes: doc.size || 0,
                        uploaded_by: user.id
                    });
                    if (docError) {
                        console.error('Document insert error:', docError);
                        throw docError;
                    }
                }

                alert(`✅ Registration successful! Registration ID: ${registration.id}`);
                closeClerkModal();

                // Reset state
                registrationState.currentStep = 1;
                registrationState.data = {
                    parcelId: '', ownershipType: '', district: '', county: '', subcounty: '',
                    parish: '', village: '', companyName: '', companyRegNumber: '',
                    acquisitionType: '', previousOwners: [], newOwners: [], uploadedDocuments: []
                };

            } catch (error) {
                console.error('Submission error:', error);
                alert('❌ Submission failed: ' + error.message);
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-check"></i> Submit Registration';
            }
        }




        // ============================================
        // TRANSFER TAB IMPLEMENTATION
        // ============================================

        // ============================================
        // LAND CLERK PHASE 3: TRANSFER TAB IMPLEMENTATION
        // ============================================

        // Transfer state management
        const transferState = {
            currentRegistration: null,
            currentOwners: [],
            transferType: '',
            newOwners: [],
            uploadedDocuments: []
        };

        // Main transfer tab renderer
        function renderTransferTab(content) {
            content.innerHTML = `
        <h3>Transfer Land Ownership</h3>
        <div class="clerk-form-group">
            <label>Search Parcel to Transfer <span class="required">*</span></label>
            <div style="display: flex; gap: 12px;">
                <input type="text" class="clerk-input" id="transferParcelSearch" 
                    placeholder="Enter Parcel ID (e.g., BLB-001234)" style="flex: 1;">
                <button class="clerk-btn clerk-btn-primary" onclick="searchParcelForTransfer()">
                    <i class="fas fa-search"></i> Search
                </button>
            </div>
            <small style="color: #6b7280; display: block; margin-top: 4px;">
                Enter the parcel ID of the land you want to transfer
            </small>
        </div>
        <div id="transferSearchResults"></div>
        <div id="transferFormContainer"></div>
    `;
        }

        // Search for parcel to transfer
        async function searchParcelForTransfer() {
            const parcelId = document.getElementById('transferParcelSearch').value.trim();
            const resultsDiv = document.getElementById('transferSearchResults');

            if (!parcelId) {
                alert('Please enter a parcel ID');
                return;
            }

            resultsDiv.innerHTML = '<p style="color: #6b7280;"><i class="fas fa-spinner fa-spin"></i> Searching...</p>';

            try {
                // Fetch registration with owners
                const { data: registration, error: regError } = await supabaseClient
                    .from('land_registrations')
                    .select('*')
                    .eq('parcel_id', parcelId)
                    .in('status', ['ACTIVE', 'PENDING'])
                    .single();

                if (regError || !registration) {
                    resultsDiv.innerHTML = `
                <div style="background: #fef2f2; border: 1px solid #fecaca; padding: 16px; border-radius: 8px; margin-top: 16px;">
                    <p style="color: #dc2626; margin: 0;">
                        <i class="fas fa-exclamation-circle"></i> 
                        Parcel not found or already transferred. Please check the ID and try again.
                    </p>
                </div>
            `;
                    return;
                }

                // Fetch current owners
                const { data: owners, error: ownersError } = await supabaseClient
                    .from('land_owners')
                    .select('*')
                    .eq('registration_id', registration.id)
                    .eq('owner_type', 'CURRENT');

                if (ownersError) throw ownersError;

                // Store in state
                transferState.currentRegistration = registration;
                transferState.currentOwners = owners || [];

                // Display current registration details
                displayCurrentOwnership(resultsDiv);

            } catch (error) {
                console.error('[TRANSFER] Search error:', error);
                resultsDiv.innerHTML = `
            <div style="background: #fef2f2; border: 1px solid #fecaca; padding: 16px; border-radius: 8px; margin-top: 16px;">
                <p style="color: #dc2626; margin: 0;">
                    <i class="fas fa-exclamation-circle"></i> 
                    Error searching for parcel: ${error.message}
                </p>
            </div>
        `;
            }
        }

        // Display current ownership details
        function displayCurrentOwnership(resultsDiv) {
            const { currentRegistration, currentOwners } = transferState;

            const ownersHTML = currentOwners.map(owner => `
        <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #e5e7eb;">
            <p style="margin: 0 0 4px 0;"><strong>${owner.owner_name}</strong></p>
            <p style="margin: 0; font-size: 14px; color: #6b7280;">
                NIN: ${owner.owner_nin || 'N/A'} | Phone: ${owner.owner_phone || 'N/A'}
            </p>
        </div>
    `).join('');

            resultsDiv.innerHTML = `
        <div style="background: #f0fdf4; border: 1px solid #86efac; padding: 16px; border-radius: 8px; margin-top: 16px;">
            <h4 style="margin-top: 0; color: #16a34a;">
                <i class="fas fa-check-circle"></i> Parcel Found
            </h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <p style="margin: 0; font-size: 14px; color: #6b7280;">Parcel ID</p>
                    <p style="margin: 4px 0 0 0; font-weight: 600;">${currentRegistration.parcel_id}</p>
                </div>
                <div>
                    <p style="margin: 0; font-size: 14px; color: #6b7280;">Ownership Type</p>
                    <p style="margin: 4px 0 0 0; font-weight: 600;">${currentRegistration.ownership_type}</p>
                </div>
                <div>
                    <p style="margin: 0; font-size: 14px; color: #6b7280;">Location</p>
                    <p style="margin: 4px 0 0 0; font-weight: 600;">${currentRegistration.village}, ${currentRegistration.parish}</p>
                </div>
                <div>
                    <p style="margin: 0; font-size: 14px; color: #6b7280;">District</p>
                    <p style="margin: 4px 0 0 0; font-weight: 600;">${currentRegistration.district}</p>
                </div>
            </div>
            <p style="margin: 12px 0 8px 0; font-weight: 600;">Current Owner(s):</p>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                ${ownersHTML}
            </div>
        </div>
    `;

            // Show transfer form
            renderTransferForm();
        }

        // Render transfer form
        function renderTransferForm() {
            const formContainer = document.getElementById('transferFormContainer');

            formContainer.innerHTML = `
        <div style="margin-top: 24px; padding-top: 24px; border-top: 2px solid #e5e7eb;">
            <h4>Transfer Details</h4>
            
            <div class="clerk-form-group">
                <label>Transfer Type <span class="required">*</span></label>
                <select class="clerk-select" id="transferTypeSelect">
                    <option value="">Select transfer type...</option>
                    <option value="SALE">Sale (Sales Agreement)</option>
                    <option value="GIFT">Gift (Gift Deed)</option>
                    <option value="INHERITANCE">Inheritance (Death Certificate + Will)</option>
                    <option value="COURT_ORDER">Court Order</option>
                </select>
            </div>

            <div class="clerk-form-group">
                <label>Transfer Document <span class="required">*</span></label>
                <input type="file" class="clerk-input" id="transferDocFile" accept=".pdf,.jpg,.jpeg,.png">
                <small style="color: #6b7280; display: block; margin-top: 4px;">
                    Upload sales agreement, gift deed, or other transfer document (PDF, JPG, PNG - max 20MB)
                </small>
            </div>

            <h4 style="margin-top: 24px;">New Owner Details</h4>
            
            <div class="clerk-form-group">
                <label>Number of New Owners <span class="required">*</span></label>
                <select class="clerk-select" id="newOwnerCountSelect" onchange="updateNewOwnerFields()">
                    <option value="1">1 Owner (Individual)</option>
                    <option value="2">2 Owners (Joint)</option>
                    <option value="3">3 Owners (Joint)</option>
                    <option value="4">4 Owners (Joint)</option>
                    <option value="5">5 Owners (Joint)</option>
                </select>
            </div>

            <div id="newOwnersFieldsContainer"></div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="clerk-btn clerk-btn-secondary" onclick="cancelTransfer()">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button class="clerk-btn clerk-btn-primary" onclick="submitTransfer()">
                    <i class="fas fa-exchange-alt"></i> Submit Transfer
                </button>
            </div>
        </div>
    `;

            // Initialize with 1 owner
            updateNewOwnerFields();
        }

        // Update new owner input fields based on count
        function updateNewOwnerFields() {
            const count = parseInt(document.getElementById('newOwnerCountSelect').value);
            const container = document.getElementById('newOwnersFieldsContainer');

            let fieldsHTML = '';
            for (let i = 0; i < count; i++) {
                fieldsHTML += `
            <div style="border: 1px solid #e5e7eb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                <h5 style="margin-top: 0;">New Owner ${i + 1}</h5>
                
                <div class="clerk-form-group">
                    <label>Full Name <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="newOwner${i}Name" placeholder="Full name">
                </div>

                <div class="clerk-form-group">
                    <label>NIN <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="newOwner${i}NIN" placeholder="National ID Number">
                </div>

                <div class="clerk-form-group">
                    <label>Phone <span class="required">*</span></label>
                    <input type="text" class="clerk-input" id="newOwner${i}Phone" placeholder="+256...">
                </div>

                <div class="clerk-form-group">
                    <label>Passport Photo <span class="required">*</span></label>
                    <input type="file" class="clerk-input" id="newOwner${i}Photo" accept="image/*">
                    <small style="color: #6b7280; display: block; margin-top: 4px;">JPG or PNG (max 20MB)</small>
                </div>
            </div>
        `;
            }

            container.innerHTML = fieldsHTML;
        }

        // Cancel transfer and reset
        function cancelTransfer() {
            transferState.currentRegistration = null;
            transferState.currentOwners = [];
            transferState.transferType = '';
            transferState.newOwners = [];
            transferState.uploadedDocuments = [];

            const content = document.getElementById('clerkContent');
            renderTransferTab(content);
        }

        // Submit transfer
        async function submitTransfer() {
            try {
                // Validate transfer type
                const transferType = document.getElementById('transferTypeSelect').value;
                if (!transferType) {
                    alert('Please select a transfer type');
                    return;
                }

                // Validate transfer document
                const transferDocFile = document.getElementById('transferDocFile').files[0];
                if (!transferDocFile) {
                    alert('Please upload a transfer document');
                    return;
                }

                // Validate new owners
                const ownerCount = parseInt(document.getElementById('newOwnerCountSelect').value);
                const newOwners = [];

                for (let i = 0; i < ownerCount; i++) {
                    const name = document.getElementById(`newOwner${i}Name`).value.trim();
                    const nin = document.getElementById(`newOwner${i}NIN`).value.trim();
                    const phone = document.getElementById(`newOwner${i}Phone`).value.trim();
                    const photoFile = document.getElementById(`newOwner${i}Photo`).files[0];

                    if (!name || !nin || !phone) {
                        alert(`Please complete all fields for New Owner ${i + 1}`);
                        return;
                    }

                    if (!photoFile) {
                        alert(`Please upload passport photo for New Owner ${i + 1}`);
                        return;
                    }

                    newOwners.push({ name, nin, phone, photoFile, ownerNumber: i + 1 });
                }

                // Show loading
                const submitBtn = event.target;
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing Transfer...';

                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) throw new Error('Not authenticated');

                const { currentRegistration } = transferState;

                // Upload transfer document
                let transferDocUrl;
                try {
                    let docType = 'sales_agreement';
                    if (transferType === 'GIFT') docType = 'gift_deed';
                    else if (transferType === 'INHERITANCE') docType = 'death_certificate';
                    else if (transferType === 'COURT_ORDER') docType = 'court_order';

                    transferDocUrl = await uploadSpecialDocument(transferDocFile, currentRegistration.parcel_id, docType);
                } catch (error) {
                    console.error('[TRANSFER] Document upload error:', error);
                    alert('Transfer document upload failed: ' + error.message);
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Submit Transfer';
                    return;
                }

                // Upload owner photos
                for (const owner of newOwners) {
                    try {
                        owner.photoUrl = await uploadPassportPhoto(
                            owner.photoFile,
                            currentRegistration.parcel_id,
                            'individual',
                            owner.ownerNumber
                        );
                    } catch (error) {
                        console.error('[TRANSFER] Photo upload error:', error);
                        alert(`Photo upload failed for ${owner.name}. Please try again.`);
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Submit Transfer';
                        return;
                    }
                }

                // 1. Update old owners to type PREVIOUS
                const { error: updateOwnersError } = await supabaseClient
                    .from('land_owners')
                    .update({ owner_type: 'PREVIOUS' })
                    .eq('registration_id', currentRegistration.id)
                    .eq('owner_type', 'CURRENT');

                if (updateOwnersError) throw updateOwnersError;

                // 2. Update the registration with new ownership details
                const { error: updateRegError } = await supabaseClient
                    .from('land_registrations')
                    .update({
                        registration_type: 'TRANSFER',
                        ownership_type: ownerCount > 1 ? 'JOINT' : 'INDIVIDUAL',
                        acquisition_method: transferType,
                        acquisition_date: new Date().toISOString().split('T')[0],
                        number_of_owners: ownerCount,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', currentRegistration.id);

                if (updateRegError) throw updateRegError;

                // 3. Insert new owners
                for (const owner of newOwners) {
                    await supabaseClient.from('land_owners').insert({
                        registration_id: currentRegistration.id,
                        owner_type: 'CURRENT',
                        owner_category: 'INDIVIDUAL',
                        owner_number: owner.ownerNumber,
                        owner_name: owner.name,
                        owner_nin: owner.nin,
                        owner_phone: owner.phone,
                        passport_photo_url: owner.photoUrl
                    });
                }

                // 4. Insert transfer document
                await supabaseClient.from('land_documents').insert({
                    registration_id: currentRegistration.id,
                    document_type: transferType.toLowerCase() + '_document',
                    document_url: transferDocUrl,
                    uploaded_by: user.id
                });


                // Success!
                alert(`âœ… Transfer successful!\n\nOld Registration: ${currentRegistration.id}\nNew Registration: ${newRegistration.id}\n\nThe land has been transferred to the new owner(s).`);

                // Reset and reload
                cancelTransfer();

            } catch (error) {
                console.error('[TRANSFER] Submission error:', error);
                alert('âŒ Transfer failed: ' + error.message);
                const submitBtn = document.querySelector('button[onclick="submitTransfer()"]');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Submit Transfer';
                }
            }
        }



        // ============================================
        // LAND CLERK PHASE 3: SEARCH TAB IMPLEMENTATION
        // ============================================

        // Search state management
        const searchState = {
            results: [],
            currentDetail: null
        };

        // Main search tab renderer
        function renderSearchTab(content) {
            content.innerHTML = `
        <h3>Search Land Registrations</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
            <div class="clerk-form-group">
                <label>Parcel ID</label>
                <input type="text" class="clerk-input" id="searchParcelId" placeholder="e.g., BLB-001234">
            </div>
            
            <div class="clerk-form-group">
                <label>Owner Name</label>
                <input type="text" class="clerk-input" id="searchOwnerName" placeholder="e.g., John Doe">
            </div>
            
            <div class="clerk-form-group">
                <label>District</label>
                <input type="text" class="clerk-input" id="searchDistrict" placeholder="e.g., Kampala">
            </div>
            
            <div class="clerk-form-group">
                <label>Status</label>
                <select class="clerk-select" id="searchStatus">
                    <option value="">All Statuses</option>
                    <option value="ACTIVE">Active</option>
                    <option value="TRANSFERRED">Transferred</option>
                    <option value="DISPUTED">Disputed</option>
                </select>
            </div>
        </div>
        
        <div style="display: flex; gap: 12px; margin-bottom: 24px;">
            <button class="clerk-btn clerk-btn-primary" onclick="executeSearch()">
                <i class="fas fa-search"></i> Search
            </button>
            <button class="clerk-btn clerk-btn-secondary" onclick="clearSearch()">
                <i class="fas fa-times"></i> Clear
            </button>
        </div>
        
        <div id="searchResults"></div>
        <div id="detailModal" style="display: none;"></div>
    `;
        }

        // Execute search
        async function executeSearch() {
            const parcelId = document.getElementById('searchParcelId').value.trim();
            const ownerName = document.getElementById('searchOwnerName').value.trim();
            const district = document.getElementById('searchDistrict').value.trim();
            const status = document.getElementById('searchStatus').value;

            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = '<p style="color: #6b7280;"><i class="fas fa-spinner fa-spin"></i> Searching...</p>';

            try {
                console.log('[SEARCH] Starting search with filters:', { parcelId, ownerName, district, status });

                let query = supabaseClient.from('land_registrations').select('*');

                // Apply filters
                if (parcelId) {
                    query = query.ilike('parcel_id', `%${parcelId}%`);
                }
                if (district) {
                    query = query.ilike('district', `%${district}%`);
                }
                if (status) {
                    query = query.eq('status', status);
                }

                // Execute query
                console.log('[SEARCH] Executing registration query...');
                const { data: registrations, error: regError } = await query.order('created_at', { ascending: false }).limit(50);

                if (regError) {
                    console.error('[SEARCH] Registration query error:', regError);
                    throw regError;
                }

                console.log('[SEARCH] Found registrations:', registrations?.length || 0);

                // If searching by owner name, filter by owners
                let results = registrations || [];
                if (ownerName && results.length > 0) {
                    console.log('[SEARCH] Filtering by owner name:', ownerName);
                    const regIds = results.map(r => r.id);
                    const { data: owners, error: ownersError } = await supabaseClient
                        .from('land_owners')
                        .select('registration_id')
                        .in('registration_id', regIds)
                        .ilike('owner_name', `%${ownerName}%`);

                    if (ownersError) {
                        console.error('[SEARCH] Owner query error:', ownersError);
                        throw ownersError;
                    }

                    console.log('[SEARCH] Matching owners:', owners?.length || 0);

                    const matchingRegIds = new Set(owners.map(o => o.registration_id));
                    results = results.filter(r => matchingRegIds.has(r.id));
                }

                console.log('[SEARCH] Final results:', results.length);
                searchState.results = results;

                // Show results in modal popup
                console.log('[SEARCH] Creating results modal...');
                const modal = document.getElementById('detailModal');

                if (results.length === 0) {
                    modal.innerHTML = `
                        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 32px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 500px;">
                            <h3 style="margin-top: 0;">No Results Found</h3>
                            <p>No registrations match your search criteria.</p>
                            <button class="clerk-btn clerk-btn-primary" onclick="document.getElementById('detailModal').innerHTML = ''; document.getElementById('detailModal').style.display = 'none';">Close</button>
                        </div>
                        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999;" onclick="document.getElementById('detailModal').innerHTML = ''; document.getElementById('detailModal').style.display = 'none';"></div>
                    `;
                    modal.style.display = 'block';
                    resultsDiv.innerHTML = '';
                    return;
                }

                // Build results table
                const tableRows = results.map(reg => `
                    <tr onclick="viewRegistrationDetail('${reg.id}')" style="cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#f9fafb'" onmouseout="this.style.background='white'">
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.parcel_id}</td>
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.ownership_type}</td>
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.district}</td>
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.village || 'N/A'}</td>
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">
                            <span style="padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; background: ${reg.status === 'ACTIVE' ? '#dcfce7' : '#fef3c7'}; color: ${reg.status === 'ACTIVE' ? '#16a34a' : '#d97706'};">
                                ${reg.status}
                            </span>
                        </td>
                        <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${new Date(reg.created_at).toLocaleDateString()}</td>
                    </tr>
                `).join('');

                modal.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; overflow-y: auto; padding: 24px;" onclick="if(event.target === this) { this.parentElement.innerHTML = ''; this.parentElement.style.display = 'none'; }">
                        <div style="max-width: 1000px; margin: 40px auto; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
                            <div style="padding: 24px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;">
                                <h3 style="margin: 0;">
                                    <i class="fas fa-search"></i> Search Results - Found ${results.length} Registration${results.length !== 1 ? 's' : ''}
                                </h3>
                                <button onclick="document.getElementById('detailModal').innerHTML = ''; document.getElementById('detailModal').style.display = 'none';" style="background: #f3f4f6; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 20px;">×</button>
                            </div>
                            <div style="padding: 24px; overflow-x: auto;">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <thead>
                                        <tr style="background: #f9fafb;">
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Parcel ID</th>
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Ownership</th>
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">District</th>
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Village</th>
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Status</th>
                                            <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Registered</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${tableRows}
                                    </tbody>
                                </table>
                                <p style="margin-top: 16px; font-size: 14px; color: #6b7280; text-align: center;">
                                    <i class="fas fa-info-circle"></i> Click any row to view full details
                                </p>
                            </div>
                        </div>
                    </div>
                `;
                modal.style.display = 'block';
                resultsDiv.innerHTML = '';
                console.log('[SEARCH] Results modal displayed');

            } catch (error) {
                console.error('[SEARCH] Error:', error);
                resultsDiv.innerHTML = `
            <div style="background: #fef2f2; border: 1px solid #fecaca; padding: 16px; border-radius: 8px;">
                <p style="color: #dc2626; margin: 0;">
                    <i class="fas fa-exclamation-circle"></i> 
                    Search failed: ${error.message}
                </p>
            </div>
        `;
            }
        }

        // Display search results
        function displaySearchResults(results) {
            console.log('[SEARCH] displaySearchResults called with:', results.length, 'results');
            const resultsDiv = document.getElementById('searchResults');

            if (results.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="background: #f9fafb; border: 1px solid #e5e7eb; padding: 24px; border-radius: 8px; text-align: center;">
                        <i class="fas fa-search" style="font-size: 48px; color: #d1d5db; margin-bottom: 12px;"></i>
                        <p style="color: #6b7280; margin: 0;">No registrations found matching your criteria.</p>
                    </div>
                `;
                return;
            }

            const tableRows = results.map(reg => `
                <tr onclick="viewRegistrationDetail('${reg.id}')" style="cursor: pointer;">
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.parcel_id}</td>
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.ownership_type}</td>
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.district}</td>
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${reg.village || 'N/A'}</td>
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">
                        <span style="padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; 
                            background: ${reg.status === 'ACTIVE' ? '#dcfce7' : reg.status === 'TRANSFERRED' ? '#fef3c7' : '#fee2e2'}; 
                            color: ${reg.status === 'ACTIVE' ? '#16a34a' : reg.status === 'TRANSFERRED' ? '#d97706' : '#dc2626'};">
                            ${reg.status}
                        </span>
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${new Date(reg.created_at).toLocaleDateString()}</td>
                </tr>
            `).join('');

            resultsDiv.innerHTML = `
                <div style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden;">
                    <div style="padding: 16px; background: #f9fafb; border-bottom: 1px solid #e5e7eb;">
                        <p style="margin: 0; font-weight: 600;">
                            <i class="fas fa-list"></i> Found ${results.length} registration${results.length !== 1 ? 's' : ''}
                        </p>
                    </div>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f9fafb;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Parcel ID</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Ownership</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">District</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Village</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Status</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #e5e7eb;">Registered</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                </div>
                <p style="margin-top: 12px; font-size: 14px; color: #6b7280;">
            <i class="fas fa-info-circle"></i> Click on any row to view full details
        </p>
    `;
        }

        // View registration detail
        async function viewRegistrationDetail(registrationId) {
            const modal = document.getElementById('detailModal');
            modal.style.display = 'block';
            modal.innerHTML = '<p style="padding: 24px; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading details...</p>';

            try {
                // Fetch registration
                const { data: registration, error: regError } = await supabaseClient
                    .from('land_registrations')
                    .select('*')
                    .eq('id', registrationId)
                    .single();

                if (regError) throw regError;

                // Fetch owners
                const { data: owners, error: ownersError } = await supabaseClient
                    .from('land_owners')
                    .select('*')
                    .eq('registration_id', registrationId)
                    .order('owner_type', { ascending: false });

                if (ownersError) throw ownersError;

                // Fetch documents
                const { data: documents, error: docsError } = await supabaseClient
                    .from('land_documents')
                    .select('*')
                    .eq('registration_id', registrationId)
                    .order('uploaded_at', { ascending: false });

                if (docsError) throw docsError;

                searchState.currentDetail = { registration, owners, documents };
                renderDetailModal(registration, owners, documents);

            } catch (error) {
                console.error('[SEARCH] Detail error:', error);
                modal.innerHTML = `
            <div style="padding: 24px;">
                <p style="color: #dc2626;">Error loading details: ${error.message}</p>
                <button class="clerk-btn clerk-btn-secondary" onclick="closeDetailModal()">Close</button>
            </div>
        `;
            }
        }

        // Render detail modal
        function renderDetailModal(registration, owners, documents) {
            const modal = document.getElementById('detailModal');

            const currentOwners = owners.filter(o => o.owner_type === 'CURRENT');
            const previousOwners = owners.filter(o => o.owner_type === 'PREVIOUS');

            const currentOwnersHTML = currentOwners.map(owner => `
        <div style="background: #f0fdf4; padding: 12px; border-radius: 6px; border: 1px solid #86efac; margin-bottom: 8px; display: flex; gap: 16px; align-items: start;">
            ${owner.passport_photo_url ? `
                <img src="${owner.passport_photo_url}" alt="Owner Photo" style="width: 80px; height: 80px; object-fit: cover; border-radius: 8px; border: 2px solid #86efac;" />
            ` : `
                <div style="width: 80px; height: 80px; background: #dcfce7; border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 2px solid #86efac;">
                    <i class="fas fa-user" style="font-size: 32px; color: #16a34a;"></i>
                </div>
            `}
            <div style="flex: 1;">
                <p style="margin: 0 0 8px 0; font-weight: 600; font-size: 16px;">${owner.full_name || 'N/A'}</p>
                <p style="margin: 0 0 4px 0; font-size: 14px; color: #6b7280;">
                    <i class="fas fa-id-card"></i> NIN: ${owner.contact_phone || 'N/A'}
                </p>
                <p style="margin: 0 0 4px 0; font-size: 14px; color: #6b7280;">
                    <i class="fas fa-phone"></i> Phone: ${owner.contact_phone || 'N/A'}
                </p>
                ${owner.contact_email ? `<p style="margin: 0; font-size: 14px; color: #6b7280;"><i class="fas fa-envelope"></i> ${owner.contact_email}</p>` : ''}
            </div>
        </div>
    `).join('');

            const previousOwnersHTML = previousOwners.length > 0 ? `
        <h4 style="margin-top: 24px;">Previous Owner(s)</h4>
        ${previousOwners.map(owner => `
            <div style="background: #fef3c7; padding: 12px; border-radius: 6px; border: 1px solid #fde047; margin-bottom: 8px; display: flex; gap: 16px; align-items: start;">
                ${owner.passport_photo_url ? `
                    <img src="${owner.passport_photo_url}" alt="Previous Owner Photo" style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px; border: 2px solid #fde047;" />
                ` : `
                    <div style="width: 60px; height: 60px; background: #fef9c3; border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 2px solid #fde047;">
                        <i class="fas fa-user" style="font-size: 24px; color: #d97706;"></i>
                    </div>
                `}
                <div style="flex: 1;">
                    <p style="margin: 0 0 4px 0; font-weight: 600;">${owner.full_name || 'N/A'}</p>
                    <p style="margin: 0; font-size: 14px; color: #6b7280;">
                        Phone: ${owner.contact_phone || 'N/A'}
                    </p>
                </div>
            </div>
        `).join('')}
    ` : '';

            const documentsHTML = documents.length > 0 ? `
        <h4 style="margin-top: 24px;">Documents</h4>
        ${documents.map(doc => `
            <div style="background: #f9fafb; padding: 12px; border-radius: 6px; border: 1px solid #e5e7eb; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <p style="margin: 0; font-weight: 600;">${doc.document_type.replace(/_/g, ' ').toUpperCase()}</p>
                    <p style="margin: 4px 0 0 0; font-size: 14px; color: #6b7280;">
                        Uploaded: ${new Date(doc.uploaded_at).toLocaleDateString()}
                    </p>
                </div>
                <a href="${doc.file_url}" target="_blank" class="clerk-btn clerk-btn-secondary" style="padding: 8px 16px;">
                    <i class="fas fa-download"></i> View
                </a>
            </div>
        `).join('')}
    ` : '<p style="color: #6b7280; margin-top: 24px;">No documents uploaded.</p>';

            modal.innerHTML = `
        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; overflow-y: auto; padding: 24px;">
            <div style="max-width: 800px; margin: 0 auto; background: white; border-radius: 12px; padding: 24px; position: relative;">
                <button onclick="closeDetailModal()" style="position: absolute; top: 16px; right: 16px; background: #f3f4f6; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 18px;">
                    ×
                </button>
                
                <h3 style="margin-top: 0;">Registration Details</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px; padding: 16px; background: #f9fafb; border-radius: 8px;">
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Parcel ID</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600; font-size: 18px;">${registration.parcel_id}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Status</p>
                        <p style="margin: 4px 0 0 0;">
                            <span style="padding: 4px 12px; border-radius: 4px; font-weight: 600; 
                                background: ${registration.status === 'ACTIVE' ? '#dcfce7' : registration.status === 'TRANSFERRED' ? '#fef3c7' : '#fee2e2'}; 
                                color: ${registration.status === 'ACTIVE' ? '#16a34a' : registration.status === 'TRANSFERRED' ? '#d97706' : '#dc2626'};">
                                ${registration.status}
                            </span>
                        </p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Ownership Type</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.ownership_type}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Registration Type</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.registration_type}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">District</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.district}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">County</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.county}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Sub-County</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.sub_county}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Parish</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.parish}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Village</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${registration.village}</p>
                    </div>
                    <div>
                        <p style="margin: 0; font-size: 14px; color: #6b7280;">Registered Date</p>
                        <p style="margin: 4px 0 0 0; font-weight: 600;">${new Date(registration.created_at).toLocaleDateString()}</p>
                    </div>
                </div>
                
                <h4>Current Owner(s)</h4>
                ${currentOwnersHTML}
                
                ${previousOwnersHTML}
                
                ${documentsHTML}
                
                
                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e5e7eb; display: flex; gap: 12px;">
                    <button class="clerk-btn clerk-btn-primary" onclick="generateCertificatePDF('${registration.id}')" style="background: #16a34a;">
                        <i class="fas fa-file-pdf"></i> Export PDF Certificate
                    </button>
                    <button class="clerk-btn clerk-btn-secondary" onclick="printCertificate('${registration.id}')">
                        <i class="fas fa-print"></i> Print Certificate
                    </button>
                    <button class="clerk-btn clerk-btn-secondary" onclick="closeDetailModal()">
                        Close
                    </button>
                </div>
            </div>
        </div>
    `;
        }

        // Close detail modal
        function closeDetailModal() {
            const modal = document.getElementById('detailModal');
            modal.style.display = 'none';
            modal.innerHTML = '';
            searchState.currentDetail = null;
        }

        // ============================================
        // PHASE 4: PDF CERTIFICATE GENERATION & PRINT
        // ============================================

        async function generateCertificatePDF(registrationId) {
            try {
                const btn = event.target;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating PDF...';

                // Fetch data
                const { data: registration } = await supabaseClient
                    .from('land_registrations')
                    .select('*')
                    .eq('id', registrationId)
                    .single();

                const { data: owners } = await supabaseClient
                    .from('land_owners')
                    .select('*')
                    .eq('registration_id', registrationId);

                const { data: { user } } = await supabaseClient.auth.getUser();

                // Initialize jsPDF
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('p', 'mm', 'a4');

                const pageWidth = 210;
                const pageHeight = 297;
                const margin = 20;
                let yPos = margin;

                // Helper function to add text
                const addText = (text, x, y, options = {}) => {
                    doc.setFontSize(options.size || 12);
                    doc.setFont('helvetica', options.style || 'normal');
                    if (options.color) doc.setTextColor(...options.color);
                    else doc.setTextColor(0, 0, 0);
                    doc.text(text, x, y, options.align ? { align: options.align } : {});
                };

                // Border
                doc.setDrawColor(22, 163, 74); // Green
                doc.setLineWidth(1);
                doc.rect(10, 10, pageWidth - 20, pageHeight - 20);

                // Header with flag
                // Add Uganda flag on left
                const flagUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAAACXBIWXMAAAsTAAALEwEAmpwYAAAMeElEQVR4nO2dW2xU1xXHf3vfmXnYM/Z4bGzjBwETYyAQQhJCAgkJtKFNS5u0TZWqUqtWbVWpD32o+tBKfehTH6pWqvpQqVWrPlRV1apV1aZNmqQNhDYJhJAQAgRCgh/Y2J7xw56x53XvPvXB3sNc82AwjGfGc3/SlffsNTN7Zu79n73X3mfttUFRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRFEVRlLlHcLoARVEURVEURVEURfmoSIDB/5/PwcEgAnB4+BKAlHdI271yD4DH47n2mJmPm2W9dn/Txtzk0/fPXFfr1tPSWo/5mPO5Py6fJ/8tFV75fPK88jnz3wvr+r9TRVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVEURVGujwgQTaYAcr9d87n552f+fK1j7u93/Y/IWe8vz3+t/wqmfMz1/ZhS+1NqcErtL/81KflnJ90OOJ3Oezbc+kj6/A1NPp+PUPkKSpdU4x9cyJKlK1h33x6EhNtvuw0AEaErEKY9lkRKaO8N8b0XLUF7PGmNv0x9o/eV55fXmllDppYlL/m439vk3q+8zmSe9L7K+3au/fDNX/H4k99g9z1f5uIlg0svHuXnL+/n4OGznLlwgaMnyti9ppym5qUcPDHGy++GQCbc+rryeVeew+Rj5M1zKp/vC+uu1NnWHaJn8MKr/+v5cMp45nMURVEURVEURVEURVEURVEURVEURVEURVEUZU4T+b9vZJJJEs4i5RqLlBdyfZjf/RmYj5eX/vn/zvX6JL/WtT6XmXW58hGLpa3jeQMr6w++dXGgf/T8r3a/9/W/PPKvL9x/a/0OO82Y7dvz3nf34bWyR3y+29Mkr1w+nQmbjEGj8+ez2SRInPzv2QlfOfeuPGe+/Ndah1zr/BdWiJXb/2M8m/3R8j/84nt/uu2uN55av/pBywrY5sqf3nwsP/T9l/J8Lx0mJUoyF0FKcpb1O1C+lnzl9c/1Xpf7Gjlv9r63xWN8+4Ob/7rn5uU/e2t1VVSt17siIQkZgymTz5HxG5nPAzkflvMVzfyf8l8rX/n+yud7+9L+0ZuvPDP8s/vWPRyN+B4yzzdrnhvr9Q3+5IdLTkdCvzpzIfs6En0+n1j68LLJZx//7B3xpLGKC+cT4W1vPv4P8/wzzrdJJmUxjPNVeOk/jR/mjb9Gm/h5zVPM93vu9V3/HQFAKZ0dAyZbXrt4c/WjvlwcKDZcuZp2X//3oijKNRGBr333xQOWuPvKpBOUz/m9V3Y2SYqUKC5v3lLI+S0yX/sT+a8vjxs3Uq5cPPV5yw8gknv+RB6kRHTM4JU3eveL5D28qLJm0+L6BhY1LBLPPP90Wr78N+2vHxp88iujey+em5tS8vwCrvUNyq7/+u+Y/CXy/5gSy6+58uZH8u+fPPfKPz/K/cjnSb32yv97rW/ykp/N82/Kv/4a/+NV/78r13t/z/ufR/IFT/54p35rvydBrvV/zne/mfU5X/yrAFSVVfHMU1/lwJGPDp7/03/nz19/9s5fPPOtL3d2tDHWNjFHm/M/XusXyfVr5v879z3WN3f9Y6/dxp3/n/MNLj+m/P+Xf+BrzPe84srmXAZ1ldWseXQX731wiDr/aB+A3+czlteVs3NzAy++tcCujWR+a41lD5unL7+n8l9zWX5tzmf/cj/Y/NU/GEm+88q9v3jw5i+3La8vsM8e3m3M/O1rk3+x8q/a77uyv/x6n8r97ryfct9t8rr8xgYGGDgdAvVdTW0Rcs7xgeHqr79pV0/27+l/pH28T4Aojb82TpfaW5f/vfZ+I6wbX3k1iUV/OypPext6q9nrK/PXPSsf2HW/4+r3ZaXmQP/84/PciHy0qhpjNuW/YPHnn68y48TfFxW5T7nc9c4f8l1X/ZlfP07K72hL3zC8hZKiqLceKTQ/2qIQCqZIp4WIhJCAAlRjj+ykmgswa8e3vzHX/zoR1/5xpefg3n6DV/m91b+Z/pxl5M/X37/T/vfvzNs/S3yyu9ftT55Y99nv7L7E1/GcxZZ7p91vef1fjeW2yVnLWs9rbPH+XL9+/d+48Vvru2PUvLdfflAzlteZLh8Ieb3Nb/fmbkKSr++/PXl65SvafI/K3/9qy+A/P74A4zHktySbX+85YXnXvvF5sbfPPX8B6ywv67gysyXv/bmh/c55fmve/5r1Fu+/XLO/VLyfU3z9a/3f5BfQ/mxl/9e+d8z8/65vp9I/sEzh/8cPfzWl/55+3MPv/Pis1/xffXf7JnvU/l1zzvu8p+X38t8H8vvV+5rX+Nr5H8f7te+smdYfnDy+13te5q/L7/7qzs6u+gZuPhZv99XPfkr5Np/s+Sa1TJrfeX/LfdeX1sBzJffJ9lIL6Hhfr+lhBRk05P1TtZX/r98tfPw62e+83LojZ/6lj23Yfmq298fF795+K71LR+2FWZ+bZ/ksf/lB7M99sF35mfunWvf+HxefqznnPe8sXdvO/9M/B/yZOfMvPeeG08Q2PUp1q94aMPSliWfb+mTtswfQf5Xef3v/bV+FPnHlr/n+cflv6byf5WX+x3MX/sVv/bl/+dav/crv/5V7gsvfPfHX/r00sXrKuvrOx3PcEVCbX44kP/8zNqvu2tYfv/L78XV/n7Vm8Xc/cq/76Huj3Dw2P+xomHxEpfr5tr/X/73svx/nqur3Otu/ueS2+wP/f+vdv4yP4u8v81M+d/1G/8tQX/gDQQEIURI6XBp5ZMnQvzx6YPv/f3IYX7yR5Mv/vqDPY22GG/dse6VqinvYSH+73+TQv/Dh/0flq/8yutm+z9m/G3uvuvff+V/m/P9dfm/Gfb/nGve//L/fPTf53K/nfyfy3fX/WI5mfEU6WQa0wzwxu6n+c1zP976vW89+d0f/+IfX+k73dH/ta/95ZM+y/ouyZkzS//1F0X+L+KG+0++7te+7te9e+l8w/I1z79r//fCKfmfS8/09A53BfxrXnh66Rc/ce8dB06c1XmjKIqiKIqiKIqiKIqiKIqiKIqiKIqi/J8SGZGg9FE/+GbYPPH1xw4M/fnQoS987cl+hCQirC+vItO18cz7Bw7x3O8P8cYH50hKiiVV9cDka3PyWevLxfDKY04p/WX88JWsZbG8/J7c/6vM+XPUfh788P/m8J99P/vpvtFLHXdWBEPPpZJJ+xPrN7H1pk10DAzw0t6D9I32k7FsGn31NK38FOvWNbK8rp5AOw+//6+DA9/4yo9XLDNvePM33/8J+48m2X3Hl1lVuXj+fsXmAOl02vvDN+8r/03/wt++9M7X3hpPj/7bSdZnttzBjvv28O6wz7hjx6P+T+/+pti6ufPvr7/+xtbFIWt1tLSU4YFBBvr72VF3K/dt3cbxc+f58zt7GYwnWVxZzpP3beOWlrU8ues+AFoeeOzNsbf+8ZNbb73j7+Vr1/r9gWD9xo0s+cxDXGhqYrS9nbBYXAmG+OT2OwF47n+2/vWuJZtvdW7Zy91YY0NDQ+zd+x6h8jDS28P4eBLH9lN/xw62tW98vvyhL/zG+s7n//D38ycOrvvC2rXl4Ouh4a69vOdvp6upg5HREA/v3En7K6+QHhkhPjQELS3Yto1t22zetpOPO2RkBJLjcdJJl8lTfaSciU+z2ZzT/upbB7sOv/fu5TfcXYe+27Jnz3e2fvqRl2zb5mRzMydbL3OmrZ9TF7o5c6mdg8fOctSZ0tlzqZtL/SNc7BnmbEcvdS1Pnwh/4esvxe+7+6WKsRJKSksFwBcMUlZWSlFJCcFwGPy+a8Yf30sYGR2ls7OT7u5ueoe6IZWm/r570puefu71+pee+fX63Q//9v0Hntv11L5jhx976Lmnnv5jyrZ/8NST9z966PgZZuyH9yf+svbZyZRnzjsHMqSSmefK/rBv4GxTo7uzs8twXX/4oYefA+pCwSCVlRWUlpRQVl5OZUUFFRVhyitCVJSXU1lRQWVFiMrKEJXhEJWhMGH/e9+58PJzf9l4z+d237Xl/mfm/i8mUumFszhj/gDRhfUs2nAL1k0r+fWFD/rfaHrj3bbmw+OX2pq/3d19rnvf4cNvt7R3LDDsfPR1AqHocwuvlk+4U7GCxHYv/j/fuM2t31c7gQAAAABJRU5ErkJggg==';
                try {
                    doc.addImage(flagUrl, 'PNG', margin, yPos - 5, 30, 20);
                } catch (e) {
                    console.log('Flag load failed');
                }

                addText('REPUBLIC OF UGANDA', pageWidth / 2, yPos, { size: 14, style: 'bold', align: 'center' });
                yPos += 8;
                addText('GEOSPATIAL NETWORK UGANDA', pageWidth / 2, yPos, { size: 12, align: 'center' });
                yPos += 10;

                // Certificate Title
                doc.setFillColor(22, 163, 74); // Green background
                doc.rect(margin, yPos, pageWidth - 2 * margin, 15, 'F');
                addText('LAND REGISTRATION CERTIFICATE', pageWidth / 2, yPos + 10, {
                    size: 16,
                    style: 'bold',
                    color: [255, 255, 255],
                    align: 'center'
                });
                yPos += 20;

                // Registration Number
                addText(`Registration No: ${registration.parcel_id}`, pageWidth / 2, yPos, {
                    size: 14,
                    style: 'bold',
                    align: 'center'
                });
                yPos += 10;
                addText(`Date: ${new Date(registration.created_at).toLocaleDateString('en-GB')}`, pageWidth / 2, yPos, {
                    size: 10,
                    align: 'center'
                });
                yPos += 15;

                // Parcel Information Section
                doc.setDrawColor(200, 200, 200);
                doc.setLineWidth(0.5);
                doc.line(margin, yPos, pageWidth - margin, yPos);
                yPos += 8;

                addText('PARCEL INFORMATION', margin, yPos, { size: 12, style: 'bold', color: [22, 163, 74] });
                yPos += 8;

                const parcelInfo = [
                    ['Parcel ID:', registration.parcel_id],
                    ['Ownership Type:', registration.ownership_type],
                    ['District:', registration.district],
                    ['County:', registration.county],
                    ['Sub-County:', registration.sub_county],
                    ['Parish:', registration.parish],
                    ['Village:', registration.village],
                    ['Area (Acres):', registration.parcel_area_acres || 'N/A'],
                ];

                parcelInfo.forEach(([label, value]) => {
                    addText(label, margin, yPos, { size: 10, style: 'bold' });
                    addText(String(value), margin + 50, yPos, { size: 10 });
                    yPos += 6;
                });

                yPos += 5;

                // Current Owners Section
                doc.line(margin, yPos, pageWidth - margin, yPos);
                yPos += 8;
                addText('REGISTERED OWNER(S)', margin, yPos, { size: 12, style: 'bold', color: [22, 163, 74] });
                yPos += 8;

                const currentOwners = owners.filter(o => o.owner_type === 'CURRENT');

                for (const owner of currentOwners) {
                    // Owner box
                    doc.setFillColor(240, 253, 244); // Light green
                    doc.rect(margin, yPos - 5, pageWidth - 2 * margin, 25, 'F');
                    doc.setDrawColor(134, 239, 172);
                    doc.rect(margin, yPos - 5, pageWidth - 2 * margin, 25);

                    // Owner photo placeholder or actual photo
                    if (owner.passport_photo_url) {
                        try {
                            // Try to load and embed photo
                            const img = await loadImageAsBase64(owner.passport_photo_url);
                            doc.addImage(img, 'JPEG', margin + 5, yPos - 3, 20, 20);
                        } catch (e) {
                            // Fallback to placeholder
                            doc.setFillColor(220, 252, 231);
                            doc.rect(margin + 5, yPos - 3, 20, 20, 'F');
                            addText('📷', margin + 12, yPos + 10, { size: 14 });
                        }
                    } else {
                        doc.setFillColor(220, 252, 231);
                        doc.rect(margin + 5, yPos - 3, 20, 20, 'F');
                        addText('👤', margin + 12, yPos + 10, { size: 14 });
                    }

                    // Owner details
                    addText(owner.full_name || 'N/A', margin + 30, yPos + 2, { size: 11, style: 'bold' });
                    addText(`Phone: ${owner.contact_phone || 'N/A'}`, margin + 30, yPos + 8, { size: 9 });
                    if (owner.contact_email) {
                        addText(`Email: ${owner.contact_email}`, margin + 30, yPos + 14, { size: 9 });
                    }

                    yPos += 30;
                }

                yPos += 5;

                // Previous Owners (if any)
                const previousOwners = owners.filter(o => o.owner_type === 'PREVIOUS');
                if (previousOwners.length > 0) {
                    doc.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 8;
                    addText('PREVIOUS OWNER(S)', margin, yPos, { size: 11, style: 'bold', color: [217, 119, 6] });
                    yPos += 6;

                    previousOwners.forEach(owner => {
                        addText(`• ${owner.full_name || 'N/A'}`, margin + 5, yPos, { size: 9 });
                        yPos += 5;
                    });
                    yPos += 5;
                }

                // Registration Details
                doc.line(margin, yPos, pageWidth - margin, yPos);
                yPos += 8;
                addText('REGISTRATION DETAILS', margin, yPos, { size: 12, style: 'bold', color: [22, 163, 74] });
                yPos += 8;

                const regDetails = [
                    ['Registration Type:', registration.registration_type],
                    ['Acquisition Method:', registration.acquisition_method],
                    ['Acquisition Date:', new Date(registration.acquisition_date).toLocaleDateString('en-GB')],
                    ['Status:', registration.status],
                ];

                regDetails.forEach(([label, value]) => {
                    addText(label, margin, yPos, { size: 10, style: 'bold' });
                    addText(String(value), margin + 50, yPos, { size: 10 });
                    yPos += 6;
                });

                yPos += 10;

                // ISSUER SECTION
                doc.setDrawColor(22, 163, 74);
                doc.setLineWidth(1);
                doc.line(margin, yPos, pageWidth - margin, yPos);
                yPos += 10;

                // Two columns for issuer section
                const leftCol = margin;
                const rightCol = pageWidth / 2 + 10;

                // Left column - Issuer details
                addText('ISSUED BY:', leftCol, yPos, { size: 10, style: 'bold' });
                yPos += 7;
                addText(user?.email || 'Land Registration Clerk', leftCol, yPos, { size: 10 });
                yPos += 6;
                addText('Title: Land Registration Clerk', leftCol, yPos, { size: 9 });
                yPos += 6;
                addText('Department: Land Registration', leftCol, yPos, { size: 9 });
                yPos += 6;
                addText(`Issue Date: ${new Date().toLocaleDateString('en-GB')}`, leftCol, yPos, { size: 9 });

                // Right column - Signature and stamp
                const signatureY = yPos - 25;
                addText('SIGNATURE:', rightCol, signatureY, { size: 10, style: 'bold' });
                doc.line(rightCol, signatureY + 15, pageWidth - margin, signatureY + 15); // Signature line
                addText('_______________________', rightCol, signatureY + 15, { size: 10 });

                // Official stamp box
                doc.setDrawColor(100, 100, 100);
                doc.setLineWidth(0.5);
                doc.rect(rightCol, signatureY + 20, 50, 50);
                addText('OFFICIAL', rightCol + 25, signatureY + 40, { size: 8, align: 'center' });
                addText('STAMP', rightCol + 25, signatureY + 46, { size: 8, align: 'center' });

                yPos += 20;

                // Footer
                yPos = pageHeight - 25;
                doc.setFillColor(240, 240, 240);
                doc.rect(margin, yPos, pageWidth - 2 * margin, 15, 'F');
                addText('This is an official document issued by GEOSPATIAL NETWORK UGANDA',
                    pageWidth / 2, yPos + 6, { size: 8, align: 'center', style: 'italic' });
                addText(`Certificate ID: ${registration.id}`,
                    pageWidth / 2, yPos + 11, { size: 7, align: 'center', color: [100, 100, 100] });

                // Save PDF
                doc.save(`Land_Certificate_${registration.parcel_id}_${Date.now()}.pdf`);

                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-file-pdf"></i> Export PDF Certificate';
                alert('✅ PDF Certificate generated successfully!');

            } catch (error) {
                console.error('PDF generation error:', error);
                alert('❌ Failed to generate PDF: ' + error.message);
                event.target.disabled = false;
                event.target.innerHTML = '<i class="fas fa-file-pdf"></i> Export PDF Certificate';
            }
        }

        // Helper function to load image as base64
        async function loadImageAsBase64(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        // Print certificate function
        async function printCertificate(registrationId) {
            try {
                const btn = event.target;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing...';

                // Fetch data
                const { data: registration } = await supabaseClient
                    .from('land_registrations')
                    .select('*')
                    .eq('id', registrationId)
                    .single();

                const { data: owners } = await supabaseClient
                    .from('land_owners')
                    .select('*')
                    .eq('registration_id', registrationId);

                const { data: { user } } = await supabaseClient.auth.getUser();

                const currentOwners = owners.filter(o => o.owner_type === 'CURRENT');
                const previousOwners = owners.filter(o => o.owner_type === 'PREVIOUS');

                // Create print window with certificate
                const printWindow = window.open('', '_blank');
                printWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Land Certificate - ${registration.parcel_id}</title>
    <style>
        @page { size: A4; margin: 15mm; }
        @media print { body { margin: 0; padding: 0; } .no-print { display: none; } }
        body { font-family: 'Times New Roman', serif; line-height: 1.6; color: #000; }
        .certificate { border: 3px solid #16a34a; padding: 20px; max-width: 210mm; margin: 0 auto; background: white; }
        .header { text-align: center; margin-bottom: 20px; }
        .title-box { background: #16a34a; color: white; padding: 15px; text-align: center; font-size: 20px; font-weight: bold; margin: 20px 0; }
        .section { margin: 15px 0; padding: 10px 0; border-top: 1px solid #ccc; }
        .section-title { color: #16a34a; font-weight: bold; font-size: 14px; margin-bottom: 10px; }
        .info-row { display: flex; margin: 5px 0; }
        .info-label { font-weight: bold; width: 150px; }
        .owner-box { background: #f0fdf4; border: 1px solid #86efac; padding: 10px; margin: 10px 0; display: flex; gap: 15px; }
        .owner-photo { width: 60px; height: 60px; border: 2px solid #16a34a; object-fit: cover; }
        .issuer-section { margin-top: 30px; padding-top: 20px; border-top: 2px solid #16a34a; display: flex; justify-content: space-between; }
        .signature-line { border-bottom: 1px solid #000; width: 200px; margin-top: 40px; }
        .stamp-box { border: 1px solid #666; width: 120px; height: 120px; display: flex; align-items: center; justify-content: center; text-align: center; font-size: 12px; color: #666; }
        .footer { text-align: center; margin-top: 30px; padding: 10px; background: #f3f4f6; font-size: 10px; font-style: italic; }
    </style>
</head>
<body>
    <div class="certificate">
        <div class="header">
            <h2 style="margin: 5px 0;">REPUBLIC OF UGANDA</h2>
            <h3 style="margin: 5px 0;">GEOSPATIAL NETWORK UGANDA</h3>
        </div>
        <div class="title-box">LAND REGISTRATION CERTIFICATE</div>
        <div style="text-align: center; margin: 15px 0;">
            <div style="font-size: 16px; font-weight: bold;">Registration No: ${registration.parcel_id}</div>
            <div style="font-size: 12px;">Date: ${new Date(registration.created_at).toLocaleDateString('en-GB')}</div>
        </div>
        <div class="section">
            <div class="section-title">PARCEL INFORMATION</div>
            <div class="info-row"><span class="info-label">Parcel ID:</span> ${registration.parcel_id}</div>
            <div class="info-row"><span class="info-label">Ownership Type:</span> ${registration.ownership_type}</div>
            <div class="info-row"><span class="info-label">District:</span> ${registration.district}</div>
            <div class="info-row"><span class="info-label">County:</span> ${registration.county}</div>
            <div class="info-row"><span class="info-label">Sub-County:</span> ${registration.sub_county}</div>
            <div class="info-row"><span class="info-label">Parish:</span> ${registration.parish}</div>
            <div class="info-row"><span class="info-label">Village:</span> ${registration.village}</div>
            <div class="info-row"><span class="info-label">Area (Acres):</span> ${registration.parcel_area_acres || 'N/A'}</div>
        </div>
        <div class="section">
            <div class="section-title">REGISTERED OWNER(S)</div>
            ${currentOwners.map(owner => `
                <div class="owner-box">
                    ${owner.passport_photo_url ?
                        `<img src="${owner.passport_photo_url}" class="owner-photo" alt="Owner Photo" />` :
                        `<div class="owner-photo" style="background: #dcfce7; display: flex; align-items: center; justify-content: center; font-size: 24px;">👤</div>`
                    }
                    <div>
                        <div style="font-weight: bold; font-size: 14px;">${owner.full_name || 'N/A'}</div>
                        <div>Phone: ${owner.contact_phone || 'N/A'}</div>
                        ${owner.contact_email ? `<div>Email: ${owner.contact_email}</div>` : ''}
                    </div>
                </div>
            `).join('')}
        </div>
        ${previousOwners.length > 0 ? `
        <div class="section">
            <div class="section-title">PREVIOUS OWNER(S)</div>
            ${previousOwners.map(owner => `<div>• ${owner.full_name || 'N/A'}</div>`).join('')}
        </div>
        ` : ''}
        <div class="section">
            <div class="section-title">REGISTRATION DETAILS</div>
            <div class="info-row"><span class="info-label">Registration Type:</span> ${registration.registration_type}</div>
            <div class="info-row"><span class="info-label">Acquisition Method:</span> ${registration.acquisition_method}</div>
            <div class="info-row"><span class="info-label">Acquisition Date:</span> ${new Date(registration.acquisition_date).toLocaleDateString('en-GB')}</div>
            <div class="info-row"><span class="info-label">Status:</span> ${registration.status}</div>
        </div>
        <div class="issuer-section">
            <div>
                <div style="font-weight: bold; margin-bottom: 5px;">ISSUED BY:</div>
                <div>${user?.email || 'Land Registration Clerk'}</div>
                <div style="font-size: 11px;">Title: Land Registration Clerk</div>
                <div style="font-size: 11px;">Department: Land Registration</div>
                <div style="font-size: 11px;">Issue Date: ${new Date().toLocaleDateString('en-GB')}</div>
            </div>
            <div>
                <div style="font-weight: bold; margin-bottom: 5px;">SIGNATURE:</div>
                <div class="signature-line"></div>
                <div style="margin-top: 20px; font-weight: bold;">OFFICIAL STAMP:</div>
                <div class="stamp-box"><div>OFFICIAL<br/>STAMP<br/>HERE</div></div>
            </div>
        </div>
        <div class="footer">
            This is an official document issued by GEOSPATIAL NETWORK UGANDA<br/>
            Certificate ID: ${registration.id}
        </div>
                `);
                printWindow.document.close();

                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-print"></i> Print Certificate';

            } catch (error) {
                console.error('Print error:', error);
                alert('❌ Failed to prepare print: ' + error.message);
                event.target.disabled = false;
                event.target.innerHTML = '<i class="fas fa-print"></i> Print Certificate';
            }
        }


        // Clear search
        function clearSearch() {
            document.getElementById('searchParcelId').value = '';
            document.getElementById('searchOwnerName').value = '';
            document.getElementById('searchDistrict').value = '';
            document.getElementById('searchStatus').value = '';
            document.getElementById('searchResults').innerHTML = '';
            searchState.results = [];
        }


        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkClerkRole();

            const clerkBtn = document.getElementById('clerkBtn');
            if (clerkBtn) {
                clerkBtn.addEventListener('click', openClerkModal);
            }

            const closeBtn = document.getElementById('closeClerkModal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeClerkModal);
            }

            const modal = document.getElementById('clerkModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeClerkModal();
                });
            }

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('clerk-tab')) {
                    document.querySelectorAll('.clerk-tab').forEach(tab => tab.classList.remove('active'));
                    e.target.classList.add('active');
                    loadClerkTab(e.target.dataset.tab);
                }
            });
        });

        // Global PDF Export Function injected by System to ensure availability
        // Global PDF Export Function injected by System to ensure availability
        window.exportEnhancedReportPDF = function () {
            const element = document.getElementById('autoValueReportContainer');
            if (!element) {
                const msg = 'Report container not found.';
                if (window.showToast) window.showToast(msg, 'error');
                else alert(msg);
                return;
            }

            if (window.showToast) window.showToast('Generating PDF... Please wait.', 'info');

            // Clone to modify
            const clone = element.cloneNode(true);
            const buttons = clone.querySelectorAll('button');
            buttons.forEach(btn => btn.remove());

            // Fix images
            const images = clone.querySelectorAll('img');
            images.forEach(img => {
                img.crossOrigin = 'Anonymous';
            });

            // Timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `Valuation_Report_${timestamp}.pdf`;

            const opt = {
                margin: [10, 10, 10, 10],
                filename: filename,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: {
                    scale: 2,
                    useCORS: true,
                    logging: true,
                    letterRendering: true
                },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
            };

            if (typeof html2pdf === 'undefined') {
                alert('PDF library not loaded. Please refresh.');
                return;
            }

            html2pdf().set(opt).from(clone).save().then(() => {
                if (window.showToast) window.showToast('PDF exported successfully!', 'success');
            }).catch(err => {
                console.error('PDF Export Error:', err);
                alert('Export failed: ' + err.message);
            });
        };

        window.exportPopupPDF = function (elementId, title, propertyData, comparableImages) {
            if (window.showToast) window.showToast('Generating PDF... Please wait.', 'info');

            let pdfContent;

            // Create professional PDF template based on type
            if (title === 'Property_Details' && propertyData) {
                pdfContent = createPropertyDetailsPDF(propertyData);
            } else if (title === 'Comparable_Details' && propertyData) {
                pdfContent = createComparableDetailsPDF(propertyData, comparableImages);
            } else {
                alert('Missing data for PDF export');
                return;
            }

            // Container for PDF generation (off-screen)
            const container = document.createElement('div');
            container.style.position = 'absolute';
            container.style.top = '-9999px';
            container.style.left = '-9999px';
            container.style.width = '800px';
            container.innerHTML = pdfContent;
            document.body.appendChild(container);

            // Fix images for CORS
            const images = container.querySelectorAll('img');
            images.forEach(img => {
                img.crossOrigin = 'Anonymous';
            });

            const opt = {
                margin: [10, 10, 10, 10],
                filename: `${title}_${new Date().toISOString().split('T')[0]}.pdf`,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: {
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    scrollY: 0,
                    windowWidth: 800
                },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
            };

            // Wait for images to load
            const loadImages = Array.from(images).map(img => {
                if (img.complete) return Promise.resolve();
                return new Promise(resolve => {
                    img.onload = resolve;
                    img.onerror = resolve;
                });
            });

            Promise.all(loadImages).then(() => {
                html2pdf().set(opt).from(container).save().then(() => {
                    document.body.removeChild(container);
                    if (window.showToast) window.showToast('PDF exported successfully!', 'success');
                }).catch(err => {
                    console.error('PDF Export Error:', err);
                    alert('Export failed: ' + err.message);
                    if (container.parentNode) document.body.removeChild(container);
                });
            });
        };

        // Helper function to format price
        function formatPriceForPDF(value) {
            if (!value) return 'N/A';
            return parseFloat(value).toLocaleString('en-US');
        }

        // Create Property Details PDF Template
        function createPropertyDetailsPDF(property) {
            const hasImages = property.image_urls && property.image_urls.length > 0;
            const imageHTML = hasImages ? property.image_urls.map((url, idx) => `
                <div style="margin-bottom: 15px; page-break-inside: avoid;">
                    <img src="${url}" style="width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="text-align: center; color: #666; font-size: 12px; margin-top: 5px;">Photo ${idx + 1}</p>
                </div>
            `).join('') : '<p style="text-align: center; color: #999; padding: 20px;">No images available</p>';

            return `
                <div style="font-family: 'Segoe UI', Arial, sans-serif; color: #333; background: white; padding: 30px;">
                    <!-- Header -->
                    <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 4px solid #27ae60;">
                        <h1 style="margin: 0; color: #2c3e50; font-size: 28px; font-weight: 700;">PROPERTY DETAILS REPORT</h1>
                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 14px;">Generated on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                    </div>

                    <!-- Property Information -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h2 style="margin: 0 0 15px 0; font-size: 22px; font-weight: 600;">📍 ${property.district || 'N/A'}</h2>
                        <div style="font-size: 32px; font-weight: 700; margin-bottom: 5px;">UGX ${formatPriceForPDF(property.price_ugx)}</div>
                        <div style="font-size: 14px; opacity: 0.9;">Listed Price</div>
                    </div>

                    <!-- Property Details Grid -->
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 18px; border-bottom: 2px solid #27ae60; padding-bottom: 8px;">Property Information</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; width: 40%; font-weight: 600; color: #495057;">📏 Area:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.area_sqm ? formatPriceForPDF(property.area_sqm) + ' m²' : 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">📋 Plot Number:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.plot_number || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">🏗️ Block Number:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.block_number || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">📍 District:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.district || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">🏘️ County:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.county || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">🏡 Sub County:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.sub_county || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">🌍 Parish:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.parish || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">🏘️ Village:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.village || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">📌 Coordinates:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${property.lat ? property.lat.toFixed(6) : 'N/A'}, ${property.lon ? property.lon.toFixed(6) : 'N/A'}</td>
                            </tr>
                        </table>
                    </div>

                    <!-- Seller Information -->
                    <div style="background: #fff3cd; padding: 20px; border-radius: 10px; border-left: 5px solid #ffc107; margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #856404; font-size: 18px;">👤 Seller Information</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 8px 0; width: 40%; font-weight: 600; color: #856404;">Name:</td>
                                <td style="padding: 8px 0; color: #212529;">${property.seller_name || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px 0; font-weight: 600; color: #856404;">Contact:</td>
                                <td style="padding: 8px 0; color: #212529;">${property.contact || 'N/A'}</td>
                            </tr>
                        </table>
                    </div>

                    <!-- Property Images -->
                    <div style="margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 18px; border-bottom: 2px solid #27ae60; padding-bottom: 8px;">📸 Property Photos</h3>
                        ${imageHTML}
                    </div>

                    <!-- Footer -->
                    <div style="margin-top: 40px; padding-top: 20px; border-top: 3px solid #27ae60; text-align: center;">
                        <div style="font-size: 16px; font-weight: 700; color: #2c3e50; letter-spacing: 2px; margin-bottom: 5px;">GEOSPATIAL NETWORK UGANDA</div>
                        <div style="font-size: 12px; color: #7f8c8d;">Professional Property Listing Services</div>
                        <div style="font-size: 11px; color: #95a5a6; margin-top: 10px;">This report is generated automatically and contains information as of ${new Date().toLocaleString()}</div>
                    </div>
                </div>
            `;
        }

        // Create Comparable Details PDF Template
        function createComparableDetailsPDF(valuation, images) {
            const hasImages = images && images.length > 0;
            const imageHTML = hasImages ? images.map((imgObj, idx) => `
                <div style="margin-bottom: 15px; page-break-inside: avoid;">
                    <img src="${imgObj.url}" style="width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="text-align: center; color: #666; font-size: 12px; margin-top: 5px;">${imgObj.label}</p>
                </div>
            `).join('') : '<p style="text-align: center; color: #999; padding: 20px;">No images available</p>';

            return `
                <div style="font-family: 'Segoe UI', Arial, sans-serif; color: #333; background: white; padding: 30px;">
                    <!-- Header -->
                    <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 4px solid #3498db;">
                        <h1 style="margin: 0; color: #2c3e50; font-size: 28px; font-weight: 700;">PROPERTY VALUATION REPORT</h1>
                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 14px;">Comparable Property Details</p>
                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 12px;">Generated on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                    </div>

                    <!-- Valuation Summary -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h2 style="margin: 0 0 15px 0; font-size: 22px; font-weight: 600;">💰 Valuation Summary</h2>
                        <div style="font-size: 32px; font-weight: 700; margin-bottom: 5px;">UGX ${formatPriceForPDF(valuation.price_ugx || 0)}</div>
                        <div style="font-size: 14px; opacity: 0.9;">Total Valuation</div>
                        ${valuation.land_value_ugx ? `<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.3); font-size: 14px;">
                            <div style="margin-bottom: 5px;">Land Value: UGX ${formatPriceForPDF(valuation.land_value_ugx)}</div>
                            ${valuation.improvements_value_ugx ? `<div>Improvements: UGX ${formatPriceForPDF(valuation.improvements_value_ugx)}</div>` : ''}
                        </div>` : ''}
                    </div>

                    <!-- Property Location -->
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 18px; border-bottom: 2px solid #3498db; padding-bottom: 8px;">📍 Location Details</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; width: 40%; font-weight: 600; color: #495057;">District:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.district || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">County:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.county || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Sub County:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.sub_county || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Parish:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.parish || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Village:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.village_name || 'N/A'}</td>
                            </tr>
                        </table>
                    </div>

                    <!-- Property Details -->
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 18px; border-bottom: 2px solid #3498db; padding-bottom: 8px;">🏠 Property Details</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; width: 40%; font-weight: 600; color: #495057;">Plot Number:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.plot_number || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Block Number:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.block_number || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Property Type:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.property_type || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Tenure:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.tenure || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Property Size:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.property_size_sqm ? formatPriceForPDF(valuation.property_size_sqm) + ' m²' : 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Proprietor:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.proprietor_name || 'N/A'}</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; font-weight: 600; color: #495057;">Valuation Date:</td>
                                <td style="padding: 10px 0; border-bottom: 1px solid #dee2e6; color: #212529;">${valuation.valuation_date || 'N/A'}</td>
                            </tr>
                        </table>
                    </div>

                    ${valuation.surveyor_name ? `
                    <!-- Surveyor Information -->
                    <div style="background: #d1ecf1; padding: 20px; border-radius: 10px; border-left: 5px solid #17a2b8; margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #0c5460; font-size: 18px;">👨‍💼 Surveyor Information</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 8px 0; width: 40%; font-weight: 600; color: #0c5460;">Surveyor Name:</td>
                                <td style="padding: 8px 0; color: #212529;">${valuation.surveyor_name}</td>
                            </tr>
                        </table>
                    </div>
                    ` : ''}

                    <!-- Property Images -->
                    <div style="margin-bottom: 25px;">
                        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 18px; border-bottom: 2px solid #3498db; padding-bottom: 8px;">📸 Property & Document Images</h3>
                        ${imageHTML}
                    </div>

                    <!-- Footer -->
                    <div style="margin-top: 40px; padding-top: 20px; border-top: 3px solid #3498db; text-align: center;">
                        <div style="font-size: 16px; font-weight: 700; color: #2c3e50; letter-spacing: 2px; margin-bottom: 5px;">GEOSPATIAL NETWORK UGANDA</div>
                        <div style="font-size: 12px; color: #7f8c8d;">Professional Property Valuation Services</div>
                        <div style="font-size: 11px; color: #95a5a6; margin-top: 10px;">This report is generated automatically and contains information as of ${new Date().toLocaleString()}</div>
                    </div>
                </div>
            `;
        }

        // Delegated Event Listener to ensure click is caught
        document.addEventListener('click', function (e) {
            if (e.target && (e.target.id === 'exportReportPDFBtn' || e.target.closest('#exportReportPDFBtn'))) {
                e.preventDefault();
                console.log('PDF Export Button Clicked (Delegated)');
                window.exportEnhancedReportPDF();
            }
        });
    </script>
    <script>
        // Initialize Supabase - check if already declared to avoid duplicate declaration error
        var supabase;
        // Make supabaseUrl and supabaseKey globally accessible
        window.supabaseUrl = window.supabaseUrl || 'https://kwssgfanbntfjdclchfi.supabase.co';
        window.supabaseKey = window.supabaseKey || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3c3NnZmFuYm50ZmpkY2xjaGZpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzNjM4ODUsImV4cCI6MjA3MDkzOTg4NX0.zPKcOwWdWu3-7ii19c2ep6g2i-kCTaUBZablTYDgZwA';
        const supabaseUrl = window.supabaseUrl;
        const supabaseKey = window.supabaseKey;
        if (typeof window.supabaseClient === 'undefined') {
            supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
            window.supabaseClient = supabase; // Store in window for global access
        } else {
            supabase = window.supabaseClient;
        }
        window.__currentProfileRole = window.__currentProfileRole || null;
        window.__valuationFeaturesEnabled = window.__valuationFeaturesEnabled === true;

        // Enhanced authentication check with secure cookies
        document.addEventListener('DOMContentLoaded', async function () {
            // Function to validate token format
            function isValidToken(token) {
                try {
                    if (token.startsWith('{')) {
                        const parsed = JSON.parse(token);
                        return parsed && (
                            (parsed.access_token && parsed.access_token.length > 50) ||
                            (parsed.token_type && parsed.expires_at)
                        );
                    }
                    else if (token.length > 50 && token.split('.').length === 3) {
                        return true;
                    }
                } catch (e) {
                    console.log('Token validation error:', e);
                }
                return false;
            }

            // Function to get cookie value
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            // Wait a moment for cookie to be set (in case of redirect timing issues)
            await new Promise(resolve => setTimeout(resolve, 100));

            // Check authentication
            const authToken = getCookie('supabase_auth_token');
            const referrer = document.referrer;
            const isFromValidOrigin = referrer.includes('webmap.geospatialnetworkug.xyz') ||
                referrer.includes('localhost') ||
                referrer.includes('127.0.0.1') ||
                referrer.includes('ec2') ||
                referrer.includes('index.html') ||
                referrer === '';


            // If no token, try to get from localStorage as backup
            let finalToken = authToken;
            if (!finalToken) {
                const storedToken = localStorage.getItem('supabase.auth.token');
                if (storedToken && isValidToken(storedToken)) {
                    finalToken = storedToken;
                }
            }

            // TEMPORARY: Allow access for testing if coming from index.html
            if (referrer.includes('index.html') && !finalToken) {
                // Don't redirect, continue with map load
            } else if (!finalToken || !isValidToken(finalToken) || !isFromValidOrigin) {
                // Clear any potentially invalid tokens
                document.cookie = 'supabase_auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                localStorage.removeItem('supabase.auth.token');
                localStorage.removeItem('supabase.auth.session');

                window.location.href = 'index.html';
                return;
            }

            // Verify the token is still valid with Supabase (if we have a token)
            if (finalToken) {
                try {
                    const { data: { user }, error } = await supabase.auth.getUser(finalToken);
                    if (error || !user) {
                        window.location.href = 'index.html';
                        return;
                    }
                    window.__currentValuationUserId = user.id;

                    // Check if user has active subscription
                    try {
                        const { data: profile, error: profileError } = await supabase
                            .from('profiles')
                            .select('subscription, role')
                            .eq('id', user.id)
                            .single();

                        if (profileError) {
                            console.warn('Profile check failed, but continuing with authentication:', profileError);
                            // Continue with authentication even if profile check fails
                            const cachedRole = localStorage.getItem('supabase.profile.role');
                            if (cachedRole) {
                                window.__currentProfileRole = cachedRole;
                                window.__valuationFeaturesEnabled = cachedRole === 'valuer';
                            }
                            if (typeof window.__initializeValuationUI === 'function') {
                                window.__initializeValuationUI();
                            }
                        } else {
                            window.__currentProfileRole = profile?.role || null;
                            window.__valuationFeaturesEnabled = profile?.role === 'valuer';
                            if (profile?.role) {
                                localStorage.setItem('supabase.profile.role', profile.role);
                                if (typeof window.__initializeValuationUI === 'function') {
                                    window.__initializeValuationUI();
                                }
                            }
                            if (!profile?.subscription) {
                                console.log('User subscription not active, redirecting to login');
                                window.location.href = 'index.html';
                                return;
                            }
                        }
                    } catch (profileError) {
                        console.warn('Profile check error, but continuing with authentication:', profileError);
                        // Continue with authentication even if profile check fails
                        const cachedRole = localStorage.getItem('supabase.profile.role');
                        if (cachedRole) {
                            window.__currentProfileRole = cachedRole;
                            window.__valuationFeaturesEnabled = cachedRole === 'valuer';
                            if (typeof window.__initializeValuationUI === 'function') {
                                window.__initializeValuationUI();
                            }
                        }
                    }

                } catch (error) {
                    console.error('Authentication verification error:', error);
                    window.location.href = 'index.html';
                    return;
                }
            } else {
                console.log('No token available, proceeding with limited access');
            }

            if (!window.__currentProfileRole) {
                const cachedRole = localStorage.getItem('supabase.profile.role');
                if (cachedRole) {
                    window.__currentProfileRole = cachedRole;
                    window.__valuationFeaturesEnabled = cachedRole === 'valuer';
                    if (typeof window.__initializeValuationUI === 'function') {
                        window.__initializeValuationUI();
                    }
                }
            }


            // Chat system is initialized separately via DOMContentLoaded listener (see line 13599)
        });
    </script>
    <title>Geospatial Network Uganda - Professional Web Map</title>
    <!-- OpenLayers 7.3.0 CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.css" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol-layerswitcher@4.1.0/dist/ol-layerswitcher.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌍</text></svg>">
    <!-- Chart.js for valuation reports -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- jsPDF and html2canvas for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @media print {
            .comparable-page {
                page-break-before: always;
            }

            .valuation-report-section {
                page-break-inside: avoid;
            }
        }
    </style>
    <style>
        /* ========================================
           GSP.NET UPDATES LEFT-SIDE DOCK
           ======================================== */

        .gspnet-updates-dock {
            position: fixed;
            left: 0;
            top: 0;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: 2px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        .gspnet-updates-dock[aria-hidden="false"] {
            transform: translateX(0);
        }

        .dock-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .dock-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dock-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: transform 0.2s;
        }

        .dock-close:hover {
            transform: scale(1.2);
        }

        .dock-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .dock-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .dock-section h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-input,
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .file-input:focus,
        .form-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .btn {
            width: 100%;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
        }

        .edit-tool-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .radio-label,
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .radio-label:hover,
        .checkbox-label:hover {
            background: #e3f2fd;
        }

        .radio-label input,
        .checkbox-label input {
            cursor: pointer;
        }

        .attr-form-container {
            min-height: 100px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }

        .help-text {
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.9rem;
            margin: 0;
        }

        .status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            display: none;
        }

        .status-message {
            display: block;
            visibility: visible;
            opacity: 1;
            margin-top: 10px;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }

        .edit-summary {
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .edit-summary ul {
            margin: 5px 0 0 0;
            padding-left: 20px;
        }

        .edit-summary li {
            margin: 3px 0;
        }

        .commit-buttons {
            display: flex;
            gap: 8px;
        }

        .commit-buttons .btn {
            flex: 1;
        }

        .csv-mapping {
            margin: 10px 0;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 4px;
            display: none;
        }

        .csv-mapping.active {
            display: block;
        }

        .info-box {
            margin-top: 10px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 0.85rem;
            display: none;
        }

        .info-box.active {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .gspnet-updates-dock {
                width: 100%;
            }
        }

        /* Coordinate Extractor Styles */
        .coord-extractor-controls {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }

        .tolerance-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tolerance-controls input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        .tolerance-controls input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .tolerance-controls input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        #tolerance-value {
            font-weight: bold;
            color: #2c3e50;
            min-width: 35px;
        }

        .coord-extractor-btn {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            margin: 5px;
            width: calc(100% - 10px);
            text-align: center;
        }

        .coord-extractor-btn:hover {
            background: linear-gradient(to bottom, #3cb0fd, #3498db);
        }

        .crs-selector {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            margin: 10px 0;
        }

        .coord-extractor-status {
            margin-top: 10px;
            padding: 8px;
            background: #e8f4f8;
            border-radius: 6px;
            font-size: 0.9rem;
            display: none;
        }

        .coord-result-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .coord-result-table th,
        .coord-result-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .coord-result-table th {
            background-color: #f2f2f2;
        }

        /* Vertical layout for GSPNET Assist Panel */
        .gspnet-tabs {
            flex-direction: column;
            background: linear-gradient(180deg, #1a2a6c, #2c3e50);
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px;
            width: 120px;
            flex-shrink: 0;
        }

        .gspnet-tab {
            padding: 15px 10px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 3px solid transparent;
        }

        .gspnet-tab.active {
            border-right: 3px solid #3498db;
            background: rgba(255, 255, 255, 0.1);
        }

        .gspnet-tab i {
            margin-right: 0;
            margin-bottom: 5px;
            display: block;
            font-size: 1.2rem;
        }

        .gspnet-content {
            flex: 1;
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .gspnet-panel-inner {
            display: flex;
            height: 100%;
        }

        /* Upload progress styles */
        .upload-progress {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            display: none;
        }

        .upload-progress-bar {
            height: 100%;
            background: linear-gradient(to right, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s;
        }

        .upload-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.9rem;
            display: none;
        }

        .upload-status.success {
            background: #e8f6ef;
            border-left: 4px solid #2ecc71;
        }

        .upload-status.error {
            background: #fceae9;
            border-left: 4px solid #e74c3c;
        }

        /* PATCH: Drawing tools styles */
        .drawing-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .drawing-tools,
        .drawing-actions,
        .drawing-export {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .drawing-btn {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            flex: 1;
            min-width: 80px;
            justify-content: center;
        }

        .drawing-btn:hover {
            background: linear-gradient(to bottom, #2980b9, #3498db);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }

        .drawing-btn.active {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3);
        }

        .drawing-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .drawing-info p {
            margin: 0 0 8px 0;
            color: #ecf0f1;
        }

        #drawing-stats {
            display: flex;
            gap: 15px;
            font-weight: 600;
        }

        #drawing-stats span {
            color: #bdc3c7;
        }

        /* PATCH: Measurement tools styles */
        .measurement-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .measurement-tools,
        .measurement-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .measurement-btn {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            flex: 1;
            min-width: 80px;
            justify-content: center;
        }

        .measurement-btn:hover {
            background: linear-gradient(to bottom, #c0392b, #e74c3c);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }

        .measurement-btn.active {
            background: linear-gradient(to bottom, #27ae60, #2ecc71);
            box-shadow: 0 0 0 2px rgba(39, 174, 96, 0.3);
        }

        .measurement-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .measurement-info p {
            margin: 0 0 8px 0;
            color: #ecf0f1;
        }

        #measurement-results {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #measurement-results div {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* Existing styles */
        .layer-counter {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: default;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .contact-info {
            flex: 1;
            min-width: 150px;
        }

        .contact-name {
            font-size: 0.95rem;
            margin-top: 3px;
        }

        .disclaimer-box {
            margin-top: 20px;
            background: #fff8e6;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--warning);
            font-size: 0.9rem;
        }

        @media print {

            header,
            .map-bottom-controls,
            .terrain-toggle,
            .feature-info,
            .layer-warning,
            .ol-control,
            .gspnet-assist-panel,
            #gspnet-assist-btn {
                display: none !important;
            }

            #map {
                position: fixed !important;
                top: 0;
                left: 0;
                width: 100% !important;
                height: 95vh !important;
            }

            .print-disclaimer {
                display: block !important;
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background: white;
                padding: 10px;
                font-size: 10px;
                text-align: center;
                border-top: 1px solid #ccc;
                z-index: 10000;
            }

            /* Print Layout Styles for Generated Print Window */
            body.print-mode {
                margin: 0;
                padding: 0;
                font-family: 'Arial', 'Helvetica', sans-serif;
                font-size: 11px;
                color: #000;
                background: #fff;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .print-layout {
                width: 100%;
                height: 100%;
            }

            /* Header Section */
            .print-header-section {
                border: 3px solid #000;
                padding: 12px;
                margin-bottom: 10px;
                background: #fff;
                page-break-inside: avoid;
            }

            .print-heading {
                text-align: center;
                font-size: 20px;
                font-weight: bold;
                margin-bottom: 10px;
                color: #000;
                padding: 5px 0;
            }

            .print-top-row {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                margin-top: 8px;
            }

            .print-left-info {
                text-align: left;
                flex: 1;
            }

            .print-right-info {
                text-align: right;
                flex: 0 0 auto;
                padding-left: 20px;
            }

            .print-info-line {
                margin: 4px 0;
                font-size: 10px;
                line-height: 1.4;
            }

            .print-info-label {
                font-weight: 600;
                display: inline-block;
                min-width: 65px;
            }

            .print-info-value {
                display: inline-block;
            }

            .qr-container {
                margin-top: 8px;
                text-align: center;
            }

            .qr-container img {
                width: 80px;
                height: 80px;
                border: 1px solid #000;
                padding: 3px;
                background: #fff;
            }

            .company-name {
                font-weight: bold;
                font-size: 12px;
                margin-bottom: 5px;
                color: #1a2a6c;
            }

            /* Map Section - Takes most space */
            .print-map-section {
                border: 3px solid #000;
                padding: 8px;
                margin: 10px 0;
                background: #fff;
                min-height: 450px;
                position: relative;
                page-break-inside: avoid;
            }

            .print-map-container {
                width: 100%;
                height: 100%;
                min-height: 450px;
                border: 2px solid #333;
                background: #f5f5f5;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }

            .print-map-container img {
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
                display: block;
            }

            .map-scale-info {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: rgba(255, 255, 255, 0.9);
                padding: 5px 10px;
                border: 1px solid #000;
                font-size: 9px;
                font-weight: 600;
            }

            /* Bottom Section with Signatures */
            .print-bottom-section {
                border: 3px solid #000;
                padding: 12px;
                margin-top: 10px;
                display: flex;
                justify-content: space-between;
                gap: 15px;
                background: #fff;
                align-items: stretch;
                page-break-inside: avoid;
            }

            .print-signature-section {
                flex: 1;
                border: 2px solid #000;
                padding: 10px;
                background: #fafafa;
            }

            .print-signature-section h4 {
                margin: 0 0 10px 0;
                font-size: 11px;
                font-weight: bold;
                color: #1a2a6c;
                border-bottom: 1px solid #000;
                padding-bottom: 5px;
            }

            .print-signature-line {
                margin: 12px 0;
                font-size: 10px;
            }

            .print-signature-label {
                font-weight: 600;
                display: block;
                margin-bottom: 3px;
            }

            .print-signature-value {
                margin-bottom: 5px;
                min-height: 15px;
            }

            .print-signature-space {
                height: 50px;
                border-bottom: 2px solid #000;
                margin-top: 8px;
                position: relative;
            }

            .print-signature-space::after {
                content: '';
                position: absolute;
                bottom: -1px;
                left: 0;
                right: 0;
                border-bottom: 1px solid #ccc;
            }

            /* Compass Container with Rectangle */
            .print-compass-container {
                flex: 0 0 140px;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 2px solid #000;
                background: #fafafa;
                padding: 10px;
                margin: 0 5px;
                min-height: 140px;
            }

            .print-compass {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 120px;
                height: 120px;
            }

            .print-compass svg {
                display: block;
            }

            @media print {
                .print-compass-container {
                    position: fixed;
                    top: 15mm;
                    right: 15mm;
                }
            }

            /* Disclaimer Section */
            .print-disclaimer-section {
                border: 3px solid #000;
                padding: 10px;
                margin-top: 10px;
                background: #fff;
                page-break-inside: avoid;
            }

            .print-disclaimer-final {
                font-size: 9px;
                color: #333;
                text-align: center;
                line-height: 1.4;
                margin: 0;
            }

            .print-disclaimer-final strong {
                font-weight: bold;
                color: #000;
            }
        }

        .print-disclaimer {
            display: none;
        }

        /* Print Dialog Modal Styles */
        .print-dialog-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow: auto;
        }

        .print-dialog-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .print-dialog-content {
            background-color: #fff;
            margin: 20px auto;
            padding: 0;
            border-radius: 8px;
            width: 95%;
            max-width: 1400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .print-dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 2px solid #e0e0e0;
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .print-dialog-header h2 {
            margin: 0;
            font-size: 24px;
        }

        .close-print-dialog {
            background: none;
            border: none;
            font-size: 32px;
            color: white;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .close-print-dialog:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .print-dialog-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            min-height: 500px;
        }

        .print-form-panel {
            width: 40%;
            padding: 25px;
            overflow-y: auto;
            border-right: 1px solid #e0e0e0;
            background: #f9f9f9;
        }

        .print-form-panel h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #1a2a6c;
            font-size: 18px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .print-form-panel .form-group {
            margin-bottom: 20px;
        }

        .print-form-panel .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .print-form-panel .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }

        .print-form-panel .form-group input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .print-form-panel .form-row {
            display: flex;
            gap: 15px;
        }

        .print-form-panel .form-row .form-group {
            flex: 1;
        }

        .print-preview-panel {
            width: 60%;
            padding: 25px;
            display: flex;
            flex-direction: column;
            background: #fff;
        }

        .print-preview-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #1a2a6c;
            font-size: 18px;
        }

        .print-preview-panel h3 small {
            font-size: 12px;
            font-weight: normal;
            color: #666;
        }

        .print-map-preview {
            flex: 1;
            min-height: 500px;
            width: 100%;
            border: 2px solid #ddd;
            border-radius: 4px;
            position: relative;
            background: #f0f0f0;
        }

        .print-map-preview .ol-viewport {
            width: 100% !important;
            height: 100% !important;
        }

        .preview-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .preview-btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .preview-btn:hover {
            background: #2980b9;
        }

        .print-options-panel {
            display: flex;
            gap: 30px;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            background: #f5f5f5;
            align-items: center;
        }

        .print-option-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .print-option-group label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        .print-option-group select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 150px;
        }

        .print-dialog-footer {
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: #fff;
        }

        .btn-cancel,
        .btn-preview,
        .btn-print {
            padding: 12px 30px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-cancel {
            background: #95a5a6;
            color: white;
        }

        .btn-cancel:hover {
            background: #7f8c8d;
        }

        .btn-preview {
            background: #f39c12;
            color: white;
        }

        .btn-preview:hover {
            background: #e67e22;
        }

        .btn-print {
            background: #27ae60;
            color: white;
        }

        .btn-print:hover {
            background: #229954;
        }

        /* GSPNET.assist button */
        #gspnet-assist-btn {
            position: fixed;
            left: 30px;
            bottom: 100px;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: all 0.3s ease;
            border: 2px solid white;
            animation: pulse 2s infinite;
        }

        #gspnet-assist-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #3498db, #1a2a6c);
        }

        #gspnet-assist-btn img {
            width: 18px;
            height: 18px;
            filter: invert(1);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(26, 42, 108, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(26, 42, 108, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(26, 42, 108, 0);
            }
        }

        .gspnet-assist-panel {
            position: fixed;
            left: 30px;
            bottom: 160px;
            width: 500px;
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            overflow: hidden;
            max-height: 70vh;
            color: white;
        }

        .gspnet-tab span {
            font-size: 0.8rem;
        }

        .gspnet-section {
            display: none;
        }

        .gspnet-section.active {
            display: block;
        }

        /* Project Library Styles */
        .project-library-panel,
        .polygon-import-panel,
        .parcel-search-panel,
        .polygon-import-modal {
            position: absolute !important;
            right: 0 !important;
            top: 0 !important;
            width: 50% !important;
            min-width: 400px !important;
            max-width: 50% !important;
            height: 100% !important;
            background: white !important;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1) !important;
            z-index: 1001 !important;
            display: none;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease;
            border-left: 1px solid #e0e0e0;
        }

        .project-library-panel.active,
        .polygon-import-panel.active,
        .parcel-search-panel.active,
        .polygon-import-modal.active {
            display: flex;
        }

        /* Adjust map container when panel is open */
        .main-content.panel-open .map-container {
            margin-right: 25%;
            transition: margin-right 0.3s ease;
        }

        @media (max-width: 1200px) {
            .main-content.panel-open .map-container {
                margin-right: 350px;
            }

            .project-library-panel,
            .polygon-import-panel,
            .parcel-search-panel {
                width: 350px;
                min-width: 350px;
                max-width: 350px;
            }
        }

        @media (max-width: 768px) {

            .project-library-panel,
            .polygon-import-panel,
            .parcel-search-panel {
                width: 85%;
                min-width: 300px;
                max-width: 85%;
            }

            .main-content.panel-open .map-container {
                margin-right: 85%;
            }
        }

        .polygon-import-panel-header,
        .parcel-search-panel-header,
        .polygon-import-header {
            background: linear-gradient(135deg, #1a2a6c 0%, #3498db 100%) !important;
            color: white !important;
            padding: 18px 24px !important;
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1) !important;
        }

        .polygon-import-panel-header h3,
        .parcel-search-panel-header h3,
        .polygon-import-header h3 {
            margin: 0 !important;
            font-size: 1.25rem !important;
            font-weight: 600 !important;
            display: flex !important;
            align-items: center !important;
            gap: 12px !important;
            letter-spacing: 0.3px !important;
        }

        .polygon-import-header h3 i {
            font-size: 1.3rem !important;
            opacity: 0.95 !important;
        }

        .polygon-import-panel-close,
        .parcel-search-panel-close,
        .polygon-import-close,
        .polygon-import-panel-back {
            background: rgba(255, 255, 255, 0.15) !important;
            border: none !important;
            color: white !important;
            font-size: 1.6rem !important;
            cursor: pointer !important;
            padding: 8px 12px !important;
            border-radius: 4px !important;
            transition: all 0.2s ease !important;
            width: 36px !important;
            height: 36px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            line-height: 1 !important;
        }

        .polygon-import-panel-close:hover,
        .parcel-search-panel-close:hover,
        .polygon-import-close:hover,
        .polygon-import-panel-back:hover {
            background: rgba(255, 255, 255, 0.25) !important;
            transform: scale(1.05) !important;
        }

        .polygon-import-close:active {
            transform: scale(0.95) !important;
        }

        .polygon-import-panel-body,
        .parcel-search-panel-body,
        .polygon-import-body {
            flex: 1 !important;
            overflow-y: auto !important;
            padding: 24px !important;
            background: #f8f9fa !important;
        }

        .polygon-import-body::-webkit-scrollbar {
            width: 8px !important;
        }

        .polygon-import-body::-webkit-scrollbar-track {
            background: #f1f1f1 !important;
        }

        .polygon-import-body::-webkit-scrollbar-thumb {
            background: #c1c1c1 !important;
            border-radius: 4px !important;
        }

        .polygon-import-body::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8 !important;
        }

        /* Parcel Search specific styling to match Project Library */
        .parcel-search-panel-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
        }

        .parcel-search-form {
            margin-bottom: 20px;
        }

        .parcel-search-form .form-group {
            margin-bottom: 15px;
        }

        .parcel-search-form .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .parcel-search-form .form-input,
        .parcel-search-form .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .parcel-search-form .form-input:focus,
        .parcel-search-form .form-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .parcel-search-results {
            margin-top: 20px;
        }

        .parcel-results-header {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .parcel-results-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .parcel-result-item {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-bottom: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .parcel-result-item:hover {
            background: #f8f9fa;
            border-color: #3498db;
            box-shadow: 0 2px 4px rgba(52, 152, 219, 0.1);
        }

        .parcel-result-item h4 {
            margin: 0 0 8px 0;
            color: #1a2a6c;
            font-size: 1rem;
        }

        .parcel-result-item p {
            margin: 4px 0;
            font-size: 0.85rem;
            color: #666;
        }

        .parcel-result-item .parcel-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }

        .parcel-result-item .parcel-meta span {
            font-size: 0.8rem;
            color: #888;
            background: #f0f0f0;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .project-library-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .project-library-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .project-library-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: transform 0.2s;
        }

        .project-library-close:hover {
            transform: scale(1.2);
        }

        .project-library-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .project-search-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .project-search-tab {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .project-search-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .project-search-tab:hover {
            color: #3498db;
        }

        .project-search-form {
            margin-bottom: 20px;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .upload-btn.secondary {
            background: #95a5a6;
        }

        .upload-btn.secondary:hover {
            background: #7f8c8d;
        }

        .project-search-results {
            margin-top: 20px;
        }

        .results-header {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .results-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .project-result-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .project-result-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-color: #3498db;
        }

        .project-result-item h4 {
            margin: 0 0 8px 0;
            color: #1a2a6c;
            font-size: 1rem;
        }

        .project-result-item .result-meta {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }

        .project-result-item .result-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .result-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .result-action-btn.view {
            background: #3498db;
            color: white;
        }

        .result-action-btn.download {
            background: #27ae60;
            color: white;
        }

        .result-action-btn.map {
            background: #e74c3c;
            color: white;
        }

        .no-results {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }

        /* Location Selection Styles */
        .location-selection-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .location-instruction {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .location-instruction i {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .location-instruction h4 {
            margin: 10px 0;
            font-size: 1.1rem;
        }

        .location-instruction p {
            margin: 5px 0;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Location Selection Button */
        .location-select-btn {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .location-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .location-select-btn:active {
            transform: translateY(0);
        }

        .location-select-btn i {
            font-size: 1.2rem;
        }

        .location-select-btn.location-selected {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
        }

        .location-select-btn.location-selected:hover {
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }

        .coords-display {
            margin-top: 10px;
            padding: 10px 15px;
            background: rgba(39, 174, 96, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #27ae60;
            font-size: 0.9rem;
        }

        .upload-form-container {
            transition: opacity 0.3s, pointer-events 0.3s;
        }

        .upload-form-container[style*="pointer-events: none"]::before {
            content: "Select location on map first";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 10;
            pointer-events: none;
            font-weight: 600;
        }

        .dynamic-field-group {
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .file-upload-area {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s;
        }

        .file-upload-area.dragover {
            border-color: #27ae60;
            background: #e8f5e9;
        }

        .file-name-display {
            margin-top: 10px;
            padding: 8px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #1976d2;
        }

        .tutorial-list {
            list-style: none;
            margin: 15px 0;
        }

        .tutorial-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tutorial-item a {
            color: #fff;
            text-decoration: none;
            font-weight: 500;
            display: block;
            transition: all 0.2s;
        }

        .tutorial-item a:hover {
            color: #0d62d9;
            text-decoration: underline;
        }

        .tutorial-item i {
            margin-right: 8px;
            color: #e74c3c;
        }

        .upload-container {
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.1);
        }

        .upload-icon {
            font-size: 40px;
            color: #fff;
            margin-bottom: 10px;
        }

        .upload-text {
            margin: 10px 0;
            font-weight: 500;
            color: white;
        }

        .upload-note {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            margin: 15px 0;
            border-left: 3px solid #f39c12;
            color: white;
        }

        .upload-btn {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            margin-top: 10px;
        }

        .upload-btn:hover {
            background: linear-gradient(to bottom, #3cb0fd, #3498db);
        }

        .file-input {
            display: none;
        }

        .file-preview {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: none;
            color: white;
        }

        /* Close button for panel */
        .gspnet-panel-close {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 24px;
            color: white;
            cursor: pointer;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.2);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* New styles for coordinate extractor modal */
        .coord-extractor-modal {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35vh;
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            z-index: 2000;
            box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.2);
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            overflow: hidden;
            color: white;
        }

        .coord-extractor-header {
            padding: 15px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coord-extractor-header h3 {
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .coord-extractor-body {
            padding: 15px;
            height: calc(100% - 60px);
            overflow-y: auto;
        }

        .coord-extractor-close {
            font-size: 1.5rem;
            cursor: pointer;
            background: none;
            border: none;
            color: white;
        }

        .coord-extractor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .coord-extractor-controls-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            color: #333;
        }

        .coord-extractor-results-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--info);
            max-height: 200px;
            overflow-y: auto;
            color: #333;
        }

        .coord-controls-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .coord-control-btn {
            flex: 1;
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .coord-control-btn.primary {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
        }

        .coord-control-btn.secondary {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            color: white;
        }

        .coord-control-btn.warning {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            color: white;
        }

        .coord-control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .coord-control-btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Bottom control button for coordinate extractor */
        .coord-extractor-main-btn {
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            font-size: 0.9rem;
            margin: 0 5px;
        }

        .coord-extractor-main-btn:hover {
            background: linear-gradient(to bottom, #8e44ad, #9b59b6);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
        }


        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Edit mode selector */
        .edit-mode-selector {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .edit-mode-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
            text-align: center;
        }

        .edit-mode-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        /* WFS layer status */
        .wfs-layer-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            display: none;
        }

        .wfs-layer-status.success {
            background: #e8f6ef;
            border-left: 4px solid #2ecc71;
        }

        .wfs-layer-status.error {
            background: #fceae9;
            border-left: 4px solid #e74c3c;
        }

        /* Toast notifications */
        .toast-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background: #333;
            color: white;
            border-radius: 5px;
            z-index: 10000;
            display: none;
            max-width: 300px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .toast-notification.success {
            background: #2ecc71;
        }

        .toast-notification.error {
            background: #e74c3c;
        }

        .toast-notification.info {
            background: #3498db;
        }

        .toast-close {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
        }

        /* PATCH: Coordinate Search Modal Styles */
        .coord-search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .coord-search-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .coord-search-header {
            padding: 15px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coord-search-header h3 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .coord-search-body {
            padding: 20px;
            color: var(--dark);
        }

        .coord-search-footer {
            padding: 12px 15px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            text-align: right;
        }

        .coord-search-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
        }

        .coord-search-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .coord-search-tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            transition: all 0.3s;
        }

        .coord-search-tab.active {
            border-bottom-color: var(--accent);
            color: var(--accent);
        }

        .coord-search-tab-content {
            display: none;
        }

        .coord-search-tab-content.active {
            display: block;
        }

        .coord-input-group {
            margin-bottom: 15px;
        }

        .coord-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .coord-input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .coord-input-row {
            display: flex;
            gap: 10px;
        }

        .coord-input-row .coord-input-group {
            flex: 1;
        }

        .csv-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background: #f8f9fa;
        }

        .csv-upload-area.dragover {
            border-color: var(--accent);
            background: #e3f2fd;
        }

        .csv-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9rem;
            display: none;
        }

        .csv-warning.show {
            display: block;
        }

        .coord-search-btn {
            background: linear-gradient(to bottom, var(--accent), #2980b9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .coord-search-btn:hover {
            background: linear-gradient(to bottom, #3cb0fd, var(--accent));
            transform: translateY(-2px);
        }

        .coord-search-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .coord-results {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .coord-results.show {
            display: block;
        }

        .coord-results h4 {
            margin-bottom: 10px;
            color: var(--primary);
        }

        .coord-results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .coord-results-table th,
        .coord-results-table td {
            border: 1px solid #ddd;

            /* Polygon Import Modal Styles */
            /* Ensure main-content is positioned relative for absolute panels */
            .main-content {
                position: relative;
            }

            .polygon-import-modal .polygon-import-content {
                display: flex !important;
                flex-direction: column !important;
                height: 100% !important;
                width: 100% !important;
                background: #ffffff !important;
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15) !important;
            }

            .polygon-import-modal .polygon-import-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%) !important;
                color: white !important;
                padding: 22px 28px !important;
                display: flex !important;
                justify-content: space-between !important;
                align-items: center !important;
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1) !important;
                border-bottom: 3px solid rgba(255, 255, 255, 0.2) !important;
                position: relative !important;
                overflow: hidden !important;
            }

            .polygon-import-modal .polygon-import-header::before {
                content: '' !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%) !important;
                pointer-events: none !important;
            }

            .polygon-import-modal .polygon-import-header h3 {
                margin: 0 !important;
                font-size: 1.35rem !important;
                font-weight: 700 !important;
                display: flex !important;
                align-items: center !important;
                gap: 14px !important;
                letter-spacing: 0.5px !important;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
                position: relative !important;
                z-index: 1 !important;
            }

            .polygon-import-modal .polygon-import-header h3 i {
                font-size: 1.4rem !important;
                opacity: 1 !important;
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2)) !important;
            }

            .polygon-import-modal .polygon-import-close {
                background: rgba(255, 255, 255, 0.2) !important;
                border: 2px solid rgba(255, 255, 255, 0.3) !important;
                color: white !important;
                font-size: 1.8rem !important;
                cursor: pointer !important;
                padding: 8px 12px !important;
                line-height: 1 !important;
                border-radius: 8px !important;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                width: 40px !important;
                height: 40px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                position: relative !important;
                z-index: 1 !important;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
            }

            .polygon-import-modal .polygon-import-close:hover {
                background: rgba(255, 255, 255, 0.35) !important;
                border-color: rgba(255, 255, 255, 0.5) !important;
                transform: scale(1.1) rotate(90deg) !important;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2) !important;
            }

            .polygon-import-modal .polygon-import-close:active {
                transform: scale(0.95) rotate(90deg) !important;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
            }

            .polygon-import-modal .polygon-import-body {
                flex: 1 !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                padding: 28px 32px !important;
                background: linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%) !important;
                color: #2c3e50 !important;
                position: relative !important;
            }

            .polygon-import-modal .polygon-import-body form {
                width: 100% !important;
                display: block !important;
            }

            .polygon-import-modal .polygon-import-body::-webkit-scrollbar {
                width: 10px !important;
            }

            .polygon-import-modal .polygon-import-body::-webkit-scrollbar-track {
                background: #f1f1f1 !important;
                border-radius: 10px !important;
            }

            .polygon-import-modal .polygon-import-body::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, #667eea, #764ba2) !important;
                border-radius: 10px !important;
                border: 2px solid #f1f1f1 !important;
            }

            .polygon-import-modal .polygon-import-body::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(135deg, #764ba2, #667eea) !important;
            }

            @media (max-width: 1200px) {
                .polygon-import-modal {
                    width: 350px;
                    min-width: 350px;
                    max-width: 350px;
                }
            }

            @media (max-width: 768px) {
                .polygon-import-modal {
                    width: 85%;
                    min-width: 300px;
                    max-width: 85%;
                }
            }

            /* Scoped styles for polygon import modal form */
            .polygon-import-modal .polygon-form-group {
                margin-bottom: 20px !important;
            }

            .polygon-import-modal .polygon-form-group label {
                display: block !important;
                margin-bottom: 10px !important;
                margin-top: 0 !important;
                font-weight: 700 !important;
                color: #34495e !important;
                font-size: 0.95rem !important;
                letter-spacing: 0.3px !important;
                line-height: 1.5 !important;
                text-transform: uppercase !important;
                font-size: 0.85rem !important;
            }

            .polygon-import-modal .polygon-form-group .required {
                color: #e74c3c !important;
                margin-left: 4px !important;
                font-weight: 700 !important;
            }

            .polygon-import-modal .polygon-form-group input,
            .polygon-import-modal .polygon-form-group select,
            .polygon-import-modal .polygon-form-group textarea {
                width: 100% !important;
                padding: 14px 18px !important;
                border: 2px solid #e0e0e0 !important;
                border-radius: 8px !important;
                font-size: 14px !important;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                box-sizing: border-box !important;
                background: #ffffff !important;
                color: #2c3e50 !important;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05) !important;
                margin: 0 !important;
                line-height: 1.5 !important;
            }

            .polygon-import-modal .polygon-form-group input[type="text"],
            .polygon-import-modal .polygon-form-group input[type="email"],
            .polygon-import-modal .polygon-form-group input[type="number"] {
                -webkit-appearance: none !important;
                -moz-appearance: none !important;
                appearance: none !important;
            }

            .polygon-import-modal .polygon-form-group input:hover,
            .polygon-import-modal .polygon-form-group select:hover,
            .polygon-import-modal .polygon-form-group textarea:hover {
                border-color: #bdc3c7 !important;
            }

            .polygon-import-modal .polygon-form-group input:focus,
            .polygon-import-modal .polygon-form-group select:focus,
            .polygon-import-modal .polygon-form-group textarea:focus {
                outline: none !important;
                border-color: #667eea !important;
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2), 0 4px 8px rgba(102, 126, 234, 0.1) !important;
                background: #ffffff !important;
                transform: translateY(-1px) !important;
            }

            .polygon-import-modal .polygon-form-group input::placeholder,
            .polygon-import-modal .polygon-form-group textarea::placeholder {
                color: #95a5a6 !important;
                opacity: 0.7 !important;
            }

            .polygon-import-modal .polygon-form-group select {
                cursor: pointer !important;
                appearance: none !important;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E") !important;
                background-repeat: no-repeat !important;
                background-position: right 12px center !important;
                padding-right: 40px !important;
            }

            .polygon-import-modal .polygon-form-group textarea {
                resize: vertical !important;
                min-height: 90px !important;
                line-height: 1.5 !important;
            }

            .polygon-import-modal .polygon-form-row {
                display: flex !important;
                gap: 16px !important;
            }

            .polygon-import-modal .polygon-form-row .polygon-form-group {
                flex: 1 !important;
            }

            .polygon-import-modal .polygon-form-footer {
                margin-top: 20px !important;
                padding-top: 0 !important;
                border-top: none !important;
                display: flex !important;
                justify-content: flex-end !important;
                gap: 10px !important;
                background: transparent !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
                padding-bottom: 0 !important;
            }

            .polygon-import-modal .polygon-form-btn {
                background: linear-gradient(to bottom, #3498db, #2980b9) !important;
                color: white !important;
                border: none !important;
                padding: 10px 20px !important;
                border-radius: 6px !important;
                cursor: pointer !important;
                font-weight: 600 !important;
                transition: all 0.3s !important;
                display: inline-block !important;
                margin-top: 0 !important;
            }

            .polygon-import-modal .polygon-form-btn:hover {
                background: linear-gradient(to bottom, #3cb0fd, #3498db) !important;
            }

            .polygon-import-modal .polygon-form-btn-cancel {
                background: #95a5a6 !important;
                color: white !important;
            }

            .polygon-import-modal .polygon-form-btn-cancel:hover {
                background: #7f8c8d !important;
            }

            .polygon-import-modal .polygon-form-btn:disabled {
                opacity: 0.6 !important;
                cursor: not-allowed !important;
            }

            /* Parcel Search Modal Styles */
            .parcel-search-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 2000;
                justify-content: center;
                align-items: center;
            }

            .parcel-search-modal.show {
                display: flex;
            }

            .parcel-search-content {
                background: white;
                border-radius: 12px;
                width: 90%;
                max-width: 800px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                position: relative;
            }

            .parcel-search-header {
                padding: 15px 20px;
                background: linear-gradient(to right, var(--primary), var(--secondary));
                color: white;
                border-top-left-radius: 12px;
                border-top-right-radius: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .parcel-search-header h3 {
                font-size: 1.3rem;
                display: flex;
                align-items: center;
                gap: 10px;
                margin: 0;
            }

            .parcel-search-close {
                position: absolute;
                top: 10px;
                right: 15px;
                font-size: 1.5rem;
                color: white;
                cursor: pointer;
                background: none;
                border: none;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: background 0.3s;
            }

            .parcel-search-close:hover {
                background: rgba(255, 255, 255, 0.2);
            }

            .parcel-search-body {
                padding: 25px;
            }

            .parcel-search-group {
                margin-bottom: 18px;
            }

            .parcel-search-group label {
                display: block;
                margin-bottom: 6px;
                font-weight: 600;
                color: var(--dark);
                font-size: 0.95rem;
            }

            .parcel-search-group input,
            .parcel-search-group select {
                width: 100%;
                padding: 10px 12px;
                border: 1px solid #ddd;
                border-radius: 6px;
                font-size: 0.9rem;
                font-family: inherit;
                transition: border-color 0.3s;
                box-sizing: border-box;
            }

            .parcel-search-group input:focus,
            .parcel-search-group select:focus {
                outline: none;
                border-color: var(--accent);
                box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
            }

            .parcel-search-footer {
                margin-top: 25px;
                padding-top: 20px;
                border-top: 1px solid #eee;
                display: flex;
                justify-content: flex-end;
                gap: 12px;
            }

            .parcel-search-btn {
                padding: 10px 24px;
                border: none;
                border-radius: 6px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
                font-size: 0.95rem;
            }

            .parcel-search-btn-submit {
                background: linear-gradient(to bottom, var(--accent), #2980b9);
                color: white;
            }

            .parcel-search-btn-submit:hover {
                background: linear-gradient(to bottom, #3cb0fd, var(--accent));
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

            .parcel-search-btn-cancel {
                background: #95a5a6;
                color: white;
            }

            .parcel-search-btn-cancel:hover {
                background: #7f8c8d;
            }

            .parcel-search-results {
                margin-top: 25px;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 8px;
            }

            .parcel-search-results h4 {
                margin-bottom: 15px;
                color: var(--primary);
            }

            .parcel-results-table {
                width: 100%;
                border-collapse: collapse;
                background: white;
                border-radius: 6px;
                overflow: hidden;
            }

            .parcel-results-table th,
            .parcel-results-table td {
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #eee;
            }

            .parcel-results-table th {
                background: #e9ecef;
                font-weight: 600;
                color: var(--dark);
            }

            .parcel-results-table tr:hover {
                background: #f8f9fa;
                cursor: pointer;
            }

            .parcel-results-table tr:last-child td {
                border-bottom: none;
            }

            padding: 8px;
            text-align: left;
        }

        .coord-results-table th {
            background: #e9ecef;
            font-weight: 600;
        }

        .coord-results-stats {
            margin-top: 10px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* PATCH: Service health indicator styles */
        .service-health {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 6px 10px;
            border-radius: 6px;
            border-left: 4px solid #2ecc71;
            font-size: 0.85rem;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .service-health.error {
            border-left-color: #e74c3c;
        }

        .service-health.warn {
            border-left-color: #f39c12;
        }

        @media print {
            .service-health {
                display: none !important;
            }
        }

        /* Layer loading indicator */
        .layer-loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        /* Existing styles */
        :root {
            --primary: #1a2a6c;
            --secondary: #2c3e50;
            --accent: #3498db;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --tertiary: #9b59b6;
            --info: #1abc9c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        header {
            background: linear-gradient(90deg, var(--secondary), var(--primary));
            color: white;
            padding: 10px 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 45px;
            height: 45px;
            background: linear-gradient(45deg, var(--accent), var(--success));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 22px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .app-title h1 {
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .app-title p {
            font-size: 0.8rem;
            opacity: 0.9;
            margin-top: 3px;
        }

        .controls-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(to bottom, var(--accent), #2980b9);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            background: linear-gradient(to bottom, #3cb0fd, var(--accent));
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn.active {
            background: linear-gradient(to bottom, var(--success), #27ae60);
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.3);
        }

        .chat-btn {
            position: relative;
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
        }

        .unread-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            display: none;
        }

        .unread-badge.active {
            display: flex;
        }

        /* Quality Flags Button */
        .quality-flags-btn {
            position: relative;
            background: linear-gradient(to bottom, #f39c12, #e67e22);
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.3s ease;
            min-width: 40px;
        }

        .quality-flags-btn span:not(.unread-badge) {
            display: none;
            white-space: nowrap;
            margin-left: 8px;
        }

        .quality-flags-btn:hover {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            width: auto;
            min-width: 140px;
            padding: 0 12px;
            border-radius: 20px;
        }

        .quality-flags-btn:hover span:not(.unread-badge) {
            display: inline;
        }

        .quality-flags-btn i {
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        /* Quality Flags Dock */
        .quality-flags-dock {
            position: fixed;
            left: 0;
            top: 0;
            width: 25vw;
            min-width: 350px;
            max-width: 450px;
            height: 100vh;
            background: white;
            box-shadow: 2px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        .quality-flags-dock[aria-hidden="false"] {
            transform: translateX(0);
        }

        /* Quality Tabs */
        .quality-tabs {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 15px;
        }

        .quality-tab {
            flex: 1;
            padding: 12px 15px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .quality-tab:hover {
            background: #f5f5f5;
            color: #333;
        }

        .quality-tab.active {
            color: #f39c12;
            border-bottom-color: #f39c12;
            background: #fff8e1;
        }

        /* Quality Sections */
        .quality-section {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .quality-section.active {
            display: block;
        }

        .section-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section-header h4 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .section-description {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .required {
            color: #e74c3c;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.1);
        }

        .form-textarea {
            resize: vertical;
            font-family: inherit;
        }

        .form-help {
            display: block;
            margin-top: 5px;
            color: #7f8c8d;
            font-size: 0.85rem;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-col {
            flex: 1;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .radio-label:hover {
            background: #f5f5f5;
        }

        .radio-label input[type="radio"] {
            margin: 0;
        }

        .location-info {
            margin-top: 10px;
            padding: 10px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            color: #155724;
            font-size: 0.9rem;
        }

        .location-info i {
            margin-right: 5px;
        }

        /* Flag Indicators */
        .flag-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .flag-indicator.red {
            background: #e74c3c;
        }

        .flag-indicator.yellow {
            background: #f39c12;
        }

        .flag-indicator.green {
            background: #27ae60;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(to bottom, #f39c12, #e67e22);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(243, 156, 18, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
            width: auto;
        }

        .btn-back {
            background: none;
            border: none;
            color: #f39c12;
            cursor: pointer;
            padding: 5px 0;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-back:hover {
            text-decoration: underline;
        }

        /* Filters Section */
        .filters-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        /* Statistics */
        .statistics-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .statistics-section h5 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            border-radius: 6px;
            background: white;
        }

        .stat-item.red {
            border-top: 3px solid #e74c3c;
        }

        .stat-item.yellow {
            border-top: 3px solid #f39c12;
        }

        .stat-item.green {
            border-top: 3px solid #27ae60;
        }

        .stat-value {
            display: block;
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: #7f8c8d;
        }

        /* Flags List */
        .flags-list-container {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }

        .flags-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .flag-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-left: 4px solid;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .flag-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateX(2px);
        }

        .flag-item.red {
            border-left-color: #e74c3c;
        }

        .flag-item.yellow {
            border-left-color: #f39c12;
        }

        .flag-item.green {
            border-left-color: #27ae60;
        }

        .flag-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 8px;
        }

        .flag-item-type {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .flag-item-date {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .flag-item-location {
            font-size: 0.85rem;
            color: #555;
            margin-bottom: 5px;
        }

        .flag-item-reason {
            font-size: 0.85rem;
            color: #666;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .empty-state,
        .loading-state {
            text-align: center;
            padding: 40px 20px;
            color: #7f8c8d;
        }

        .empty-state i,
        .loading-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: #bdc3c7;
        }

        /* Flag Detail View */
        .flag-detail-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .flag-detail-header h4 {
            margin: 0;
            color: #2c3e50;
        }

        .flag-detail-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .flag-detail-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
        }

        .flag-detail-section h5 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        .flag-detail-section p {
            margin: 5px 0;
            color: #555;
            font-size: 0.9rem;
        }

        .flag-history-item {
            padding: 10px;
            border-left: 3px solid;
            margin-bottom: 10px;
            background: white;
            border-radius: 4px;
        }

        .flag-history-item.red {
            border-left-color: #e74c3c;
        }

        .flag-history-item.yellow {
            border-left-color: #f39c12;
        }

        .flag-history-item.green {
            border-left-color: #27ae60;
        }

        .flag-comments-section {
            margin-top: 20px;
        }

        .comment-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #3498db;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .comment-author {
            font-weight: 600;
            color: #2c3e50;
        }

        .comment-date {
            color: #7f8c8d;
        }

        .comment-text {
            color: #555;
            font-size: 0.9rem;
        }

        .add-comment-form {
            margin-top: 15px;
        }

        .change-flag-section {
            background: #fff8e1;
            padding: 15px;
            border-radius: 6px;
            border: 2px dashed #f39c12;
            margin-top: 20px;
        }

        /* Map Selection Cursor */
        .map-selection-mode {
            cursor: crosshair !important;
        }

        .map-selection-mode * {
            cursor: crosshair !important;
        }

        /* Export Section */
        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }

        .export-section .btn {
            flex: 1;
            margin-bottom: 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .quality-flags-dock {
                width: 100vw;
                min-width: 100%;
            }
        }

        /* Chat Panel */
        .chat-panel {
            position: fixed;
            top: 0;
            right: -50%;
            width: 50%;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #e0e0e0;
        }

        .chat-panel.open {
            right: 0;
        }

        .chat-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }

        .chat-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .online-count {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .chat-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
        }

        .chat-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Online Users Section */
        .online-users-section {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }

        .online-users-section h4 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #666;
        }

        .online-user {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            font-size: 0.85rem;
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #2ecc71;
        }

        .user-status.typing {
            background: #f39c12;
            animation: pulse 1s infinite;
        }

        .user-status.viewing {
            background: #3498db;
        }

        .user-status.idle {
            background: #95a5a6;
        }

        /* Messages Area */
        .messages-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages-list {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: white;
        }

        /* WhatsApp-style message bubbles */
        .message-item {
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
        }

        .message-sent {
            align-items: flex-end;
        }

        .message-received {
            align-items: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 8px 12px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
        }

        .message-sent .message-bubble {
            background: #dcf8c6;
            border-bottom-right-radius: 4px;
        }

        .message-received .message-bubble {
            background: #ffffff;
            border: 1px solid #e5e5ea;
            border-bottom-left-radius: 4px;
        }

        .sender-name {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 2px;
            font-weight: 600;
        }

        .message-content {
            margin: 0;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .message-time {
            font-size: 0.7rem;
            color: #999;
            margin-top: 4px;
            text-align: right;
        }

        .message-received .message-time {
            text-align: left;
        }

        /* Legacy message styles for backward compatibility */
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 3px solid #3498db;
        }

        .message.own {
            background: #e3f2fd;
            border-left-color: #2196f3;
            margin-left: 20px;
        }

        .message.system {
            background: #fff3cd;
            border-left-color: #ffc107;
            text-align: center;
            font-style: italic;
        }

        .message.location-message {
            background: #e8f5e8;
            border-left-color: #28a745;
        }

        .location-message {
            cursor: pointer;
            padding: 10px;
            border-radius: 12px;
            background: rgba(40, 167, 69, 0.1);
            border: 1px dashed #28a745;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .location-message:hover {
            background: rgba(40, 167, 69, 0.2);
        }

        .location-icon {
            font-size: 1.2rem;
        }

        .location-text {
            flex: 1;
            font-size: 0.9rem;
        }

        .location-content {
            cursor: pointer;
            padding: 10px;
            border-radius: 6px;
            background: rgba(40, 167, 69, 0.1);
            border: 1px dashed #28a745;
            transition: background 0.2s;
        }

        .location-content:hover {
            background: rgba(40, 167, 69, 0.2);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .message-user {
            font-weight: bold;
            color: #3498db;
            font-size: 0.9rem;
        }

        .message-time {
            font-size: 0.7rem;
            color: #999;
        }

        .message-content {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .message-mention {
            background: #ffeaa7;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }

        .message-reactions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .reaction {
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .reaction:hover {
            background: #f0f0f0;
        }

        .reaction.own {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .reaction-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 12px;
            opacity: 0.7;
            transition: all 0.2s;
            margin: 2px;
            transition: opacity 0.2s;
        }

        .reaction-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
        }

        /* Typing Indicator */
        .typing-indicator {
            display: none;
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #666;
            align-items: center;
            gap: 5px;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-indicator span {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-indicator span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typing {

            0%,
            80%,
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }

            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Message Input */
        .message-input-container {
            border-top: 1px solid #e0e0e0;
            padding: 15px;
            background: #f8f9fa;
        }

        .input-actions {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        .action-btn {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            margin: 2px;
        }

        .action-btn:hover {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .action-btn:active {
            transform: translateY(0);
            background: #3498db;
            color: white;
        }

        #formatBold {
            font-weight: 900;
        }

        #formatItalic {
            font-style: italic;
        }

        /* Message actions (reply, delete, reactions) */
        .message-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .message-item:hover .message-actions {
            opacity: 1;
        }

        /* Message actions below (for location messages) */
        .message-actions-below {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 12px;
            opacity: 1;
            transition: all 0.2s;
        }

        .message-item:hover .message-actions-below {
            background: rgba(0, 0, 0, 0.05);
        }

        .message-sent .message-actions-below {
            margin-left: auto;
            max-width: 70%;
        }

        .message-received .message-actions-below {
            margin-right: auto;
            max-width: 70%;
        }

        .action-message-btn {
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: #666;
        }

        .action-message-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .action-message-btn:active {
            transform: scale(0.95);
        }

        .delete-btn {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }

        .delete-btn:hover {
            background: #e74c3c;
            color: white;
        }

        .reply-btn {
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
        }

        .reply-btn:hover {
            background: #3498db;
            color: white;
        }

        .reaction-btn {
            background: rgba(241, 196, 15, 0.1);
            color: #f1c40f;
        }

        .reaction-btn:hover {
            background: #f1c40f;
            color: white;
        }

        .location-btn {
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
            font-weight: bold;
        }

        .location-btn:hover {
            background: #3498db;
            color: white;
            transform: scale(1.15);
        }

        /* Reply indicator */
        .reply-indicator {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            position: relative;
        }

        .reply-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .reply-label {
            font-weight: bold;
            color: #2196f3;
            font-size: 0.85rem;
        }

        .reply-text {
            color: #666;
            font-size: 0.85rem;
            flex: 1;
        }

        .reply-cancel {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reply-cancel:hover {
            background: #f0f0f0;
            color: #666;
        }

        /* Reaction menu */
        .reaction-menu {
            background: white;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px;
            animation: slideUp 0.2s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .reaction-options {
            display: flex;
            gap: 4px;
        }

        .reaction-option {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            transition: all 0.2s;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-option:hover {
            background: #f0f0f0;
            transform: scale(1.2);
        }

        /* Reaction bubbles (WhatsApp-style) */
        .message-reactions {
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
            align-items: center;
        }

        .reaction-bubble {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 2px 6px;
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .reaction-bubble:hover {
            background: rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }

        .reaction-emoji {
            font-size: 0.9rem;
        }

        .reaction-count {
            font-size: 0.75rem;
            font-weight: bold;
            color: #666;
            min-width: 12px;
            text-align: center;
        }

        @keyframes reactionPop {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #messageInput {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            resize: none;
            font-family: inherit;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        .send-btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            cursor: pointer;
            width: 100%;
        }

        .send-btn:hover {
            background: linear-gradient(to bottom, #27ae60, #2ecc71);
        }

        /* Pinned Messages */
        .pinned-messages {
            background: #fff8e6;
            border-left: 4px solid #f39c12;
            margin: 10px 0;
            padding: 10px;
        }

        /* ============================================
           PROPERTY VALUATION PANEL
           ============================================ */

        .valuation-panel {
            position: fixed;
            top: 0;
            right: -33.33%;
            width: 33.33%;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #e0e0e0;
        }

        .valuation-panel.open {
            right: 0;
        }

        .valuation-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .valuation-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .valuation-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .valuation-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .valuation-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .valuation-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }

        .valuation-tab {
            flex: 1;
            padding: 12px 15px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .valuation-tab:hover {
            background: #e9ecef;
            color: #333;
        }

        .valuation-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
            background: white;
        }

        .valuation-tab-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .valuation-tab-content.active {
            display: block;
        }

        .valuation-form-group {
            margin-bottom: 15px;
        }

        .valuation-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .valuation-form-group input,
        .valuation-form-group select,
        .valuation-form-group textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        .valuation-form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .valuation-form-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .valuation-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s;
            margin-top: 10px;
            width: 100%;
        }

        .valuation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .valuation-btn.secondary {
            background: #95a5a6;
        }

        .valuation-btn.danger {
            background: #e74c3c;
        }

        .valuation-info-box {
            padding: 15px;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .valuation-info-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .valuation-info-box p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .property-marker {
            cursor: pointer;
        }

        .valuation-properties-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        .valuation-property-item {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .valuation-property-item:hover {
            background: #f8f9fa;
        }

        /* Village autocomplete styles */
        .village-autocomplete {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: #e3f2fd;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        /* Valuation Image Upload Styles */
        .valuation-image-upload-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .valuation-image-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .valuation-image-btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        .valuation-image-btn:active {
            transform: translateY(0);
        }

        .valuation-image-btn i {
            font-size: 1rem;
        }

        .valuation-image-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .valuation-image-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e0e0e0;
            background: white;
        }

        .valuation-image-preview-item img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .valuation-image-remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .valuation-image-remove-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        /* Form hint styles */
        .form-hint {
            display: block;
            font-size: 0.8rem;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }

        /* Radio group styles */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
            cursor: pointer;
        }

        .radio-group input[type="radio"] {
            width: auto;
            margin: 0;
        }

        /* Enhanced report styles */
        .enhanced-valuation-report {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .report-section {
            padding: 25px;
            border-bottom: 1px solid #dee2e6;
        }

        .report-section:last-child {
            border-bottom: none;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .valuation-property-item:last-child {
            border-bottom: none;
        }

        .valuation-property-item.selected {
            background: rgba(142, 68, 173, 0.1);
            border-left: 4px solid #8e44ad;
            padding-left: 8px;
        }

        .valuation-property-price {
            font-weight: 700;
            color: #27ae60;
            font-size: 1.1rem;
        }

        .confidence-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .confidence-high {
            background: #d4edda;
            color: #155724;
        }

        .confidence-medium {
            background: #fff3cd;
            color: #856404;
        }

        .confidence-low {
            background: #f8d7da;
            color: #721c24;
        }

        /* Valuation Report Styles */
        .valuation-report {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .valuation-report-hero {
            background: linear-gradient(135deg, #1f3a93, #2c82c9);
            border-radius: 16px;
            padding: 28px 30px;
            color: #fff;
            box-shadow: 0 20px 45px rgba(31, 58, 147, 0.25);
            margin-bottom: 20px;
        }

        .valuation-hero-top {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
        }

        .valuation-hero-eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.75rem;
            opacity: 0.85;
            margin-bottom: 6px;
        }

        .valuation-hero-top h1 {
            margin: 0;
            font-size: 1.9rem;
            font-weight: 600;
        }

        .valuation-hero-subtitle {
            margin: 6px 0 0 0;
            font-size: 1rem;
            opacity: 0.85;
        }

        .valuation-hero-value {
            min-width: 260px;
            text-align: right;
        }

        .valuation-hero-value .value-label {
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.15em;
            opacity: 0.85;
            display: block;
        }

        .valuation-hero-value .value-amount {
            font-size: 2.9rem;
            font-weight: 700;
            margin: 6px 0;
            display: block;
        }

        .confidence-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.85rem;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.35);
            font-weight: 600;
        }

        .valuation-meta-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 22px;
        }

        .valuation-chip {
            display: inline-flex;
            flex-direction: column;
            min-width: 140px;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(6px);
            font-size: 0.85rem;
        }

        .valuation-chip span {
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .valuation-chip strong {
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            margin-top: 4px;
        }

        .valuation-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 18px;
        }

        .valuation-card {
            background: #fff;
            border-radius: 14px;
            border: 1px solid #e3e8f0;
            padding: 18px 20px;
            box-shadow: 0 20px 35px rgba(20, 23, 39, 0.05);
        }

        .valuation-card-title {
            font-weight: 600;
            color: #1a2a6c;
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .valuation-definition-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .valuation-definition-list li {
            display: flex;
            justify-content: space-between;
            gap: 18px;
            font-size: 0.9rem;
            color: #4a5568;
        }

        .valuation-definition-list li span {
            color: #6c7a91;
            font-weight: 500;
        }

        .valuation-definition-list li strong {
            color: #1f2937;
            font-weight: 600;
            text-align: right;
        }

        .valuation-metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            gap: 15px;
            margin: 12px 0 18px;
        }

        .valuation-metric-card {
            border-radius: 12px;
            padding: 16px;
            background: linear-gradient(135deg, #f8fafc, #eef2ff);
            border: 1px solid #dee5ff;
        }

        .valuation-metric-card .metric-label {
            font-size: 0.85rem;
            color: #5b6b92;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .valuation-metric-card .metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #1d3a8a;
            margin-top: 6px;
        }

        .valuation-risk-pill {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 12px;
            background: #fff5f5;
            border: 1px solid #fed7d7;
            color: #9b2c2c;
            font-size: 0.9rem;
        }

        .valuation-risk-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .valuation-note-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .valuation-note-list li {
            background: #f8f9ff;
            border: 1px solid #e0e7ff;
            border-radius: 10px;
            padding: 10px 12px;
            color: #3b4468;
        }

        .valuation-report-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .valuation-report-section:last-child {
            border-bottom: none;
        }

        .valuation-report-section h3 {
            color: #1a2a6c;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .valuation-report-summary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .valuation-report-summary .estimated-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 10px 0;
        }

        .valuation-report-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .valuation-report-table th,
        .valuation-report-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .valuation-report-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
        }

        .valuation-report-table tr:hover {
            background: #f8f9fa;
        }

        .valuation-table-scroll {
            border: 1px solid #e3e8f0;
            border-radius: 12px;
            overflow: auto;
        }

        .valuation-table-scroll::-webkit-scrollbar {
            height: 8px;
        }

        .valuation-table-scroll::-webkit-scrollbar-thumb {
            background: #c7cfe2;
            border-radius: 999px;
        }

        .valuation-report-table--compact th,
        .valuation-report-table--compact td {
            white-space: nowrap;
            font-size: 0.85rem;
        }

        .valuation-chart-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            position: relative;
            height: 300px;
        }

        .valuation-chart-container canvas {
            max-height: 280px;
        }

        .valuation-statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .valuation-stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #3498db;
        }

        .valuation-stat-card .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3498db;
        }

        .valuation-stat-card .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .valuation-pending-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 12px;
        }

        .valuation-pending-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 14px;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .valuation-pending-card.synced {
            border-color: #2ecc71;
            background: #ecf9f1;
        }

        .valuation-pending-card h5 {
            margin: 0 0 4px 0;
            font-size: 1rem;
            color: #1a2a6c;
        }

        .valuation-pending-card p {
            margin: 2px 0;
            font-size: 0.85rem;
            color: #555;
        }

        .valuation-pending-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .valuation-pending-actions button {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .valuation-pending-actions button.sync {
            background: #3498db;
            color: white;
        }

        .valuation-pending-actions button.delete {
            background: #e74c3c;
            color: white;
        }

        .valuation-pending-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .report-template-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .report-template-selector label {
            font-weight: 600;
            color: #1a2a6c;
        }

        .report-template-selector select {
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid #d0d7de;
            min-width: 220px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .chat-panel {
                width: 85%;
                right: -85%;
            }

            .chat-panel.open {
                right: 0;
            }

            .valuation-panel {
                width: 85%;
                right: -85%;
            }

            .valuation-panel.open {
                right: 0;
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
            }
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 0 15px;
            gap: 15px;
            flex-direction: column;
            position: relative;
        }

        .map-container {
            flex: 1;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            transition: margin-right 0.3s ease;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #e9ecef;
        }

        .terrain-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .terrain-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .terrain-toggle.active {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        /* ========================================
           3D TERRAIN DTM & CONTOURS DOCK
           ======================================== */

        .terrain-3d-dock {
            position: fixed;
            left: 0;
            top: 0;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: 2px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .terrain-3d-dock.active {
            display: flex;
        }

        .terrain-3d-header {
            background: linear-gradient(135deg, #6a4c93, #3498db);
            color: white;
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .terrain-3d-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terrain-3d-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: transform 0.2s;
        }

        .terrain-3d-close:hover {
            transform: scale(1.2);
        }

        .terrain-3d-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .terrain-3d-section {
            border-bottom: 1px solid #e0e0e0;
            padding: 0;
        }

        .terrain-3d-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            padding: 15px 20px;
            background: #f8f9fa;
            transition: background 0.2s;
        }

        .terrain-3d-section-header:hover {
            background: #e9ecef;
        }

        .terrain-3d-section-header i {
            margin-right: 10px;
            color: #3498db;
        }

        .terrain-3d-section-header .toggle-icon {
            transition: transform 0.3s;
        }

        .terrain-3d-section-header .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .terrain-3d-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 20px;
        }

        .terrain-3d-section-content.expanded {
            max-height: 2000px;
            padding: 15px 20px;
        }

        .terrain-data-source-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .terrain-radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .terrain-radio-option:hover {
            border-color: #3498db;
            background: #f0f8ff;
        }

        .terrain-radio-option input[type="radio"] {
            accent-color: #3498db;
        }

        .terrain-radio-option.selected {
            border-color: #3498db;
            background: #e3f2fd;
        }

        .terrain-csv-upload-area {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
            margin-bottom: 15px;
            transition: all 0.2s;
        }

        .terrain-csv-upload-area:hover {
            background: #e9ecef;
            border-color: #2980b9;
        }

        .terrain-csv-upload-area.has-file {
            border-color: #27ae60;
            background: #d5f4e6;
        }

        .terrain-file-info {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            text-align: left;
        }

        .terrain-file-info.visible {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .form-select,
        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            color: #2c3e50;
            transition: border-color 0.2s;
        }

        .form-select:focus,
        .form-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .terrain-search-filters {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .terrain-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .terrain-btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .terrain-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .terrain-btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .terrain-btn-secondary:hover {
            background: #7f8c8d;
        }

        .terrain-btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .terrain-btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        .terrain-btn-info {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .terrain-btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .terrain-btn-danger {
            background: #e74c3c;
            color: white;
        }

        .terrain-btn-danger:hover {
            background: #c0392b;
        }

        /* ===================================
           Profile Generation Panel Styles
           =================================== */

        #profile-generation-panel {
            position: fixed;
            top: 80px;
            left: -50vw;
            width: 50vw;
            max-width: 800px;
            min-width: 500px;
            height: calc(100vh - 100px);
            background: #fff;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            border-radius: 0 8px 8px 0;
        }

        #profile-generation-panel.active {
            left: 0;
        }

        /* Responsive adjustments for profile panel */
        @media (max-width: 1200px) {
            #profile-generation-panel {
                width: 60vw;
                left: -60vw;
                min-width: 450px;
            }
        }

        @media (max-width: 768px) {
            #profile-generation-panel {
                width: 90vw;
                left: -90vw;
                min-width: unset;
            }
        }

        .profile-panel-header {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 18px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            border-radius: 0 8px 0 0;
        }

        .profile-panel-header h3 {
            margin: 0;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .profile-panel-header h3 i {
            margin-right: 10px;
        }

        .profile-panel-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 28px;
            line-height: 1;
            cursor: pointer;
            padding: 5px 12px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .profile-panel-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .profile-content {
            padding: 20px;
        }

        .profile-step {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .profile-step h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .profile-step-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .profile-form-group {
            margin-bottom: 15px;
        }

        .profile-form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #34495e;
            font-size: 0.9rem;
        }

        .profile-form-group input[type="number"],
        .profile-form-group input[type="text"],
        .profile-form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .profile-form-group input:focus,
        .profile-form-group select:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .profile-form-row {
            display: flex;
            gap: 12px;
        }

        .profile-form-row .profile-form-group {
            flex: 1;
        }

        .profile-checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .profile-checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .profile-checkbox-group label {
            margin: 0;
            cursor: pointer;
            user-select: none;
        }

        .profile-chart-container {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            height: 500px;
            width: 100%;
            position: relative;
        }

        .profile-chart-container canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .profile-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .profile-stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .profile-stat-card.stat-min {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .profile-stat-card.stat-max {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .profile-stat-card.stat-avg {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }

        .profile-stat-label {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .profile-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .profile-volume-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .profile-volume-table th,
        .profile-volume-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .profile-volume-table th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .profile-volume-table tr:last-child td {
            border-bottom: none;
        }

        .profile-volume-table .volume-cut {
            color: #e74c3c;
            font-weight: 600;
        }

        .profile-volume-table .volume-fill {
            color: #27ae60;
            font-weight: 600;
        }

        .profile-volume-table .volume-balance {
            color: #2c3e50;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .profile-export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .profile-export-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .profile-export-btn.export-csv {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }

        .profile-export-btn.export-pdf {
            background: linear-gradient(135deg, #eb3349, #f45c43);
            color: white;
        }

        .profile-export-btn.export-dxf {
            background: linear-gradient(135deg, #fc466b, #3f5efb);
            color: white;
        }

        .profile-export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .profile-export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .drawing-mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(52, 152, 219, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            z-index: 9999;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.85;
            }
        }

        .drawing-mode-indicator i {
            font-size: 1.4rem;
        }

        .terrain-btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .terrain-btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        .profile-display-area {
            display: none;
            margin-top: 20px;
        }

        .profile-display-area.visible {
            display: block;
        }

        .profile-section-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 25px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .cut-fill-legend {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }

        .legend-color.cut {
            background: rgba(231, 76, 60, 0.7);
        }

        .legend-color.fill {
            background: rgba(39, 174, 96, 0.7);
        }

        .terrain-dataset-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            background: #f8f9fa;
        }

        .merged-badge {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .dataset-item.merged-dataset {
            border-left: 3px solid #3498db;
            background: linear-gradient(to right, rgba(52, 152, 219, 0.05), transparent);
        }

        .dataset-item {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .dataset-item:hover {
            background: #f0f8ff;
            border-color: #3498db;
        }

        .dataset-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .dataset-item.loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .dataset-item.loading::after {
            content: 'Loading...';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: #555;
        }

        .dataset-item input[type="checkbox"] {
            margin-right: 10px;
            margin-top: 3px;
            accent-color: #3498db;
        }

        .dataset-info {
            flex: 1;
        }

        .dataset-info strong {
            display: block;
            color: #2c3e50;
            margin-bottom: 3px;
        }

        .dataset-info small {
            color: #7f8c8d;
            font-size: 0.85rem;
        }

        .terrain-display-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .terrain-checkbox-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terrain-checkbox-option input[type="checkbox"] {
            accent-color: #3498db;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-picker-wrapper input[type="color"] {
            width: 50px;
            height: 35px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
        }

        .range-slider-wrapper {
            margin: 10px 0;
        }

        .range-slider-wrapper label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .range-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        .terrain-dtm-config {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .color-scheme-preview {
            height: 30px;
            border-radius: 4px;
            margin-top: 5px;
            border: 1px solid #e0e0e0;
        }

        .elevation-breaks {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .elevation-break-input {
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            text-align: center;
            font-size: 0.85rem;
        }

        .terrain-contour-config {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .contour-style-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            align-items: center;
        }

        .terrain-basemap-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .basemap-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .basemap-option:hover {
            border-color: #3498db;
            background: #f0f8ff;
        }

        .basemap-option input[type="radio"] {
            accent-color: #3498db;
        }

        .basemap-option.selected {
            border-color: #3498db;
            background: #e3f2fd;
        }

        /* ========================================
           PROJECT INFORMATION MODAL
           ======================================== */

        .terrain-project-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
        }

        .terrain-project-modal.show {
            display: flex;
        }

        .terrain-project-modal-content {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes slideInSuccess {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .terrain-project-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #e0e0e0;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-radius: 12px 12px 0 0;
        }

        .terrain-project-modal-header h3 {
            margin: 0;
            color: white;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .terrain-project-modal-header h3 i {
            margin-right: 10px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            font-size: 28px;
            color: white;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        #terrainProjectForm {
            padding: 20px;
        }

        #terrainProjectForm .form-group {
            margin-bottom: 20px;
        }

        #terrainProjectForm .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        #terrainProjectForm .form-group input,
        #terrainProjectForm .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        #terrainProjectForm .form-group input:focus,
        #terrainProjectForm .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        #terrainProjectForm .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        #terrainProjectForm .form-actions button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #terrainProjectForm .form-actions .terrain-btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        #terrainProjectForm .form-actions .terrain-btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #21618c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        #terrainProjectForm .form-actions .terrain-btn-secondary {
            background: #ecf0f1;
            color: #2c3e50;
        }

        #terrainProjectForm .form-actions .terrain-btn-secondary:hover {
            background: #bdc3c7;
            transform: translateY(-2px);
        }

        .terrain-action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
            background: #f8f9fa;
            border-top: 2px solid #e0e0e0;
        }

        .terrain-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .terrain-loading-overlay.visible {
            display: flex;
        }

        .terrain-loading-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
        }

        .terrain-loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e0e0e0;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .terrain-loading-message {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .terrain-loading-progress {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .no-results {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .terrain-3d-dock {
                width: 100%;
            }

            .contour-style-row {
                grid-template-columns: 1fr;
            }

            .elevation-breaks {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .feature-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
        }

        .feature-info h3 {
            margin-bottom: 10px;
            color: var(--primary);
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .feature-info-content {
            max-height: 300px;
            overflow-y: auto;
        }

        .feature-info-item {
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .feature-info-item:last-child {
            border-bottom: none;
        }

        .close-feature-info {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .map-controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }

        .search-container {
            display: flex;
            gap: 8px;
            flex: 1;
            min-width: 200px;
        }

        .search-box {
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.15);
            padding: 8px;
            border-radius: 6px;
            flex: 1;
        }

        .search-input {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            flex: 1;
            min-width: 120px;
            font-size: 0.9rem;
        }

        .search-btn {
            padding: 8px 14px;
            background: linear-gradient(to bottom, var(--success), #27ae60);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .coord-search {
            display: flex;
            gap: 8px;
            flex: 1;
            min-width: 200px;
        }

        .coord-input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
        }

        .quick-info-btn {
            background: linear-gradient(to bottom, var(--info), #16a085);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .modal-header {
            padding: 15px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        .modal-header h3 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body {
            padding: 15px;
            color: var(--dark);
        }

        .modal-footer {
            padding: 12px 15px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            text-align: right;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
        }

        .contact-list {
            list-style: none;
            margin: 10px 0;
            padding: 0;
        }

        .contact-item {
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .contact-item:last-child {
            border-bottom: none;
        }

        .district-name {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.95rem;
        }

        .contact-number {
            font-family: monospace;
            font-size: 1rem;
        }

        .whatsapp-link {
            display: inline-block;
            background: #25D366;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .whatsapp-link:hover {
            background: #128C7E;
            transform: translateY(-2px);
        }

        .layer-warning {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 80%;
        }

        @media (max-width: 1200px) {
            .control-btn span {
                display: none;
            }

            .control-btn {
                padding: 8px 10px;
            }
        }

        @media (max-width: 992px) {
            .map-bottom-controls {
                flex-direction: column;
            }

            .search-container,
            .coord-search {
                min-width: 100%;
            }

            /* Reduce gap between controls for better fit */
            .map-controls-row {
                gap: 5px;
            }

            .coord-extractor-main-btn {
                padding: 8px 10px;
                font-size: 0.85rem;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 8px 10px;
            }

            .app-title h1 {
                font-size: 1.2rem;
            }

            .app-title p {
                font-size: 0.75rem;
            }

            .control-btn {
                padding: 6px 8px;
                font-size: 0.8rem;
            }

            .search-btn,
            .coord-btn {
                padding: 6px 10px;
            }

            .terrain-toggle {
                padding: 6px 10px;
                font-size: 0.9rem;
            }

            .map-bottom-controls {
                gap: 10px;
            }

            #gspnet-assist-btn {
                width: 28px;
                height: 28px;
                left: 20px;
                bottom: 90px;
            }

            #gspnet-assist-btn img {
                width: 16px;
                height: 16px;
            }

            .gspnet-assist-panel {
                left: 15px;
                bottom: 120px;
            }

            .coord-extractor-grid {
                grid-template-columns: 1fr;
            }

            .coord-extractor-modal {
                height: 45vh;
            }

            /* Further reduce spacing for small screens */
            .map-controls-row {
                gap: 3px;
            }

            .search-container,
            .coord-search {
                min-width: 100%;
                gap: 5px;
            }

            .search-box,
            .coord-search {
                padding: 6px;
            }

            .search-input,
            .coord-input {
                padding: 6px 10px;
                font-size: 0.85rem;
            }

            .coord-extractor-main-btn {
                padding: 6px 8px;
                font-size: 0.8rem;
                margin: 2px;
            }

            .search-btn {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
        }

        /* PATCH: Coordinate Search Popup Styles - Self-contained styles for the coordinate search popup */
        .coordinate-search-popup {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 3px solid #3498db;
            z-index: 1000;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        }

        .coordsearch-popup-content {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .coordsearch-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            border-bottom: 1px solid #ddd;
        }

        .coordsearch-popup-header h3 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .coordsearch-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }

        .coordsearch-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .coordsearch-popup-body {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            overflow-y: auto;
            max-height: calc(50vh - 80px);
        }

        .coordsearch-panel {
            flex: 1;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
            min-width: 0;
            overflow-y: auto;
        }

        .coordsearch-panel h4 {
            margin: 0 0 15px 0;
            color: #1a2a6c;
            font-size: 1rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .coordsearch-form-group {
            margin-bottom: 12px;
        }

        .coordsearch-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .coordsearch-select,
        .coordsearch-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        .coordsearch-select:focus,
        .coordsearch-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .coordsearch-file {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .coordsearch-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .coordsearch-btn:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: translateY(-1px);
        }

        .coordsearch-btn-secondary {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .coordsearch-btn-secondary:hover {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
        }

        .coordsearch-button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .coordsearch-checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .coordsearch-checkbox {
            margin: 0;
        }

        .coordsearch-status {
            font-size: 0.8rem;
            color: #666;
            padding: 5px 0;
            min-height: 20px;
        }

        .coordsearch-status.success {
            color: #27ae60;
        }

        .coordsearch-status.error {
            color: #e74c3c;
        }

        .coordsearch-status.warning {
            color: #f39c12;
        }

        /* PATCH: Snapping Settings Popup Styles */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
        }

        .form-group input[type="checkbox"] {
            margin: 0;
            accent-color: #3498db;
        }

        .form-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .form-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .form-group input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 0 0 8px 8px;
        }

        @media (max-width: 768px) {
            .coordinate-search-popup {
                height: 60vh;
            }

            .coordsearch-popup-body {
                flex-direction: column;
                padding: 15px;
                gap: 15px;
                max-height: calc(60vh - 80px);
            }

            .coordsearch-panel {
                padding: 15px;
                min-height: 200px;
            }
        }

        @media (max-width: 576px) {
            .control-btn i {
                margin-right: 0;
            }

            .control-btn span {
                display: none;
            }

            .logo {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }

            .app-title h1 {
                font-size: 1.1rem;
            }

            .search-box,
            .coord-search {
                flex-direction: column;
            }

            .search-container,
            .coord-search {
                min-width: 100%;
            }

            #gspnet-assist-btn {
                width: 26px;
                height: 26px;
                left: 15px;
                bottom: 80px;
            }

            #gspnet-assist-btn img {
                width: 14px;
                height: 14px;
            }

            .gspnet-assist-panel {
                width: 300px;
                bottom: 150px;
            }

            .gspnet-tabs {
                width: 80px;
            }

            .gspnet-tab span {
                font-size: 0.7rem;
            }

            .coord-extractor-main-btn span {
                display: none;
            }


            .map-controls-row {
                flex-direction: column;
                align-items: stretch;
            }

            .search-container,
            .coord-search {
                order: 1;
            }

            .coord-extractor-main-btn {
                order: 2;
                margin: 5px 0;
                justify-content: center;
            }

            /* Stack controls vertically on very small screens */
            .map-controls-row {
                flex-direction: column;
            }

            .search-container,
            .coord-search,
            .coord-extractor-main-btn {
                width: 100%;
                margin-bottom: 5px;
            }
        }

        /* ========================================
           NEW FEATURES CSS STYLES
           ======================================== */

        /* Icon buttons in chat header */
        .icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* Icon overlay for combined icons */
        .icon-overlay {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 0.6em;
            background: #27ae60;
            border-radius: 50%;
            padding: 2px;
        }

        /* Chat search bar */
        .chat-search-bar {
            background: #f0f0f0;
            padding: 10px 15px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .chat-search-bar input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .search-btn,
        .clear-search-btn {
            background: #3498db;
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .clear-search-btn {
            background: #e74c3c;
        }

        .search-btn:hover {
            background: #2980b9;
        }

        .clear-search-btn:hover {
            background: #c0392b;
        }

        /* Pinned messages section */
        .pinned-messages-section {
            background: #fff8e6;
            border-bottom: 1px solid #f39c12;
            padding: 10px 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        .pinned-messages-section h4 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #f39c12;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pinned-messages-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pinned-message-item {
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #f39c12;
            font-size: 0.85rem;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pinned-message-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateX(5px);
        }

        .pinned-message-item .unpin-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e74c3c;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .pinned-message-item:hover .unpin-btn {
            opacity: 1;
        }

        /* Location History Sidebar */
        .location-history-sidebar {
            position: fixed;
            top: 0;
            right: -30%;
            width: 30%;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            z-index: 10001;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .location-history-sidebar.open {
            right: 0;
        }

        .sidebar-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h3 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
        }

        .sidebar-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .location-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .filter-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .filter-btn.active,
        .filter-btn:hover {
            background: #3498db;
            color: white;
        }

        .locations-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .location-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            cursor: pointer;
            transition: all 0.3s;
        }

        .location-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateX(5px);
        }

        .location-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .location-user {
            font-weight: 600;
            color: #333;
        }

        .location-time {
            font-size: 0.75rem;
            color: #666;
        }

        .location-coords {
            font-size: 0.85rem;
            color: #666;
            font-family: monospace;
        }

        /* Message Templates Modal */
        .templates-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .templates-modal .modal-content {
            background: white;
            width: 90%;
            max-width: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .templates-modal .modal-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .templates-modal .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .templates-modal .modal-body {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .template-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            cursor: pointer;
            transition: all 0.3s;
        }

        .template-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-3px);
        }

        .template-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .template-preview {
            font-size: 0.85rem;
            color: #666;
            line-height: 1.4;
        }

        /* Coordinate Sharing Modal */
        .coord-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .coord-modal .modal-content {
            background: white;
            width: 90%;
            max-width: 500px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .coord-modal .modal-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coord-modal .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .coord-modal .modal-body {
            padding: 20px;
        }

        .coord-formats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .coord-format-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .coord-format-item label {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .coord-format-item input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            background: #f8f9fa;
        }

        .copy-btn {
            padding: 8px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .copy-btn:hover {
            background: #2980b9;
        }

        .coord-actions {
            display: flex;
            gap: 10px;
        }

        .btn-primary {
            flex: 1;
            padding: 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            flex: 1;
            padding: 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        /* Draw and Share Modal */
        .draw-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .draw-modal .modal-content {
            background: white;
            width: 90%;
            max-width: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .draw-modal .modal-header {
            background: linear-gradient(135deg, #1a2a6c, #3498db);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .draw-modal .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .draw-modal .modal-body {
            padding: 20px;
        }

        .modal-instruction {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 6px;
            color: #1976d2;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .draw-tools {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .draw-tool-btn {
            padding: 12px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            font-size: 0.85rem;
        }

        .draw-tool-btn:hover,
        .draw-tool-btn.active {
            background: #3498db;
            border-color: #3498db;
            color: white;
        }

        .draw-options {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .draw-options label {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.9rem;
            font-weight: 600;
            flex: 1;
        }

        .draw-options input[type="color"] {
            height: 40px;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
        }

        .draw-options input[type="number"],
        .draw-options input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .draw-actions {
            display: flex;
            gap: 10px;
        }

        /* Dark Theme (Chat Only) */
        .chat-panel.dark-theme {
            background: #1e1e1e;
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .chat-header {
            background: linear-gradient(135deg, #0d1b2a, #1b263b);
        }

        .chat-panel.dark-theme .chat-body {
            background: #1e1e1e;
        }

        .chat-panel.dark-theme .online-users-section {
            background: #2a2a2a;
            border-bottom-color: #3a3a3a;
        }

        .chat-panel.dark-theme .online-users-section h4 {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .messages-container {
            background: #1e1e1e;
        }

        /* These are the old selectors - keeping for backward compatibility */

        .chat-panel.dark-theme .sender-name {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .message-time {
            color: #808080;
        }

        .chat-panel.dark-theme .message-input-container {
            background: #2a2a2a;
            border-top-color: #3a3a3a;
        }

        .chat-panel.dark-theme #messageInput {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .chat-panel.dark-theme .action-btn {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .action-btn:hover {
            background: #4a4a4a;
        }

        .chat-panel.dark-theme .send-btn {
            background: linear-gradient(to bottom, #0b5345, #145a46);
        }

        .chat-panel.dark-theme .chat-search-bar {
            background: #2a2a2a;
            border-bottom-color: #3a3a3a;
        }

        .chat-panel.dark-theme .chat-search-bar input {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .chat-panel.dark-theme .pinned-messages-section {
            background: #2a2408;
            border-bottom-color: #4a4020;
        }

        .chat-panel.dark-theme .pinned-message-item {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        /* Message highlight (for search results) */
        .message-item.highlighted {
            background: #fff3cd;
            animation: highlightPulse 1s ease;
        }

        /* ============================================
           SOCIAL CHAT SYSTEM STYLES
           ============================================ */

        /* Chat Tabs */
        .chat-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 10px;
        }

        .chat-tab {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .chat-tab.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chat-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Chat Views */
        .chat-view {
            display: none;
            flex: 1;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            /* Allows flex item to shrink properly */
            overflow: hidden;
            /* Prevents content overflow */
        }

        .chat-view.active {
            display: flex;
        }

        /* ============================================
           CHAT ROOMS STYLES
           ============================================ */

        /* Room Selector */
        .room-selector {
            padding: 15px 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }

        .room-dropdown {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }

        /* Posts List */
        .posts-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            min-height: 0;
            /* Allows flex item to shrink */
        }

        /* Post Card */
        .post-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .post-card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        .post-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin-right: 12px;
            font-size: 16px;
        }

        .post-user-info {
            flex: 1;
        }

        .post-username {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .post-time {
            color: #666;
            font-size: 12px;
            margin-top: 2px;
        }

        .post-content {
            color: #333;
            line-height: 1.5;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .post-location {
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 12px;
            color: #1976d2;
            border-left: 3px solid #1976d2;
        }

        .post-actions {
            display: flex;
            align-items: center;
            gap: 16px;
            padding-top: 12px;
            border-top: 1px solid #f0f0f0;
        }

        .reaction-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .reaction-btn:hover {
            background: #f5f5f5;
            color: #333;
        }

        .reaction-btn.liked {
            color: #e91e63;
            background: #fce4ec;
        }

        .reaction-btn.disliked {
            color: #f44336;
            background: #ffebee;
        }

        .reaction-btn .icon {
            font-size: 16px;
        }

        .comment-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .comment-toggle:hover {
            background: #f5f5f5;
            color: #333;
        }

        /* Comments Section */
        .comments-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #f0f0f0;
        }

        .comment-item {
            display: flex;
            margin-bottom: 12px;
            padding-left: 20px;
            position: relative;
        }

        .comment-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 20px;
            bottom: -12px;
            width: 2px;
            background: #e0e0e0;
        }

        .comment-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff9a9e, #fecfef);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin-right: 12px;
            font-size: 12px;
        }

        .comment-content {
            flex: 1;
        }

        .comment-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .comment-username {
            font-weight: 600;
            color: #333;
            font-size: 13px;
        }

        .comment-time {
            color: #666;
            font-size: 11px;
            margin-left: 8px;
        }

        .comment-text {
            color: #555;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .comment-actions {
            display: flex;
            gap: 12px;
        }

        .comment-action-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .comment-action-btn:hover {
            background: #f5f5f5;
            color: #333;
        }

        /* Add Comment Form */
        .add-comment-form {
            margin-top: 12px;
            padding-left: 52px;
        }

        .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 13px;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .comment-input:focus {
            border-color: #1976d2;
        }

        .comment-submit-btn {
            background: #1976d2;
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 8px;
            transition: background 0.3s ease;
        }

        .comment-submit-btn:hover {
            background: #1565c0;
        }

        /* Post Input Area */
        .post-input-area {
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            background: white;
            flex-shrink: 0;
            /* Prevent input area from shrinking */
        }

        .post-input-area textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 12px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
            margin-bottom: 12px;
        }

        .post-input-area textarea:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .post-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .post-submit {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .post-submit:hover {
            background: linear-gradient(135deg, #1565c0, #0d47a1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        /* ============================================
           INBOX STYLES
           ============================================ */

        /* Inbox Layout */
        .inbox-layout {
            display: flex;
            height: 100%;
            flex-direction: column;
            position: relative;
        }

        /* Users List */
        .users-list {
            flex: 1;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .users-list.active {
            display: flex;
        }

        .users-list.hidden {
            display: none;
        }

        .user-search-input {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
            outline: none;
            background: white;
        }

        .user-search-input::placeholder {
            color: #999;
        }

        .users-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .user-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-radius: 8px;
            margin-bottom: 4px;
            transition: all 0.3s ease;
            position: relative;
        }

        .user-item:hover {
            background: #e3f2fd;
        }

        .user-item.selected {
            background: #1976d2;
            color: white;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin-right: 12px;
            font-size: 14px;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .user-status {
            font-size: 12px;
            color: #666;
        }

        .user-item.selected .user-status {
            color: rgba(255, 255, 255, 0.8);
        }

        .user-online-indicator {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            border: 2px solid white;
        }

        .user-online-indicator.offline {
            background: #ccc;
        }

        /* Chat Conversation */
        .chat-conversation {
            flex: 1;
            display: none;
            /* Hidden by default, shown when user selected */
            flex-direction: column;
            background: white;
            overflow: hidden;
        }

        .conversation-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .conversation-header span {
            font-weight: 600;
            color: #333;
        }

        .back-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        /* Messages List */
        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            /* Start with column to stack messages vertically */
        }

        /* Messages container within inbox */
        .messages-list .message-item {
            margin-bottom: 16px;
            display: flex;
            flex-direction: row !important;
            /* Override chatroom's column direction */
            align-items: flex-end;
            width: 100%;
            /* Ensure full width for alignment */
        }

        .messages-list .message-item.sent {
            justify-content: flex-end;
        }

        .messages-list .message-item.received {
            justify-content: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
        }

        .messages-list .message-item.sent .message-bubble {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .messages-list .message-item.received .message-bubble {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .message-text {
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 4px;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            text-align: right;
        }

        .message-item.received .message-time {
            text-align: left !important;
        }

        .message-status {
            font-size: 11px;
            margin-top: 4px;
            text-align: right;
        }

        .message-status .delivered {
            color: #4caf50;
        }

        .message-status .read {
            color: #2196f3;
        }

        /* Message Input Area */
        .message-input-area {
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            background: white;
            flex-shrink: 0;
            /* Prevent input area from shrinking */
        }

        /* Inbox message actions - higher specificity to override chatroom styles */
        .message-input-area .message-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 1 !important;
            /* Override chatroom opacity:0 */
            position: static !important;
            /* Override chatroom absolute positioning */
        }

        .message-input-area textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 12px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
            margin-bottom: 12px;
        }

        .message-input-area textarea:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .message-send {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .message-send:hover {
            background: linear-gradient(135deg, #1565c0, #0d47a1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        /* ============================================
           DARK THEME SUPPORT
           ============================================ */

        .chat-panel.dark-theme .room-selector {
            background: #2a2a2a;
            border-bottom-color: #3a3a3a;
        }

        .chat-panel.dark-theme .room-dropdown {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .chat-panel.dark-theme .posts-list {
            background: #2a2a2a;
        }

        .chat-panel.dark-theme .post-card {
            background: #3a3a3a;
            border-color: #4a4a4a;
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .post-username {
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .post-time {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .post-content {
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .post-actions {
            border-top-color: #4a4a4a;
        }

        .chat-panel.dark-theme .reaction-btn {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .reaction-btn:hover {
            background: #4a4a4a;
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .comments-section {
            border-top-color: #4a4a4a;
        }

        .chat-panel.dark-theme .comment-username {
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .comment-text {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .comment-input {
            background: #4a4a4a;
            color: #e0e0e0;
            border-color: #5a5a5a;
        }

        .chat-panel.dark-theme .post-input-area {
            background: #2a2a2a;
            border-top-color: #3a3a3a;
        }

        .chat-panel.dark-theme .post-input-area textarea {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .chat-panel.dark-theme .users-list {
            background: #2a2a2a;
            border-right-color: #3a3a3a;
        }

        .chat-panel.dark-theme .user-search-input {
            background: #3a3a3a;
            color: #e0e0e0;
            border-bottom-color: #4a4a4a;
        }

        .chat-panel.dark-theme .user-item {
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .user-item:hover {
            background: #4a4a4a;
        }

        .chat-panel.dark-theme .user-item.selected {
            background: #1976d2;
        }

        .chat-panel.dark-theme .user-status {
            color: #b0b0b0;
        }

        .chat-panel.dark-theme .conversation-header {
            background: #2a2a2a;
            border-bottom-color: #3a3a3a;
        }

        .chat-panel.dark-theme .conversation-header span {
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .messages-list {
            background: #2a2a2a;
        }

        .chat-panel.dark-theme .messages-list .message-item.sent .message-bubble {
            background: linear-gradient(135deg, #0b5345, #145a46);
            color: #e0e0e0;
        }

        .chat-panel.dark-theme .messages-list .message-item.received .message-bubble {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .chat-panel.dark-theme .message-input-area {
            background: #2a2a2a;
            border-top-color: #3a3a3a;
        }

        .chat-panel.dark-theme .message-input-area textarea {
            background: #3a3a3a;
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        /* ============================================
           RESPONSIVE DESIGN
           ============================================ */

        @media (max-width: 768px) {
            .chat-panel {
                width: 85%;
                right: -85%;
            }

            .chat-panel.open {
                right: 0;
            }

            .inbox-layout {
                flex-direction: column;
            }

            .users-list {
                width: 100%;
                height: 30%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }

            .chat-conversation {
                height: 70%;
            }

            .messages-list {
                max-height: calc(100vh - 500px);
                /* Smaller on mobile */
            }

            .post-actions {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }

            .post-submit {
                width: 100%;
            }

            .message-actions {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }

            .message-send {
                width: 100%;
            }
        }

        @keyframes highlightPulse {

            0%,
            100% {
                background: #fff3cd;
            }

            50% {
                background: #ffeaa7;
            }
        }

        /* Pin icon in message actions */
        .pin-btn {
            background: rgba(243, 156, 18, 0.1);
            color: #f39c12;
        }

        .pin-btn:hover {
            background: #f39c12;
            color: white;
        }

        .message-item.pinned {
            border-left: 3px solid #f39c12;
        }

        /* User mention styling */
        .message-mention {
            background: rgba(52, 152, 219, 0.2);
            color: #2980b9;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }

        /* Location clustering marker */
        .cluster-marker {
            background: #3498db;
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Location bubble styling */
        .location-bubble {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .location-bubble:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .location-hint {
            font-size: 0.75rem;
            color: #3498db;
            margin-top: 4px;
            font-style: italic;
            text-align: center;
        }

        .coord-selection-info {
            margin-top: 15px;
        }

        /* OpenLayers Popup for Coordinate Selection */
        .ol-popup {
            position: absolute;
            background-color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            padding: 0;
            border-radius: 12px;
            border: 2px solid #3498db;
            min-width: 300px;
            z-index: 1000;
            transform: translate(-50%, -100%);
            margin-top: -20px;
        }

        .ol-popup:after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -10px;
            border: 10px solid transparent;
            border-top-color: #3498db;
        }

        .popup-closer {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            transition: all 0.3s;
            z-index: 1;
        }

        .popup-closer:hover {
            background: #f0f0f0;
            color: #e74c3c;
        }

        .popup-content {
            padding: 20px;
        }

        .popup-content h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 1.1rem;
            padding-right: 24px;
        }

        .popup-coords {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #2c3e50;
            margin-bottom: 12px;
            border: 1px solid #e0e0e0;
        }

        .popup-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 12px;
            transition: border-color 0.3s;
        }

        .popup-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .popup-actions {
            display: flex;
            gap: 8px;
        }

        .popup-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .popup-btn.share-btn {
            background: #3498db;
            color: white;
        }

        .popup-btn.share-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .popup-btn.cancel-btn {
            background: #95a5a6;
            color: white;
        }

        .popup-btn.cancel-btn:hover {
            background: #7f8c8d;
        }

        /* Screenshot preview */
        .screenshot-preview {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .location-history-sidebar {
                width: 85%;
                right: -85%;
            }

            .templates-modal .modal-content,
            .coord-modal .modal-content,
            .draw-modal .modal-content {
                width: 95%;
            }

            .templates-grid {
                grid-template-columns: 1fr;
            }

            .draw-tools {
                grid-template-columns: repeat(2, 1fr);
            }

            .chat-controls {
                flex-wrap: wrap;
                gap: 5px;
            }

            .icon-btn {
                width: 28px;
                height: 28px;
                font-size: 0.8rem;
            }
        }

        /* Loading animation for reverse geocoding */
        .geocoding-loader {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* ========================================
           CUSTOM CROSSHAIR CURSOR FOR TOOLS
           ======================================== */
        .crosshair-active {
            cursor: url('assets/icons/crosshair-dot.svg') 12 12, crosshair !important;
        }

        /* Ensure crosshair applies to all child elements */
        .crosshair-active * {
            cursor: url('assets/icons/crosshair-dot.svg') 12 12, crosshair !important;
        }

        /* ========================================
           PROPERTY LISTING SYSTEM STYLES
           ======================================== */

        /* Property Search Panel */
        .property-search-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.2);
            z-index: 10003;
            display: flex;
            flex-direction: column;
        }

        /* Property Listing Panel */
        .property-listing-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 420px;
            max-height: calc(100vh - 80px);
            background: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 10004;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .property-listing-header {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .property-listing-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .property-listing-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        /* Instruction overlay when no location selected */
        .location-instruction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            padding: 30px;
            text-align: center;
        }

        .location-instruction-overlay i {
            font-size: 4rem;
            color: #e67e22;
            margin-bottom: 20px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .location-instruction-overlay h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .location-instruction-overlay p {
            color: #7f8c8d;
            line-height: 1.6;
        }

        /* Coordinates display badge */
        .property-coords-badge {
            background: #e8f5e9;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .property-coords-badge i {
            color: #27ae60;
            font-size: 1.2rem;
        }

        .property-coords-badge .coords-text {
            font-family: monospace;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        /* Property form in panel */
        .property-listing-form {
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .property-listing-form.active {
            opacity: 1;
            pointer-events: all;
        }

        .property-listing-form .form-row {
            margin-bottom: 15px;
        }

        .property-listing-form .form-row label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .property-listing-form .form-row input,
        .property-listing-form .form-row select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        .property-listing-form .form-row input:focus,
        .property-listing-form .form-row select:focus {
            outline: none;
            border-color: #e67e22;
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.1);
        }

        .property-listing-form .form-row-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .property-listing-form .form-row-split label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .property-listing-form .form-row-split input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .price-preview {
            margin-top: 5px;
            font-size: 0.85rem;
            color: #27ae60;
            font-weight: 600;
        }

        /* Form actions */
        .property-form-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .property-form-actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .property-form-actions .save-property-btn {
            background: #e67e22;
            color: white;
        }

        .property-form-actions .save-property-btn:hover {
            background: #d35400;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.3);
        }

        .property-form-actions .save-property-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .property-form-actions .cancel-property-btn {
            background: #95a5a6;
            color: white;
        }

        .property-form-actions .cancel-property-btn:hover {
            background: #7f8c8d;
        }

        /* Loading spinner in form */
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #e67e22;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .search-panel-header {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-panel-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .search-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .search-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .search-input:focus {
            outline: none;
            border-color: #27ae60;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.1);
        }

        .search-input.half {
            width: 100%;
        }

        .price-range {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .range-separator {
            color: #666;
            font-weight: 600;
        }

        .search-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .search-action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .search-action-btn.primary {
            background: #27ae60;
            color: white;
        }

        .search-action-btn.primary:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }

        .search-action-btn.secondary {
            background: #95a5a6;
            color: white;
        }

        .search-action-btn.secondary:hover {
            background: #7f8c8d;
        }

        /* Search Results */
        .search-results {
            background: white;
            border-radius: 12px;
            overflow: hidden;
        }

        .results-header {
            background: #f8f9fa;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #27ae60;
        }

        .results-header h4 {
            margin: 0;
            font-size: 1rem;
            color: #2c3e50;
        }

        .results-count {
            font-size: 0.85rem;
            color: #27ae60;
            font-weight: 600;
        }

        .results-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .property-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .property-card:hover {
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.2);
            transform: translateY(-2px);
            border-color: #27ae60;
        }

        .property-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .property-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1rem;
        }

        .property-price {
            background: #27ae60;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .property-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .property-detail-item {
            font-size: 0.85rem;
            color: #666;
        }

        .property-detail-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .property-contact {
            background: #e3f2fd;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85rem;
            margin-top: 8px;
        }

        .property-coords {
            font-family: monospace;
            font-size: 0.75rem;
            color: #999;
            margin-top: 5px;
        }

        /* Property Marker Styles */
        .property-marker-cluster {
            background: #27ae60;
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .property-listing-panel {
                width: 95%;
                right: 2.5%;
                max-height: calc(100vh - 40px);
                top: 20px;
            }

            .property-search-panel {
                width: 100%;
            }

            .form-row-split {
                grid-template-columns: 1fr;
            }

            .property-listing-body {
                padding: 15px;
            }
        }

        /* Image Upload Styles */
        .image-upload-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 14px;
        }

        .image-upload-btn:hover {
            background: #0056b3;
        }

        .image-upload-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .image-preview {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f9f9f9;
            position: relative;
        }

        .image-preview img {
            border-radius: 4px;
            max-width: 200px;
            max-height: 150px;
        }

        .remove-image-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-image-btn:hover {
            background: #c82333;
        }

        .image-upload-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .image-upload-item {
            flex: 1;
            min-width: 200px;
        }

        .image-upload-item input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .image-preview-small {
            margin-top: 5px;
        }

        .image-preview-small img {
            max-width: 100%;
            max-height: 120px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid #ddd;
        }

        .upload-hint {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .property-images {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .property-images img {
            width: 80px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
            transition: opacity 0.2s;
        }

        .property-images img:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .image-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-modal img {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .image-modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            color: white;
            font-size: 30px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .image-modal-close:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Loading spinner for image uploads */
        .image-upload-loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .image-upload-section {
                flex-direction: column;
            }

            .property-images {
                justify-content: center;
            }

            .property-images img {
                width: 60px;
                height: 45px;
            }
        }

        /* ============================================ */
        /* LAND CLERK SYSTEM STYLES */
        /* ============================================ */

        .clerk-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .clerk-modal-content {
            background: white;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .clerk-header {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clerk-header h2 {
            margin: 0;
            font-size: 22px;
            font-weight: 600;
        }

        .clerk-close {
            background: none;
            border: none;
            color: white;
            font-size: 36px;
            cursor: pointer;
            line-height: 1;
            transition: transform 0.2s;
        }

        .clerk-close:hover {
            transform: scale(1.2);
        }

        .clerk-tabs {
            display: flex;
            background: #f3f4f6;
            border-bottom: 2px solid #e5e7eb;
        }

        .clerk-tab {
            flex: 1;
            padding: 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.2s;
            color: #6b7280;
        }

        .clerk-tab.active {
            background: white;
            color: #2563eb;
            border-bottom: 3px solid #2563eb;
        }

        .clerk-tab:hover:not(.active) {
            background: #e5e7eb;
        }

        .clerk-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .clerk-form-group {
            margin-bottom: 20px;
        }

        .clerk-form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .clerk-form-group label .required {
            color: #ef4444;
            margin-left: 4px;
        }

        .clerk-input,
        .clerk-select,
        .clerk-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .clerk-input:focus,
        .clerk-select:focus,
        .clerk-textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .clerk-file-upload {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .clerk-file-upload:hover {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .clerk-file-upload input[type="file"] {
            display: none;
        }

        .clerk-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .clerk-btn-primary {
            background: #2563eb;
            color: white;
        }

        .clerk-btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .clerk-btn-secondary {
            background: #6b7280;
            color: white;
        }

        .clerk-btn-secondary:hover {
            background: #4b5563;
        }

        .clerk-progress {
            display: flex;
            justify-content: space-between;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e5e7eb;
        }

        .clerk-step {
            flex: 1;
            text-align: center;
            position: relative;
            color: #9ca3af;
            font-size: 13px;
            font-weight: 600;
        }

        .clerk-step.active {
            color: #2563eb;
        }

        .clerk-step.completed {
            color: #10b981;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .clerk-modal-content {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
            }

            .clerk-tabs {
                font-size: 13px;
            }

            .clerk-tab {
                padding: 12px 8px;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <header>
            <div class="header-top">
                <div class="logo-container">
                    <div class="logo">GN</div>
                    <div class="app-title">
                        <h1>Geospatial Network Uganda</h1>
                        <p>Professional GIS Web Mapping Platform</p>
                    </div>
                </div>
                <div class="controls-container">
                    <!-- Layer counter added -->
                    <div class="layer-counter" title="Active Layers">
                        <i class="fas fa-layer-group"></i>
                        <span id="activeLayerCount">0</span>
                    </div>
                    <button type="button" class="control-btn" id="parcelSearchBtn" title="Parcel Search">
                        <i class="fas fa-search"></i> <span>PARCEL SEARCH</span>
                    </button>
                    <button type="button" class="control-btn" id="valuationBtn" title="Property Valuation">
                        <i class="fas fa-coins"></i> <span>VALUATION</span>
                    </button>
                    <button type="button" class="control-btn" id="locateBtn" title="Locate Me">
                        <i class="fas fa-location-dot"></i> <span>Locate</span>
                    </button>
                    <button type="button" class="control-btn" id="printBtn" title="Print Map">
                        <i class="fas fa-print"></i> <span>Print</span>
                    </button>
                    <button type="button" class="control-btn" id="fullScreenBtn" title="Full Screen">
                        <i class="fas fa-expand"></i> <span>Full</span>
                    </button>
                    <button type="button" class="control-btn" id="clerkBtn" title="Land Registration"
                        style="display: none;">
                        <i class="fas fa-file-contract"></i> <span>CLERK</span>
                    </button>
                    <button type="button" class="control-btn" id="infoBtn" title="Feature Info">
                        <i class="fas fa-info-circle"></i> <span>Info</span>
                    </button>
                    <button type="button" class="control-btn chat-btn" id="chatBtn" title="Chat Room" data-unread="0">
                        <i class="fas fa-comments"></i> <span>Chat</span>
                        <span class="unread-badge" id="unreadBadge">0</span>
                    </button>
                    <button type="button" class="control-btn quality-flags-btn" id="qualityFlagsBtn"
                        title="Quality Flags" data-unread="0">
                        <i class="fas fa-flag-checkered"></i> <span>QUALITY FLAGS</span>
                        <span class="unread-badge" id="qualityFlagsBadge">0</span>
                    </button>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>

                <div class="terrain-toggle" id="terrainToggle">
                    <span aria-hidden="true">🏔️</span> 3D Terrain
                </div>

                <div class="feature-info" id="featureInfo">
                    <button type="button" class="close-feature-info" id="closeFeatureInfo"
                        aria-label="Close feature information">&times;</button>
                    <h3>Feature Information</h3>
                    <div class="feature-info-content" id="featureInfoContent">
                        <!-- Feature info will be displayed here -->
                    </div>
                </div>

                <div class="layer-warning" id="layerWarning">
                    <i class="fas fa-exclamation-triangle" aria-hidden="true"></i> Some layers may not appear in print
                    preview
                </div>
            </div>

            <!-- Bottom controls with search and new buttons -->
            <div class="map-bottom-controls">
                <div class="map-controls-row">
                    <div class="search-container">
                        <div class="search-box">
                            <input type="text" class="search-input" id="placeSearch" placeholder="Search place...">
                            <button type="button" class="search-btn" id="placeSearchBtn">
                                <i class="fas fa-search"></i> <span>Search</span>
                            </button>
                        </div>
                    </div>

                    <!-- Project Library Button -->
                    <button type="button" class="control-btn" id="projectLibraryBtn" title="Project Library">
                        <i class="fas fa-folder-open"></i> <span>PROJECT LIBRARY</span>
                    </button>

                    <!-- Symbols Library Button -->
                    <button type="button" class="control-btn" id="symbolsLibraryToggleBtn" title="Symbols Library">
                        <i class="fas fa-toolbox"></i> <span>🧰 SYMBOLS</span>
                    </button>

                    <!-- Coordinate Search Button -->
                    <button type="button" class="control-btn" id="coordSearchBtn" title="Coordinate Search">
                        <i class="fas fa-crosshairs"></i> <span>COORD SEARCH</span>
                    </button>

                    <!-- Coordinate Extractor Button -->
                    <button type="button" class="coord-extractor-main-btn" id="coordExtractorMainBtn">
                        <i class="fas fa-ruler-combined"></i> <span>COORD EXTRACTOR</span>
                    </button>

                    <!-- GSP.NET UPDATES Button (New) -->
                    <button type="button" class="control-btn" id="gspnet-updates-toggle"
                        title="GSP.NET UPDATES - Edit PostGIS Layers">
                        <i class="fas fa-database"></i> <span>GSP.NET UPDATES</span>
                    </button>
                </div>
            </div>

            <!-- Toast notification container -->
            <div class="toast-notification" id="toastNotification">
                <span class="toast-close" id="toastClose">&times;</span>
                <div id="toastMessage"></div>
            </div>

            <style>
                /* Symbols Library Dock Styles */
                .symbols-library-dock {
                    position: fixed;
                    top: 80px;
                    left: 20px;
                    width: 400px;
                    max-height: calc(100vh - 100px);
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    z-index: 1000;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                }

                .dock-header {
                    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                    color: white;
                    padding: 15px 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .dock-header h3 {
                    margin: 0;
                    font-size: 18px;
                    font-weight: 600;
                }

                .dock-close-btn {
                    background: transparent;
                    border: none;
                    color: white;
                    font-size: 24px;
                    cursor: pointer;
                    padding: 0;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 4px;
                    transition: background 0.2s;
                }

                .dock-close-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                }

                .dock-tabs {
                    display: flex;
                    background: #f3f4f6;
                    border-bottom: 1px solid #e5e7eb;
                    overflow-x: auto;
                }

                .dock-tab-btn {
                    flex: 1;
                    padding: 12px 10px;
                    background: transparent;
                    border: none;
                    cursor: pointer;
                    font-size: 13px;
                    color: #6b7280;
                    transition: all 0.2s;
                    border-bottom: 3px solid transparent;
                    white-space: nowrap;
                }

                .dock-tab-btn:hover {
                    background: #e5e7eb;
                    color: #111827;
                }

                .dock-tab-btn.active {
                    background: white;
                    color: #3b82f6;
                    border-bottom-color: #3b82f6;
                    font-weight: 600;
                }

                .dock-content {
                    flex: 1;
                    overflow-y: auto;
                    background: white;
                }

                .dock-tab-content {
                    display: none;
                }

                .dock-tab-content.active {
                    display: block;
                }

                .draw-tool-btn,
                .action-btn {
                    padding: 10px 16px;
                    background: #3b82f6;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.2s;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                }

                .draw-tool-btn:hover,
                .action-btn:hover {
                    background: #2563eb;
                    transform: translateY(-1px);
                    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                }

                .draw-tool-btn:active,
                .action-btn:active {
                    transform: translateY(0);
                }
            </style>

            <!-- Symbols Library Dock -->
            <div class="symbols-library-dock" id="symbolsLibraryDock" style="display: none;">
                <div class="dock-header">
                    <h3><i class="fas fa-map-marked-alt"></i> Symbols Library</h3>
                    <button class="dock-close-btn" aria-label="Close Symbols Library">&times;</button>
                </div>

                <div class="dock-tabs">
                    <button class="dock-tab-btn active" data-target="catalog">
                        <i class="fas fa-th"></i> Catalog
                    </button>
                    <button class="dock-tab-btn" data-target="draw">
                        <i class="fas fa-pencil-alt"></i> Draw
                    </button>
                    <button class="dock-tab-btn" data-target="myfeatures">
                        <i class="fas fa-user"></i> My Features
                    </button>
                    <button class="dock-tab-btn" data-target="flags">
                        <i class="fas fa-flag"></i> Flags
                    </button>
                    <button class="dock-tab-btn" data-target="legend">
                        <i class="fas fa-file-pdf"></i> Legend
                    </button>
                </div>

                <div class="dock-content">
                    <!-- Catalog Tab -->
                    <div id="catalogTab" class="dock-tab-content active">
                        <div id="catalogSymbols" style="padding: 15px;">
                            <p style="color: #6b7280; text-align: center; padding: 20px;">
                                Loading symbols...
                            </p>
                        </div>
                    </div>

                    <!-- Draw Tab -->
                    <div id="drawTab" class="dock-tab-content" style="display: none;">
                        <div style="padding: 15px;">
                            <p style="margin-bottom: 15px; color: #6b7280;">
                                Select a symbol from the Catalog, then choose a drawing tool:
                            </p>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                                <button id="drawPointBtn" class="draw-tool-btn">
                                    <i class="fas fa-map-pin"></i> Point
                                </button>
                                <button id="drawLineBtn" class="draw-tool-btn">
                                    <i class="fas fa-minus"></i> Line
                                </button>
                                <button id="drawPolygonBtn" class="draw-tool-btn">
                                    <i class="fas fa-draw-polygon"></i> Polygon
                                </button>
                                <button id="stopDrawBtn" class="action-btn" style="background: #ef4444;">
                                    <i class="fas fa-stop"></i> Stop
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- My Features Tab -->
                    <div id="myfeaturesTab" class="dock-tab-content" style="display: none;">
                        <div style="padding: 15px;">
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <button id="loadFeaturesBtn" class="action-btn" style="flex: 1;">
                                    <i class="fas fa-download"></i> Load Features
                                </button>
                            </div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px;">
                                <input type="checkbox" id="autoLoadToggle">
                                <span>Auto-load when panning/zooming</span>
                            </label>
                            <div id="featuresListContainer">
                                <p style="color: #6b7280; text-align: center;">
                                    Click "Load Features" to see your features.
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Flags Tab -->
                    <div id="flagsTab" class="dock-tab-content" style="display: none;">
                        <div style="padding: 15px;">
                            <p style="color: #6b7280; text-align: center;">
                                Flagging functionality coming soon.
                            </p>
                        </div>
                    </div>

                    <!-- Legend Tab -->
                    <div id="legendTab" class="dock-tab-content" style="display: none;">
                        <div style="padding: 15px;">
                            <button class="action-btn" style="width: 100%; margin-bottom: 15px;">
                                <i class="fas fa-download"></i> Export as PDF
                            </button>
                            <p style="color: #6b7280; text-align: center;">
                                Legend export functionality coming soon.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced GSPNET.assist Floating Button -->
            <div id="gspnet-assist-btn">
                <img src="https://static.vecteezy.com/system/resources/previews/022/227/366/non_2x/openai-chatgpt-logo-icon-free-png.png"
                    alt="GSPNET Assist">
            </div>

            <!-- GSPNET.assist Panel -->
            <div class="gspnet-assist-panel" id="gspnet-assist-panel">
                <button type="button" class="gspnet-panel-close" id="gspnet-panel-close"
                    aria-label="Close panel">&times;</button>
                <div class="gspnet-panel-inner">
                    <div class="gspnet-tabs">
                        <div class="gspnet-tab active" data-tab="file-csv-upload">
                            <i class="fas fa-file-csv"></i> <span>File & CSV</span>
                        </div>
                        <div class="gspnet-tab" data-tab="dwg-dxf-upload">
                            <i class="fas fa-drafting-compass"></i> <span>DWG & DXF</span>
                        </div>
                        <div class="gspnet-tab" data-tab="drawing">
                            <i class="fas fa-pen-fancy"></i> <span>DRAWING</span>
                        </div>
                        <div class="gspnet-tab" data-tab="measurement">
                            <i class="fas fa-ruler"></i> <span>MEASURE</span>
                        </div>
                    </div>

                    <div class="gspnet-content">
                        <!-- File & CSV Upload Section -->
                        <div class="gspnet-section active" id="file-csv-upload-section">
                            <h3>File & CSV Upload</h3>

                            <!-- Form Container (disabled until location selected) -->
                            <div class="upload-form-container" id="fileCsvFormContainer"
                                style="opacity: 0.5; pointer-events: none;">
                                <!-- Location Selection Button -->
                                <div class="form-group">
                                    <button type="button" class="location-select-btn" id="fileCsvLocationBtn">
                                        <i class="fas fa-map-marker-alt"></i> Select Project Location on Map
                                    </button>
                                    <div class="coords-display" id="fileCsvCoords"
                                        style="display: none; margin-top: 10px;">
                                        <i class="fas fa-map-pin"></i>
                                        <span id="fileCsvCoordsText"></span>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label for="fileCsvClient">Client *</label>
                                    <input type="text" id="fileCsvClient" class="form-input"
                                        placeholder="Enter client name" required>
                                </div>

                                <div class="form-group">
                                    <label for="fileCsvNature">Nature of File/CSV *</label>
                                    <select id="fileCsvNature" class="form-select" required>
                                        <option value="">Select nature...</option>
                                        <option value="control_points">Control Points</option>
                                        <option value="jrj">JRJ</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>

                                <!-- Dynamic Fields Container -->
                                <div id="fileCsvDynamicFields"></div>

                                <!-- File Upload Area -->
                                <div class="form-group">
                                    <label>Upload File/CSV *</label>
                                    <div class="file-upload-area" id="fileCsvDropArea">
                                        <div class="upload-icon">
                                            <i class="fas fa-cloud-upload-alt"></i>
                                        </div>
                                        <p class="upload-text">Drag & drop file here</p>
                                        <p>OR</p>
                                        <button type="button" class="upload-btn" id="fileCsvBrowse">
                                            <i class="fas fa-folder-open"></i> Browse Files
                                        </button>
                                        <input type="file" id="fileCsvInput" class="file-input" accept=".csv,.txt,.xlsx"
                                            style="display: none;">
                                        <div id="fileCsvFileName" class="file-name-display"></div>
                                    </div>
                                </div>

                                <div class="upload-progress" id="fileCsvUploadProgress" style="display: none;">
                                    <div class="upload-progress-bar" id="fileCsvProgressBar"></div>
                                </div>

                                <div class="upload-status" id="fileCsvUploadStatus"></div>

                                <div class="form-actions">
                                    <button type="button" class="upload-btn" id="fileCsvSaveBtn" disabled>
                                        <i class="fas fa-save"></i> Save & Upload
                                    </button>
                                    <button type="button" class="upload-btn secondary" id="fileCsvCancelBtn">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- DWG & DXF Upload Section -->
                        <div class="gspnet-section" id="dwg-dxf-upload-section">
                            <h3>DWG & DXF Upload</h3>

                            <!-- Form Container (disabled until location selected) -->
                            <div class="upload-form-container" id="dwgDxfFormContainer"
                                style="opacity: 0.5; pointer-events: none;">
                                <!-- Location Selection Button -->
                                <div class="form-group">
                                    <button type="button" class="location-select-btn" id="dwgDxfLocationBtn">
                                        <i class="fas fa-map-marker-alt"></i> Select Project Location on Map
                                    </button>
                                    <div class="coords-display" id="dwgDxfCoords"
                                        style="display: none; margin-top: 10px;">
                                        <i class="fas fa-map-pin"></i>
                                        <span id="dwgDxfCoordsText"></span>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label for="dwgDxfClient">Client *</label>
                                    <input type="text" id="dwgDxfClient" class="form-input"
                                        placeholder="Enter client name" required>
                                </div>

                                <div class="form-group">
                                    <label for="dwgDxfNature">Nature of Drawing *</label>
                                    <select id="dwgDxfNature" class="form-select" required>
                                        <option value="">Select nature...</option>
                                        <option value="land_survey">Land Survey</option>
                                        <option value="other">Other Project</option>
                                    </select>
                                </div>

                                <!-- Dynamic Fields Container -->
                                <div id="dwgDxfDynamicFields"></div>

                                <!-- File Upload Area -->
                                <div class="form-group">
                                    <label>Upload DWG/DXF File *</label>
                                    <div class="file-upload-area" id="dwgDxfDropArea">
                                        <div class="upload-icon">
                                            <i class="fas fa-drafting-compass"></i>
                                        </div>
                                        <p class="upload-text">Drag & drop file here</p>
                                        <p>OR</p>
                                        <button type="button" class="upload-btn" id="dwgDxfBrowse">
                                            <i class="fas fa-folder-open"></i> Browse Files
                                        </button>
                                        <input type="file" id="dwgDxfInput" class="file-input" accept=".dwg,.dxf"
                                            style="display: none;">
                                        <div id="dwgDxfFileName" class="file-name-display"></div>
                                    </div>
                                </div>

                                <div class="upload-progress" id="dwgDxfUploadProgress" style="display: none;">
                                    <div class="upload-progress-bar" id="dwgDxfProgressBar"></div>
                                </div>

                                <div class="upload-status" id="dwgDxfUploadStatus"></div>

                                <div class="form-actions">
                                    <button type="button" class="upload-btn" id="dwgDxfSaveBtn" disabled>
                                        <i class="fas fa-save"></i> Save & Upload
                                    </button>
                                    <button type="button" class="upload-btn secondary" id="dwgDxfCancelBtn">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- PATCH: DRAWING/MARKUP Section -->
                        <div class="gspnet-section" id="drawing-section">
                            <h3>Drawing & Markup Tools</h3>
                            <div class="drawing-controls">
                                <div class="drawing-tools">
                                    <button type="button" class="drawing-btn" id="drawPoint" title="Draw Point">
                                        <i class="fas fa-map-pin"></i> Point
                                    </button>
                                    <button type="button" class="drawing-btn" id="drawLine" title="Draw Line">
                                        <i class="fas fa-minus"></i> Line
                                    </button>
                                    <button type="button" class="drawing-btn" id="drawPolygon" title="Draw Polygon">
                                        <i class="fas fa-draw-polygon"></i> Polygon
                                    </button>
                                    <button type="button" class="drawing-btn" id="drawCircle" title="Draw Circle">
                                        <i class="fas fa-circle"></i> Circle
                                    </button>
                                </div>

                                <div class="drawing-actions">
                                    <button type="button" class="drawing-btn" id="modifyFeatures"
                                        title="Modify Features">
                                        <i class="fas fa-edit"></i> Modify
                                    </button>
                                    <button type="button" class="drawing-btn" id="deleteFeatures"
                                        title="Delete Features">
                                        <i class="fas fa-trash"></i> Delete
                                    </button>
                                    <button type="button" class="drawing-btn" id="clearAll" title="Clear All">
                                        <i class="fas fa-eraser"></i> Clear
                                    </button>
                                    <button type="button" class="drawing-btn stop-btn" id="stopDrawing"
                                        title="Stop Drawing" style="background: #e74c3c; display: none;">
                                        <i class="fas fa-stop"></i> Stop
                                    </button>
                                </div>

                                <div class="drawing-export">
                                    <button type="button" class="drawing-btn" id="exportGeoJSON"
                                        title="Export as GeoJSON">
                                        <i class="fas fa-download"></i> Export
                                    </button>
                                    <button type="button" class="drawing-btn" id="importGeoJSON" title="Import GeoJSON">
                                        <i class="fas fa-upload"></i> Import
                                    </button>
                                    <input type="file" id="geojson-file-input" accept=".geojson,.json"
                                        style="display:none;">
                                </div>

                                <div class="drawing-info">
                                    <p><i class="fas fa-info-circle"></i> Click a tool to start drawing. Features are
                                        saved locally.</p>
                                    <div id="drawing-stats">
                                        <span>Points: <span id="point-count">0</span></span>
                                        <span>Lines: <span id="line-count">0</span></span>
                                        <span>Polygons: <span id="polygon-count">0</span></span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- PATCH: MEASUREMENT Section -->
                        <div class="gspnet-section" id="measurement-section">
                            <h3>Measurement Tools</h3>
                            <div class="measurement-controls">
                                <div class="measurement-tools">
                                    <button class="measurement-btn" id="measureDistance" title="Measure Distance">
                                        <i class="fas fa-ruler-horizontal"></i> Distance
                                    </button>
                                    <button class="measurement-btn" id="measureArea" title="Measure Area">
                                        <i class="fas fa-vector-square"></i> Area
                                    </button>
                                    <button class="measurement-btn" id="measureAzimuth" title="Measure Azimuth">
                                        <i class="fas fa-compass"></i> Azimuth
                                    </button>
                                </div>

                                <div class="measurement-actions">
                                    <button class="measurement-btn" id="clearMeasurements"
                                        title="Clear All Measurements">
                                        <i class="fas fa-eraser"></i> Clear
                                    </button>
                                    <button class="measurement-btn" id="toggleMeasurements" title="Toggle Measurements">
                                        <i class="fas fa-eye"></i> Toggle
                                    </button>
                                    <button class="measurement-btn stop-btn" id="stopMeasurement"
                                        title="Stop Measurement" style="background: #e74c3c; display: none;">
                                        <i class="fas fa-stop"></i> Stop
                                    </button>
                                </div>

                                <div class="measurement-info">
                                    <p><i class="fas fa-info-circle"></i> Click a tool to start measuring. Double-click
                                        to finish.</p>
                                    <div id="measurement-results">
                                        <div id="distance-result" style="display:none;">
                                            <strong>Distance:</strong> <span id="distance-value">0</span> m
                                        </div>
                                        <div id="area-result" style="display:none;">
                                            <strong>Area:</strong> <span id="area-value">0</span> m²
                                        </div>
                                        <div id="azimuth-result" style="display:none;">
                                            <strong>Azimuth:</strong> <span id="azimuth-value">0</span>°
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Polygon Import Form Panel (Project Information) -->
            <div class="polygon-import-modal" id="polygonImportModal">
                <div class="polygon-import-content">
                    <div class="polygon-import-header">
                        <h3><i class="fas fa-database"></i> Polygon Import - Project Information</h3>
                        <button class="polygon-import-close" id="polygonImportClose">&times;</button>
                    </div>
                    <div class="polygon-import-body">
                        <form id="polygonImportForm">
                            <div class="polygon-form-group">
                                <label for="polygonClient">Client <span class="required">*</span></label>
                                <input type="text" id="polygonClient" name="client" required>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonProjectName">Project Name <span class="required">*</span></label>
                                <input type="text" id="polygonProjectName" name="projectName" required>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonCoordinateSystem">Coordinate System <span
                                        class="required">*</span></label>
                                <select id="polygonCoordinateSystem" name="coordinateSystem" required>
                                    <!-- Will be populated from UGANDA_COORDINATE_SYSTEMS -->
                                </select>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonDistrict">District <span class="required">*</span></label>
                                <select id="polygonDistrict" name="district" required>
                                    <option value="">-- Select District --</option>
                                    <!-- Will be populated from UGANDA_DISTRICTS -->
                                </select>
                            </div>

                            <div class="polygon-form-row">
                                <div class="polygon-form-group">
                                    <label for="polygonBlockNumber">Block Number</label>
                                    <input type="text" id="polygonBlockNumber" name="blockNumber">
                                </div>

                                <div class="polygon-form-group">
                                    <label for="polygonPlotNumber">Plot Number</label>
                                    <input type="text" id="polygonPlotNumber" name="plotNumber">
                                </div>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonCounty">County</label>
                                <input type="text" id="polygonCounty" name="county">
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonSurveyor">Surveyor's Name <span class="required">*</span></label>
                                <input type="text" id="polygonSurveyor" name="surveyor" required>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonSupervisor">Supervisor's Name <span class="required">*</span></label>
                                <input type="text" id="polygonSupervisor" name="supervisor" required>
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonCompany">Company</label>
                                <input type="text" id="polygonCompany" name="company">
                            </div>

                            <div class="polygon-form-group">
                                <label for="polygonAdditionalInfo">Additional Information</label>
                                <textarea id="polygonAdditionalInfo" name="additionalInfo" rows="3"></textarea>
                            </div>

                            <div class="polygon-form-footer">
                                <button type="button" class="polygon-form-btn polygon-form-btn-cancel"
                                    id="polygonFormCancel">Cancel</button>
                                <button type="submit" class="polygon-form-btn polygon-form-btn-submit">Continue</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>

            <!-- Project Library Search Panel -->
            <div class="project-library-panel" id="projectLibraryPanel">
                <div class="project-library-header">
                    <h3><i class="fas fa-folder-open"></i> Project Library</h3>
                    <button type="button" class="project-library-close" id="closeProjectLibrary"
                        aria-label="Close panel">&times;</button>
                </div>
                <div class="project-library-body">
                    <div class="project-search-tabs">
                        <button class="project-search-tab active" data-search-type="files">
                            <i class="fas fa-file-csv"></i> File & CSV
                        </button>
                        <button class="project-search-tab" data-search-type="drawings">
                            <i class="fas fa-drafting-compass"></i> DWG & DXF
                        </button>
                    </div>

                    <div class="project-search-form" id="projectSearchForm">
                        <div class="form-group">
                            <label for="searchNature">Nature of Project</label>
                            <select id="searchNature" class="form-select">
                                <option value="">All Types</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="searchClient">Client</label>
                            <input type="text" id="searchClient" class="form-input" placeholder="Enter client name">
                        </div>

                        <div class="form-group">
                            <label for="searchDistrict">District</label>
                            <select id="searchDistrict" class="form-select">
                                <option value="">All Districts</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="searchCounty">County</label>
                            <input type="text" id="searchCounty" class="form-input" placeholder="Enter county">
                        </div>

                        <div class="form-group">
                            <label for="searchBlockNumber">Block Number</label>
                            <input type="text" id="searchBlockNumber" class="form-input"
                                placeholder="Enter block number">
                        </div>

                        <div class="form-group">
                            <label for="searchPlotNumber">Plot Number</label>
                            <input type="text" id="searchPlotNumber" class="form-input" placeholder="Enter plot number">
                        </div>

                        <div class="form-group">
                            <label for="searchProjectName">Project Name</label>
                            <input type="text" id="searchProjectName" class="form-input"
                                placeholder="Enter project name">
                        </div>

                        <div class="form-group">
                            <label for="searchSurveyor">Surveyor</label>
                            <input type="text" id="searchSurveyor" class="form-input" placeholder="Enter surveyor name">
                        </div>

                        <div class="form-group">
                            <label for="searchCoordinateSystem">Coordinate System</label>
                            <select id="searchCoordinateSystem" class="form-select">
                                <option value="">All Systems</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="searchDateFrom">Date From</label>
                            <input type="date" id="searchDateFrom" class="form-input">
                        </div>

                        <div class="form-group">
                            <label for="searchDateTo">Date To</label>
                            <input type="date" id="searchDateTo" class="form-input">
                        </div>

                        <div class="form-group">
                            <label for="searchSortBy">Sort By</label>
                            <select id="searchSortBy" class="form-select">
                                <option value="uploaded_at DESC">Date (Newest)</option>
                                <option value="uploaded_at ASC">Date (Oldest)</option>
                                <option value="project_name ASC">Name (A-Z)</option>
                                <option value="project_name DESC">Name (Z-A)</option>
                                <option value="district ASC">District (A-Z)</option>
                            </select>
                        </div>

                        <div class="form-actions">
                            <button type="button" class="upload-btn" id="projectSearchBtn">
                                <i class="fas fa-search"></i> Search
                            </button>
                            <button type="button" class="upload-btn secondary" id="projectSearchResetBtn">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>

                    <div class="project-search-results" id="projectSearchResults">
                        <div class="results-header">
                            <span id="resultsCount">No results</span>
                        </div>
                        <div class="results-list" id="resultsList">
                            <p class="no-results">Use the search form above to find projects.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Coordinate Extractor Modal -->
            <div class="coord-extractor-modal" id="coordExtractorModal">
                <div class="coord-extractor-header">
                    <h3><i class="fas fa-ruler-combined"></i> Coordinate Extractor Tool</h3>
                    <button type="button" class="coord-extractor-close" id="coordExtractorClose"
                        aria-label="Close coordinate extractor">&times;</button>
                </div>
                <div class="coord-extractor-body">
                    <div class="coord-extractor-grid">
                        <div class="coord-extractor-controls-panel">
                            <label for="crs-selector">Coordinate Reference System:</label>
                            <select id="crs-selector" name="crs" class="crs-selector">
                                <option value="EPSG:32636">WGS84 UTM Zone 36N (Default)</option>
                                <option value="EPSG:21096">Arc1960 UTM Zone 36N — EPSG:21096</option>
                                <option value="EPSG:21036">Arc1960 UTM Zone 36S — EPSG:21036</option>
                                <option value="EPSG:32736">WGS84 UTM Zone 36S — EPSG:32736</option>
                                <option value="EPSG:4326">WGS84 Geographic (Lat/Lon) — EPSG:4326</option>
                                <option value="EPSG:3857">Web Mercator — EPSG:3857</option>
                            </select>

                            <label for="coordExtractorLayerSelect" style="margin-top: 15px; display: block;">Layer for
                                Snapping:</label>
                            <select id="coordExtractorLayerSelect" name="layer" class="crs-selector">
                                <option value="">-- Select Layer --</option>
                                <!-- Options will be populated dynamically -->
                            </select>

                            <label for="snapping-tolerance" style="margin-top: 15px; display: block;">Snapping Tolerance
                                (meters):</label>
                            <div class="tolerance-controls">
                                <input type="range" id="snapping-tolerance" min="1" max="50" value="5" step="1">
                                <span id="tolerance-value">5m</span>
                            </div>

                            <label for="snapping-mode" style="margin-top: 15px; display: block;">Snapping Mode:</label>
                            <select id="snapping-mode" class="crs-selector">
                                <option value="both">Vertex & Edge Snapping</option>
                                <option value="vertex">Vertex Only</option>
                                <option value="edge">Edge Only</option>
                            </select>

                            <div class="coord-controls-row">
                                <button type="button" class="coord-control-btn primary" id="start-extraction-btn">
                                    <i class="fas fa-play"></i> Start Extraction
                                </button>
                                <button type="button" class="coord-control-btn secondary" id="export-csv-btn" disabled>
                                    <i class="fas fa-file-export"></i> Export CSV
                                </button>
                            </div>

                            <div class="coord-controls-row">
                                <button type="button" class="coord-control-btn warning" id="undo-btn" disabled>
                                    <i class="fas fa-undo"></i> Undo
                                </button>
                                <button type="button" class="coord-control-btn warning" id="clear-all-btn" disabled>
                                    <i class="fas fa-trash"></i> Clear All
                                </button>
                            </div>

                            <!-- Snapping Toggle Button -->
                            <div class="coord-controls-row">
                                <button type="button" class="coord-control-btn" id="snapping-toggle-btn">
                                    <i class="fas fa-magnet"></i> Snapping: OFF
                                </button>
                            </div>

                            <!-- Validation Toggle -->
                            <div class="coord-controls-row">
                                <button type="button" class="coord-control-btn info" id="validation-toggle-btn">
                                    <i class="fas fa-check-circle"></i> Validation: ON
                                </button>
                            </div>

                            <!-- Batch Operations -->
                            <div class="batch-operations"
                                style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                                <h4 style="margin: 0 0 10px 0; color: #2c3e50;">Batch Operations</h4>
                                <div class="coord-controls-row">
                                    <button type="button" class="coord-control-btn success"
                                        id="extract-polygon-vertices-btn">
                                        <i class="fas fa-draw-polygon"></i> Extract Polygon Vertices
                                    </button>
                                </div>
                                <div class="coord-controls-row" style="margin-top: 5px;">
                                    <button type="button" class="coord-control-btn success" id="extract-along-edge-btn">
                                        <i class="fas fa-route"></i> Extract Along Edge
                                    </button>
                                </div>
                            </div>

                            <!-- Test Transform Button -->
                            <div class="coord-controls-row">
                                <button type="button" class="coord-control-btn" id="test-transform-btn">
                                    <i class="fas fa-cog"></i> Test Transform
                                </button>
                            </div>

                            <div class="coord-extractor-status" id="coord-extractor-status">
                                <i class="fas fa-info-circle"></i> <span id="coord-status-text">Ready to start</span>
                                <span id="wfs-loading-indicator" style="display:none;" class="loading-indicator"></span>
                            </div>
                        </div>

                        <div class="coord-extractor-results-panel">
                            <h4>Extracted Coordinates:</h4>
                            <table class="coord-result-table">
                                <thead>
                                    <tr>
                                        <th>Point ID</th>
                                        <th>Easting</th>
                                        <th>Northing</th>
                                        <th>Latitude</th>
                                        <th>Longitude</th>
                                    </tr>
                                </thead>
                                <tbody id="coord-results-body">
                                    <!-- Results will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Print disclaimer (hidden until printing) -->
            <div class="print-disclaimer">
                <p><strong>Data Disclaimer:</strong> This map combines data from multiple sources including
                    OpenStreetMap, Esri, Google, and our own geospatial databases. We have not independently verified
                    every dataset. Use this information with caution as accuracy and completeness may vary. Geospatial
                    Network Uganda is not liable for any errors or consequences arising from the use of this map.</p>
            </div>

            <!-- Print Dialog Modal -->
            <div id="printDialogModal" class="print-dialog-modal">
                <div class="print-dialog-content">
                    <div class="print-dialog-header">
                        <h2><i class="fas fa-print"></i> Print Map Configuration</h2>
                        <button type="button" class="close-print-dialog" id="closePrintDialog"
                            aria-label="Close print dialog">&times;</button>
                    </div>

                    <div class="print-dialog-body">
                        <!-- Left Panel: Form Inputs -->
                        <div class="print-form-panel">
                            <h3>Project Details</h3>

                            <div class="form-group">
                                <label for="printHeading">Heading *</label>
                                <input type="text" id="printHeading" placeholder="Enter project heading" required>
                            </div>

                            <div class="form-row">
                                <div class="form-group">
                                    <label for="printDistrict">District *</label>
                                    <input type="text" id="printDistrict" placeholder="District" required>
                                </div>
                                <div class="form-group">
                                    <label for="printCounty">County *</label>
                                    <input type="text" id="printCounty" placeholder="County" required>
                                </div>
                            </div>

                            <div class="form-row">
                                <div class="form-group">
                                    <label for="printBlock">Block Number</label>
                                    <input type="text" id="printBlock" placeholder="Block">
                                </div>
                                <div class="form-group">
                                    <label for="printPlot">Plot Number/Unique ID</label>
                                    <input type="text" id="printPlot" placeholder="Plot/ID">
                                </div>
                            </div>

                            <div class="form-row">
                                <div class="form-group">
                                    <label for="printClientName">Client Name *</label>
                                    <input type="text" id="printClientName" placeholder="Client name" required>
                                </div>
                                <div class="form-group">
                                    <label for="printClientContact">Client Contact *</label>
                                    <input type="text" id="printClientContact" placeholder="Contact" required>
                                </div>
                            </div>

                            <h3>Surveyor Information</h3>

                            <div class="form-group">
                                <label for="printSurveyorName">Surveyor Name *</label>
                                <input type="text" id="printSurveyorName" placeholder="Surveyor name" required>
                            </div>

                            <div class="form-group">
                                <label for="printSurveyorContact">Surveyor Contact *</label>
                                <input type="text" id="printSurveyorContact" placeholder="Contact" required>
                            </div>

                            <h3>Supervisor Information</h3>

                            <div class="form-group">
                                <label for="printSupervisorName">Supervisor Name</label>
                                <input type="text" id="printSupervisorName" placeholder="Supervisor name">
                            </div>

                            <div class="form-group">
                                <label for="printCompany">Company</label>
                                <input type="text" id="printCompany" placeholder="Company name">
                            </div>
                        </div>

                        <!-- Right Panel: Map Preview -->
                        <div class="print-preview-panel">
                            <h3>Map Preview <small>(Pan to center)</small></h3>
                            <div id="printMapPreview" class="print-map-preview"></div>
                            <div class="preview-controls">
                                <button type="button" class="preview-btn" id="resetPreviewView" title="Reset View">
                                    <i class="fas fa-home"></i> Reset View
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Print Options -->
                    <div class="print-options-panel">
                        <div class="print-option-group">
                            <label for="printOrientation">Page Orientation:</label>
                            <select id="printOrientation">
                                <option value="portrait" selected>Portrait</option>
                                <option value="landscape">Landscape</option>
                            </select>
                        </div>

                        <div class="print-option-group">
                            <label for="printScale">Map Scale:</label>
                            <select id="printScale">
                                <option value="auto">Auto</option>
                                <option value="1:500">1:500</option>
                                <option value="1:1000">1:1000</option>
                                <option value="1:2000">1:2000</option>
                                <option value="1:5000">1:5,000</option>
                                <option value="1:10000">1:10,000</option>
                                <option value="1:25000">1:25,000</option>
                                <option value="1:50000">1:50,000</option>
                            </select>
                        </div>

                        <div class="print-option-group">
                            <label for="printFormat">Export Format:</label>
                            <select id="printFormat">
                                <option value="pdf">PDF</option>
                                <option value="print">Print</option>
                            </select>
                        </div>

                        <div class="print-option-group">
                            <label for="printCRS">Coordinate System:</label>
                            <select id="printCRS">
                                <option value="none">No Grid</option>
                                <option value="EPSG:32636">WGS84 UTM Zone 36N (EPSG:32636)</option>
                                <option value="EPSG:21096">Arc1960 UTM Zone 36N (EPSG:21096)</option>
                                <option value="EPSG:4326">WGS84 Geographic (EPSG:4326)</option>
                            </select>
                        </div>
                    </div>

                    <div class="print-dialog-footer">
                        <button type="button" class="btn-cancel" id="cancelPrint">Cancel</button>
                        <button type="button" class="btn-preview" id="previewPrint">Preview</button>
                        <button type="button" class="btn-print" id="executePrint">Print/Export</button>
                    </div>
                </div>
            </div>

            <!-- Project Information Modal for 3D Terrain -->
            <div id="terrainProjectModal" class="terrain-project-modal">
                <div class="terrain-project-modal-content">
                    <div class="terrain-project-modal-header">
                        <h3><i class="fas fa-project-diagram"></i> Project Information</h3>
                        <button type="button" class="modal-close" id="terrainProjectModalClose"
                            aria-label="Close modal">&times;</button>
                    </div>
                    <form id="terrainProjectForm">
                        <div class="form-group">
                            <label for="terrainProjectClient">Client *</label>
                            <input type="text" id="terrainProjectClient" class="form-input" required
                                placeholder="Enter client name" autocomplete="off">
                        </div>

                        <div class="form-group">
                            <label for="terrainProjectName">Project Name *</label>
                            <input type="text" id="terrainProjectName" class="form-input" required
                                placeholder="Enter project name" autocomplete="off">
                        </div>

                        <div class="form-group">
                            <label for="terrainProjectCRS">Coordinate System *</label>
                            <select id="terrainProjectCRS" class="form-select" required>
                                <option value="">Select coordinate system...</option>
                                <option value="EPSG:32636">WGS84 UTM Zone 36N (EPSG:32636)</option>
                                <option value="EPSG:32736">WGS84 UTM Zone 36S (EPSG:32736)</option>
                                <option value="EPSG:21096">Arc1960 UTM Zone 36N (EPSG:21096)</option>
                                <option value="EPSG:21036">Arc1960 UTM Zone 36S (EPSG:21036)</option>
                                <option value="EPSG:4326">WGS84 Geographic (EPSG:4326)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="terrainProjectDistrict">District *</label>
                            <select id="terrainProjectDistrict" class="form-select" required>
                                <option value="">Select district...</option>
                                <!-- Populated dynamically -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="terrainProjectSurveyor">Surveyor *</label>
                            <input type="text" id="terrainProjectSurveyor" class="form-input" required
                                placeholder="Enter surveyor name" autocomplete="off">
                        </div>

                        <div class="form-group">
                            <label for="terrainProjectSupervisor">Supervisor *</label>
                            <input type="text" id="terrainProjectSupervisor" class="form-input" required
                                placeholder="Enter supervisor name" autocomplete="off">
                        </div>

                        <div class="form-actions">
                            <button type="submit" class="terrain-btn terrain-btn-primary">
                                <i class="fas fa-check"></i> Continue
                            </button>
                            <button type="button" class="terrain-btn terrain-btn-secondary" id="terrainProjectCancel">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- 3D TERRAIN DTM & CONTOURS Left-Side Dock -->
            <aside id="terrain-3d-dock" class="terrain-3d-dock">
                <div class="terrain-3d-header">
                    <h3><i class="fas fa-mountain"></i> 3D Terrain & Contours</h3>
                    <button type="button" class="terrain-3d-close" id="terrain-3d-close"
                        aria-label="Close dock">&times;</button>
                </div>

                <div class="terrain-3d-body">
                    <!-- 1. Data Source Selection -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="data-source">
                            <span><i class="fas fa-database"></i> Data Source</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="data-source-content">
                            <div class="terrain-data-source-selector">
                                <label class="terrain-radio-option">
                                    <input type="radio" name="dataSource" value="import" id="dataSourceImport" checked>
                                    <span>Import New CSV</span>
                                </label>
                                <label class="terrain-radio-option">
                                    <input type="radio" name="dataSource" value="existing" id="dataSourceExisting">
                                    <span>Use Existing Data</span>
                                </label>
                                <label class="terrain-radio-option">
                                    <input type="radio" name="dataSource" value="both" id="dataSourceBoth">
                                    <span>Combine Both</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- 2. CSV Upload Interface -->
                    <div class="terrain-3d-section" id="csv-upload-section">
                        <div class="terrain-3d-section-header" data-section="csv-upload">
                            <span><i class="fas fa-file-csv"></i> Import CSV</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="csv-upload-content">
                            <div class="terrain-csv-upload-area" id="terrainCsvUploadArea">
                                <i class="fas fa-cloud-upload-alt" style="font-size: 2rem; color: #3498db;"></i>
                                <p style="margin: 10px 0;">Click to browse or drag and drop CSV file</p>
                                <button type="button" class="terrain-btn terrain-btn-primary" id="terrainCsvBrowseBtn">
                                    <i class="fas fa-folder-open"></i> Browse Files
                                </button>
                                <input type="file" id="terrainCsvFileInput" accept=".csv" style="display: none;">
                                <div class="terrain-file-info" id="terrainCsvFileInfo">
                                    <strong id="terrainCsvFileName"></strong>
                                    <p id="terrainCsvFileDetails"
                                        style="margin: 5px 0; color: #7f8c8d; font-size: 0.85rem;"></p>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="csvCoordinateSystem">Coordinate System *</label>
                                <select id="csvCoordinateSystem" class="form-select">
                                    <option value="EPSG:32636">WGS84 UTM Zone 36N (EPSG:32636)</option>
                                    <option value="EPSG:21096">Arc1960 UTM Zone 36N (EPSG:21096)</option>
                                    <option value="EPSG:21036">Arc1960 UTM Zone 36S (EPSG:21036)</option>
                                    <option value="EPSG:32736">WGS84 UTM Zone 36S (EPSG:32736)</option>
                                    <option value="EPSG:4326">WGS84 Geographic (EPSG:4326)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- 3. Search Existing Data -->
                    <div class="terrain-3d-section" id="search-existing-section">
                        <div class="terrain-3d-section-header" data-section="search-existing">
                            <span><i class="fas fa-search"></i> Search Existing Data</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="search-existing-content">
                            <div class="terrain-search-filters">
                                <div class="form-group">
                                    <label for="terrainSearchDistrict">District</label>
                                    <select id="terrainSearchDistrict" class="form-select">
                                        <option value="">All Districts</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label for="terrainSearchNature">Nature</label>
                                    <select id="terrainSearchNature" class="form-select">
                                        <option value="">All Types</option>
                                        <option value="control_points">Control Points</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label for="terrainSearchProject">Project Name</label>
                                    <input type="text" id="terrainSearchProject" class="form-input"
                                        placeholder="Enter project name">
                                </div>

                                <div class="form-group">
                                    <label for="terrainSearchSurveyor">Surveyor</label>
                                    <input type="text" id="terrainSearchSurveyor" class="form-input"
                                        placeholder="Enter surveyor name">
                                </div>

                                <div class="form-group">
                                    <label for="terrainSearchDateFrom">Date From</label>
                                    <input type="date" id="terrainSearchDateFrom" class="form-input">
                                </div>

                                <div class="form-group">
                                    <label for="terrainSearchDateTo">Date To</label>
                                    <input type="date" id="terrainSearchDateTo" class="form-input">
                                </div>

                                <button type="button" class="terrain-btn terrain-btn-primary" id="terrainSearchBtn">
                                    <i class="fas fa-search"></i> Search Projects
                                </button>
                                <button type="button" class="terrain-btn terrain-btn-secondary"
                                    id="terrainSearchResetBtn">
                                    <i class="fas fa-redo"></i> Reset Filters
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 4. Available Datasets -->
                    <div class="terrain-3d-section" id="datasets-section">
                        <div class="terrain-3d-section-header" data-section="datasets">
                            <span><i class="fas fa-list"></i> Available Datasets <span
                                    id="datasetsCount">(0)</span></span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="datasets-content">
                            <div class="terrain-dataset-list" id="datasetsList">
                                <p class="no-results">Search for existing data to display datasets</p>
                            </div>
                        </div>
                    </div>

                    <!-- 5. Processing Extent -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="processing-extent">
                            <span><i class="fas fa-vector-square"></i> Processing Extent</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="processing-extent-content">
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin-bottom: 12px;">
                                <i class="fas fa-info-circle"></i> Define a custom boundary for DTM/contour generation.
                                Only points inside the extent will be used.
                            </p>

                            <button id="drawExtentBtn" class="terrain-btn" style="width: 100%; margin-bottom: 8px;">
                                <i class="fas fa-draw-polygon"></i> Draw Extent Polygon
                            </button>

                            <button id="clearExtentBtn" class="terrain-btn"
                                style="width: 100%; margin-bottom: 12px; background: #e74c3c; opacity: 0.6;" disabled>
                                <i class="fas fa-times"></i> Clear Extent
                            </button>

                            <label class="terrain-checkbox-option">
                                <input type="checkbox" id="useCustomExtent" disabled>
                                <span>Use Custom Extent</span>
                            </label>

                            <!-- Extent Info Panel -->
                            <div id="extentInfoPanel"
                                style="display:none; margin-top:12px; padding:12px; background:#e8f5e9; border-left: 4px solid #4caf50; border-radius:4px;">
                                <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px; font-size: 0.9rem;">
                                    <i class="fas fa-check-circle"></i> Extent Defined
                                </div>
                                <div style="font-size: 0.85rem; color: #555; line-height: 1.8;">
                                    <div><i class="fas fa-ruler-combined" style="width: 20px; color: #4caf50;"></i>
                                        Area: <strong><span id="extentArea">-</span> m²</strong></div>
                                    <div><i class="fas fa-border-all" style="width: 20px; color: #4caf50;"></i>
                                        Perimeter: <strong><span id="extentPerimeter">-</span> m</strong></div>
                                    <div><i class="fas fa-map-marker-alt" style="width: 20px; color: #2196f3;"></i>
                                        Points inside: <strong><span id="extentPointsInside">-</span></strong></div>
                                    <div><i class="fas fa-ban" style="width: 20px; color: #f44336;"></i> Points
                                        excluded: <strong><span id="extentPointsExcluded">-</span></strong></div>
                                </div>

                                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #c8e6c9;">
                                    <button id="exportExtentBtn" class="terrain-btn"
                                        style="width: 48%; font-size: 0.8rem; padding: 6px;">
                                        <i class="fas fa-download"></i> Export
                                    </button>
                                    <button id="importExtentBtn" class="terrain-btn"
                                        style="width: 48%; font-size: 0.8rem; padding: 6px; float: right;">
                                        <i class="fas fa-upload"></i> Import
                                    </button>
                                </div>
                            </div>

                            <!-- Extent Settings -->
                            <div
                                style="margin-top: 12px; padding: 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e0e0e0;">
                                <div style="font-size: 0.85rem; font-weight: 600; color: #555; margin-bottom: 8px;">
                                    <i class="fas fa-cog"></i> Display Settings
                                </div>
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="showExtentOnMap" checked>
                                    <span>Show Extent on Map</span>
                                </label>
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="snapToPoints" checked>
                                    <span>Snap to Points (Drawing)</span>
                                </label>
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="showExtentMeasurements" checked>
                                    <span>Show Measurements</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- 6. Display Options -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="display-options">
                            <span><i class="fas fa-eye"></i> Display Options</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="display-options-content">
                            <div class="terrain-display-options">
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="showPoints" checked>
                                    <span>Show Points on Map</span>
                                </label>
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="showPointNumbers" checked>
                                    <span>Show Point Numbers</span>
                                </label>
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="showDescriptions" checked>
                                    <span>Show Descriptions</span>
                                </label>

                                <div class="form-group">
                                    <label>Point Color</label>
                                    <div class="color-picker-wrapper">
                                        <input type="color" id="pointColor" value="#3498db">
                                        <span>Blue</span>
                                    </div>
                                </div>

                                <div class="range-slider-wrapper">
                                    <label>
                                        <span>Point Size</span>
                                        <span id="pointSizeValue">6px</span>
                                    </label>
                                    <input type="range" id="pointSize" class="range-slider" min="3" max="12" value="6"
                                        step="1">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 6. DTM Configuration -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="dtm-config">
                            <span><i class="fas fa-layer-group"></i> DTM Configuration</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="dtm-config-content">
                            <div class="terrain-dtm-config">
                                <!-- Grid Resolution -->
                                <div class="range-slider-wrapper">
                                    <label>
                                        <span>Grid Resolution (Cell Size)</span>
                                        <span id="cellSizeValue">5m</span>
                                    </label>
                                    <input type="range" id="cellSize" class="range-slider" min="1" max="20" value="5"
                                        step="1">
                                    <small
                                        style="color: #7f8c8d; font-size: 11px; display: block; margin-top: 5px;">Smaller
                                        = More detail (slower)</small>
                                </div>

                                <!-- Interpolation Method -->
                                <div class="form-group">
                                    <label for="interpolationMethod">Interpolation Method</label>
                                    <select id="interpolationMethod" class="form-select">
                                        <option value="tin">TIN - Sharp Terrain (QGIS-like)</option>
                                        <option value="idw" selected>IDW - Smooth (Power=2)</option>
                                        <option value="idw-sharp">IDW Sharp (Power=4)</option>
                                        <option value="nearest">Nearest Neighbor</option>
                                    </select>
                                    <small style="color: #7f8c8d; font-size: 11px;">TIN produces sharper, more realistic
                                        terrain</small>
                                </div>

                                <!-- IDW Parameters -->
                                <div class="form-group">
                                    <label for="idwPower">IDW Power</label>
                                    <input type="number" id="idwPower" class="form-input" value="2" min="1" max="5"
                                        step="0.5">
                                    <small style="color: #7f8c8d; font-size: 11px;">Higher = More weight to nearby
                                        points</small>
                                </div>

                                <div class="form-group">
                                    <label for="idwMaxDistance">IDW Max Distance (meters)</label>
                                    <input type="number" id="idwMaxDistance" class="form-input" value="1000" min="100"
                                        max="10000" step="100">
                                    <small style="color: #7f8c8d; font-size: 11px;">Maximum search radius for
                                        interpolation</small>
                                </div>

                                <!-- Color Ramp -->
                                <div class="form-group">
                                    <label for="colorRamp">Color Ramp</label>
                                    <select id="colorRamp" class="form-select">
                                        <option value="elevation">Elevation (Blue-Cyan-Green-Yellow-Red-White)</option>
                                        <option value="terrain">Terrain (Green-Brown-White)</option>
                                        <option value="grayscale">Grayscale (Black-White) - Best for 3D Effect</option>
                                        <option value="viridis">Viridis (Purple-Blue-Green-Yellow)</option>
                                        <option value="spectral">Spectral (Red-Orange-Yellow-Green-Blue-Purple)</option>
                                        <option value="plasma">Plasma (Purple-Pink-Orange-Yellow)</option>
                                    </select>
                                    <div class="color-scheme-preview" id="colorSchemePreview"></div>
                                </div>

                                <!-- Elevation Range -->
                                <div class="form-group">
                                    <label>Elevation Range (Auto-calculated)</label>
                                    <div style="display: flex; gap: 10px;">
                                        <input type="number" id="minElevation" class="form-input" placeholder="Min"
                                            style="flex: 1;" readonly>
                                        <input type="number" id="maxElevation" class="form-input" placeholder="Max"
                                            style="flex: 1;" readonly>
                                    </div>
                                </div>

                                <!-- Rendering Adjustments -->
                                <div class="range-slider-wrapper">
                                    <label>
                                        <span>Contrast</span>
                                        <span id="contrastValue">0</span>
                                    </label>
                                    <input type="range" id="contrastSlider" class="range-slider" min="-100" max="100"
                                        value="0" step="10">
                                </div>

                                <div class="range-slider-wrapper">
                                    <label>
                                        <span>Brightness</span>
                                        <span id="brightnessValue">0</span>
                                    </label>
                                    <input type="range" id="brightnessSlider" class="range-slider" min="-100" max="100"
                                        value="0" step="10">
                                </div>

                                <!-- Hillshade Settings -->
                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="hillshadeEnabled" checked>
                                    <span>Apply Hillshade Effect</span>
                                </label>

                                <div id="hillshadeSettings" style="display: block;">
                                    <label class="terrain-checkbox-option">
                                        <input type="checkbox" id="multidirectionalHillshade" checked>
                                        <span>Multidirectional (Enhanced 3D Effect)</span>
                                    </label>
                                    <small
                                        style="color: #7f8c8d; font-size: 11px; display: block; margin: -5px 0 10px 0;">Uses
                                        4 light sources for more dramatic terrain visualization</small>

                                    <div class="range-slider-wrapper">
                                        <label>
                                            <span>Hillshade Azimuth (degrees)</span>
                                            <span id="azimuthValue">315°</span>
                                        </label>
                                        <input type="range" id="azimuthSlider" class="range-slider" min="0" max="360"
                                            value="315" step="15">
                                    </div>

                                    <div class="range-slider-wrapper">
                                        <label>
                                            <span>Hillshade Altitude (degrees)</span>
                                            <span id="altitudeValue">45°</span>
                                        </label>
                                        <input type="range" id="altitudeSlider" class="range-slider" min="0" max="90"
                                            value="45" step="5">
                                    </div>

                                    <div class="range-slider-wrapper">
                                        <label>
                                            <span>Z-Factor (Vertical Exaggeration)</span>
                                            <span id="zFactorValue">1.0</span>
                                        </label>
                                        <input type="range" id="zFactorSlider" class="range-slider" min="0.1" max="5"
                                            value="1" step="0.1">
                                    </div>

                                    <div class="form-group">
                                        <label for="hillshadeBlend">Hillshade Blend Mode</label>
                                        <select id="hillshadeBlend" class="form-select">
                                            <option value="multiply">Multiply</option>
                                            <option value="overlay">Overlay</option>
                                            <option value="soft-light">Soft Light</option>
                                        </select>
                                    </div>

                                    <div class="range-slider-wrapper">
                                        <label>
                                            <span>Hillshade Opacity</span>
                                            <span id="hillshadeOpacityValue">50%</span>
                                        </label>
                                        <input type="range" id="hillshadeOpacity" class="range-slider" min="0" max="100"
                                            value="50" step="5">
                                    </div>
                                </div>

                                <!-- DTM Layer Opacity -->
                                <div class="range-slider-wrapper">
                                    <label>
                                        <span>DTM Layer Opacity</span>
                                        <span id="dtmOpacityValue">80%</span>
                                    </label>
                                    <input type="range" id="dtmOpacity" class="range-slider" min="0" max="100"
                                        value="80" step="5">
                                </div>

                                <label class="terrain-checkbox-option" style="margin-top: 8px;">
                                    <input type="checkbox" id="dtmLayerToggle" disabled>
                                    <span>Show DTM Layer</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- 7. Contour Configuration -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="contour-config">
                            <span><i class="fas fa-chart-line"></i> Contour Configuration</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="contour-config-content">
                            <div class="terrain-contour-config">
                                <label class="terrain-checkbox-option" style="margin-bottom: 10px;">
                                    <input type="checkbox" id="contourLayerToggle" disabled>
                                    <span>Show Contour Layer</span>
                                </label>
                                <div class="form-group">
                                    <label for="contourInterval">Contour Interval (meters)</label>
                                    <input type="number" id="contourInterval" class="form-input" value="5" min="1"
                                        step="0.5">
                                </div>

                                <div class="form-group">
                                    <label for="majorInterval">Major Interval (meters)</label>
                                    <input type="number" id="majorInterval" class="form-input" value="25" min="1"
                                        step="1">
                                </div>

                                <h4 style="margin: 15px 0 10px 0; font-size: 0.95rem;">Minor Contours</h4>
                                <div class="contour-style-row">
                                    <div class="form-group" style="margin: 0;">
                                        <label>Color</label>
                                        <input type="color" id="minorContourColor" value="#888888"
                                            style="width: 100%; height: 35px;">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <label>Width</label>
                                        <input type="number" id="minorContourWidth" class="form-input" value="1"
                                            min="0.5" max="5" step="0.5">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <label>Style</label>
                                        <select id="minorContourStyle" class="form-select">
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                            <option value="dotted">Dotted</option>
                                        </select>
                                    </div>
                                </div>

                                <h4 style="margin: 15px 0 10px 0; font-size: 0.95rem;">Major Contours</h4>
                                <div class="contour-style-row">
                                    <div class="form-group" style="margin: 0;">
                                        <label>Color</label>
                                        <input type="color" id="majorContourColor" value="#8b4513"
                                            style="width: 100%; height: 35px;">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <label>Width</label>
                                        <input type="number" id="majorContourWidth" class="form-input" value="2"
                                            min="0.5" max="5" step="0.5">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <label>Style</label>
                                        <select id="majorContourStyle" class="form-select">
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                            <option value="dotted">Dotted</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- Contour Labels Section - ENHANCED -->
                                <div
                                    style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0; margin-top: 12px;">
                                    <label class="terrain-checkbox-option" style="margin-bottom: 12px;">
                                        <input type="checkbox" id="showContourLabels" checked>
                                        <span style="font-weight: 600;">Show Contour Labels</span>
                                    </label>

                                    <div id="contourLabelSettings">
                                        <div class="form-group">
                                            <label for="labelSpacingMeters">
                                                <i class="fas fa-ruler-horizontal"></i> Label Spacing
                                            </label>
                                            <select id="labelSpacingMeters" class="form-select">
                                                <option value="10">Every 10m (Small Parcels)</option>
                                                <option value="20">Every 20m</option>
                                                <option value="50">Every 50m</option>
                                                <option value="100" selected>Every 100m</option>
                                                <option value="200">Every 200m</option>
                                                <option value="500">Every 500m</option>
                                                <option value="1000">Every 1000m</option>
                                                <option value="custom">Custom...</option>
                                            </select>
                                        </div>

                                        <div class="form-group" id="customLabelSpacingWrapper" style="display: none;">
                                            <label for="customLabelSpacing">
                                                <i class="fas fa-edit"></i> Custom Spacing (meters)
                                            </label>
                                            <input type="number" id="customLabelSpacing" class="form-input" min="5"
                                                max="10000" value="100" step="5">
                                        </div>

                                        <div class="form-group">
                                            <label for="maxLabelsPerContour">
                                                <i class="fas fa-hashtag"></i> Max Labels per Contour
                                            </label>
                                            <select id="maxLabelsPerContour" class="form-select">
                                                <option value="1">1 Label</option>
                                                <option value="2">2 Labels</option>
                                                <option value="3" selected>3 Labels</option>
                                                <option value="5">5 Labels</option>
                                            </select>
                                        </div>

                                        <div class="form-group">
                                            <label for="labelFrequency">
                                                <i class="fas fa-filter"></i> Label Frequency
                                            </label>
                                            <select id="labelFrequency" class="form-select">
                                                <option value="1">Every Major Contour</option>
                                                <option value="2" selected>Every 2nd Major Contour</option>
                                                <option value="3">Every 3rd Major Contour</option>
                                                <option value="5">Every 5th Major Contour</option>
                                            </select>
                                        </div>

                                        <label class="terrain-checkbox-option">
                                            <input type="checkbox" id="rotateLabels" checked>
                                            <span>Rotate Labels Along Contours</span>
                                        </label>

                                        <div class="form-group" id="labelFontSizeWrapper">
                                            <label for="labelFontSize">Font Size: <span
                                                    id="labelFontSizeValue">14px</span></label>
                                            <input type="range" id="labelFontSize" min="8" max="16" value="11" step="1">
                                        </div>

                                        <div
                                            style="font-size: 0.8rem; color: #7f8c8d; margin-top: 10px; padding: 8px; background: #fff; border-radius: 4px;">
                                            <i class="fas fa-lightbulb" style="color: #f39c12;"></i> Labels are placed
                                            on straighter sections for better readability
                                        </div>
                                    </div>
                                </div>

                                <!-- Minor Contour Labels -->
                                <div id="minorContourLabelsSection">
                                    <h4 style="margin: 15px 0 10px 0; font-size: 0.95rem;">Minor Contour Labels</h4>

                                    <div
                                        style="background: #fff9e6; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                                        <label class="terrain-checkbox-option">
                                            <input type="checkbox" id="labelMinorContours" checked>
                                            <span>Label Minor Contours</span>
                                        </label>

                                        <div id="minorLabelOptions">
                                            <div class="form-group" style="margin-top: 10px;">
                                                <label for="minorLabelFrequency">Minor Label Frequency</label>
                                                <select id="minorLabelFrequency" class="form-select">
                                                    <option value="1" selected>All Minor Contours</option>
                                                    <option value="2">Every 2nd Minor</option>
                                                    <option value="3">Every 3rd Minor</option>
                                                    <option value="5">Every 5th Minor</option>
                                                    <option value="10">Every 10th Minor</option>
                                                </select>
                                            </div>

                                            <div class="form-group">
                                                <label for="minorLabelFontSize">Minor Font Size: <span
                                                        id="minorLabelFontSizeValue">11px</span></label>
                                                <input type="range" id="minorLabelFontSize" min="9" max="16" value="11"
                                                    step="1">
                                            </div>

                                            <div class="form-group">
                                                <label for="minorLabelColor">Minor Label Color</label>
                                                <input type="color" id="minorLabelColor" value="#666666">
                                            </div>

                                            <div style="font-size: 0.8rem; color: #7f8c8d; margin-top: 10px;">
                                                <i class="fas fa-info-circle"></i> Minor labels use same spacing but
                                                smaller font and lighter color
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Smoothing Options -->
                                <h4 style="margin: 15px 0 10px 0; font-size: 0.95rem;">Contour Generation Method</h4>

                                <label class="terrain-checkbox-option" style="margin-bottom: 12px;">
                                    <input type="checkbox" id="useTINContours" checked>
                                    <span style="font-weight: 600;">Use TIN-based Contours (QGIS Quality)</span>
                                </label>
                                <small
                                    style="color: #7f8c8d; font-size: 11px; display: block; margin-top: -8px; margin-bottom: 12px; padding-left: 24px;">
                                    TIN-based contours are generated directly from coordinates, producing smoother, more
                                    accurate results without crossing artifacts.
                                </small>

                                <h4 style="margin: 15px 0 10px 0; font-size: 0.95rem;">Contour Refinement</h4>

                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="smoothContours" checked>
                                    <span>Apply Smoothing (Chaikin)</span>
                                </label>

                                <div class="range-slider-wrapper" id="smoothIterationsWrapper">
                                    <label>
                                        <span>Smoothing Iterations</span>
                                        <span id="smoothIterationsValue">2</span>
                                    </label>
                                    <input type="range" id="smoothIterations" class="range-slider" min="0" max="5"
                                        value="2" step="1">
                                </div>

                                <label class="terrain-checkbox-option">
                                    <input type="checkbox" id="simplifyContours">
                                    <span>Apply Simplification (Douglas-Peucker)</span>
                                </label>

                                <div class="range-slider-wrapper" id="simplifyToleranceWrapper" style="display: none;">
                                    <label>
                                        <span>Simplification Tolerance</span>
                                        <span id="simplifyToleranceValue">1.0m</span>
                                    </label>
                                    <input type="range" id="simplifyTolerance" class="range-slider" min="0.1" max="5"
                                        value="1" step="0.1">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 8. Terrain Analysis -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="terrain-analysis">
                            <span><i class="fas fa-chart-area"></i> Terrain Analysis</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="terrain-analysis-content">
                            <div class="form-group">
                                <label for="analysisType">Analysis Type</label>
                                <select id="analysisType" class="form-select">
                                    <option value="">Select Analysis...</option>
                                    <option value="slope">Slope Map (Gradient)</option>
                                    <option value="aspect">Aspect Map (Direction)</option>
                                    <option value="curvature">Curvature Map (Shape)</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="analysisUnit">Display Unit</label>
                                <select id="analysisUnit" class="form-select">
                                    <option value="degrees">Degrees</option>
                                    <option value="percent">Percent (%)</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="showAnalysisStats">
                                    Show Statistics Panel
                                </label>
                            </div>

                            <button type="button" class="terrain-btn terrain-btn-info" id="generateAnalysisBtn"
                                style="width: 100%; margin-top: 10px;">
                                <i class="fas fa-calculator"></i> Generate Analysis
                            </button>

                            <label class="terrain-checkbox-option" style="margin-top: 10px;">
                                <input type="checkbox" id="analysisLayerToggle" disabled>
                                <span>Show Analysis Layer</span>
                            </label>

                            <div id="analysisStatsPanel"
                                style="display: none; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                                <h4 style="margin: 0 0 10px 0; font-size: 0.9rem;">Analysis Statistics</h4>
                                <div id="analysisStatsContent"></div>
                            </div>
                        </div>
                    </div>

                    <!-- 9. 3D Export Formats -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="3d-export">
                            <span><i class="fas fa-download"></i> 3D Export</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="3d-export-content">
                            <div class="form-group">
                                <label for="exportVerticalExaggeration">Vertical Exaggeration</label>
                                <input type="number" id="exportVerticalExaggeration" class="form-input" value="1.0"
                                    min="0.1" max="10" step="0.1">
                            </div>

                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px;">
                                <button type="button" class="terrain-btn terrain-btn-secondary" id="exportSTLBtn"
                                    title="Export as STL for 3D printing">
                                    <i class="fas fa-cube"></i> STL
                                </button>
                                <button type="button" class="terrain-btn terrain-btn-secondary" id="exportOBJBtn"
                                    title="Export as OBJ for 3D modeling">
                                    <i class="fas fa-shapes"></i> OBJ
                                </button>
                                <button type="button" class="terrain-btn terrain-btn-secondary" id="exportGeoTIFFBtn"
                                    title="Export as GeoTIFF raster">
                                    <i class="fas fa-map"></i> GeoTIFF
                                </button>
                                <button type="button" class="terrain-btn terrain-btn-secondary" id="exportLASBtn"
                                    title="Export as LAS point cloud">
                                    <i class="fas fa-braille"></i> LAS
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 10. Volume Calculations -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="volume-calcs">
                            <span><i class="fas fa-cubes"></i> Volume Calculations</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="volume-calcs-content">
                            <div class="form-group">
                                <label for="volumeCalcType">Calculation Type</label>
                                <select id="volumeCalcType" class="form-select">
                                    <option value="plane">Volume to Reference Plane</option>
                                    <option value="polygon">Volume in Polygon</option>
                                    <option value="surface">Compare Two Surfaces</option>
                                    <option value="stockpile">Stockpile Volume</option>
                                </select>
                            </div>

                            <div id="volumePlaneInputs" class="form-group">
                                <label for="referencePlaneElevation">Reference Plane Elevation (m)</label>
                                <input type="number" id="referencePlaneElevation" class="form-input" value="0"
                                    step="0.1">
                            </div>

                            <button type="button" class="terrain-btn terrain-btn-warning" id="calculateVolumeBtn"
                                style="width: 100%; margin-top: 10px;">
                                <i class="fas fa-calculator"></i> Calculate Volume
                            </button>

                            <div id="volumeResultsPanel" style="display: none; margin-top: 15px;"></div>
                        </div>
                    </div>

                    <!-- 11. Breaklines -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="breaklines">
                            <span><i class="fas fa-project-diagram"></i> Breaklines</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="breaklines-content">
                            <p style="font-size: 0.85rem; color: #7f8c8d; margin: 0 0 10px 0;">
                                Breaklines enforce sharp edges in terrain (roads, ridges, streams)
                            </p>

                            <div style="margin-bottom: 10px;">
                                <label
                                    style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.85rem;">Breakline
                                    Type:</label>
                                <select id="breaklineTypeSelect" class="form-select"
                                    style="width: 100%; margin-bottom: 10px;">
                                    <option value="road">Road Extent</option>
                                    <option value="river">River Extent</option>
                                    <option value="ridge">Ridge</option>
                                    <option value="stream">Stream</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>

                            <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                                <button type="button" class="terrain-btn terrain-btn-info" id="drawBreaklineBtn"
                                    style="flex: 1;">
                                    <i class="fas fa-pen"></i> Draw
                                </button>
                                <button type="button" class="terrain-btn terrain-btn-info" id="importBreaklineBtn"
                                    style="flex: 1;">
                                    <i class="fas fa-upload"></i> Import
                                </button>
                            </div>

                            <div id="breaklineList" style="max-height: 150px; overflow-y: auto;">
                                <p style="font-size: 0.85rem; color: #95a5a6; text-align: center; padding: 20px 0;">
                                    No breaklines added
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- 12. Terrain Classification -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="terrain-classification">
                            <span><i class="fas fa-layer-group"></i> Terrain Classification</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="terrain-classification-content">
                            <div class="form-group">
                                <label for="classifyType">Classification Type</label>
                                <select id="classifyType" class="form-select">
                                    <option value="basic">Basic Features (Peaks, Valleys, Ridges, Pits)</option>
                                    <option value="advanced">Advanced Features (Passes, Saddles, Planes, Channels)
                                    </option>
                                    <option value="landform">Landform Types (Hills, Mountains, Plains, Depressions)
                                    </option>
                                </select>
                            </div>

                            <button type="button" class="terrain-btn terrain-btn-success" id="classifyTerrainPanelBtn"
                                style="width: 100%; margin-top: 10px;">
                                <i class="fas fa-magic"></i> Classify Terrain
                            </button>

                            <label class="terrain-checkbox-option" style="margin-top: 10px;">
                                <input type="checkbox" id="classificationLayerToggle" disabled>
                                <span>Show Classification Layer</span>
                            </label>

                            <div id="classificationResultsPanel" style="display: none; margin-top: 15px;"></div>
                        </div>
                    </div>

                    <!-- 13. Basemap Settings -->
                    <div class="terrain-3d-section">
                        <div class="terrain-3d-section-header" data-section="basemap-settings">
                            <span><i class="fas fa-map"></i> Basemap Settings</span>
                            <i class="fas fa-chevron-right toggle-icon"></i>
                        </div>
                        <div class="terrain-3d-section-content" id="basemap-settings-content">
                            <div class="terrain-basemap-selector">
                                <label class="basemap-option">
                                    <input type="radio" name="basemap" value="google" id="basemapGoogle">
                                    <span>Google Satellite Hybrid</span>
                                </label>
                                <label class="basemap-option">
                                    <input type="radio" name="basemap" value="esri" id="basemapEsri" checked>
                                    <span>Esri World Imagery</span>
                                </label>
                                <label class="basemap-option">
                                    <input type="radio" name="basemap" value="osm" id="basemapOSM">
                                    <span>OpenStreetMap</span>
                                </label>
                                <label class="basemap-option">
                                    <input type="radio" name="basemap" value="none" id="basemapNone">
                                    <span>None</span>
                                </label>
                            </div>

                            <div class="range-slider-wrapper" id="basemapOpacityWrapper">
                                <label>
                                    <span>Basemap Opacity</span>
                                    <span id="basemapOpacityValue">60%</span>
                                </label>
                                <input type="range" id="basemapOpacity" class="range-slider" min="0" max="100"
                                    value="60" step="5">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 14. Action Buttons -->
                <div class="terrain-action-buttons">
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <button type="button" class="terrain-btn terrain-btn-success" id="generateDTMOnlyBtn"
                            title="Generate DTM Only" style="flex: 1; font-size: 0.85rem; padding: 8px 12px;">
                            <i class="fas fa-mountain"></i> DTM
                        </button>
                        <button type="button" class="terrain-btn terrain-btn-success" id="generateContoursOnlyBtn"
                            title="Generate Contours Only" style="flex: 1; font-size: 0.85rem; padding: 8px 12px;">
                            <i class="fas fa-chart-line"></i> Contours
                        </button>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button type="button" class="terrain-btn terrain-btn-info" id="generateProfileBtn"
                            title="Generate Profile from Alignment"
                            style="flex: 1; font-size: 0.85rem; padding: 8px 12px;">
                            <i class="fas fa-project-diagram"></i> Profile
                        </button>
                        <button type="button" class="terrain-btn terrain-btn-primary" id="saveConfigBtn"
                            title="Save Current Configuration" style="flex: 1; font-size: 0.85rem; padding: 8px 12px;">
                            <i class="fas fa-save"></i> Save Config
                        </button>
                    </div>
                    <button type="button" class="terrain-btn terrain-btn-danger" id="clearTerrainBtn">
                        <i class="fas fa-trash-alt"></i> Clear All
                    </button>
                </div>
            </aside>

            <!-- Profile Generation Panel -->
            <aside id="profile-generation-panel" class="profile-generation-panel">
                <div class="profile-panel-header">
                    <h3><i class="fas fa-project-diagram"></i> Profile Generation</h3>
                    <button id="profile-panel-close" class="profile-panel-close">&times;</button>
                </div>

                <div class="profile-content">
                    <!-- Step 1: Draw Alignment -->
                    <div class="profile-step">
                        <h4>
                            <span class="profile-step-number">1</span>
                            Draw Alignment
                        </h4>
                        <p style="font-size: 0.9rem; margin: 10px 0; color: #7f8c8d;">
                            Click on the map to draw your alignment. Double-click to finish.
                        </p>
                        <button type="button" class="terrain-btn terrain-btn-primary" id="startDrawingBtn"
                            style="width: 100%;">
                            <i class="fas fa-pencil-alt"></i> Start Drawing Alignment
                        </button>
                        <button type="button" class="terrain-btn terrain-btn-warning" id="clearAlignmentBtn"
                            style="width: 100%; margin-top: 8px; display: none;">
                            <i class="fas fa-trash"></i> Clear Alignment
                        </button>
                    </div>

                    <!-- Step 2: Profile Settings -->
                    <div class="profile-step">
                        <h4>
                            <span class="profile-step-number">2</span>
                            Profile Settings
                        </h4>

                        <div class="profile-form-row">
                            <div class="profile-form-group">
                                <label for="samplingInterval">Sampling Interval (m)</label>
                                <input type="number" id="samplingInterval" value="10" min="1" max="100" step="1">
                            </div>
                            <div class="profile-form-group">
                                <label for="stationInterval">Station Interval (m)</label>
                                <input type="number" id="stationInterval" value="50" min="10" max="500" step="10">
                            </div>
                        </div>

                        <div class="profile-checkbox-group">
                            <input type="checkbox" id="showContourCrossings" checked>
                            <label for="showContourCrossings">Show Contour Crossings</label>
                        </div>

                        <div class="profile-checkbox-group">
                            <input type="checkbox" id="showStationMarkers" checked>
                            <label for="showStationMarkers">Show Station Markers</label>
                        </div>

                        <div class="profile-checkbox-group">
                            <input type="checkbox" id="enableCrossSections">
                            <label for="enableCrossSections">Generate Cross Sections</label>
                        </div>

                        <div id="crossSectionInputs" style="display: none; margin-top: 12px;">
                            <div class="profile-form-row">
                                <div class="profile-form-group">
                                    <label for="crossSectionInterval">Cross Section Interval (m)</label>
                                    <input type="number" id="crossSectionInterval" value="50" min="10" max="500"
                                        step="10">
                                </div>
                                <div class="profile-form-group">
                                    <label for="crossSectionWidth">Cross Section Width (m)</label>
                                    <input type="number" id="crossSectionWidth" value="30" min="10" max="100" step="5">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 3: Design Grade (Optional) -->
                    <div class="profile-step">
                        <h4>
                            <span class="profile-step-number">3</span>
                            Design Grade (Optional)
                        </h4>

                        <div class="profile-checkbox-group">
                            <input type="checkbox" id="enableDesignGrade">
                            <label for="enableDesignGrade">Enable Design Grade</label>
                        </div>

                        <div id="designGradeInputs" style="display: none; margin-top: 12px;">
                            <div class="profile-form-row">
                                <div class="profile-form-group">
                                    <label for="designGrade">Grade (%)</label>
                                    <input type="number" id="designGrade" value="0" min="-15" max="15" step="0.1">
                                </div>
                                <div class="profile-form-group">
                                    <label for="designStartElevation">Start Elevation (m)</label>
                                    <input type="number" id="designStartElevation" value="0" step="0.1">
                                </div>
                            </div>

                            <div class="profile-form-row">
                                <div class="profile-form-group">
                                    <label for="sideSlope">Side Slope (H:V)</label>
                                    <input type="number" id="sideSlope" value="2" min="0.5" max="5" step="0.1">
                                    <small style="color: #7f8c8d; font-size: 10px;">Horizontal : Vertical ratio</small>
                                </div>
                                <div class="profile-form-group">
                                    <label for="roadWidth">Road Width (m)</label>
                                    <input type="number" id="roadWidth" value="6" min="2" max="20" step="0.5">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 4: Generate -->
                    <div class="profile-step">
                        <h4>
                            <span class="profile-step-number">4</span>
                            Generate Profile
                        </h4>
                        <button type="button" class="terrain-btn terrain-btn-success" id="generateProfileDataBtn"
                            style="width: 100%;">
                            <i class="fas fa-chart-area"></i> Generate Profile
                        </button>
                    </div>

                    <!-- Profile Display Area -->
                    <div id="profileDisplayArea" class="profile-display-area">
                        <h3 class="profile-section-title">Profile Results</h3>

                        <!-- Statistics -->
                        <div class="profile-stats-grid">
                            <div class="profile-stat-card stat-min">
                                <div class="profile-stat-label">Min Elevation</div>
                                <div class="profile-stat-value" id="profileMinElev">--</div>
                            </div>
                            <div class="profile-stat-card stat-max">
                                <div class="profile-stat-label">Max Elevation</div>
                                <div class="profile-stat-value" id="profileMaxElev">--</div>
                            </div>
                            <div class="profile-stat-card stat-avg">
                                <div class="profile-stat-label">Avg Elevation</div>
                                <div class="profile-stat-value" id="profileAvgElev">--</div>
                            </div>
                        </div>

                        <!-- Cut/Fill Legend -->
                        <div class="cut-fill-legend" id="cutFillLegend" style="display: none;">
                            <div class="legend-item">
                                <div class="legend-color cut"></div>
                                <span>Cut (Excavation)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color fill"></div>
                                <span>Fill (Embankment)</span>
                            </div>
                        </div>

                        <!-- Chart -->
                        <div class="profile-chart-container">
                            <canvas id="profileChart"></canvas>
                        </div>

                        <!-- Cross Sections -->
                        <div id="crossSectionsContainer" style="display: none;">
                            <h3 class="profile-section-title">Cross Sections</h3>
                            <div id="crossSectionCharts" style="max-height: 600px; overflow-y: auto;"></div>
                        </div>

                        <!-- Volumes Table -->
                        <div id="volumesTableContainer" style="display: none;">
                            <h3 class="profile-section-title">Earthwork Volumes</h3>
                            <table class="profile-volume-table">
                                <thead>
                                    <tr>
                                        <th>Item</th>
                                        <th>Volume (m³)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Cut (Excavation)</td>
                                        <td class="volume-cut" id="volumeCut">--</td>
                                    </tr>
                                    <tr>
                                        <td>Fill (Embankment)</td>
                                        <td class="volume-fill" id="volumeFill">--</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Net Balance</strong></td>
                                        <td class="volume-balance" id="volumeBalance">--</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Export Buttons -->
                        <div class="profile-export-buttons">
                            <button class="profile-export-btn export-csv" id="exportCSVBtn">
                                <i class="fas fa-file-csv"></i> Export CSV
                            </button>
                            <button class="profile-export-btn export-pdf" id="exportPDFBtn">
                                <i class="fas fa-file-pdf"></i> Export PDF
                            </button>
                            <button class="profile-export-btn export-dxf" id="exportDXFBtn">
                                <i class="fas fa-file-code"></i> Export DXF
                            </button>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Drawing Mode Indicator -->
            <div id="drawingModeIndicator" class="drawing-mode-indicator" style="display: none;">
                <i class="fas fa-pencil-alt"></i>
                <span>Drawing Alignment... Double-click to finish</span>
            </div>

            <!-- Loading Overlay -->
            <div class="terrain-loading-overlay" id="terrainLoadingOverlay">
                <div class="terrain-loading-content">
                    <div class="terrain-loading-spinner"></div>
                    <div class="terrain-loading-message" id="terrainLoadingMessage">Processing...</div>
                    <div class="terrain-loading-progress" id="terrainLoadingProgress"></div>
                </div>
            </div>

            <!-- GSP.NET UPDATES Left-Side Dock -->
            <aside id="gspnet-updates-dock" class="gspnet-updates-dock" aria-hidden="true">
                <div class="dock-header">
                    <h3><i class="fas fa-database"></i> GSP.NET Updates</h3>
                    <button id="gspnet-updates-close" class="dock-close" aria-label="Close dock">&times;</button>
                </div>

                <div class="dock-body">
                    <!-- 3. CSV Import Section (OLD - not used, keeping for reference) -->
                    <section id="gsp-csv-section-old" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-file-csv"></i> Import CSV (OLD)</h4>
                        <div class="csv-drop-area" id="polygon-csv-drop-area-old"
                            style="border: 2px dashed #ddd; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 10px; background: #f8f9fa; cursor: pointer;">
                            <i class="fas fa-cloud-upload-alt"
                                style="font-size: 2rem; color: #666; margin-bottom: 10px;"></i>
                            <p style="margin: 5px 0;">Drag & Drop CSV file here</p>
                            <p style="margin: 5px 0; font-size: 0.9rem; color: #999;">OR</p>
                            <button type="button" id="polygon-csv-browse-btn-old" class="btn btn-secondary"
                                style="margin-top: 10px;">
                                <i class="fas fa-folder-open"></i> Browse Files
                            </button>
                            <input id="polygon-csv-file-input-old" type="file" accept=".csv" style="display: none;" />
                        </div>
                        <div id="polygon-csv-filename-old"
                            style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85rem; margin-bottom: 10px; text-align: center; color: #999;">
                            No file selected</div>
                        <div id="polygon-csv-status-old" class="status-message"></div>
                    </section>

                    <!-- 4. Plot Points Section -->
                    <section id="gsp-plot-section" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-map-marked-alt"></i> Plot Points</h4>
                        <div id="parcel-selector-container" style="margin-bottom: 10px;">
                            <label for="parcel-selector"
                                style="display: block; margin-bottom: 5px; font-weight: 600;">Select Parcel:</label>
                            <select id="parcel-selector" class="form-select">
                                <option value="">-- Select Parcel --</option>
                            </select>
                        </div>
                        <div id="point-count-display"
                            style="margin-bottom: 10px; padding: 8px; background: #e8f5e9; border-radius: 4px; font-size: 0.9rem;">
                            <strong>Points:</strong> <span id="point-count-value">0</span>
                        </div>
                        <button id="plot-points-btn" class="btn btn-primary" disabled>
                            <i class="fas fa-map-marked-alt"></i> Plot Points on Map
                        </button>
                        <button id="clear-points-btn" class="btn btn-secondary" style="margin-top: 8px; width: 100%;"
                            disabled>
                            <i class="fas fa-eraser"></i> Clear Points
                        </button>
                    </section>

                    <!-- 5. Polygon Creation Section -->
                    <section id="gsp-polygon-section" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-draw-polygon"></i> Create Polygon</h4>
                        <div id="selected-parcel-info"
                            style="margin-bottom: 10px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 0.9rem;">
                            <strong>Selected Parcel:</strong> <span id="selected-parcel-id">None</span>
                        </div>
                        <button id="create-polygon-btn" class="btn btn-success" disabled>
                            <i class="fas fa-magic"></i> Generate Polygon
                        </button>
                        <div id="polygon-validation-results" style="margin-top: 10px;"></div>
                        <div id="polygon-preview-info"
                            style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;">
                            <div><strong>Area:</strong> <span id="polygon-area-display">--</span> hectares</div>
                            <div><strong>Vertices:</strong> <span id="polygon-vertices-display">--</span></div>
                        </div>
                    </section>

                    <!-- 6. Save Section -->
                    <section id="gsp-save-polygon-section" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-save"></i> Save Polygon</h4>
                        <div id="save-summary"
                            style="margin-bottom: 10px; padding: 10px; background: #e3f2fd; border-radius: 4px; font-size: 0.9rem;">
                            <div><strong>Unique ID:</strong> <span id="save-unique-id">--</span></div>
                            <div><strong>Layer:</strong> <span id="save-layer-name">--</span></div>
                            <div><strong>Area:</strong> <span id="save-area">--</span> ha</div>
                        </div>
                        <button id="save-polygon-btn" class="btn btn-primary" disabled>
                            <i class="fas fa-cloud-upload-alt"></i> Save to Database
                        </button>
                        <button id="create-another-btn" class="btn btn-secondary" style="margin-top: 8px; width: 100%;"
                            disabled>
                            <i class="fas fa-plus"></i> Create Another Polygon
                        </button>
                        <div id="save-status" class="status-message" style="margin-top: 10px;"></div>
                    </section>

                    <!-- 2. Layer Selection Section -->
                    <section id="gsp-layer-section" class="dock-section">
                        <h4><i class="fas fa-layer-group"></i> Select Layer for Polygon Import</h4>
                        <div class="layer-radio-group">
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="TITLE TRACTS UTM ZONE 36N">
                                TITLE TRACTS UTM ZONE 36N
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="TITLE TRACTS UTM ZONE 36S">
                                TITLE TRACTS UTM ZONE 36S
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="UNTITLED UTM ZONE 36N">
                                UNTITLED UTM ZONE 36N
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="UNTITLED UTM ZONE 36S">
                                UNTITLED UTM ZONE 36S
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="BLB-UNTITLED">
                                BLB-UNTITLED
                            </label>
                        </div>
                        <div id="layer-info" class="info-box" style="margin-top: 10px; display: none;"></div>
                    </section>

                    <!-- Coordinate System Confirmation Section (OLD - not used) -->
                    <section id="gsp-crs-section-old" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-globe"></i> Coordinate System (OLD)</h4>
                        <select id="polygon-crs-confirm-old" class="form-select">
                            <!-- Will be populated from form data -->
                        </select>
                        <div id="crs-info-old" class="info-box"
                            style="margin-top: 10px; font-size: 0.85rem; color: #666;"></div>
                    </section>

                    <!-- 3. Edit Tools Section -->
                    <section id="gsp-edit-tools" class="dock-section">
                        <h4><i class="fas fa-edit"></i> Edit Tools</h4>
                        <div class="edit-tool-buttons">
                            <button id="edit-start-btn" class="btn btn-success" disabled>
                                <i class="fas fa-play"></i> Start Editing
                            </button>
                            <button id="edit-stop-btn" class="btn btn-danger" disabled>
                                <i class="fas fa-stop"></i> Stop Editing
                            </button>
                        </div>

                        <div class="geometry-type-selector" style="margin-top: 10px;">
                            <p style="margin-bottom: 5px; font-weight: 600;">Geometry Type:</p>
                            <label class="radio-label">
                                <input type="radio" name="geomType" value="Point" checked>
                                <i class="fas fa-map-pin"></i> Point
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="geomType" value="LineString">
                                <i class="fas fa-minus"></i> Line
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="geomType" value="Polygon">
                                <i class="fas fa-draw-polygon"></i> Polygon
                            </label>
                        </div>

                        <div class="snap-controls"
                            style="margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px;">
                            <label class="checkbox-label">
                                <input type="checkbox" id="snap-to-csv" checked>
                                <i class="fas fa-magnet"></i> Snap to CSV Points
                            </label>
                            <div class="tolerance-control" style="margin-top: 8px;">
                                <label style="font-size: 0.85rem;">Tolerance: <span
                                        id="snap-tolerance-display">10</span>px</label>
                                <input type="range" id="snap-tolerance-range" min="1" max="50" value="10"
                                    style="width: 100%;">
                            </div>
                        </div>
                    </section>

                    <!-- 4. Attribute Editor Section -->
                    <section id="gsp-attr-section" class="dock-section">
                        <h4><i class="fas fa-table"></i> Feature Attributes</h4>
                        <div id="attr-form-container" class="attr-form-container">
                            <p class="help-text">Select a feature to edit attributes</p>
                        </div>
                    </section>

                    <!-- 5. Save / Cancel Section -->
                    <section id="gsp-save-section" class="dock-section">
                        <h4><i class="fas fa-save"></i> Commit Changes</h4>
                        <div class="edit-summary" id="edit-summary">
                            <p><strong>Pending changes:</strong></p>
                            <ul>
                                <li>New features: <span id="new-count">0</span></li>
                                <li>Modified features: <span id="modified-count">0</span></li>
                                <li>Deleted features: <span id="deleted-count">0</span></li>
                            </ul>
                        </div>
                        <div class="commit-buttons">
                            <button id="commit-edits-btn" class="btn btn-primary" disabled>
                                <i class="fas fa-cloud-upload-alt"></i> Save to Database
                            </button>
                            <button id="cancel-edits-btn" class="btn btn-secondary" disabled>
                                <i class="fas fa-times"></i> Discard Changes
                            </button>
                        </div>
                        <div id="commit-status" class="status-message"></div>
                    </section>
                </div>
            </aside>

            <!-- Polygon Import Right Panel -->
            <div class="polygon-import-panel" id="polygonImportPanel">
                <div class="polygon-import-panel-header">
                    <h3><i class="fas fa-database"></i> Polygon Import Workflow</h3>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" class="polygon-import-panel-back" id="polygonImportPanelBack"
                            aria-label="Back to project information" title="Back to Project Information">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <button type="button" class="polygon-import-panel-close" id="polygonImportPanelClose"
                            aria-label="Close panel">&times;</button>
                    </div>
                </div>
                <div class="polygon-import-panel-body">
                    <!-- 1. Layer Selection Section -->
                    <section id="gsp-layer-section" class="dock-section" style="margin-bottom: 20px;">
                        <h4><i class="fas fa-layer-group"></i> Select Layer for Polygon Import</h4>
                        <div class="layer-radio-group">
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="TITLE TRACTS UTM ZONE 36N">
                                TITLE TRACTS UTM ZONE 36N
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="TITLE TRACTS UTM ZONE 36S">
                                TITLE TRACTS UTM ZONE 36S
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="UNTITLED UTM ZONE 36N">
                                UNTITLED UTM ZONE 36N
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="UNTITLED UTM ZONE 36S">
                                UNTITLED UTM ZONE 36S
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="polygonLayer" value="BLB-UNTITLED">
                                BLB-UNTITLED
                            </label>
                        </div>
                        <div id="layer-info" class="info-box" style="margin-top: 10px; display: none;"></div>
                    </section>

                    <!-- Coordinate System Confirmation Section -->
                    <section id="gsp-crs-section" class="dock-section" style="margin-bottom: 20px;">
                        <h4><i class="fas fa-globe"></i> Coordinate System</h4>
                        <select id="polygon-crs-confirm" class="form-select">
                            <!-- Will be populated from form data -->
                        </select>
                        <div id="crs-info" class="info-box" style="margin-top: 10px; font-size: 0.85rem; color: #666;">
                        </div>
                    </section>

                    <!-- 2. CSV Import Section -->
                    <section id="gsp-csv-section" class="dock-section" style="margin-bottom: 20px;">
                        <h4><i class="fas fa-file-csv"></i> Import CSV</h4>
                        <div class="csv-drop-area" id="polygon-csv-drop-area"
                            style="border: 2px dashed #ddd; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 10px; background: #f8f9fa; cursor: pointer;">
                            <i class="fas fa-cloud-upload-alt"
                                style="font-size: 2rem; color: #666; margin-bottom: 10px;"></i>
                            <p style="margin: 5px 0;">Drag & Drop CSV file here</p>
                            <p style="margin: 5px 0; font-size: 0.9rem; color: #999;">OR</p>
                            <button type="button" id="polygon-csv-browse-btn" class="btn btn-secondary"
                                style="margin-top: 10px;">
                                <i class="fas fa-folder-open"></i> Browse Files
                            </button>
                            <input id="polygon-csv-file-input" type="file" accept=".csv" style="display: none;" />
                        </div>
                        <div id="polygon-csv-filename"
                            style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85rem; margin-bottom: 10px; text-align: center; color: #999;">
                            No file selected</div>
                        <div id="polygon-csv-status" class="status-message"></div>
                    </section>

                    <!-- 3. Plot Points Section -->
                    <section id="gsp-plot-section" class="dock-section" style="display: none; margin-bottom: 20px;">
                        <h4><i class="fas fa-map-marked-alt"></i> Plot Points</h4>
                        <div id="parcel-selector-container" style="margin-bottom: 10px;">
                            <label for="parcel-selector"
                                style="display: block; margin-bottom: 5px; font-weight: 600;">Select Parcel:</label>
                            <select id="parcel-selector" class="form-select">
                                <option value="">-- Select Parcel --</option>
                            </select>
                        </div>
                        <div id="point-count-display"
                            style="margin-bottom: 10px; padding: 8px; background: #e8f5e9; border-radius: 4px; font-size: 0.9rem;">
                            <strong>Points:</strong> <span id="point-count-value">0</span>
                        </div>
                        <button id="plot-points-btn" class="btn btn-primary" disabled>
                            <i class="fas fa-map-marked-alt"></i> Plot Points on Map
                        </button>
                        <button id="clear-points-btn" class="btn btn-secondary" style="margin-top: 8px; width: 100%;"
                            disabled>
                            <i class="fas fa-eraser"></i> Clear Points
                        </button>
                    </section>

                    <!-- 4. Polygon Creation Section -->
                    <section id="gsp-polygon-section" class="dock-section" style="display: none; margin-bottom: 20px;">
                        <h4><i class="fas fa-draw-polygon"></i> Create Polygon</h4>
                        <div id="selected-parcel-info"
                            style="margin-bottom: 10px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 0.9rem;">
                            <strong>Selected Parcel:</strong> <span id="selected-parcel-id">None</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label
                                style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem; cursor: pointer;">
                                <input type="checkbox" id="skip-self-intersection-check" style="cursor: pointer;">
                                <span>Bypass self-intersection check (for complex polygons)</span>
                            </label>
                        </div>
                        <button id="create-polygon-btn" class="btn btn-success" disabled>
                            <i class="fas fa-magic"></i> Generate Polygon
                        </button>
                        <div id="polygon-validation-results" style="margin-top: 10px;"></div>
                        <div id="polygon-preview-info"
                            style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;">
                            <div><strong>Area:</strong> <span id="polygon-area-display">--</span> hectares</div>
                            <div><strong>Vertices:</strong> <span id="polygon-vertices-display">--</span></div>
                        </div>
                    </section>

                    <!-- 5. Save Section -->
                    <section id="gsp-save-polygon-section" class="dock-section" style="display: none;">
                        <h4><i class="fas fa-save"></i> Save Polygon</h4>
                        <div id="save-summary"
                            style="margin-bottom: 10px; padding: 10px; background: #e3f2fd; border-radius: 4px; font-size: 0.9rem;">
                            <div><strong>Unique ID:</strong> <span id="save-unique-id">--</span></div>
                            <div><strong>Layer:</strong> <span id="save-layer-name">--</span></div>
                            <div><strong>Area:</strong> <span id="save-area">--</span> ha</div>
                        </div>
                        <button id="save-polygon-btn" class="btn btn-primary" disabled>
                            <i class="fas fa-cloud-upload-alt"></i> Save to Database
                        </button>
                        <button id="create-another-btn" class="btn btn-secondary" style="margin-top: 8px; width: 100%;"
                            disabled>
                            <i class="fas fa-plus"></i> Create Another Polygon
                        </button>
                        <div id="save-status" class="status-message" style="margin-top: 10px;"></div>
                    </section>
                </div>
            </div>

            <!-- Parcel Search Right Panel -->
            <div class="parcel-search-panel" id="parcelSearchPanel">
                <div class="parcel-search-panel-header">
                    <h3><i class="fas fa-search"></i> Parcel Search</h3>
                    <button type="button" class="parcel-search-panel-close" id="parcelSearchPanelClose"
                        aria-label="Close panel">&times;</button>
                </div>
                <div class="parcel-search-panel-body">
                    <form id="parcelSearchForm" class="parcel-search-form">
                        <div class="form-group">
                            <label for="parcelSearchDistrict">District</label>
                            <select id="parcelSearchDistrict" name="district" class="form-select">
                                <option value="">All Districts</option>
                                <!-- Will be populated from UGANDA_DISTRICTS -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="parcelSearchUniqueId">Unique Identifier</label>
                            <input type="text" id="parcelSearchUniqueId" name="uniqueId" class="form-input"
                                placeholder="e.g., TT36N-001">
                        </div>

                        <div class="form-group">
                            <label for="parcelSearchClient">Client Name</label>
                            <input type="text" id="parcelSearchClient" name="client" class="form-input"
                                placeholder="Enter client name">
                        </div>

                        <div class="form-group">
                            <label for="parcelSearchProject">Project Name</label>
                            <input type="text" id="parcelSearchProject" name="project" class="form-input"
                                placeholder="Enter project name">
                        </div>

                        <div class="form-group">
                            <label for="parcelSearchSurveyor">Surveyor Name</label>
                            <input type="text" id="parcelSearchSurveyor" name="surveyor" class="form-input"
                                placeholder="Enter surveyor name">
                        </div>

                        <div class="form-group">
                            <label for="parcelSearchLayer">Layer</label>
                            <select id="parcelSearchLayer" name="layer" class="form-select">
                                <option value="">All Layers</option>
                                <option value="TITLE TRACTS UTM ZONE 36N">TITLE TRACTS UTM ZONE 36N</option>
                                <option value="TITLE TRACTS UTM ZONE 36S">TITLE TRACTS UTM ZONE 36S</option>
                                <option value="UNTITLED UTM ZONE 36N">UNTITLED UTM ZONE 36N</option>
                                <option value="UNTITLED UTM ZONE 36S">UNTITLED UTM ZONE 36S</option>
                                <option value="BLB-UNTITLED">BLB-UNTITLED</option>
                            </select>
                        </div>

                        <div class="form-actions">
                            <button type="button" class="upload-btn secondary" id="parcelSearchCancel">Clear</button>
                            <button type="submit" class="upload-btn">
                                <i class="fas fa-search"></i> Search
                            </button>
                        </div>
                    </form>

                    <div id="parcelSearchResults" class="parcel-search-results" style="display: none;">
                        <div class="parcel-results-header">Search Results</div>
                        <div id="parcelResultsTable" class="parcel-results-list"></div>
                    </div>
                </div>
            </div>

            <!-- Parcel Search Modal (OLD - keeping for reference but not used) -->
            <div class="parcel-search-modal" id="parcelSearchModal" style="display: none;">
                <div class="parcel-search-content">
                    <div class="parcel-search-header">
                        <h3><i class="fas fa-search"></i> Parcel Search</h3>
                        <button class="parcel-search-close" id="parcelSearchClose">&times;</button>
                    </div>
                    <div class="parcel-search-body">
                        <form id="parcelSearchForm">
                            <div class="parcel-search-group">
                                <label for="parcelSearchDistrict">District</label>
                                <select id="parcelSearchDistrict" name="district">
                                    <option value="">-- All Districts --</option>
                                    <!-- Will be populated from UGANDA_DISTRICTS -->
                                </select>
                            </div>

                            <div class="parcel-search-group">
                                <label for="parcelSearchUniqueId">Unique Identifier</label>
                                <input type="text" id="parcelSearchUniqueId" name="uniqueId"
                                    placeholder="e.g., TT36N-001">
                            </div>

                            <div class="parcel-search-group">
                                <label for="parcelSearchClient">Client Name</label>
                                <input type="text" id="parcelSearchClient" name="client"
                                    placeholder="Enter client name">
                            </div>

                            <div class="parcel-search-group">
                                <label for="parcelSearchProject">Project Name</label>
                                <input type="text" id="parcelSearchProject" name="project"
                                    placeholder="Enter project name">
                            </div>

                            <div class="parcel-search-group">
                                <label for="parcelSearchSurveyor">Surveyor Name</label>
                                <input type="text" id="parcelSearchSurveyor" name="surveyor"
                                    placeholder="Enter surveyor name">
                            </div>

                            <div class="parcel-search-group">
                                <label for="parcelSearchLayer">Layer</label>
                                <select id="parcelSearchLayer" name="layer">
                                    <option value="">-- All Layers --</option>
                                    <option value="TITLE TRACTS UTM ZONE 36N">TITLE TRACTS UTM ZONE 36N</option>
                                    <option value="TITLE TRACTS UTM ZONE 36S">TITLE TRACTS UTM ZONE 36S</option>
                                    <option value="UNTITLED UTM ZONE 36N">UNTITLED UTM ZONE 36N</option>
                                    <option value="UNTITLED UTM ZONE 36S">UNTITLED UTM ZONE 36S</option>
                                    <option value="BLB-UNTITLED">BLB-UNTITLED</option>
                                </select>
                            </div>

                            <div class="parcel-search-footer">
                                <button type="button" class="parcel-search-btn parcel-search-btn-cancel"
                                    id="parcelSearchCancel">Clear</button>
                                <button type="submit" class="parcel-search-btn parcel-search-btn-submit">
                                    <i class="fas fa-search"></i> Search
                                </button>
                            </div>
                        </form>

                        <div id="parcelSearchResults" class="parcel-search-results" style="display: none;">
                            <h4>Search Results</h4>
                            <div id="parcelResultsTable"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PATCH: Coordinate Search Modal -->
            <div class="coord-search-modal" id="coordSearchModal">
                <div class="coord-search-content">
                    <div class="coord-search-header">
                        <h3><i class="fas fa-search-location"></i> Coordinate Search</h3>
                        <button class="coord-search-close" id="coordSearchClose">&times;</button>
                    </div>
                    <div class="coord-search-body">
                        <div class="coord-search-tabs">
                            <div class="coord-search-tab active" data-tab="manual">Manual Entry</div>
                            <div class="coord-search-tab" data-tab="csv">CSV Upload</div>
                        </div>

                        <!-- Manual Entry Tab -->
                        <div class="coord-search-tab-content active" id="manual-tab">
                            <div class="coord-input-group">
                                <label for="coordCrs">Coordinate Reference System:</label>
                                <select id="coordCrs" class="crs-selector">
                                    <option value="EPSG:32636">WGS84 UTM Zone 36N (Default)</option>
                                    <option value="EPSG:21096">Arc1960 UTM Zone 36N — EPSG:21096</option>
                                    <option value="EPSG:4326">WGS84 Geographic (Lat/Lon) — EPSG:4326</option>
                                </select>
                            </div>

                            <div class="coord-input-row">
                                <div class="coord-input-group">
                                    <label for="coordX">X/Easting/Longitude:</label>
                                    <input type="text" id="coordX" placeholder="Enter X coordinate">
                                </div>
                                <div class="coord-input-group">
                                    <label for="coordY">Y/Northing/Latitude:</label>
                                    <input type="text" id="coordY" placeholder="Enter Y coordinate">
                                </div>
                            </div>

                            <button class="coord-search-btn" id="plotCoordBtn">
                                <i class="fas fa-map-marker-alt"></i> Plot Coordinate
                            </button>
                        </div>

                        <!-- CSV Upload Tab -->
                        <div class="coord-search-tab-content" id="csv-tab">
                            <div class="coord-input-group">
                                <label for="csvCrs">Coordinate Reference System of CSV:</label>
                                <select id="csvCrs" class="crs-selector">
                                    <option value="EPSG:32636">WGS84 UTM Zone 36N (Default)</option>
                                    <option value="EPSG:21096">Arc1960 UTM Zone 36N — EPSG:21096</option>
                                    <option value="EPSG:4326">WGS84 Geographic (Lat/Lon) — EPSG:4326</option>
                                </select>
                            </div>

                            <div class="csv-upload-area" id="csvDropArea">
                                <i class="fas fa-file-csv"
                                    style="font-size: 2rem; color: #666; margin-bottom: 10px;"></i>
                                <p>Drag & Drop CSV file here or <button type="button" id="csvBrowseBtn"
                                        style="background: none; border: none; color: #3498db; text-decoration: underline; cursor: pointer;">browse</button>
                                </p>
                                <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
                            </div>

                            <div class="csv-warning" id="csvWarning">
                                <i class="fas fa-exclamation-triangle" aria-hidden="true"></i>
                                <strong>Warning:</strong> More than 50% of coordinates are outside Uganda bounds (Lon
                                28-36, Lat -3-5).
                                Do you want to continue?
                                <div style="margin-top: 10px;">
                                    <button type="button" id="csvContinueBtn"
                                        style="background: #e74c3c; color: white; border: none; padding: 5px 10px; border-radius: 4px; margin-right: 10px;">Continue</button>
                                    <button type="button" id="csvCancelBtn"
                                        style="background: #95a5a6; color: white; border: none; padding: 5px 10px; border-radius: 4px;">Cancel</button>
                                </div>
                            </div>

                            <button type="button" class="coord-search-btn" id="plotCsvBtn" disabled>
                                <i class="fas fa-upload"></i> Plot CSV Coordinates
                            </button>
                        </div>

                        <!-- Results Section -->
                        <div class="coord-results" id="coordResults">
                            <h4>Search Results</h4>
                            <div class="coord-results-stats" id="coordStats"></div>
                            <table class="coord-results-table" id="coordTable">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>X/Easting</th>
                                        <th>Y/Northing</th>
                                        <th>Latitude</th>
                                        <th>Longitude</th>
                                    </tr>
                                </thead>
                                <tbody id="coordTableBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="coord-search-footer">
                        <button type="button" class="coord-search-btn" id="clearResultsBtn">
                            <i class="fas fa-trash"></i> Clear Results
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- PATCH: Coordinate Search Popup - Split panel modal for coordinate search functionality -->
        <div class="coordinate-search-popup" id="coordinate-search-popup" style="display: none;">
            <div class="coordsearch-popup-content">
                <div class="coordsearch-popup-header">
                    <h3><i class="fas fa-search-location"></i> Coordinate Search</h3>
                    <button type="button" class="coordsearch-close" id="search-popup-close">&times;</button>
                </div>
                <div class="coordsearch-popup-body">
                    <!-- Left Panel: Manual Input -->
                    <div class="coordsearch-panel coordsearch-manual-panel">
                        <h4><i class="fas fa-keyboard"></i> Manual Input</h4>
                        <div class="coordsearch-form-group">
                            <label for="search-manual-crs">Coordinate System:</label>
                            <select id="search-manual-crs" class="coordsearch-select">
                                <option value="EPSG:21096">Arc 1960 / UTM zone 36N — EPSG:21096</option>
                                <option value="EPSG:21036">Arc 1960 / UTM zone 36S — EPSG:21036</option>
                                <option value="EPSG:32636">WGS84 / UTM zone 36N — EPSG:32636</option>
                                <option value="EPSG:32736">WGS84 / UTM zone 36S — EPSG:32736</option>
                                <option value="EPSG:4326">WGS84 (lat/lon) — EPSG:4326</option>
                            </select>
                        </div>
                        <div class="coordsearch-form-group">
                            <label for="search-manual-easting">Easting/Longitude:</label>
                            <input type="text" id="search-manual-easting" class="coordsearch-input"
                                placeholder="Enter easting/longitude">
                        </div>
                        <div class="coordsearch-form-group">
                            <label for="search-manual-northing">Northing/Latitude:</label>
                            <input type="text" id="search-manual-northing" class="coordsearch-input"
                                placeholder="Enter northing/latitude">
                        </div>
                        <button class="coordsearch-btn" id="search-manual-enter">
                            <i class="fas fa-map-marker-alt"></i> Plot Point
                        </button>
                        <div class="coordsearch-status" id="search-manual-status">Ready to plot coordinates</div>
                    </div>

                    <!-- Right Panel: CSV Import -->
                    <div class="coordsearch-panel coordsearch-csv-panel">
                        <h4><i class="fas fa-file-csv"></i> CSV Import</h4>
                        <div class="coordsearch-form-group">
                            <label for="search-csv-crs">Coordinate System:</label>
                            <select id="search-csv-crs" class="coordsearch-select">
                                <option value="EPSG:21096">Arc 1960 / UTM zone 36N — EPSG:21096</option>
                                <option value="EPSG:21036">Arc 1960 / UTM zone 36S — EPSG:21036</option>
                                <option value="EPSG:32636">WGS84 / UTM zone 36N — EPSG:32636</option>
                                <option value="EPSG:32736">WGS84 / UTM zone 36S — EPSG:32736</option>
                                <option value="EPSG:4326">WGS84 (lat/lon) — EPSG:4326</option>
                            </select>
                        </div>
                        <div class="coordsearch-form-group">
                            <label for="search-csv-file">CSV File:</label>
                            <input type="file" id="search-csv-file" class="coordsearch-file" accept=".csv">
                        </div>
                        <div class="coordsearch-form-group">
                            <label class="coordsearch-checkbox-label">
                                <input type="checkbox" id="search-csv-append" class="coordsearch-checkbox">
                                Append to existing points
                            </label>
                        </div>
                        <div class="coordsearch-button-group">
                            <button class="coordsearch-btn" id="search-csv-plot">
                                <i class="fas fa-upload"></i> Plot CSV
                            </button>
                            <button class="coordsearch-btn coordsearch-btn-secondary" id="search-clear-results">
                                <i class="fas fa-trash"></i> Clear Results
                            </button>
                        </div>
                        <div class="coordsearch-status" id="search-csv-status">Select a CSV file to plot coordinates
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- OpenLayers 7.3.0 - Standard build for global ol object -->
        <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/ol-layerswitcher@4.1.0/dist/ol-layerswitcher.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
        <script src="https://unpkg.com/flatgeobuf@4.3.3/dist/flatgeobuf-ol.min.js"></script>
        <!-- FlatGeobuf library - using raw library instead of ol.format.FlatGeobuf -->
        <!-- flatgeobuf-ol versions have issues with ArrayBuffer (expect HTTP range requests) -->
        <!-- So we'll use the raw flatgeobuf library and convert to GeoJSON manually -->
        <!-- Use a UMD build that works with file:// protocol -->
        <script src="https://unpkg.com/@flatgeobuf/flatgeobuf@3.28.2/dist/index.umd.js"></script>
        <script>
            // Expose flatgeobuf library globally after script loads
            window.addEventListener('load', function () {
                setTimeout(function () {
                    // Check various possible global variable names from UMD build
                    if (typeof window.flatgeobuf !== 'undefined') {
                        window.flatgeobufLib = window.flatgeobuf;
                        console.log('[NLIS] FlatGeobuf library loaded from window.flatgeobuf');
                    } else if (typeof window.FlatGeobuf !== 'undefined') {
                        window.flatgeobufLib = window.FlatGeobuf;
                        console.log('[NLIS] FlatGeobuf library loaded from window.FlatGeobuf');
                    } else {
                        // Try to find it in common UMD export patterns
                        const possibleNames = Object.keys(window).filter(k =>
                            k.toLowerCase().includes('flatgeobuf') ||
                            k.toLowerCase().includes('fgb')
                        );
                        if (possibleNames.length > 0) {
                            window.flatgeobufLib = window[possibleNames[0]];
                            console.log('[NLIS] FlatGeobuf library found as:', possibleNames[0]);
                        } else {
                            console.warn('[NLIS] FlatGeobuf library not found in global scope');
                        }
                    }
                }, 1000);
            });
        </script>

        <!-- Turf.js for spatial operations and TIN interpolation -->
        <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

        <!-- D3-delaunay for TIN triangulation (QGIS-quality contours) -->
        <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>

        <!-- D3-contour for contour line generation -->
        <script src="https://cdn.jsdelivr.net/npm/d3-contour@4"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>

        <!-- PapaParse for CSV parsing -->
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
        <!-- GeoTIFF for raster export -->
        <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>

        <!-- Chart.js for profile visualization -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>

        <!-- jsPDF for PDF export -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.6.0/jspdf.plugin.autotable.min.js"></script>

        <script>

            // Toast notification function
            function showToast(message, type = 'info', duration = 5000) {
                const toast = document.getElementById('toastNotification');
                const toastMessage = document.getElementById('toastMessage');

                toast.className = `toast-notification ${type}`;
                toastMessage.textContent = message;
                toast.style.display = 'block';

                setTimeout(() => {
                    toast.style.display = 'none';
                }, duration);
            }

            document.getElementById('toastClose').addEventListener('click', function () {
                document.getElementById('toastNotification').style.display = 'none';
            });

            // PATCH: register authoritative proj4 definitions for WGS84 UTM and Arc1960 BEFORE creating the map/view
            proj4.defs("EPSG:32636", "+proj=utm +zone=36 +datum=WGS84 +units=m +no_defs");
            proj4.defs("EPSG:32736", "+proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs");

            // Arc1960 UTM authoritative (include TOWGS84). Use these values from EPSG registry:
            proj4.defs("EPSG:21096", "+proj=utm +zone=36 +a=6378249.145 +rf=293.465 +towgs84=-160,-6,-302,0,0,0,0 +units=m +no_defs +type=crs");
            proj4.defs("EPSG:21036", "+proj=utm +zone=36 +south +a=6378249.145 +rf=293.465 +towgs84=-160,-6,-302,0,0,0,0 +units=m +no_defs +type=crs");

            if (ol.proj.proj4 && typeof ol.proj.proj4.register === "function") {
                ol.proj.proj4.register(proj4);
            }

            // Projection tests completed successfully

            // Base map layers with crossOrigin: 'anonymous' to fix canvas export issue
            const osmLayer = new ol.layer.Tile({
                title: 'OpenStreetMap',
                type: 'base',
                visible: true,
                source: new ol.source.OSM({ crossOrigin: 'anonymous' })
            });

            const esriSatellite = new ol.layer.Tile({
                title: 'Esri World Imagery',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    attributions: 'Tiles © Esri',
                    crossOrigin: 'anonymous'
                })
            });

            const googleHybrid = new ol.layer.Tile({
                title: 'Google Satellite Hybrid',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
                    attributions: '© Google',
                    crossOrigin: 'anonymous'
                })
            });

            const openTopoMap = new ol.layer.Tile({
                title: 'OpenTopoMap',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://a.tile.opentopomap.org/{z}/{x}/{y}.png',
                    attributions: '© OpenTopoMap',
                    crossOrigin: 'anonymous'
                })
            });

            const openMapSurfer = new ol.layer.Tile({
                title: 'OpenMapSurfer Hillshade',
                type: 'base',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://maps.heigit.org/openmapsurfer/tiles/roads/webmercator/{z}/{x}/{y}.png',
                    attributions: '© OpenMapSurfer',
                    crossOrigin: 'anonymous'
                })
            });

            const noBasemap = new ol.layer.Tile({
                title: 'No Basemap',
                type: 'base',
                visible: false,
                source: null
            });

            // Create terrain layers using reliable free services
            const terrainLayer = new ol.layer.Tile({
                title: '3D Terrain',
                type: 'terrain',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://tile.opentopomap.org/{z}/{x}/{y}.png',
                    attributions: '© OpenTopoMap',
                    crossOrigin: 'anonymous'
                })
            });

            // Removed failed terrain layers: hillshade, contours, srtm

            // Alternative terrain layers using different free services
            const openTopoMapLayer = new ol.layer.Tile({
                title: 'OpenTopoMap Terrain',
                type: 'opentopo',
                visible: false,
                source: new ol.source.XYZ({
                    url: 'https://tile.opentopomap.org/{z}/{x}/{y}.png',
                    attributions: '© OpenTopoMap',
                    crossOrigin: 'anonymous'
                }),
                opacity: 0.9
            });

            // Removed failed terrain effect layer

            // Create base maps group
            const baseMapsGroup = new ol.layer.Group({
                title: 'Base Maps',
                layers: [
                    osmLayer,
                    esriSatellite,
                    googleHybrid,
                    openTopoMap,
                    openMapSurfer,
                    noBasemap
                ]
            });

            // Removed all failed terrain layers: cartoDB, stamen, working, ugandaDEM, alternative

            // Create terrain group (always at bottom) - only working layers
            const terrainGroup = new ol.layer.Group({
                title: 'Terrain & Relief',
                layers: [
                    openTopoMapLayer,
                    terrainLayer
                ]
            });

            // Create the map view
            const view = new ol.View({
                center: ol.proj.fromLonLat([32.0, 1.0]),
                zoom: 7
            });

            // Fit view to Uganda extent
            const ugandaExtent = ol.proj.transformExtent([29.5, -1.5, 35.0, 4.5], 'EPSG:4326', 'EPSG:3857');
            view.fit(ugandaExtent, { size: [window.innerWidth, window.innerHeight], maxZoom: 8 });

            // Define controls
            const controls = [
                new ol.control.Zoom(),
                new ol.control.Rotate(),
                new ol.control.FullScreen(),
                new ol.control.ScaleLine()
            ];

            // Instantiate the map
            const map = new ol.Map({
                target: 'map',
                view: view,
                layers: [baseMapsGroup],
                controls: controls
            });

            // Make map globally accessible
            window.map = map;

            // ========================================
            // 3D TERRAIN DTM & CONTOURS STATE
            // ========================================
            const terrain3DState = {
                // Data Source
                dataSource: 'import', // 'import', 'existing', 'both'
                importedCSV: null,
                importedData: [],
                existingDatasets: [],
                selectedDatasets: [],
                combinedData: [],
                coordinateSystem: 'EPSG:32636',

                // Display Options
                showPoints: true,
                showPointNumbers: true,
                showDescriptions: true,
                pointColor: '#3498db',
                pointSize: 6,

                // DTM Configuration
                interpolationMethod: 'idw', // 'tin', 'idw', 'idw-sharp', 'nearest'
                cellSize: 5, // Grid cell size in meters (reduced for more detail)
                idwPower: 2, // IDW power parameter
                idwMaxDistance: 1000, // Maximum distance for IDW interpolation
                colorRamp: 'elevation', // 'viridis', 'terrain', 'elevation', 'spectral', 'plasma'
                colorScheme: 'elevation', // Legacy, kept for compatibility
                classificationMode: 'auto', // 'auto', 'custom'
                classBreaks: [],
                minElevation: null,
                maxElevation: null,
                hillshadeEnabled: true,
                hillshadeOpacity: 0.5,
                azimuth: 315, // Hillshade sun azimuth (0-360 degrees)
                altitude: 45, // Hillshade sun altitude (0-90 degrees)
                zFactor: 1, // Vertical exaggeration factor
                hillshadeBlend: 'multiply', // 'multiply', 'overlay', 'soft-light'
                multidirectionalHillshade: true, // Use multiple light sources for enhanced 3D effect
                dtmOpacity: 0.8,
                contrast: 0, // Contrast adjustment (-100 to 100)
                brightness: 0, // Brightness adjustment (-100 to 100)

                // Contour Configuration
                contourInterval: 5,
                majorInterval: 25,
                minorContourColor: '#999999',
                minorContourWidth: 0.8,
                minorContourStyle: 'solid',
                majorContourColor: '#8b4513',
                majorContourWidth: 2.5,
                majorContourStyle: 'solid',
                showContourLabels: true,
                labelFrequency: 2,
                labelFontSize: 10,
                useTINContours: true, // Use TIN-based contour generation (QGIS quality)
                smoothContours: true, // Apply enhanced smoothing (Chaikin + Catmull-Rom splines)
                smoothIterations: 3, // Number of smoothing iterations (increased for better quality)
                simplifyContours: false, // Apply Douglas-Peucker simplification
                simplifyTolerance: 1, // Simplification tolerance

                // Grid Data Storage
                gridData: null, // Stores the elevation grid for reuse

                // Basemap
                activeBasemap: 'esri',
                basemapOpacity: 0.6,

                // Layers
                pointsLayer: null,
                dtmLayer: null,
                contourLayer: null,
                datasetPinsLayer: null,
                analysisLayer: null,
                analysisLayerVisible: true,
                dtmLayerVisible: true,
                contourLayerVisible: true,
                classificationLayerVisible: true,
                breaklineLayer: null,
                breaklines: [], // Array of breakline features
                breaklineTypes: {
                    road: { name: 'Road Extent', color: '#FF6B35' },
                    river: { name: 'River Extent', color: '#4A90E2' },
                    ridge: { name: 'Ridge', color: '#8B4513' },
                    stream: { name: 'Stream', color: '#5F9EA0' },
                    other: { name: 'Other', color: '#e74c3c' }
                },
                currentBreaklineType: 'road', // Default type when drawing
                classificationLayer: null,

                // Extent Control
                customExtent: null,              // Polygon feature for extent
                extentLayer: null,               // Layer to display extent
                useCustomExtent: false,          // Whether to filter by extent
                snapToPoints: true,              // Snap vertices to points when drawing
                showExtentMeasurements: true,    // Show distance labels
                showExtentOnMap: true,           // Show/hide extent on map

                // Enhanced Contour Labeling
                labelSpacingMeters: 100,         // Distance between labels (default 100m for small parcels)
                maxLabelsPerContour: 3,          // Max labels per contour
                rotateLabels: true,              // Auto-rotate labels
                labelStraightSectionsOnly: true, // Place labels on straight sections
                minStraightRadius: 500,          // Min curvature radius (meters) for "straight"

                // NEW: Minor Contour Labeling
                labelMinorContours: true,        // Enable minor contour labels
                minorLabelFrequency: 1,          // Label all minor contours (1 = every minor contour)
                minorLabelFontSize: 11,           // Increased for better visibility
                minorLabelColor: '#666666',      // Lighter color for minor labels

                // Processing State
                isProcessing: false,
                lastGeneratedConfig: null,
                lastClassificationResults: null,
                lastVolumeResults: null
            };

            // Make terrain3DState globally accessible
            window.terrain3DState = terrain3DState;

            // ========================================
            // MERGED CSV DATASET CONFIGURATIONS
            // ========================================
            const MERGED_DATASET_CONFIGS = [
                {
                    name: 'UGANDA-36N-ALL',
                    coordinateSystem: 'EPSG:32636',
                    natureFilter: null, // All natures
                    description: 'All data in WGS84 UTM Zone 36N'
                },
                {
                    name: 'UGANDA-36S-ALL',
                    coordinateSystem: 'EPSG:32736',
                    natureFilter: null,
                    description: 'All data in WGS84 UTM Zone 36S'
                },
                {
                    name: 'UGANDA-36N-CONTROL',
                    coordinateSystem: 'EPSG:32636',
                    natureFilter: 'control_points',
                    description: 'Control points in WGS84 UTM Zone 36N'
                },
                {
                    name: 'UGANDA-36S-CONTROL',
                    coordinateSystem: 'EPSG:32736',
                    natureFilter: 'control_points',
                    description: 'Control points in WGS84 UTM Zone 36S'
                },
                {
                    name: 'WGS84-36N-ALL',
                    coordinateSystem: 'EPSG:32636',
                    natureFilter: null,
                    description: 'All data in WGS84 UTM Zone 36N (alternative name)'
                },
                {
                    name: 'WGS84-36S-ALL',
                    coordinateSystem: 'EPSG:32736',
                    natureFilter: null,
                    description: 'All data in WGS84 UTM Zone 36S (alternative name)'
                },
                {
                    name: 'WGS84-GEOGRAPHIC',
                    coordinateSystem: 'EPSG:4326',
                    natureFilter: null,
                    description: 'All data in WGS84 Geographic coordinates'
                }
            ];

            // ========================================
            // PROFILE GENERATION SYSTEM
            // ========================================

            // Profile state management
            const profileState = {
                isDrawing: false,
                drawInteraction: null,
                alignmentFeature: null,
                alignmentLayer: null,
                profileData: [],
                samplingInterval: 10,
                stationInterval: 50,
                designGrade: null,
                designStartElevation: null,
                enableDesignGrade: false,
                sideSlope: 2,
                roadWidth: 6,
                chart: null,
                enableCrossSections: false,
                crossSectionInterval: 50,
                crossSectionWidth: 30,
                crossSectionData: [],
                crossSectionCharts: []
            };

            // Create vector layer for alignment visualization
            const profileVectorSource = new ol.source.Vector();
            const profileVectorLayer = new ol.layer.Vector({
                source: profileVectorSource,
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#3498db',
                        width: 4,
                        lineDash: [10, 10]
                    }),
                    image: new ol.style.Circle({
                        radius: 6,
                        fill: new ol.style.Fill({ color: '#3498db' }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                    })
                }),
                zIndex: 200
            });
            map.addLayer(profileVectorLayer);

            // Start drawing alignment
            function startProfileDrawing() {
                if (profileState.isDrawing) return;

                // Clear any existing alignment
                profileVectorSource.clear();
                profileState.alignmentFeature = null;

                // Create draw interaction
                profileState.drawInteraction = new ol.interaction.Draw({
                    source: profileVectorSource,
                    type: 'LineString',
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: 'rgba(52, 152, 219, 0.8)',
                            width: 4,
                            lineDash: [10, 5]
                        }),
                        image: new ol.style.Circle({
                            radius: 5,
                            fill: new ol.style.Fill({ color: '#3498db' })
                        })
                    })
                });

                map.addInteraction(profileState.drawInteraction);
                profileState.isDrawing = true;

                // Show drawing indicator
                document.getElementById('drawingModeIndicator').style.display = 'flex';
                document.getElementById('startDrawingBtn').disabled = true;

                // Handle draw end
                profileState.drawInteraction.on('drawend', function (event) {
                    profileState.alignmentFeature = event.feature;
                    map.removeInteraction(profileState.drawInteraction);
                    profileState.isDrawing = false;

                    // Hide drawing indicator
                    document.getElementById('drawingModeIndicator').style.display = 'none';
                    document.getElementById('startDrawingBtn').disabled = false;
                    document.getElementById('clearAlignmentBtn').style.display = 'block';

                    showToast('Alignment drawn successfully! Configure settings and generate profile.', 'success');
                });
            }

            // Clear alignment
            function clearAlignment() {
                profileVectorSource.clear();
                profileState.alignmentFeature = null;
                profileState.profileData = [];
                document.getElementById('clearAlignmentBtn').style.display = 'none';
                document.getElementById('profileDisplayArea').classList.remove('visible');

                if (profileState.chart) {
                    profileState.chart.destroy();
                    profileState.chart = null;
                }
            }

            // Generate profile from alignment
            async function generateProfileFromAlignment() {
                if (!profileState.alignmentFeature) {
                    showToast('Please draw an alignment first', 'error');
                    return;
                }

                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first to create a profile', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Generating Profile', 0);

                    // Get alignment geometry
                    const geometry = profileState.alignmentFeature.getGeometry();
                    const coordinates = geometry.getCoordinates();

                    // Sample elevations along the line
                    updateLoadingProgress(20, 'Sampling elevations...');
                    const profileData = await sampleElevationsAlongLine(coordinates);
                    profileState.profileData = profileData;

                    // Calculate statistics
                    updateLoadingProgress(60, 'Calculating statistics...');
                    const stats = calculateProfileStatistics(profileData);

                    // Calculate volumes if design grade is enabled
                    let volumes = null;
                    if (profileState.enableDesignGrade) {
                        updateLoadingProgress(75, 'Calculating cut/fill volumes...');
                        volumes = calculateCutFillVolumes(profileData);
                    }

                    // Display results
                    updateLoadingProgress(90, 'Rendering chart...');
                    displayProfile(profileData, stats, volumes);

                    // Generate cross-sections if enabled
                    if (profileState.enableCrossSections) {
                        updateLoadingProgress(95, 'Generating cross-sections...');
                        const crossSections = await generateCrossSections();
                        profileState.crossSectionData = crossSections;
                        displayCrossSections(crossSections);
                    }

                    // Zoom to alignment extent
                    const extent = geometry.getExtent();
                    map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 1000 });

                    hideLoadingIndicator();
                    showToast('Profile generated successfully!', 'success');

                } catch (error) {
                    console.error('Profile generation error:', error);
                    hideLoadingIndicator();
                    showToast('Failed to generate profile: ' + error.message, 'error');
                }
            }

            // Sample elevations along the line
            async function sampleElevationsAlongLine(coordinates) {
                const samplingInterval = parseFloat(document.getElementById('samplingInterval').value) || 10;
                const stationInterval = parseFloat(document.getElementById('stationInterval').value) || 50;

                const profileData = [];
                let chainage = 0;

                // Sample at regular intervals along the line
                for (let i = 0; i < coordinates.length - 1; i++) {
                    const start = coordinates[i];
                    const end = coordinates[i + 1];

                    const dx = end[0] - start[0];
                    const dy = end[1] - start[1];
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);

                    const numSamples = Math.ceil(segmentLength / samplingInterval);

                    for (let j = 0; j < numSamples; j++) {
                        const fraction = j / numSamples;
                        const x = start[0] + fraction * dx;
                        const y = start[1] + fraction * dy;

                        // Get elevation from DTM grid
                        const elevation = getElevationFromGrid(x, y, terrain3DState.gridData);

                        if (elevation !== null) {
                            // Calculate design elevation if enabled
                            let designElevation = null;
                            if (profileState.enableDesignGrade) {
                                const grade = parseFloat(document.getElementById('designGrade').value) / 100; // Convert % to decimal
                                const startElev = parseFloat(document.getElementById('designStartElevation').value);
                                designElevation = startElev + (chainage * grade);
                            }

                            profileData.push({
                                chainage: chainage,
                                elevation: elevation,
                                designElevation: designElevation,
                                isStation: (Math.abs(chainage % stationInterval) < 0.1)
                            });
                        }

                        chainage += samplingInterval;
                    }
                }

                return profileData;
            }

            // Get elevation from grid using bilinear interpolation
            function getElevationFromGrid(x, y, gridData) {
                if (!gridData || !gridData.grid) {
                    console.error('Invalid gridData:', gridData);
                    return null;
                }

                const { grid, width, height, bounds, cellSize } = gridData;

                // Convert coordinates to grid indices - FIXED: Use correct row calculation
                const col = (x - bounds.minX) / cellSize;
                const row = (y - bounds.minY) / cellSize;  // FIXED: Changed from maxY

                // Check bounds
                if (col < 0 || col >= width - 1 || row < 0 || row >= height - 1) {
                    return null;
                }

                // Get grid cell indices
                const col0 = Math.floor(col);
                const col1 = Math.min(col0 + 1, width - 1);
                const row0 = Math.floor(row);
                const row1 = Math.min(row0 + 1, height - 1);

                // Get elevation values at grid points - FIXED: Use 2D array indexing
                const z00 = grid[row0][col0];
                const z10 = grid[row0][col1];
                const z01 = grid[row1][col0];
                const z11 = grid[row1][col1];

                // Check for null/undefined values
                if (z00 === null || z00 === undefined ||
                    z10 === null || z10 === undefined ||
                    z01 === null || z01 === undefined ||
                    z11 === null || z11 === undefined) {
                    return null;
                }

                // Bilinear interpolation
                const fx = col - col0;
                const fy = row - row0;

                const z0 = z00 * (1 - fx) + z10 * fx;
                const z1 = z01 * (1 - fx) + z11 * fx;
                const z = z0 * (1 - fy) + z1 * fy;

                // Debug logging (can be removed after testing)
                if (Math.random() < 0.001) { // Log 0.1% of samples to avoid spam
                    console.log(`Sampled elevation at (${x.toFixed(1)}, ${y.toFixed(1)}): ${z.toFixed(2)}m`);
                }

                return z;
            }

            // Calculate profile statistics
            function calculateProfileStatistics(data) {
                if (!data || data.length === 0) return {
                    minElev: 0,
                    maxElev: 0,
                    avgElev: 0,
                    totalLength: 0,
                    relief: 0
                };

                const elevations = data.map(d => parseFloat(d.elevation) || 0);
                const minElev = Math.min(...elevations);
                const maxElev = Math.max(...elevations);
                const avgElev = elevations.reduce((a, b) => a + b, 0) / elevations.length;
                const totalLength = parseFloat(data[data.length - 1].chainage) || 0;

                return {
                    minElev: minElev,
                    maxElev: maxElev,
                    avgElev: avgElev,
                    totalLength: totalLength,
                    relief: maxElev - minElev
                };
            }

            // Calculate cut/fill volumes
            function calculateCutFillVolumes(data) {
                if (!profileState.enableDesignGrade) return null;

                const sideSlope = parseFloat(document.getElementById('sideSlope').value);
                const roadWidth = parseFloat(document.getElementById('roadWidth').value);
                const samplingInterval = parseFloat(document.getElementById('samplingInterval').value);

                let cutVolume = 0;
                let fillVolume = 0;

                for (let i = 0; i < data.length - 1; i++) {
                    const current = data[i];
                    const next = data[i + 1];

                    if (current.designElevation === null || next.designElevation === null) continue;

                    // Calculate cut/fill depths
                    const currentDepth = current.elevation - current.designElevation;
                    const nextDepth = next.elevation - next.designElevation;

                    // Calculate cross-sectional areas
                    const currentArea = calculateCrossSectionArea(Math.abs(currentDepth), roadWidth, sideSlope);
                    const nextArea = calculateCrossSectionArea(Math.abs(nextDepth), roadWidth, sideSlope);

                    // Volume = average area * length
                    const avgArea = (currentArea + nextArea) / 2;
                    const volume = avgArea * samplingInterval;

                    if (currentDepth > 0) { // Cut
                        cutVolume += volume;
                    } else { // Fill
                        fillVolume += volume;
                    }
                }

                return {
                    cut: cutVolume.toFixed(2),
                    fill: fillVolume.toFixed(2),
                    balance: (cutVolume - fillVolume).toFixed(2)
                };
            }

            // Calculate cross-section area
            function calculateCrossSectionArea(depth, width, sideSlope) {
                // Trapezoidal cross-section
                // Area = (b + b + 2*s*d) * d / 2 where s is side slope, d is depth, b is width
                const topWidth = width + 2 * sideSlope * depth;
                return (width + topWidth) * depth / 2;
            }

            // Display profile chart and results
            function displayProfile(data, stats, volumes) {
                // Show display area
                document.getElementById('profileDisplayArea').classList.add('visible');

                // Update statistics
                document.getElementById('profileMinElev').textContent = stats.minElev + ' m';
                document.getElementById('profileMaxElev').textContent = stats.maxElev + ' m';
                document.getElementById('profileAvgElev').textContent = stats.avgElev + ' m';

                // Update volumes if available
                if (volumes) {
                    document.getElementById('volumesTableContainer').style.display = 'block';
                    document.getElementById('cutFillLegend').style.display = 'flex';
                    document.getElementById('volumeCut').textContent = volumes.cut + ' m³';
                    document.getElementById('volumeFill').textContent = volumes.fill + ' m³';
                    const balance = parseFloat(volumes.balance);
                    document.getElementById('volumeBalance').textContent =
                        Math.abs(balance).toFixed(2) + ' m³ ' + (balance > 0 ? '(Excess Cut)' : '(Excess Fill)');
                } else {
                    document.getElementById('volumesTableContainer').style.display = 'none';
                    document.getElementById('cutFillLegend').style.display = 'none';
                }

                // Prepare chart data
                const chainages = data.map(d => d.chainage);
                const elevations = data.map(d => d.elevation);

                const datasets = [{
                    label: 'Existing Ground',
                    data: elevations,
                    borderColor: '#2c3e50',
                    backgroundColor: 'rgba(44, 62, 80, 0.1)',
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    borderWidth: 2
                }];

                // Add design grade if enabled
                if (profileState.enableDesignGrade) {
                    const designElevations = data.map(d => d.designElevation);
                    datasets.push({
                        label: 'Design Grade',
                        data: designElevations,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        fill: false,
                        tension: 0,
                        pointRadius: 0,
                        borderWidth: 2,
                        borderDash: [10, 5]
                    });

                    // Add cut/fill areas
                    const cutFillData = data.map(d => {
                        if (d.designElevation === null) return null;
                        return d.elevation > d.designElevation ? d.elevation : d.designElevation;
                    });

                    datasets.push({
                        label: 'Cut Area',
                        data: cutFillData,
                        borderColor: 'transparent',
                        backgroundColor: 'rgba(231, 76, 60, 0.3)',
                        fill: '-1',
                        pointRadius: 0
                    });
                }

                // Destroy existing chart
                if (profileState.chart) {
                    profileState.chart.destroy();
                }

                // Create new chart
                const ctx = document.getElementById('profileChart').getContext('2d');

                // Set canvas size to fit container properly - ensure full data range is visible
                const container = document.querySelector('.profile-chart-container');
                if (container) {
                    const containerWidth = Math.max(container.clientWidth - 30, 800); // Account for padding, min 800px for better visibility
                    const containerHeight = Math.max(container.clientHeight - 30, 450); // Min 450px
                    ctx.canvas.width = containerWidth;
                    ctx.canvas.height = containerHeight;
                }

                profileState.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chainages,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 10,
                                right: 10,
                                bottom: 10,
                                left: 10
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Chainage (m)',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                },
                                // Ensure full range is displayed
                                min: Math.min(...chainages),
                                max: Math.max(...chainages),
                                ticks: {
                                    maxTicksLimit: 20, // More ticks for better visibility
                                    callback: function (value) {
                                        return value.toFixed(0) + ' m';
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Elevation (m)',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Longitudinal Profile',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function (context) {
                                        return 'Chainage: ' + context[0].label + ' m';
                                    },
                                    label: function (context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' m';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Chainage (m)',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Elevation (m)',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            }
                        }
                    }
                });
            }

            // Generate cross sections
            async function generateCrossSections() {
                if (!profileState.alignmentFeature || !terrain3DState.gridData) {
                    return [];
                }

                const geometry = profileState.alignmentFeature.getGeometry();
                const coordinates = geometry.getCoordinates();
                const interval = profileState.crossSectionInterval;
                const width = profileState.crossSectionWidth;

                const crossSections = [];
                let currentChainage = 0;

                // Generate cross-sections at regular intervals along the alignment
                for (let i = 0; i < coordinates.length - 1; i++) {
                    const start = coordinates[i];
                    const end = coordinates[i + 1];

                    const dx = end[0] - start[0];
                    const dy = end[1] - start[1];
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);

                    const numSections = Math.floor(segmentLength / interval);

                    for (let j = 0; j <= numSections; j++) {
                        const fraction = j / Math.max(1, numSections);
                        const x = start[0] + fraction * dx;
                        const y = start[1] + fraction * dy;

                        // Calculate perpendicular direction
                        const perpX = -dy / segmentLength;
                        const perpY = dx / segmentLength;

                        // Sample elevations across the perpendicular line
                        const crossSectionData = [];
                        const sampleCount = 20; // Number of samples across the cross-section

                        for (let k = 0; k <= sampleCount; k++) {
                            const offset = (k / sampleCount - 0.5) * width;
                            const sampleX = x + perpX * offset;
                            const sampleY = y + perpY * offset;

                            const elevation = getElevationFromGrid(sampleX, sampleY, terrain3DState.gridData);

                            if (elevation !== null) {
                                crossSectionData.push({
                                    offset: offset,
                                    elevation: elevation
                                });
                            }
                        }

                        if (crossSectionData.length > 0) {
                            crossSections.push({
                                chainage: currentChainage,
                                data: crossSectionData,
                                centerX: x,
                                centerY: y
                            });
                        }

                        currentChainage += interval;
                    }
                }

                return crossSections;
            }

            // Display cross sections
            function displayCrossSections(crossSections) {
                if (!crossSections || crossSections.length === 0) {
                    document.getElementById('crossSectionsContainer').style.display = 'none';
                    return;
                }

                document.getElementById('crossSectionsContainer').style.display = 'block';
                const container = document.getElementById('crossSectionCharts');
                container.innerHTML = ''; // Clear existing charts

                // Destroy old charts
                profileState.crossSectionCharts.forEach(chart => chart.destroy());
                profileState.crossSectionCharts = [];

                // Create a chart for each cross-section (limit to first 10 for performance)
                const sectionsToShow = Math.min(crossSections.length, 10);

                for (let i = 0; i < sectionsToShow; i++) {
                    const section = crossSections[i];

                    // Create canvas for this cross-section
                    const chartDiv = document.createElement('div');
                    chartDiv.style.cssText = 'background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 15px; margin-bottom: 15px; height: 300px;';

                    const canvas = document.createElement('canvas');
                    canvas.id = `crossSectionChart${i}`;
                    chartDiv.appendChild(canvas);
                    container.appendChild(chartDiv);

                    // Prepare data
                    const offsets = section.data.map(d => d.offset);
                    const elevations = section.data.map(d => d.elevation);

                    // Create chart
                    const ctx = canvas.getContext('2d');
                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: offsets,
                            datasets: [{
                                label: 'Ground Level',
                                data: elevations,
                                borderColor: '#2c3e50',
                                backgroundColor: 'rgba(44, 62, 80, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointRadius: 0,
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: `Cross Section at Chainage ${section.chainage.toFixed(1)}m`,
                                    font: { size: 14, weight: 'bold' }
                                },
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Offset from Centerline (m)',
                                        font: { size: 12 }
                                    },
                                    ticks: {
                                        callback: function (value) {
                                            return value.toFixed(1);
                                        }
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Elevation (m)',
                                        font: { size: 12 }
                                    }
                                }
                            }
                        }
                    });

                    profileState.crossSectionCharts.push(chart);
                }

                if (crossSections.length > sectionsToShow) {
                    const note = document.createElement('p');
                    note.style.cssText = 'text-align: center; color: #7f8c8d; font-style: italic; margin-top: 10px;';
                    note.textContent = `Showing first ${sectionsToShow} of ${crossSections.length} cross-sections. All will be included in exports.`;
                    container.appendChild(note);
                }
            }

            // Export profile to CSV
            function exportProfileCSV() {
                if (!profileState.profileData || profileState.profileData.length === 0) {
                    showToast('No profile data to export', 'error');
                    return;
                }

                let csvContent = '';

                // ===== PROJECT METADATA SECTION =====
                if (currentTerrainProject) {
                    csvContent += '=== PROJECT INFORMATION ===\n';
                    csvContent += `Client,${currentTerrainProject.client}\n`;
                    csvContent += `Project Name,${currentTerrainProject.project_name}\n`;
                    csvContent += `District,${currentTerrainProject.district}\n`;
                    csvContent += `Coordinate System,${currentTerrainProject.coordinate_system}\n`;
                    csvContent += `Surveyor,${currentTerrainProject.surveyor}\n`;
                    csvContent += `Supervisor,${currentTerrainProject.supervisor}\n`;
                    csvContent += `Generated,${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}\n`;
                    csvContent += '\n';
                }

                csvContent += '=== LONGITUDINAL PROFILE ===\n';
                csvContent += 'Chainage (m),Elevation (m)';
                if (profileState.enableDesignGrade) {
                    csvContent += ',Design Elevation (m),Cut/Fill (m),Volume Type\n';
                } else {
                    csvContent += '\n';
                }

                profileState.profileData.forEach(point => {
                    let row = `${point.chainage.toFixed(2)},${point.elevation.toFixed(3)}`;
                    if (profileState.enableDesignGrade && point.designElevation !== null) {
                        const diff = point.elevation - point.designElevation;
                        const type = diff > 0 ? 'Cut' : 'Fill';
                        row += `,${point.designElevation.toFixed(3)},${Math.abs(diff).toFixed(3)},${type}`;
                    }
                    csvContent += row + '\n';
                });

                // Add cross-sections if available
                if (profileState.enableCrossSections && profileState.crossSectionData.length > 0) {
                    csvContent += '\n\n=== CROSS SECTIONS ===\n';

                    profileState.crossSectionData.forEach(section => {
                        csvContent += `\nCross Section at Chainage ${section.chainage.toFixed(2)}m\n`;
                        csvContent += 'Offset from Centerline (m),Elevation (m)\n';
                        section.data.forEach(point => {
                            csvContent += `${point.offset.toFixed(2)},${point.elevation.toFixed(3)}\n`;
                        });
                    });
                }

                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const fileName = `Profile_Data_${new Date().toISOString().slice(0, 10)}.csv`;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);

                showToast('Profile data exported to CSV successfully!', 'success');
            }

            // Export profile to PDF - Redesigned version
            function exportProfilePDF() {
                if (!profileState.profileData || profileState.profileData.length === 0) {
                    showToast('No profile data to export', 'error');
                    return;
                }

                try {
                    const { jsPDF } = window.jspdf;
                    // Use A3 landscape for better profile visibility (420mm x 297mm)
                    const doc = new jsPDF({
                        orientation: 'landscape',
                        unit: 'mm',
                        format: 'a3'
                    });

                    // ===== PAGE 1: TERRAIN ANALYSIS REPORT =====
                    let yPos = 20;

                    // Header with blue background
                    doc.setFillColor(26, 42, 108);
                    doc.rect(0, 0, 297, 40, 'F');

                    // Title
                    doc.setFontSize(24);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text('TERRAIN ANALYSIS REPORT', 15, 25);

                    // Date
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'normal');
                    const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                    doc.text(`Generated: ${dateStr}`, 15, 35);

                    // Reset text color
                    doc.setTextColor(0, 0, 0);
                    yPos = 50;

                    // Project Information Section
                    if (currentTerrainProject) {
                        doc.setFontSize(16);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(26, 42, 108);
                        doc.text('Project Information', 15, yPos);
                        yPos += 10;

                        // Project info table with subtle background (A3 width: 420mm)
                        doc.setFillColor(245, 247, 250);
                        doc.roundedRect(15, yPos, 390, 50, 3, 3, 'F');

                        const metadata = [
                            ['Client:', currentTerrainProject.client || 'N/A'],
                            ['Project Name:', currentTerrainProject.project_name || 'N/A'],
                            ['District:', currentTerrainProject.district || 'N/A'],
                            ['Coordinate System:', currentTerrainProject.coordinate_system || 'N/A'],
                            ['Surveyor:', currentTerrainProject.surveyor || 'N/A'],
                            ['Supervisor:', currentTerrainProject.supervisor || 'N/A']
                        ];

                        doc.setFontSize(10);
                        let rowY = yPos + 8;
                        metadata.forEach(([label, value], idx) => {
                            const col = idx < 3 ? 0 : 1;
                            const x = 20 + (col * 195); // Adjusted for A3 width
                            const y = rowY + (idx % 3) * 14;

                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(44, 62, 80);
                            doc.text(label, x, y);
                            doc.setFont(undefined, 'normal');
                            doc.setTextColor(0, 0, 0);
                            doc.text(value, x + 45, y);
                        });

                        yPos += 60;
                    }

                    // Profile Statistics Section
                    doc.setFontSize(16);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(26, 42, 108);
                    doc.text('Profile Statistics', 15, yPos);
                    yPos += 12;

                    const stats = calculateProfileStatistics(profileState.profileData);

                    if (!stats) {
                        showToast('Unable to calculate profile statistics', 'error');
                        return;
                    }

                    // Enhanced stat boxes
                    const statBoxes = [
                        { label: 'Total Length', value: stats.totalLength.toFixed(2) + ' m', color: [52, 152, 219], icon: '📏' },
                        { label: 'Min Elevation', value: stats.minElev.toFixed(2) + ' m', color: [231, 76, 60], icon: '⬇️' },
                        { label: 'Max Elevation', value: stats.maxElev.toFixed(2) + ' m', color: [46, 204, 113], icon: '⬆️' },
                        { label: 'Relief', value: stats.relief.toFixed(2) + ' m', color: [155, 89, 182], icon: '⛰️' },
                        { label: 'Avg Slope', value: (stats.totalLength > 0 ? (stats.relief / stats.totalLength * 100).toFixed(2) : '0.00') + '%', color: [230, 126, 34], icon: '📐' }
                    ];

                    let xPos = 15;
                    statBoxes.forEach((stat, idx) => {
                        if (idx > 0 && idx % 3 === 0) {
                            xPos = 15;
                            yPos += 35;
                        }

                        doc.setFillColor(stat.color[0], stat.color[1], stat.color[2]);
                        doc.roundedRect(xPos, yPos, 85, 30, 3, 3, 'F');
                        doc.setTextColor(255, 255, 255);
                        doc.setFontSize(9);
                        doc.setFont(undefined, 'normal');
                        doc.text(stat.label, xPos + 5, yPos + 10);
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text(stat.value, xPos + 5, yPos + 22);

                        xPos += 90;
                    });

                    doc.setTextColor(0, 0, 0);
                    yPos += 40;

                    // Terrain Classification Section (if available)
                    if (terrain3DState.classificationLayer || terrain3DState.lastClassificationResults) {
                        doc.setFontSize(16);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(26, 42, 108);
                        doc.text('Terrain Classification', 15, yPos);
                        yPos += 12;

                        // Classification statistics box
                        doc.setFillColor(236, 240, 241);
                        doc.roundedRect(15, yPos, 267, 60, 3, 3, 'F');

                        // Get classification stats
                        let classStats = null;
                        if (terrain3DState.lastClassificationResults?.stats) {
                            classStats = terrain3DState.lastClassificationResults.stats;
                        } else if (terrain3DState.lastClassificationResults?.classification?.stats) {
                            classStats = terrain3DState.lastClassificationResults.classification.stats;
                        } else {
                            // Try to parse from DOM
                            const statsEl = document.getElementById('classificationStats');
                            if (statsEl && statsEl.textContent) {
                                const text = statsEl.textContent;
                                classStats = {};
                                const matches = text.match(/(\w+):\s*([\d.]+)%/g);
                                if (matches) {
                                    matches.forEach(match => {
                                        const parts = match.split(':');
                                        const type = parts[0].trim().toLowerCase();
                                        const percent = parts[1].trim().replace('%', '');
                                        classStats[type] = percent;
                                    });
                                }
                            }
                        }

                        if (classStats) {
                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(44, 62, 80);
                            doc.text('Terrain Type Distribution:', 20, yPos + 10);

                            const colors = {
                                'flat': [144, 238, 144],
                                'gentle': [255, 215, 0],
                                'moderate': [255, 140, 0],
                                'steep': [255, 69, 0],
                                'very_steep': [139, 0, 0]
                            };

                            let classY = yPos + 20;
                            let classX = 20;
                            Object.entries(classStats).forEach(([type, percent], idx) => {
                                if (idx > 0 && idx % 2 === 0) {
                                    classX = 20;
                                    classY += 15;
                                }

                                const color = colors[type] || [200, 200, 200];
                                doc.setFillColor(color[0], color[1], color[2]);
                                doc.rect(classX, classY - 5, 10, 10, 'F');

                                doc.setFont(undefined, 'normal');
                                doc.setTextColor(0, 0, 0);
                                const label = type.charAt(0).toUpperCase() + type.slice(1).replace('_', ' ');
                                doc.text(`${label}: ${percent}%`, classX + 15, classY + 2);

                                classX += 140;
                            });
                        } else {
                            doc.setFontSize(10);
                            doc.setTextColor(127, 140, 141);
                            doc.text('Terrain classification data not available', 20, yPos + 30);
                        }

                        yPos += 70;
                    }

                    // Additional Statistics
                    if (terrain3DState.gridData) {
                        doc.setFontSize(16);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(26, 42, 108);
                        doc.text('Terrain Analysis Details', 15, yPos);
                        yPos += 12;

                        doc.setFillColor(245, 247, 250);
                        doc.roundedRect(15, yPos, 267, 35, 3, 3, 'F');

                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(44, 62, 80);
                        doc.text('Grid Resolution:', 20, yPos + 12);
                        doc.setFont(undefined, 'normal');
                        doc.text((terrain3DState.cellSize || 10) + ' m', 90, yPos + 12);

                        doc.setFont(undefined, 'bold');
                        doc.text('Interpolation Method:', 20, yPos + 25);
                        doc.setFont(undefined, 'normal');
                        const methodName = terrain3DState.interpolationMethod === 'tin' ? 'TIN' :
                            terrain3DState.interpolationMethod === 'idw' ? 'IDW' :
                                terrain3DState.interpolationMethod === 'idw-sharp' ? 'IDW Sharp' : 'Nearest Neighbor';
                        doc.text(methodName, 90, yPos + 25);

                        if (terrain3DState.minElevation !== undefined && terrain3DState.maxElevation !== undefined) {
                            doc.setFont(undefined, 'bold');
                            doc.text('Elevation Range:', 150, yPos + 12);
                            doc.setFont(undefined, 'normal');
                            doc.text(`${terrain3DState.minElevation.toFixed(2)} m - ${terrain3DState.maxElevation.toFixed(2)} m`, 220, yPos + 12);
                        }

                        yPos += 45;
                    }

                    // Footer will be added at the end for all pages

                    // ===== PAGE 2: PROFILE CHART =====
                    doc.addPage();
                    yPos = 20;

                    // Header
                    doc.setFillColor(26, 42, 108);
                    doc.rect(0, 0, 420, 35, 'F'); // A3 width is 420mm
                    doc.setFontSize(20);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text('LONGITUDINAL PROFILE', 15, 25);
                    doc.setTextColor(0, 0, 0);
                    yPos = 45;

                    // Profile Chart (full width on A3 - 420mm x 297mm)
                    const canvas = document.getElementById('profileChart');
                    if (canvas) {
                        // Get actual chart dimensions
                        const chartWidth = canvas.width || 800;
                        const chartHeight = canvas.height || 400;

                        // Calculate dimensions to fit A3 page (landscape: 420mm x 297mm)
                        // Leave margins: 15mm on each side = 390mm width
                        // Leave space for header (45mm) and footer (20mm) = 232mm height available
                        const maxWidth = 390; // mm
                        const maxHeight = 232; // mm

                        // Maintain aspect ratio
                        const aspectRatio = chartWidth / chartHeight;
                        let imgWidth = maxWidth;
                        let imgHeight = imgWidth / aspectRatio;

                        if (imgHeight > maxHeight) {
                            imgHeight = maxHeight;
                            imgWidth = imgHeight * aspectRatio;
                        }

                        // Center the image horizontally
                        const imgX = (420 - imgWidth) / 2;

                        // Export chart at higher resolution for better quality
                        const chartImage = canvas.toDataURL('image/png', 1.0);
                        doc.addImage(chartImage, 'PNG', imgX, yPos, imgWidth, imgHeight);
                        yPos += imgHeight + 10;

                        console.log('Profile chart added to PDF:', imgWidth.toFixed(1), 'x', imgHeight.toFixed(1), 'mm');
                    }

                    // Footer will be added at the end for all pages

                    // Cross-sections on new pages
                    if (profileState.enableCrossSections && profileState.crossSectionData.length > 0) {
                        doc.addPage();
                        yPos = 20;

                        // Header (A3 width)
                        doc.setFillColor(52, 152, 219);
                        doc.rect(0, 0, 420, 30, 'F');
                        doc.setFontSize(20);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(255, 255, 255);
                        doc.text('CROSS SECTIONS', 15, 20);
                        doc.setTextColor(0, 0, 0);
                        yPos = 40;

                        // Footer will be added at the end for all pages

                        // Add up to 6 cross-sections per page
                        const charts = profileState.crossSectionCharts.slice(0, 6);
                        let chartIndex = 0;

                        for (let i = 0; i < charts.length; i++) {
                            if (i > 0 && i % 2 === 0) {
                                yPos += 70;
                                if (yPos > 250) { // A3 height allows more space
                                    doc.addPage();
                                    yPos = 20;

                                    // Footer will be added at the end for all pages
                                }
                            }

                            const xOffset = (i % 2) * 210; // Adjusted for A3 width (420mm / 2 = 210mm)
                            const canvas = charts[i].canvas;
                            const imgData = canvas.toDataURL('image/png', 1.0);

                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.text(`Section at ${profileState.crossSectionData[i].chainage.toFixed(1)}m`, 15 + xOffset, yPos);
                            doc.addImage(imgData, 'PNG', 15 + xOffset, yPos + 5, 180, 90); // Larger images for A3
                        }
                    }

                    // Terrain Analysis Section (if available)
                    if (terrain3DState.gridData && document.getElementById('classificationResultsPanel')?.style.display !== 'none') {
                        doc.addPage();
                        yPos = 20;

                        // Header with gradient background (A3 width)
                        doc.setFillColor(39, 174, 96);
                        doc.rect(0, 0, 420, 35, 'F');
                        doc.setFontSize(20);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(255, 255, 255);
                        doc.text('TERRAIN ANALYSIS', 15, 20);
                        doc.setTextColor(0, 0, 0);
                        yPos = 45;

                        // Analysis Details Box (A3 width)
                        doc.setFillColor(236, 240, 241);
                        doc.roundedRect(15, yPos, 390, 25, 3, 3, 'F');

                        // Footer will be added at the end for all pages

                        const classifyType = document.getElementById('classifyType')?.value || 'basic';
                        const analysisType = document.getElementById('analysisMapType')?.value || 'slope';

                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(44, 62, 80);
                        doc.text('Classification Type:', 20, yPos + 10);
                        doc.setFont(undefined, 'normal');
                        doc.text(classifyType.charAt(0).toUpperCase() + classifyType.slice(1) + ' Features', 70, yPos + 10);

                        doc.setFont(undefined, 'bold');
                        doc.text('Display Unit:', 150, yPos + 10);
                        doc.setFont(undefined, 'normal');
                        doc.text('Meters (m)', 180, yPos + 10);

                        doc.setFont(undefined, 'bold');
                        doc.text('Grid Resolution:', 20, yPos + 20);
                        doc.setFont(undefined, 'normal');
                        doc.text(terrain3DState.cellSize + ' m', 70, yPos + 20);

                        doc.setFont(undefined, 'bold');
                        doc.text('Interpolation Method:', 150, yPos + 20);
                        doc.setFont(undefined, 'normal');
                        const methodName = terrain3DState.interpolationMethod === 'tin' ? 'TIN' :
                            terrain3DState.interpolationMethod === 'idw' ? 'IDW' :
                                terrain3DState.interpolationMethod === 'idw-sharp' ? 'IDW Sharp' : 'Nearest';
                        doc.text(methodName, 200, yPos + 20);

                        yPos += 35;

                        // Statistics Panel
                        const classPanel = document.getElementById('classificationResultsPanel');
                        if (classPanel && classPanel.innerHTML) {
                            doc.setFontSize(14);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(39, 174, 96);
                            doc.text('Feature Statistics', 15, yPos);
                            yPos += 10;

                            // Extract feature counts from the classification results
                            const featureStats = [];
                            if (terrain3DState.lastClassificationResults) {
                                const features = terrain3DState.lastClassificationResults;
                                for (const [featureType, items] of Object.entries(features)) {
                                    if (Array.isArray(items) && items.length > 0) {
                                        featureStats.push({
                                            type: featureType.charAt(0).toUpperCase() + featureType.slice(1),
                                            count: items.length
                                        });
                                    }
                                }
                            }

                            if (featureStats.length > 0) {
                                // Create colorful stat boxes
                                const colors = [
                                    [231, 76, 60], [52, 152, 219], [46, 204, 113],
                                    [155, 89, 182], [241, 196, 15], [230, 126, 34],
                                    [149, 165, 166], [22, 160, 133]
                                ];

                                let boxX = 15;
                                let boxY = yPos;
                                featureStats.forEach((stat, idx) => {
                                    const colorIdx = idx % colors.length;
                                    doc.setFillColor(colors[colorIdx][0], colors[colorIdx][1], colors[colorIdx][2]);
                                    doc.roundedRect(boxX, boxY, 60, 22, 3, 3, 'F');

                                    doc.setTextColor(255, 255, 255);
                                    doc.setFontSize(9);
                                    doc.setFont(undefined, 'normal');
                                    doc.text(stat.type, boxX + 5, boxY + 8);
                                    doc.setFontSize(14);
                                    doc.setFont(undefined, 'bold');
                                    doc.text(stat.count.toString(), boxX + 5, boxY + 17);

                                    boxX += 65;
                                    if (boxX > 230) {
                                        boxX = 15;
                                        boxY += 27;
                                    }
                                });

                                yPos = boxY + 30;
                            }
                        }

                        doc.setTextColor(0, 0, 0);

                        // Add terrain analysis visualization info
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'italic');
                        doc.setTextColor(127, 140, 141);
                        doc.text('Features identified using terrain curvature, slope, and topographic position analysis', 15, yPos);
                    }

                    // Volume Calculations Section (if available)
                    if (document.getElementById('volumeResultsPanel')?.style.display !== 'none') {
                        doc.addPage();
                        yPos = 20;

                        // Header with orange gradient
                        doc.setFillColor(230, 126, 34);
                        doc.rect(0, 0, 297, 35, 'F');
                        doc.setFontSize(20);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(255, 255, 255);
                        doc.text('VOLUME CALCULATIONS', 15, 20);
                        doc.setTextColor(0, 0, 0);
                        yPos = 45;

                        // Calculation Details Box
                        doc.setFillColor(254, 249, 231);
                        doc.roundedRect(15, yPos, 267, 25, 3, 3, 'F');

                        const volumeType = document.getElementById('volumeCalcType')?.value || 'plane';
                        const referencePlane = document.getElementById('referencePlaneElevation')?.value || '0';

                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(44, 62, 80);
                        doc.text('Calculation Type:', 20, yPos + 10);
                        doc.setFont(undefined, 'normal');
                        const volumeTypeName = volumeType === 'plane' ? 'Volume to Reference Plane' :
                            volumeType === 'polygon' ? 'Volume within Polygon' :
                                volumeType === 'surface' ? 'Surface Comparison' : 'Stockpile Volume';
                        doc.text(volumeTypeName, 70, yPos + 10);

                        doc.setFont(undefined, 'bold');
                        doc.text('Reference Plane Elevation:', 20, yPos + 20);
                        doc.setFont(undefined, 'normal');
                        doc.text(referencePlane + ' m', 90, yPos + 20);

                        doc.setFont(undefined, 'bold');
                        doc.text('Display Unit:', 150, yPos + 20);
                        doc.setFont(undefined, 'normal');
                        doc.text('Cubic Meters (m³)', 180, yPos + 20);

                        yPos += 35;

                        // Volume Results Table
                        if (terrain3DState.lastVolumeResults) {
                            doc.setFontSize(14);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(230, 126, 34);
                            doc.text('Calculated Volumes', 15, yPos);
                            yPos += 5;

                            const results = terrain3DState.lastVolumeResults;
                            const tableData = [];

                            for (const [key, value] of Object.entries(results)) {
                                if (key === 'type') continue;
                                const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                                const unit = key.includes('Volume') || key.includes('volume') ? 'm³' :
                                    key.includes('Elevation') || key.includes('elevation') ||
                                        key.includes('Height') || key.includes('height') ? 'm' :
                                        key.includes('tonnage') ? 'tons' :
                                            key.includes('area') || key.includes('Area') ? 'm²' : '';
                                tableData.push([label, value.toString(), unit]);
                            }

                            doc.autoTable({
                                head: [['Parameter', 'Value', 'Unit']],
                                body: tableData,
                                startY: yPos,
                                theme: 'grid',
                                headStyles: {
                                    fillColor: [230, 126, 34],
                                    fontSize: 11,
                                    fontStyle: 'bold',
                                    textColor: [255, 255, 255]
                                },
                                styles: {
                                    fontSize: 10,
                                    cellPadding: 5
                                },
                                columnStyles: {
                                    0: { fontStyle: 'bold', cellWidth: 100 },
                                    1: { halign: 'right', cellWidth: 80 },
                                    2: { halign: 'center', cellWidth: 40 }
                                },
                                alternateRowStyles: {
                                    fillColor: [254, 249, 231]
                                }
                            });

                            yPos = doc.lastAutoTable.finalY + 15;

                            // Add summary boxes for key values
                            if (results.cutVolume && results.fillVolume && results.netVolume) {
                                const summaryBoxes = [
                                    { label: 'Cut Volume', value: results.cutVolume + ' m³', color: [231, 76, 60] },
                                    { label: 'Fill Volume', value: results.fillVolume + ' m³', color: [46, 204, 113] },
                                    { label: 'Net Balance', value: results.netVolume + ' m³', color: [52, 152, 219] }
                                ];

                                let boxX = 15;
                                summaryBoxes.forEach(box => {
                                    doc.setFillColor(box.color[0], box.color[1], box.color[2]);
                                    doc.roundedRect(boxX, yPos, 85, 25, 3, 3, 'F');
                                    doc.setTextColor(255, 255, 255);
                                    doc.setFontSize(9);
                                    doc.text(box.label, boxX + 5, yPos + 8);
                                    doc.setFontSize(12);
                                    doc.setFont(undefined, 'bold');
                                    doc.text(box.value, boxX + 5, yPos + 18);
                                    doc.setFont(undefined, 'normal');
                                    boxX += 90;
                                });
                            }
                        }

                        doc.setTextColor(0, 0, 0);
                    }

                    // Hydrology Analysis Section (if available)
                    if (terrain3DState.lastHydrologyResults) {
                        doc.addPage();
                        yPos = 20;

                        // Header with blue gradient
                        doc.setFillColor(52, 152, 219);
                        doc.rect(0, 0, 420, 35, 'F');
                        doc.setFontSize(20);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(255, 255, 255);
                        doc.text('HYDROLOGY ANALYSIS', 15, 20);
                        doc.setTextColor(0, 0, 0);
                        yPos = 45;

                        const hydrologyResults = terrain3DState.lastHydrologyResults;

                        // Summary Statistics
                        if (hydrologyResults.stats) {
                            doc.setFontSize(16);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(52, 152, 219);
                            doc.text('Summary Statistics', 15, yPos);
                            yPos += 12;

                            doc.setFillColor(236, 240, 241);
                            doc.roundedRect(15, yPos, 390, 40, 3, 3, 'F');

                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(44, 62, 80);

                            if (hydrologyResults.stats.watershedCount) {
                                doc.text('Watersheds Identified:', 20, yPos + 10);
                                doc.setFont(undefined, 'normal');
                                doc.text(hydrologyResults.stats.watershedCount.toString(), 90, yPos + 10);
                            }

                            if (hydrologyResults.stats.totalArea) {
                                doc.setFont(undefined, 'bold');
                                doc.text('Total Area:', 150, yPos + 10);
                                doc.setFont(undefined, 'normal');
                                doc.text(hydrologyResults.stats.totalArea.toFixed(2) + ' m²', 190, yPos + 10);
                            }

                            if (hydrologyResults.watersheds && Array.isArray(hydrologyResults.watersheds)) {
                                doc.setFont(undefined, 'bold');
                                doc.text('Watershed Details:', 20, yPos + 25);
                                yPos += 35;

                                const watershedData = hydrologyResults.watersheds.slice(0, 10).map((ws, idx) => [
                                    (idx + 1).toString(),
                                    (ws.area || 0).toFixed(2) + ' m²',
                                    ws.outlet ? `${ws.outlet[0].toFixed(2)}, ${ws.outlet[1].toFixed(2)}` : 'N/A'
                                ]);

                                if (watershedData.length > 0) {
                                    doc.autoTable({
                                        head: [['#', 'Area', 'Outlet Coordinates']],
                                        body: watershedData,
                                        startY: yPos,
                                        theme: 'grid',
                                        headStyles: {
                                            fillColor: [52, 152, 219],
                                            fontSize: 11,
                                            fontStyle: 'bold',
                                            textColor: [255, 255, 255]
                                        },
                                        styles: {
                                            fontSize: 10,
                                            cellPadding: 5
                                        }
                                    });
                                    yPos = doc.lastAutoTable.finalY + 15;
                                }
                            }
                        } else {
                            doc.setFontSize(10);
                            doc.setTextColor(127, 140, 141);
                            doc.text('Hydrology analysis data not available', 20, yPos + 30);
                        }

                        doc.setTextColor(0, 0, 0);
                    }

                    // Save PDF
                    const fileName = `Profile_Report_${new Date().toISOString().slice(0, 10)}.pdf`;

                    // Add page numbers and footer to all pages (single footer per page)
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.setFontSize(8);
                        doc.setTextColor(127, 140, 141);
                        doc.text(`Page ${i} of ${pageCount}`, 390, 287);
                        doc.text('Generated by Terrain Analysis System of GSP.NET UG', 15, 287);
                    }

                    doc.save(fileName);
                    showToast('Enhanced PDF exported successfully!', 'success');

                } catch (error) {
                    console.error('PDF export error:', error);
                    showToast('Failed to export PDF: ' + error.message, 'error');
                }
            }

            // Export profile to DXF
            function exportProfileDXF() {
                if (!profileState.profileData || profileState.profileData.length === 0) {
                    showToast('No profile data to export', 'error');
                    return;
                }

                // Create basic DXF content
                let dxfContent = '0\nSECTION\n2\nHEADER\n0\nENDSEC\n';
                dxfContent += '0\nSECTION\n2\nENTITIES\n';

                // Add profile line
                for (let i = 0; i < profileState.profileData.length - 1; i++) {
                    const current = profileState.profileData[i];
                    const next = profileState.profileData[i + 1];

                    dxfContent += '0\nLINE\n';
                    dxfContent += '8\nPROFILE\n'; // Layer name
                    dxfContent += `10\n${current.chainage.toFixed(3)}\n`;
                    dxfContent += `20\n${current.elevation.toFixed(3)}\n`;
                    dxfContent += '30\n0.0\n';
                    dxfContent += `11\n${next.chainage.toFixed(3)}\n`;
                    dxfContent += `21\n${next.elevation.toFixed(3)}\n`;
                    dxfContent += '31\n0.0\n';
                }

                // Add design grade line if enabled
                if (profileState.enableDesignGrade) {
                    for (let i = 0; i < profileState.profileData.length - 1; i++) {
                        const current = profileState.profileData[i];
                        const next = profileState.profileData[i + 1];

                        if (current.designElevation !== null && next.designElevation !== null) {
                            dxfContent += '0\nLINE\n';
                            dxfContent += '8\nDESIGN_GRADE\n';
                            dxfContent += `10\n${current.chainage.toFixed(3)}\n`;
                            dxfContent += `20\n${current.designElevation.toFixed(3)}\n`;
                            dxfContent += '30\n0.0\n';
                            dxfContent += `11\n${next.chainage.toFixed(3)}\n`;
                            dxfContent += `21\n${next.designElevation.toFixed(3)}\n`;
                            dxfContent += '31\n0.0\n';
                        }
                    }
                }

                dxfContent += '0\nENDSEC\n0\nEOF\n';

                // Download DXF
                const blob = new Blob([dxfContent], { type: 'application/dxf' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `profile_${new Date().getTime()}.dxf`;
                a.click();
                window.URL.revokeObjectURL(url);

                showToast('Profile exported to DXF successfully!', 'success');
            }

            // Create a graticule layer function for reuse
            function createGraticuleLayer() {
                return new ol.layer.Graticule({
                    strokeStyle: new ol.style.Stroke({
                        color: 'rgba(0,0,0,0.3)',
                        width: 1,
                        lineDash: [4, 4]
                    }),
                    showLabels: true,
                    lonLabelPosition: 1,
                    latLabelPosition: 1,
                    lonLabelStyle: new ol.style.Text({
                        font: '12px Calibri,sans-serif',
                        textBaseline: 'bottom',
                        fill: new ol.style.Fill({
                            color: 'rgba(0,0,0,0.7)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(255,255,255,0.7)',
                            width: 3
                        })
                    }),
                    latLabelStyle: new ol.style.Text({
                        font: '12px Calibri,sans-serif',
                        textAlign: 'end',
                        fill: new ol.style.Fill({
                            color: 'rgba(0,0,0,0.7)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(255,255,255,0.7)',
                            width: 3
                        })
                    })
                });
            }

            // Add graticule to main map
            const graticule = createGraticuleLayer();
            graticule.setMap(map);

            // Define all layers from the provided list (using working SRS codes from 8.html)
            // FlatGeobuf layer configurations from FLATGEOBUF-LAYERS.txt
            const layersData = [
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/arua.nlis.fgb', title: 'Arua NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/gulu.nlis.fgb', title: 'Gulu NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/gulublocks.fgb', title: 'Gulu Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/jinja.nlis.fgb', title: 'Jinja NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/jinjablocks.fgb', title: 'Jinja Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kabale.nlis.fgb', title: 'Kabale NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kabaleblocks.fgb', title: 'Kabale Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kabalore.nlis.fgb', title: 'Kabalore NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kabaloreblocks.fgb', title: 'Kabalore Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kampala.nlsi1.fgb', title: 'Kampala NLSI 1' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kampala.nlsi2.fgb', title: 'Kampala NLSI 2' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kampalablocks.fgb', title: 'Kampala Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kibaale.nlis.fgb', title: 'Kibaale NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/kibaaleblocks.fgb', title: 'Kibaale Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/lira.nlis.fgb', title: 'Lira NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/lirablocks.fgb', title: 'Lira Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/luwero.nlis.fgb', title: 'Luwero NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/luweroblocks.fgb', title: 'Luwero Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/masaka.nlis.fgb', title: 'Masaka NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/masakablocks.fgb', title: 'Masaka Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/masindi.nlis.fgb', title: 'Masindi NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/masindiblocks.fgb', title: 'Masindi Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/mbale.nlis.fgb', title: 'Mbale NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/DGB/flatgeobuf/mbaleblocks.fgb', title: 'Mbale Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mbarara.nlis.fgb', title: 'Mbarara NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mbararablocks.fgb', title: 'Mbarara Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mityana.nlis.fgb', title: 'Mityana NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mityanablocks.fgb', title: 'Mityana Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/moroto.nlis.fgb', title: 'Moroto NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/morotoblock.fgb', title: 'Moroto Block' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mpigi.nlis.fgb', title: 'Mpigi NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/mpigiblocks.fgb', title: 'Mpigi Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson/mukono.nlis1.fgb', title: 'Mukono NLIS 1' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson/mukono.nlis2.fgb', title: 'Mukono NLIS 2' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson/mukono.blocks.fgb', title: 'Mukono Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/protectedareas.fgb', title: 'Protected Areas' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/rukingiri.nlis.fgb', title: 'Rukungiri NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/rukungiriblocks.fgb', title: 'Rukungiri Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/Ssoroti.nlis.fgb', title: 'Soroti NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/sorotiblocks.fgb', title: 'Soroti Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/tororo.nlis.fgb', title: 'Tororo NLIS' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/tororoblocks.fgb', title: 'Tororo Blocks' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/wakiso.nlis1.fgb', title: 'Wakiso NLIS 1' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/wakiso.nlis2.fgb', title: 'Wakiso NLIS 2' },
                { url: 'https://data.geospatialnetworkug.xyz/geojeson2/wakisoblocks.fgb', title: 'Wakiso Blocks' }
            ];

            // Create buffered extent function for FlatGeobuf loading strategy
            function createBufferedExtent(coord) {
                const extent = ol.extent.boundingExtent([coord]);
                const bufferedExtent = ol.extent.buffer(extent, 1000);
                return bufferedExtent;
            }

            // Create FlatGeobuf layers using the EXACT pattern from large.html
            function createBufferedExtent(coord) {
                const extent = ol.extent.boundingExtent([coord]);
                const bufferedExtent = ol.extent.buffer(extent, 1000);
                return bufferedExtent;
            }

            // Create FlatGeobuf layers using newexample.html pattern
            const gspnetLayers = [];
            const layerConfigs = layersData.map(layerData => ({
                name: layerData.title,
                url: layerData.url,
                color: [26, 95, 180, 0.6], // Blue color
                borderColor: [26, 95, 180, 1],
                borderWidth: 2,
                visible: false,
                featureCount: 0
            }));

            // Load each layer like newexample.html
            layerConfigs.forEach(config => {
                const source = new ol.source.Vector();
                const loader = flatgeobuf.createLoader(
                    source,
                    config.url,
                    "EPSG:4326",
                    function (extent) {
                        return [extent];
                    },
                    true // autoLoad
                );
                source.setLoader(loader);

                const layer = new ol.layer.Vector({
                    title: config.name,
                    source: source,
                    style: config.name === 'Protected Areas' ?
                        function (feature) {
                            return getProtectedAreasStyle(feature);
                        } :
                        config.name === 'Mukono Blocks' ?
                            function (feature) {
                                return getMukonoBlocksStyle(feature);
                            } :
                            (config.name.toLowerCase().includes('blocks') || config.name.toLowerCase().includes('block')) ?
                                function (feature) {
                                    return getBlockBoundaryStyle(feature);
                                } :
                                function (feature) {
                                    return getFlatGeobufParcelStyle(feature);
                                },
                    visible: config.visible
                });

                gspnetLayers.push(layer);
            });
            // ========================================
            // SURVEY POLYGONS LAYER GROUP
            // ========================================
            const polygonLayerSources = {};
            const polygonLayers = {};

            // Create vector sources for each polygon layer with bbox loading strategy
            const polygonLayerNames = [
                'TITLE TRACTS UTM ZONE 36N',
                'TITLE TRACTS UTM ZONE 36S',
                'UNTITLED UTM ZONE 36N',
                'UNTITLED UTM ZONE 36S',
                'BLB-UNTITLED'
            ];

            polygonLayerNames.forEach(layerName => {
                const source = new ol.source.Vector({
                    loader: function (extent, resolution, projection) {
                        loadPolygonsForExtent(layerName, extent, projection, source);
                    },
                    strategy: ol.loadingstrategy.bbox
                });

                polygonLayerSources[layerName] = source;

                // Create layer with styling
                const layer = new ol.layer.Vector({
                    title: layerName,
                    source: source,
                    zIndex: 500,
                    style: function (feature) {
                        return getPolygonStyle(feature);
                    },
                    visible: false
                });

                polygonLayers[layerName] = layer;
            });

            // Create layer group
            const surveyPolygonsGroup = new ol.layer.Group({
                title: 'Survey Polygons',
                layers: Object.values(polygonLayers)
            });

            map.addLayer(surveyPolygonsGroup);

            // Define NLIS layer configurations
            // NLIS Layers using newexample.html pattern
            const nlisLayerConfigs = [
                {
                    name: 'KAMPALA BLOCKS',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/KAMPALA%20BLOCKS.fgb',
                        'https://data.geospatialnetworkug.xyz/geojeson2/kampalablocks.fgb'
                    ],
                    color: [38, 162, 105, 0.6], borderColor: [38, 162, 105, 1], borderWidth: 1
                },
                {
                    name: 'WAKISO BLOCKS',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/WAKISO%20BLOCKS.fgb',
                        'https://data.geospatialnetworkug.xyz/geojeson2/wakisoblocks.fgb'
                    ],
                    color: [38, 162, 105, 0.6], borderColor: [38, 162, 105, 1], borderWidth: 1
                },
                {
                    name: 'MPIGI BLOCKS',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/MPIGI%20BLOCKS.fgb'
                    ],
                    color: [38, 162, 105, 0.6], borderColor: [38, 162, 105, 1], borderWidth: 1
                },
                {
                    name: 'MUKONO BLOCKS',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/MUKONO%20BLOCKS.fgb'
                    ],
                    color: [38, 162, 105, 0.6], borderColor: [38, 162, 105, 1], borderWidth: 1
                },
                {
                    name: 'KAMPALA1',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/KAMPALA1.fgb',
                        'https://data.geospatialnetworkug.xyz/geojeson2/kampala.nlsi1.fgb'
                    ],
                    color: [26, 95, 180, 0.6], borderColor: [26, 95, 180, 1], borderWidth: 2
                },
                {
                    name: 'KAMPALA2',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/KAMPALA2.fgb',
                        'https://data.geospatialnetworkug.xyz/geojeson2/kampala.nlsi2.fgb'
                    ],
                    color: [26, 95, 180, 0.6], borderColor: [26, 95, 180, 1], borderWidth: 2
                },
                {
                    name: 'MPIGI',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/MPIGI.fgb'
                    ],
                    color: [26, 95, 180, 0.6], borderColor: [26, 95, 180, 1], borderWidth: 2
                },
                {
                    name: 'WAKISO',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/WAKISO2.fgb',
                        'https://data.geospatialnetworkug.xyz/geojeson2/wakiso.nlis2.fgb'
                    ],
                    color: [26, 95, 180, 0.6], borderColor: [26, 95, 180, 1], borderWidth: 2
                },
                {
                    name: 'MUKONO',
                    urls: [
                        'https://kwssgfanbntfjdclchfi.supabase.co/storage/v1/object/public/uploads/NLIS%20LAYERS/MUKONO2.fgb'
                    ],
                    color: [26, 95, 180, 0.6], borderColor: [26, 95, 180, 1], borderWidth: 2
                }
            ];



            // NLIS Polygon style function (similar to Survey Polygons)
            function getNlisPolygonStyle(feature) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    return [];
                }

                const coordinates = geometry.getCoordinates()[0];
                const styles = [];

                // Base stroke style with white buffer (two strokes layered)
                // Bottom layer: white stroke (wider for buffer effect)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ffffff',
                        width: 4,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // Top layer: black stroke (narrower)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000',
                        width: 2,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                    // No fill as specified
                }));

                // Get map resolution for corner circles (1 meter radius scaled by resolution)
                const view = map.getView();
                const resolution = view.getResolution();
                const radiusInPixels = resolution ? (1 / resolution) : 3;
                const circleRadius = Math.max(2, Math.min(10, radiusInPixels));

                // Haversine distance function (for WGS84 coordinates)
                function haversineDistance(lon1, lat1, lon2, lat2) {
                    const R = 6371000; // Earth radius in meters
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a =
                        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    return R * c;
                }

                // Transform coordinates from Web Mercator to WGS84 for accurate distance calculation
                const wgs84Coords = coordinates.map(coord => {
                    return ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
                });

                // Add distance labels for each edge (same as Survey Polygons)
                for (let i = 0; i < wgs84Coords.length - 1; i++) {
                    const p1 = wgs84Coords[i];
                    const p2 = wgs84Coords[i + 1];

                    // Calculate distance using Haversine (accurate for WGS84)
                    const distanceMeters = haversineDistance(p1[0], p1[1], p2[0], p2[1]);

                    // Use LineString geometry for automatic text alignment along the edge
                    const p1Merc = coordinates[i];
                    const p2Merc = coordinates[i + 1];
                    const edgeLine = new ol.geom.LineString([p1Merc, p2Merc]);

                    styles.push(new ol.style.Style({
                        text: new ol.style.Text({
                            text: `${distanceMeters.toFixed(2)} m`,
                            font: '12px sans-serif',
                            fill: new ol.style.Fill({ color: '#333' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                            offsetY: -10, // Offset perpendicular to line
                            placement: 'line', // Automatically aligns text along the line
                            textAlign: 'center',
                            textBaseline: 'middle',
                            overflow: true,
                            maxAngle: Math.PI / 4 // Only show text if line is not too steep
                        }),
                        geometry: edgeLine // Use line geometry instead of point
                    }));
                }

                // Add 1-meter radius circles at every corner (vertex) - same as Survey Polygons
                for (let i = 0; i < coordinates.length - 1; i++) { // Exclude closing point
                    styles.push(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: circleRadius, // 1 meter in pixels (scaled by resolution)
                            fill: new ol.style.Fill({ color: '#000000' }), // Black fill
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White stroke for visibility
                                width: 1.5
                            })
                        }),
                        geometry: new ol.geom.Point(coordinates[i])
                    }));
                }

                return styles;
            }

            // Special styling for Mukono Blocks (uses Number_ attribute for labeling)
            function getMukonoBlocksStyle(feature) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    return [];
                }

                const numberAttr = feature.get('Number_'); // Use Number_ attribute for Mukono Blocks
                const styles = [];

                // 1. MAIN POLYGON STYLING: Simple bluish transparent fill, black stroke with white buffer
                // Bottom layer: white stroke (wider for buffer effect)
                styles.push(new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: 'rgba(52, 152, 219, 0.15)' // Light bluish transparent fill
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#ffffff', // White buffer
                        width: 3,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // Top layer: black stroke (narrower)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000', // Black stroke
                        width: 1.5,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // 2. POLYGON LABEL: Black text with white buffer using Number_ attribute
                const labelText = numberAttr ? numberAttr.toString() : null;
                if (labelText) {
                    // Calculate polygon centroid for label placement
                    const centroid = ol.extent.getCenter(geometry.getExtent());

                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(centroid),
                        text: new ol.style.Text({
                            text: labelText,
                            font: '11px sans-serif',
                            fill: new ol.style.Fill({ color: '#000000' }), // Black text
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White buffer
                                width: 2
                            }),
                            textAlign: 'center',
                            textBaseline: 'middle',
                            offsetY: 0
                        })
                    }));
                }

                // Note: No survey markers or distance measurements for block boundaries
                // as requested - this distinguishes them from survey parcels

                return styles;
            }

            // Special styling for Block layers (administrative boundaries)
            function getBlockBoundaryStyle(feature) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    return [];
                }

                const nlisId = feature.get('nlis_id'); // Use the normalized nlis_id attribute if available
                const styles = [];

                // 1. MAIN POLYGON STYLING: Simple bluish transparent fill, black stroke with white buffer
                // Bottom layer: white stroke (wider for buffer effect)
                styles.push(new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: 'rgba(52, 152, 219, 0.15)' // Light bluish transparent fill
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#ffffff', // White buffer
                        width: 3,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // Top layer: black stroke (narrower)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000', // Black stroke
                        width: 1.5,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // 2. POLYGON LABEL: Black text with white buffer using nlis_id (if available)
                // Unlike parcel style, we accept features without nlis_id for block boundaries
                const labelText = nlisId ? nlisId.toString() : null;
                if (labelText) {
                    // Calculate polygon centroid for label placement
                    const centroid = ol.extent.getCenter(geometry.getExtent());

                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(centroid),
                        text: new ol.style.Text({
                            text: labelText,
                            font: '11px sans-serif',
                            fill: new ol.style.Fill({ color: '#000000' }), // Black text
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White buffer
                                width: 2
                            }),
                            textAlign: 'center',
                            textBaseline: 'middle',
                            offsetY: 0
                        })
                    }));
                }

                // Note: No survey markers or distance measurements for block boundaries
                // as requested - this distinguishes them from survey parcels

                return styles;
            }

            // Special styling for Protected Areas layer
            function getProtectedAreasStyle(feature) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    return [];
                }

                const nlisId = feature.get('nlis_id'); // Use the normalized nlis_id attribute
                const styles = [];

                // 1. MAIN POLYGON STYLING: Light transparent red fill, black stroke with white buffer
                // Bottom layer: white stroke (wider for buffer effect)
                styles.push(new ol.style.Style({
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 0, 0, 0.1)' // Very light transparent red fill
                    }),
                    stroke: new ol.style.Stroke({
                        color: '#ffffff', // White buffer
                        width: 4,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // Top layer: black stroke (narrower)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000', // Black stroke
                        width: 2,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // 2. POLYGON LABEL: Black text with white buffer using nlis_id
                if (nlisId) {
                    // Calculate polygon centroid for label placement
                    const centroid = ol.extent.getCenter(geometry.getExtent());

                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(centroid),
                        text: new ol.style.Text({
                            text: nlisId.toString(),
                            font: 'bold 12px sans-serif',
                            fill: new ol.style.Fill({ color: '#000000' }), // Black text
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White buffer
                                width: 3
                            }),
                            textAlign: 'center',
                            textBaseline: 'middle',
                            offsetY: 0
                        })
                    }));
                }

                // Note: No survey markers or distance measurements for protected areas
                // as requested - this distinguishes them from survey parcels

                return styles;
            }

            // NLIS Layers infrastructure
            const nlisLayers = {};

            // Create vector sources and layers for each NLIS layer
            nlisLayerConfigs.forEach(config => {
                // Use bbox strategy like original implementation to ensure all data loads
                const source = new ol.source.Vector({
                    strategy: ol.loadingstrategy.bbox
                });

                // Create custom loader that tries multiple URLs
                const loader = function (extent, resolution, projection) {
                    // Only load if not already loaded
                    if (source.getFeatures().length > 0) {
                        return; // Already loaded
                    }

                    const urls = config.urls || [config.url];
                    let urlIndex = 0;

                    const tryNextUrl = () => {
                        if (urlIndex >= urls.length) {
                            console.error(`Failed to load ${config.name} from all URLs`);
                            return;
                        }

                        const url = urls[urlIndex];
                        urlIndex++;

                        console.log(`Loading ${config.name} from ${url}...`);
                        try {
                            flatgeobuf.createLoader(source, url, "EPSG:4326", () => [extent], true);
                        } catch (error) {
                            console.warn(`Failed to load ${config.name} from ${url}:`, error);
                            tryNextUrl(); // Try next URL
                        }
                    };

                    tryNextUrl();
                };

                source.setLoader(loader);

                // Create layer with styling
                const layer = new ol.layer.Vector({
                    title: config.name,
                    source: source,
                    zIndex: 10000, // Much higher than basemaps
                    minResolution: 76.4, // Only show at zoom level 10 or higher
                    style: function (feature) {
                        return getNlisPolygonStyle(feature);
                    },
                    visible: false // Hidden by default, visible when toggled in layer switcher
                });

                nlisLayers[config.name] = layer;
            });

            // Create NLIS Layers group (same pattern as Survey Polygons)
            const nlisLayersGroup = new ol.layer.Group({
                title: 'NLIS LAYERS',
                layers: Object.values(nlisLayers),
                zIndex: 1000 // Above base maps (which have zIndex: 1)
            });

            // Create GSPNET Layer Group
            const gspnetLayerGroup = new ol.layer.Group({
                title: 'GSPNET LAYERS',
                layers: gspnetLayers,
                zIndex: 900 // Below NLIS layers but above base maps
            });

            // Add layer groups to map
            map.addLayer(gspnetLayerGroup);

            // Extent-based loading function
            let polygonLoadCache = {};
            let polygonLoadDebounce = null;

            async function loadPolygonsForExtent(layerName, extent, projection, source) {
                // Debounce to avoid too many requests
                if (polygonLoadDebounce) {
                    clearTimeout(polygonLoadDebounce);
                }

                polygonLoadDebounce = setTimeout(async () => {
                    try {
                        // Transform extent from map projection to WGS84
                        const bottomLeft = ol.proj.transform([extent[0], extent[1]], projection, 'EPSG:4326');
                        const topRight = ol.proj.transform([extent[2], extent[3]], projection, 'EPSG:4326');

                        // Create cache key
                        const cacheKey = `${layerName}_${Math.floor(extent[0] / 1000)}_${Math.floor(extent[1] / 1000)}_${Math.floor(extent[2] / 1000)}_${Math.floor(extent[3] / 1000)}`;

                        // Check cache
                        if (polygonLoadCache[cacheKey]) {
                            return;
                        }

                        // Query Supabase with bounding box
                        // Note: Supabase PostGIS functions may need to be enabled
                        // Using client-side filtering for now
                        const { data, error } = await supabase
                            .from('polygon_features')
                            .select('*')
                            .eq('layer_name', layerName)
                            .eq('is_archived', false);

                        if (error) {
                            console.error('Error loading polygons:', error);
                            return;
                        }

                        if (!data || data.length === 0) {
                            polygonLoadCache[cacheKey] = true;
                            return;
                        }

                        // Filter by extent (client-side)
                        const format = new ol.format.GeoJSON();
                        const features = [];

                        data.forEach(polygon => {
                            try {
                                // Parse geometry from database
                                const geom = polygon.geometry;
                                if (!geom || !geom.coordinates) return;

                                // Check if polygon intersects extent
                                const coords = geom.coordinates[0];
                                let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;

                                coords.forEach(coord => {
                                    minLon = Math.min(minLon, coord[0]);
                                    maxLon = Math.max(maxLon, coord[0]);
                                    minLat = Math.min(minLat, coord[1]);
                                    maxLat = Math.max(maxLat, coord[1]);
                                });

                                // Check intersection
                                if (maxLon < bottomLeft[0] || minLon > topRight[0] ||
                                    maxLat < bottomLeft[1] || minLat > topRight[1]) {
                                    return; // Outside extent
                                }

                                // Create feature
                                const feature = format.readFeature({
                                    type: 'Feature',
                                    geometry: geom,
                                    properties: {
                                        unique_id: polygon.unique_id,
                                        layer_name: polygon.layer_name,
                                        client: polygon.client,
                                        project_name: polygon.project_name,
                                        district: polygon.district,
                                        county: polygon.county,
                                        block_number: polygon.block_number,
                                        plot_number: polygon.plot_number,
                                        surveyor: polygon.surveyor,
                                        supervisor: polygon.supervisor,
                                        company: polygon.company,
                                        coordinate_system: polygon.coordinate_system,
                                        additional_info: polygon.additional_info,
                                        area_hectares: polygon.area_hectares,
                                        num_vertices: polygon.num_vertices,
                                        edge_distances: polygon.edge_distances || null, // Include stored edge distances
                                        csv_file_id: polygon.csv_file_id,
                                        created_at: polygon.created_at
                                    }
                                }, {
                                    dataProjection: 'EPSG:4326',
                                    featureProjection: projection
                                });

                                features.push(feature);
                            } catch (e) {
                                console.warn('Error processing polygon:', e);
                            }
                        });

                        // Add features to source
                        if (features.length > 0) {
                            source.addFeatures(features);
                            polygonLoadCache[cacheKey] = true;
                            console.log(`Loaded ${features.length} polygons for ${layerName}`);
                        }

                    } catch (error) {
                        console.error('Error in loadPolygonsForExtent:', error);
                    }
                }, 350); // Debounce 350ms
            }

            // Polygon style function
            // Professional FlatGeobuf Parcel Styling Function
            function getFlatGeobufParcelStyle(feature) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    return [];
                }

                const nlisId = feature.get('nlis_id'); // Use the normalized nlis_id attribute
                const coordinates = geometry.getCoordinates()[0];
                const styles = [];

                // 1. MAIN POLYGON STYLING: No fill, black stroke with white buffer
                // Bottom layer: white stroke (wider for buffer effect)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ffffff', // White buffer
                        width: 4,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                }));

                // Top layer: black stroke (narrower)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000', // Black stroke
                        width: 2,
                        lineCap: 'round',
                        lineJoin: 'round'
                    })
                    // No fill as specified
                }));

                // 2. POLYGON LABEL: Black text with white buffer using nlis_id (if available)
                // Unlike block boundaries, parcel layers should still try to label with nlis_id when available
                if (nlisId) {
                    // Calculate polygon centroid for label placement
                    const centroid = ol.extent.getCenter(geometry.getExtent());

                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(centroid),
                        text: new ol.style.Text({
                            text: nlisId.toString(),
                            font: 'bold 12px sans-serif',
                            fill: new ol.style.Fill({ color: '#000000' }), // Black text
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White buffer
                                width: 3
                            }),
                            textAlign: 'center',
                            textBaseline: 'middle',
                            offsetY: 0
                        })
                    }));
                }

                // 3. SURVEY MARKERS: 1 meter red circles with black dots at corners
                // Get map resolution for accurate 1-meter sizing
                const view = map.getView();
                const resolution = view.getResolution();
                const radiusInPixels = resolution ? (1 / resolution) : 3; // 1 meter in pixels
                const circleRadius = Math.max(3, Math.min(12, radiusInPixels)); // Clamp to reasonable size

                // Add markers at each corner (excluding closing point)
                for (let i = 0; i < coordinates.length - 1; i++) {
                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(coordinates[i]),
                        image: new ol.style.Circle({
                            radius: circleRadius,
                            fill: new ol.style.Fill({
                                color: '#ff0000' // Red fill
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#000000', // Black stroke
                                width: 1.5
                            })
                        })
                    }));

                    // Add black dot in center of red circle for survey marker effect
                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(coordinates[i]),
                        image: new ol.style.Circle({
                            radius: Math.max(1, circleRadius / 4), // Smaller black dot
                            fill: new ol.style.Fill({
                                color: '#000000' // Black dot
                            })
                        })
                    }));
                }

                // 4. DISTANCE LABELS: Corner-to-corner measurements along polygon edges
                // Transform coordinates to WGS84 for accurate distance calculation
                const wgs84Coords = coordinates.map(coord => {
                    return ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
                });

                // Haversine distance function for accurate measurements
                function haversineDistance(lon1, lat1, lon2, lat2) {
                    const R = 6371000; // Earth radius in meters
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a =
                        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    return R * c;
                }

                // Add distance labels along each edge
                for (let i = 0; i < wgs84Coords.length - 1; i++) {
                    const p1 = wgs84Coords[i];
                    const p2 = wgs84Coords[i + 1];

                    // Calculate distance using Haversine formula
                    const distanceMeters = haversineDistance(p1[0], p1[1], p2[0], p2[1]);

                    // Create LineString geometry for automatic text alignment
                    const p1Merc = coordinates[i];
                    const p2Merc = coordinates[i + 1];
                    const edgeLine = new ol.geom.LineString([p1Merc, p2Merc]);

                    styles.push(new ol.style.Style({
                        text: new ol.style.Text({
                            text: `${distanceMeters.toFixed(2)} m`,
                            font: '11px sans-serif',
                            fill: new ol.style.Fill({ color: '#000000' }), // Black text
                            stroke: new ol.style.Stroke({
                                color: '#ffffff', // White buffer
                                width: 2
                            }),
                            offsetY: -8, // Offset perpendicular to line
                            placement: 'line', // Automatically aligns text along the line
                            textAlign: 'center',
                            textBaseline: 'middle',
                            overflow: true,
                            maxAngle: Math.PI / 4 // Only show text if line is not too steep
                        }),
                        geometry: edgeLine
                    }));
                }

                return styles;
            }

            function getPolygonStyle(feature) {
                const layerName = feature.get('layer_name');
                const uniqueId = feature.get('unique_id');
                const edgeDistances = feature.get('edge_distances'); // Stored edge distances from database
                const layerColors = {
                    'TITLE TRACTS UTM ZONE 36N': '#e74c3c',
                    'TITLE TRACTS UTM ZONE 36S': '#c0392b',
                    'UNTITLED UTM ZONE 36N': '#3498db',
                    'UNTITLED UTM ZONE 36S': '#2980b9',
                    'BLB-UNTITLED': '#9b59b6'
                };

                const color = layerColors[layerName] || '#3498db';
                const geometry = feature.getGeometry();
                const coordinates = geometry.getCoordinates()[0];
                const styles = [
                    new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 2
                        })
                        // No fill as specified
                    })
                ];

                // Get map resolution to convert 1 meter to pixels for corner circles
                const view = map.getView();
                const resolution = view.getResolution();
                // Resolution is in meters per pixel (for Web Mercator)
                // For 1 meter radius: radius in pixels = 1 / resolution
                const radiusInPixels = resolution ? (1 / resolution) : 3; // Fallback to 3px if resolution unavailable
                // Clamp to reasonable range (2-10 pixels) for visibility
                const circleRadius = Math.max(2, Math.min(10, radiusInPixels));

                // Haversine distance function (for WGS84 coordinates)
                function haversineDistance(lon1, lat1, lon2, lat2) {
                    const R = 6371000; // Earth radius in meters
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a =
                        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    return R * c;
                }

                const areaHectares = feature.get('area_hectares');
                if (areaHectares) {
                    // Use stored edge_distances if available, otherwise calculate on-the-fly
                    if (edgeDistances && Array.isArray(edgeDistances) && edgeDistances.length > 0) {
                        // Use stored edge distances from database
                        edgeDistances.forEach((edge, index) => {
                            if (index < coordinates.length - 1) {
                                // Transform midpoint from WGS84 to Web Mercator for display
                                const midpoint = ol.proj.transform(
                                    edge.midpoint,
                                    'EPSG:4326',
                                    'EPSG:3857'
                                );

                                // Use LineString geometry for automatic text alignment along the edge
                                const p1Merc = coordinates[index];
                                const p2Merc = coordinates[index + 1];

                                // Create a LineString for this edge
                                const edgeLine = new ol.geom.LineString([p1Merc, p2Merc]);

                                styles.push(new ol.style.Style({
                                    text: new ol.style.Text({
                                        text: edge.label || `${edge.distance.toFixed(2)} m`,
                                        font: '12px sans-serif',
                                        fill: new ol.style.Fill({ color: '#333' }),
                                        stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                                        offsetY: -10, // Offset perpendicular to line
                                        placement: 'line', // Automatically aligns text along the line
                                        textAlign: 'center',
                                        textBaseline: 'middle',
                                        overflow: true,
                                        maxAngle: Math.PI / 4 // Only show text if line is not too steep
                                    }),
                                    geometry: edgeLine // Use line geometry instead of point
                                }));
                            }
                        });
                    } else {
                        // Fallback: Calculate distances on-the-fly if not stored
                        // Transform coordinates from Web Mercator to WGS84 for accurate distance calculation
                        const wgs84Coords = coordinates.map(coord => {
                            return ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
                        });

                        // Add distance labels for each edge with rotation
                        for (let i = 0; i < wgs84Coords.length - 1; i++) {
                            const p1 = wgs84Coords[i];
                            const p2 = wgs84Coords[i + 1];

                            // Calculate distance using Haversine (accurate for WGS84)
                            const distanceMeters = haversineDistance(p1[0], p1[1], p2[0], p2[1]);

                            // Calculate midpoint in Web Mercator for display
                            const midpoint = [
                                (coordinates[i][0] + coordinates[i + 1][0]) / 2,
                                (coordinates[i][1] + coordinates[i + 1][1]) / 2
                            ];

                            // Use LineString geometry for automatic text alignment along the edge
                            const p1Merc = coordinates[i];
                            const p2Merc = coordinates[i + 1];

                            // Create a LineString for this edge
                            const edgeLine = new ol.geom.LineString([p1Merc, p2Merc]);

                            styles.push(new ol.style.Style({
                                text: new ol.style.Text({
                                    text: `${distanceMeters.toFixed(2)} m`,
                                    font: '12px sans-serif',
                                    fill: new ol.style.Fill({ color: '#333' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                                    offsetY: -10, // Offset perpendicular to line
                                    placement: 'line', // Automatically aligns text along the line
                                    textAlign: 'center',
                                    textBaseline: 'middle',
                                    overflow: true,
                                    maxAngle: Math.PI / 4 // Only show text if line is not too steep
                                }),
                                geometry: edgeLine // Use line geometry instead of point
                            }));
                        }
                    }

                    // Add 1-meter radius circles at every corner (vertex)
                    for (let i = 0; i < coordinates.length - 1; i++) { // Exclude closing point
                        styles.push(new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: circleRadius, // 1 meter in pixels (scaled by resolution)
                                fill: new ol.style.Fill({ color: color }),
                                stroke: new ol.style.Stroke({
                                    color: '#fff',
                                    width: 1.5
                                })
                            }),
                            geometry: new ol.geom.Point(coordinates[i])
                        }));
                    }

                    // Add area and unique_id label in center
                    const center = ol.extent.getCenter(geometry.getExtent());
                    const labelText = uniqueId
                        ? `${uniqueId}\n${areaHectares.toFixed(4)} ha`
                        : `${areaHectares.toFixed(4)} ha`;

                    styles.push(new ol.style.Style({
                        text: new ol.style.Text({
                            text: labelText,
                            font: 'bold 14px sans-serif',
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                            placement: 'point',
                            textAlign: 'center',
                            textBaseline: 'middle'
                        }),
                        geometry: new ol.geom.Point(center)
                    }));
                }

                return styles;
            }

            // Update refresh function
            function refreshPolygonLayers() {
                // Clear cache and reload all polygon layers
                polygonLoadCache = {};
                Object.values(polygonLayerSources).forEach(source => {
                    source.clear();
                });

                // Trigger reload by slightly changing view
                const currentExtent = map.getView().calculateExtent();
                map.getView().fit(currentExtent, { duration: 0 });
            }

            // Add Layer Switcher with improved configuration
            const layerSwitcher = new ol.control.LayerSwitcher({
                tipLabel: 'Layers',
                groupSelectStyle: 'children',
                activationMode: 'click',
                startActive: true
            });
            map.addControl(layerSwitcher);


            // Layer counter functionality
            function updateLayerCounter() {
                let count = 0;
                gspnetLayers.forEach(layer => {
                    if (layer.getVisible()) {
                        count++;
                    }
                });
                document.getElementById('activeLayerCount').textContent = count;
            }

            // Monitor layer visibility changes
            gspnetLayers.forEach(layer => {
                layer.on('change:visible', function () {
                    updateLayerCounter();
                    if (this.getVisible()) {
                        showToast(`Layer "${this.get('title')}" is now visible`, 'info', 2000);
                    }
                });
            });
            updateLayerCounter();

            // PATCH: Create drawing layer for markup/drawing tools
            const drawingSource = new ol.source.Vector();
            const drawingLayer = new ol.layer.Vector({
                title: 'Drawing & Markup',
                source: drawingSource,
                style: function (feature) {
                    const geometry = feature.getGeometry();
                    const type = geometry.getType();

                    if (type === 'Point') {
                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 6,
                                fill: new ol.style.Fill({ color: '#ff6b6b' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            })
                        });
                    } else if (type === 'LineString') {
                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#4ecdc4',
                                width: 3
                            })
                        });
                    } else if (type === 'Polygon') {
                        return new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(78, 205, 196, 0.3)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#4ecdc4',
                                width: 2
                            })
                        });
                    } else if (type === 'Circle') {
                        return new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 107, 107, 0.2)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 2
                            })
                        });
                    }
                    return new ol.style.Style();
                }
            });
            map.addLayer(drawingLayer);

            // PATCH: Create dedicated search layer for coordinate search results
            const searchSource = new ol.source.Vector();
            const searchLayer = new ol.layer.Vector({
                title: 'Search Results',
                source: searchSource,
                style: function (feature) {
                    return new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#e74c3c' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                        }),
                        text: new ol.style.Text({
                            text: feature.get('name') || 'Point',
                            offsetY: -20,
                            font: 'bold 12px sans-serif',
                            fill: new ol.style.Fill({ color: '#e74c3c' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
                        })
                    });
                }
            });
            map.addLayer(searchLayer);

            // PATCH: Create measurement layer for measurement tools
            const measurementSource = new ol.source.Vector();
            const measurementLayer = new ol.layer.Vector({
                title: 'Measurements',
                source: measurementSource,
                style: function (feature) {
                    const geometry = feature.getGeometry();
                    const type = geometry.getType();

                    if (type === 'LineString') {
                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 3
                            }),
                            text: new ol.style.Text({
                                text: feature.get('measurement') || '',
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: '#ff6b6b' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 2 }),
                                offsetY: -10
                            })
                        });
                    } else if (type === 'Polygon') {
                        return new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 107, 107, 0.2)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 2
                            }),
                            text: new ol.style.Text({
                                text: feature.get('measurement') || '',
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: '#ff6b6b' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                            })
                        });
                    }
                    return new ol.style.Style();
                }
            });
            map.addLayer(measurementLayer);

            // Create a vector layer for project pins
            const projectPinsSource = new ol.source.Vector();
            window.projectPinsSource = projectPinsSource;
            const projectPinsLayer = new ol.layer.Vector({
                title: 'Project Pins',
                source: projectPinsSource,
                style: function (feature) {
                    const nature = feature.get('nature');
                    let color = '#3498db'; // Default blue
                    if (nature === 'control_points') color = '#3498db'; // Blue
                    else if (nature === 'jrj') color = '#27ae60'; // Green
                    else if (nature === 'land_survey') color = '#e74c3c'; // Red
                    else color = '#95a5a6'; // Gray for other

                    return new ol.style.Style({
                        image: new ol.style.Icon({
                            anchor: [0.5, 1],
                            src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="' + color + '" stroke="%23ffffff" stroke-width="2" d="M16 0C10.5 0 6 4.5 6 10c0 8 10 22 10 22s10-14 10-22c0-5.5-4.5-10-10-10zm0 14c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>',
                            scale: 1.2
                        }),
                        text: new ol.style.Text({
                            text: feature.get('label') || '',
                            offsetY: -35,
                            font: 'bold 11px sans-serif',
                            fill: new ol.style.Fill({ color: color }),
                            stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                        })
                    });
                },
                zIndex: 999
            });
            map.addLayer(projectPinsLayer);

            // Create a vector layer for markers
            const markerSource = new ol.source.Vector();
            const markerLayer = new ol.layer.Vector({
                title: 'Location Markers',
                source: markerSource,
                style: function (feature) {
                    const type = feature.get('type');
                    if (type === 'user') {
                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({
                                    color: 'rgba(0, 153, 255, 0.5)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#09f',
                                    width: 2
                                })
                            }),
                            text: new ol.style.Text({
                                text: 'You are here',
                                offsetY: -20,
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: '#09f' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                            })
                        });
                    } else if (type === 'accuracy') {
                        // PATCH: Accuracy circle styling
                        return new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(0, 153, 255, 0.1)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#09f',
                                width: 1,
                                lineDash: [5, 5]
                            })
                        });
                    } else if (type === 'coordinate') {
                        // CSV coordinate points - red dots with labels
                        const label = feature.get('label') || '';
                        const description = feature.get('description') || '';
                        const displayText = description ? `${label}\n${description}` : label;

                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({
                                    color: '#ff0000'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: 'white',
                                    width: 2
                                })
                            }),
                            text: new ol.style.Text({
                                text: displayText,
                                offsetY: -20,
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: '#000000' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                            })
                        });
                    } else {
                        // Default style for other features
                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({
                                    color: 'rgba(231, 76, 60, 0.8)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: 'white',
                                    width: 2
                                })
                            }),
                            text: new ol.style.Text({
                                text: feature.get('label') || '',
                                offsetY: -20,
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: '#e74c3c' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                            })
                        });
                    }
                }
            });
            map.addLayer(markerLayer);

            // ============================================
            // QUALITY FLAGS FEATURE IMPLEMENTATION
            // ============================================

            // Toast notification helper (if not already defined)
            if (typeof showToast === 'undefined') {
                function showToast(message, type = 'info', duration = 5000) {
                    const toast = document.getElementById('toastNotification');
                    if (toast) {
                        const toastMessage = document.getElementById('toastMessage');
                        toast.className = `toast-notification ${type}`;
                        if (toastMessage) toastMessage.textContent = message;
                        toast.style.display = 'block';
                        setTimeout(() => {
                            toast.style.display = 'none';
                        }, duration);
                    } else {
                        // Fallback: create temporary toast
                        const t = document.createElement('div');
                        t.className = `toast-notification ${type}`;
                        t.textContent = message;
                        t.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 10000; padding: 12px 20px; border-radius: 6px; color: white; font-weight: 600; background: ' + (type === 'error' ? '#e74c3c' : type === 'success' ? '#27ae60' : type === 'warning' ? '#f39c12' : '#3498db') + '; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 300px;';
                        document.body.appendChild(t);
                        setTimeout(() => t.remove(), duration);
                    }
                }
            }

            // Uganda Districts List (use window.UGANDA_DISTRICTS if available, otherwise use our own list)
            const QUALITY_FLAGS_DISTRICTS = (function () {
                try {
                    // Check window object first to avoid ReferenceError
                    if (typeof window !== 'undefined' && typeof window.UGANDA_DISTRICTS !== 'undefined' && Array.isArray(window.UGANDA_DISTRICTS)) {
                        return window.UGANDA_DISTRICTS.slice().sort();
                    }
                } catch (e) {
                    // Fall through to default list
                }
                // Default comprehensive list
                return [
                    'Abim', 'Adjumani', 'Agago', 'Alebtong', 'Amolatar', 'Amudat', 'Amuria', 'Amuru', 'Apac', 'Arua',
                    'Budaka', 'Bududa', 'Bugiri', 'Buhweju', 'Buikwe', 'Bukedea', 'Bukomansimbi', 'Bukwo', 'Bulambuli', 'Buliisa',
                    'Bundibugyo', 'Bushenyi', 'Busia', 'Butaleja', 'Butebo', 'Buvuma', 'Buyende',
                    'Dokolo',
                    'Gomba', 'Gulu', 'Gulu City',
                    'Hoima', 'Hoima City',
                    'Ibanda', 'Iganga', 'Isingiro',
                    'Jinja', 'Jinja City', 'Kaabong', 'Kabale', 'Kabarole', 'Kaberamaido', 'Kagadi', 'Kakumiro', 'Kalangala', 'Kaliro', 'Kalungu', 'Kampala', 'Kamuli', 'Kamwenge', 'Kanungu', 'Kapchorwa', 'Kapelebyong', 'Karenga', 'Kasanda', 'Kasese', 'Katakwi', 'Kayunga', 'Kazo', 'Kibaale', 'Kiboga', 'Kibuku', 'Kitagwenda', 'Kitgum', 'Koboko', 'Kole', 'Kotido', 'Kumi', 'Kwania', 'Kween', 'Kyankwanzi', 'Kyegegwa', 'Kyenjojo',
                    'Lamwo', 'Lira', 'Lira City', 'Luuka', 'Luwero', 'Lwengo', 'Lyantonde',
                    'Madi Okollo', 'Manafwa', 'Maracha', 'Masaka', 'Masaka City', 'Masindi', 'Mayuge', 'Mbale', 'Mbale City', 'Mbarara', 'Mbarara City', 'Mitooma', 'Mityana', 'Moroto', 'Moyo', 'Mpigi', 'Mubende', 'Mukono', 'Mukono City', 'Nakapiripirit', 'Nakaseke', 'Nakasongola', 'Namayingo', 'Namisindwa', 'Namutumba', 'Napak', 'Nebbi', 'Ngora', 'Ntoroko', 'Ntungamo', 'Nwoya',
                    'Omoro', 'Otuke', 'Oyam',
                    'Pader', 'Pakwach', 'Pallisa', 'Rakai', 'Rubanda', 'Rubirizi', 'Rukiga', 'Rukungiri', 'Rwampara',
                    'Sembabule', 'Serere', 'Sheema', 'Sironko', 'Soroti', 'Soroti City',
                    'Tororo',
                    'Wakiso', 'Yumbe',
                    'Zombo'
                ].sort();
            })();

            // Quality Flags State
            const qualityFlagsState = {
                isPanelOpen: false,
                currentTab: 'flag',
                selectedLocation: null,
                mapSelectionMode: false,
                flags: [],
                selectedFlagId: null,
                unreadCount: 0,
                currentPage: 1,
                hasMoreFlags: true,
                selectedFlags: new Set(),
                mapSelectionListener: null,
                tempPinFeature: null,
                autoRefreshInterval: null
            };

            // Create quality flags vector layer
            const qualityFlagsSource = new ol.source.Vector();
            const qualityFlagsLayer = new ol.layer.Vector({
                title: 'Quality Flags',
                source: qualityFlagsSource,
                style: function (feature) {
                    const flagType = feature.get('flag_type') || feature.get('current_flag_type') || 'red';
                    const colorMap = {
                        'red': '#e74c3c',
                        'yellow': '#f39c12',
                        'green': '#27ae60'
                    };
                    const color = colorMap[flagType] || '#e74c3c';

                    return new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 10,
                            fill: new ol.style.Fill({
                                color: color + 'CC'
                            }),
                            stroke: new ol.style.Stroke({
                                color: color,
                                width: 3
                            })
                        }),
                        text: new ol.style.Text({
                            text: '🚩',
                            offsetY: -25,
                            font: 'bold 16px sans-serif',
                            fill: new ol.style.Fill({ color: color }),
                            stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                        })
                    });
                }
            });
            map.addLayer(qualityFlagsLayer);

            // Initialize panel state from localStorage
            function loadPanelState() {
                const savedTab = localStorage.getItem('qualityFlags_lastTab');
                const savedDistrict = localStorage.getItem('qualityFlags_lastDistrict');
                if (savedTab && (savedTab === 'flag' || savedTab === 'check')) {
                    qualityFlagsState.currentTab = savedTab;
                    // Switch to saved tab after a small delay to ensure DOM is ready
                    setTimeout(() => {
                        switchQualityFlagsTab(savedTab);
                    }, 50);
                }
                if (savedDistrict && document.getElementById('checkDistrict')) {
                    document.getElementById('checkDistrict').value = savedDistrict;
                }
            }

            // Save panel state to localStorage
            function savePanelState() {
                localStorage.setItem('qualityFlags_lastTab', qualityFlagsState.currentTab);
                const checkDistrict = document.getElementById('checkDistrict');
                if (checkDistrict && checkDistrict.value) {
                    localStorage.setItem('qualityFlags_lastDistrict', checkDistrict.value);
                }
            }

            // Populate district dropdowns
            function populateDistrictDropdowns() {
                const flagDistrict = document.getElementById('flagDistrict');
                const checkDistrict = document.getElementById('checkDistrict');

                if (flagDistrict) {
                    QUALITY_FLAGS_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        flagDistrict.appendChild(option);
                    });
                }

                if (checkDistrict) {
                    QUALITY_FLAGS_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        checkDistrict.appendChild(option);
                    });
                }
            }

            // Utility Functions
            function validatePhone(phone) {
                // Uganda phone format: +256XXXXXXXXX or 256XXXXXXXXX or 0XXXXXXXXX
                const phoneRegex = /^(\+?256|0)?[0-9]{9}$/;
                return phoneRegex.test(phone.replace(/\s+/g, ''));
            }

            function validateEmail(email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            }

            function validateContact(contact) {
                return validatePhone(contact) || validateEmail(contact);
            }

            function formatDate(dateString) {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            }

            function formatCoordinates(lat, lng) {
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }

            // Supabase CRUD Functions
            async function createFlag(flagData) {
                try {
                    // Check if supabase is available
                    if (!supabase) {
                        throw new Error('Supabase client is not initialized');
                    }

                    // Format coordinates as PostGIS POINT using ST_MakePoint format
                    // We'll use RPC call if available, otherwise try direct insert
                    const pointString = `(${flagData.lng},${flagData.lat})`;

                    console.log('Creating flag with data:', {
                        coordinates: pointString,
                        lng: flagData.lng,
                        lat: flagData.lat,
                        district: flagData.district,
                        county: flagData.county,
                        flag_type: flagData.flag_type,
                        reporter_name: flagData.reporter_name
                    });

                    // Try using RPC function first if it exists, otherwise use direct insert
                    let data, error;

                    try {
                        // Try direct insert with POINT string format
                        const insertData = {
                            coordinates: pointString,
                            district: flagData.district,
                            block: flagData.block || null,
                            plot: flagData.plot || null,
                            is_untitled: flagData.is_untitled || false,
                            flag_type: flagData.flag_type,
                            current_flag_type: flagData.flag_type,
                            reporter_name: flagData.reporter_name,
                            reporter_contact: flagData.reporter_contact,
                            reason: flagData.reason
                        };

                        // Only add county if it exists in the table
                        if (flagData.county) {
                            insertData.county = flagData.county;
                        }

                        // Only add created_by if user is authenticated
                        if (window.__currentValuationUserId) {
                            insertData.created_by = window.__currentValuationUserId;
                        }

                        console.log('Insert data:', insertData);

                        const result = await supabase
                            .from('parcel_flags')
                            .insert([insertData])
                            .select()
                            .single();

                        data = result.data;
                        error = result.error;

                    } catch (insertError) {
                        console.error('Direct insert failed, trying RPC function:', insertError);
                        // If direct insert fails, try RPC function
                        if (insertError.code === '42804' || insertError.message?.includes('POINT')) {
                            // Try using RPC function
                            const rpcResult = await supabase.rpc('insert_parcel_flag', {
                                p_lng: flagData.lng,
                                p_lat: flagData.lat,
                                p_district: flagData.district,
                                p_county: flagData.county || null,
                                p_block: flagData.block || null,
                                p_plot: flagData.plot || null,
                                p_is_untitled: flagData.is_untitled || false,
                                p_flag_type: flagData.flag_type,
                                p_reporter_name: flagData.reporter_name,
                                p_reporter_contact: flagData.reporter_contact,
                                p_reason: flagData.reason,
                                p_created_by: window.__currentValuationUserId || null
                            });

                            if (rpcResult.error) {
                                throw rpcResult.error;
                            }

                            // Fetch the created flag
                            const fetchResult = await supabase
                                .from('parcel_flags')
                                .select('*')
                                .eq('id', rpcResult.data)
                                .single();

                            data = fetchResult.data;
                            error = fetchResult.error;
                        } else {
                            throw insertError;
                        }
                    }

                    if (error) {
                        console.error('Supabase insert error details:', {
                            message: error.message,
                            details: error.details,
                            hint: error.hint,
                            code: error.code
                        });
                        throw error;
                    }

                    console.log('Flag created successfully:', data);
                    return data;
                } catch (error) {
                    console.error('Error creating flag:', error);
                    throw error;
                }
            }

            async function getFlags(filters = {}, page = 1, pageSize = 20) {
                try {
                    let query = supabase
                        .from('parcel_flags')
                        .select('*', { count: 'exact' })
                        .order('created_at', { ascending: false });

                    if (filters.district) {
                        query = query.eq('district', filters.district);
                    }
                    if (filters.county) {
                        query = query.ilike('county', `%${filters.county}%`);
                    }
                    if (filters.flag_type) {
                        query = query.eq('current_flag_type', filters.flag_type);
                    }
                    if (filters.dateFrom) {
                        query = query.gte('created_at', filters.dateFrom);
                    }
                    if (filters.dateTo) {
                        query = query.lte('created_at', filters.dateTo + 'T23:59:59');
                    }

                    const from = (page - 1) * pageSize;
                    const to = from + pageSize - 1;
                    query = query.range(from, to);

                    const { data, error, count } = await query;
                    if (error) throw error;

                    return { data: data || [], count: count || 0, hasMore: (data || []).length === pageSize };
                } catch (error) {
                    console.error('Error fetching flags:', error);
                    throw error;
                }
            }

            async function getFlagById(id) {
                try {
                    const { data: flag, error: flagError } = await supabase
                        .from('parcel_flags')
                        .select('*')
                        .eq('id', id)
                        .single();

                    if (flagError) throw flagError;

                    const { data: history, error: historyError } = await supabase
                        .from('flag_history')
                        .select('*')
                        .eq('flag_id', id)
                        .order('changed_at', { ascending: false });

                    if (historyError) console.error('Error fetching history:', historyError);

                    const { data: comments, error: commentsError } = await supabase
                        .from('flag_comments')
                        .select('*')
                        .eq('flag_id', id)
                        .order('created_at', { ascending: false });

                    if (commentsError) console.error('Error fetching comments:', commentsError);

                    return {
                        flag: flag,
                        history: history || [],
                        comments: comments || []
                    };
                } catch (error) {
                    console.error('Error fetching flag details:', error);
                    throw error;
                }
            }

            async function updateFlagType(flagId, newType, changerInfo, reason) {
                try {
                    // Get current flag
                    const { data: currentFlag, error: getError } = await supabase
                        .from('parcel_flags')
                        .select('current_flag_type')
                        .eq('id', flagId)
                        .single();

                    if (getError) throw getError;

                    const oldType = currentFlag.current_flag_type;

                    // Update flag
                    const { data: updatedFlag, error: updateError } = await supabase
                        .from('parcel_flags')
                        .update({
                            current_flag_type: newType,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', flagId)
                        .select()
                        .single();

                    if (updateError) throw updateError;

                    // Create history entry
                    const { error: historyError } = await supabase
                        .from('flag_history')
                        .insert([{
                            flag_id: flagId,
                            changed_by_name: changerInfo.name,
                            changed_by_contact: changerInfo.contact,
                            change_reason: reason,
                            old_flag_type: oldType,
                            new_flag_type: newType
                        }]);

                    if (historyError) console.error('Error creating history:', historyError);

                    return updatedFlag;
                } catch (error) {
                    console.error('Error updating flag type:', error);
                    throw error;
                }
            }

            async function addComment(flagId, commentData) {
                try {
                    const { data, error } = await supabase
                        .from('flag_comments')
                        .insert([{
                            flag_id: flagId,
                            commenter_name: commentData.name,
                            commenter_contact: commentData.contact || null,
                            comment: commentData.comment,
                            created_by: window.__currentValuationUserId || null
                        }])
                        .select()
                        .single();

                    if (error) throw error;
                    return data;
                } catch (error) {
                    console.error('Error adding comment:', error);
                    throw error;
                }
            }

            async function getUnreadCount(userId, lastViewed) {
                try {
                    const { count, error } = await supabase
                        .from('parcel_flags')
                        .select('*', { count: 'exact', head: true })
                        .gt('created_at', lastViewed || '1970-01-01');

                    if (error) throw error;
                    return count || 0;
                } catch (error) {
                    console.error('Error getting unread count:', error);
                    return 0;
                }
            }

            async function markFlagsAsViewed(userId) {
                try {
                    const { error } = await supabase
                        .from('user_flag_views')
                        .upsert({
                            user_id: userId,
                            last_viewed_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        });

                    if (error) throw error;
                } catch (error) {
                    console.error('Error marking flags as viewed:', error);
                }
            }

            // Panel Toggle & Tab Management
            function toggleQualityFlagsPanel() {
                const dock = document.getElementById('qualityFlagsDock');
                if (!dock) return;

                qualityFlagsState.isPanelOpen = !qualityFlagsState.isPanelOpen;
                dock.setAttribute('aria-hidden', !qualityFlagsState.isPanelOpen);

                if (qualityFlagsState.isPanelOpen) {
                    // Mark flags as viewed when panel opens
                    if (window.__currentValuationUserId) {
                        markFlagsAsViewed(window.__currentValuationUserId);
                        updateNotificationBadge();
                    }
                    loadPanelState();
                }
            }

            function switchQualityFlagsTab(tabName) {
                qualityFlagsState.currentTab = tabName;

                // Update tab buttons
                document.querySelectorAll('.quality-tab').forEach(tab => {
                    if (tab) tab.classList.remove('active');
                });
                const activeTabBtn = document.getElementById(tabName === 'flag' ? 'flagTabBtn' : 'checkTabBtn');
                if (activeTabBtn) {
                    activeTabBtn.classList.add('active');
                } else {
                    console.error('Quality Flags: Tab button not found for', tabName);
                }

                // Hide detail section first
                const flagDetailSection = document.getElementById('flagDetailSection');
                if (flagDetailSection) flagDetailSection.style.display = 'none';

                // Update sections - hide all first
                document.querySelectorAll('.quality-section').forEach(section => {
                    if (section) section.classList.remove('active');
                });

                // Show the active section
                const activeSection = document.getElementById(tabName === 'flag' ? 'flagSection' : 'checkSection');
                if (activeSection) {
                    activeSection.classList.add('active');
                } else {
                    console.error('Quality Flags: Section not found for', tabName);
                }

                savePanelState();
            }

            // Map Selection Mode
            function enableMapSelectionMode() {
                if (qualityFlagsState.mapSelectionMode) return;

                qualityFlagsState.mapSelectionMode = true;
                document.getElementById('map').classList.add('map-selection-mode');
                document.getElementById('cancelSelectionBtn').style.display = 'block';

                // Remove existing listener if any
                if (qualityFlagsState.mapSelectionListener) {
                    map.un('singleclick', qualityFlagsState.mapSelectionListener);
                }

                // Add click listener
                qualityFlagsState.mapSelectionListener = function (event) {
                    const coordinate = event.coordinate;
                    const lonLat = ol.proj.toLonLat(coordinate);

                    qualityFlagsState.selectedLocation = {
                        lat: lonLat[1],
                        lng: lonLat[0],
                        coordinate: coordinate
                    };

                    // Remove temporary pin if exists
                    if (qualityFlagsState.tempPinFeature) {
                        qualityFlagsSource.removeFeature(qualityFlagsState.tempPinFeature);
                    }

                    // Create temporary pin
                    qualityFlagsState.tempPinFeature = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        flag_type: 'yellow',
                        is_temp: true
                    });
                    qualityFlagsSource.addFeature(qualityFlagsState.tempPinFeature);

                    // Update UI
                    document.getElementById('selectedLocationInfo').style.display = 'block';
                    document.getElementById('selectedCoordinates').textContent = formatCoordinates(lonLat[1], lonLat[0]);

                    disableMapSelectionMode();
                };

                map.on('singleclick', qualityFlagsState.mapSelectionListener);
                showToast('Click on the map to select parcel location', 'info');
            }

            function disableMapSelectionMode() {
                qualityFlagsState.mapSelectionMode = false;
                document.getElementById('map').classList.remove('map-selection-mode');
                document.getElementById('cancelSelectionBtn').style.display = 'none';

                if (qualityFlagsState.mapSelectionListener) {
                    map.un('singleclick', qualityFlagsState.mapSelectionListener);
                    qualityFlagsState.mapSelectionListener = null;
                }
            }

            function cancelMapSelection() {
                if (qualityFlagsState.tempPinFeature) {
                    qualityFlagsSource.removeFeature(qualityFlagsState.tempPinFeature);
                    qualityFlagsState.tempPinFeature = null;
                }
                qualityFlagsState.selectedLocation = null;
                document.getElementById('selectedLocationInfo').style.display = 'none';
                disableMapSelectionMode();
            }

            // Form Validation
            function validateFlagForm() {
                const district = document.getElementById('flagDistrict').value;
                const flagType = document.getElementById('flagType').value;
                const reporterName = document.getElementById('reporterName').value.trim();
                const reporterContact = document.getElementById('reporterContact').value.trim();
                const reason = document.getElementById('flagReason').value.trim();
                const parcelType = document.querySelector('input[name="parcelType"]:checked').value;

                if (!district) {
                    showToast('Please select a district', 'error');
                    return false;
                }

                if (!qualityFlagsState.selectedLocation) {
                    showToast('Please select a location on the map', 'error');
                    return false;
                }

                if (!flagType) {
                    showToast('Please select a flag type', 'error');
                    return false;
                }

                if (!reporterName) {
                    showToast('Please enter your name', 'error');
                    return false;
                }

                if (!reporterContact) {
                    showToast('Please enter your contact information', 'error');
                    return false;
                }

                if (!validateContact(reporterContact)) {
                    showToast('Please enter a valid phone number (+256XXXXXXXXX) or email address', 'error');
                    return false;
                }

                if (!reason || reason.length < 10) {
                    showToast('Please provide a reason (at least 10 characters)', 'error');
                    return false;
                }

                if (reason.length > 1000) {
                    showToast('Reason must be 1000 characters or less', 'error');
                    return false;
                }

                if (parcelType === 'titled') {
                    const block = document.getElementById('flagBlock').value.trim();
                    const plot = document.getElementById('flagPlot').value.trim();
                    if (!block && !plot) {
                        showToast('Please enter Block or Plot number for titled parcels', 'error');
                        return false;
                    }
                }

                return true;
            }

            // Flag Creation
            async function submitFlag() {
                if (!validateFlagForm()) return;

                const form = document.getElementById('flagParcelForm');
                const submitBtn = document.getElementById('submitFlagBtn');
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

                try {
                    const parcelType = document.querySelector('input[name="parcelType"]:checked').value;
                    const flagData = {
                        district: document.getElementById('flagDistrict').value,
                        county: document.getElementById('flagCounty') ? document.getElementById('flagCounty').value.trim() : null,
                        block: parcelType === 'titled' ? document.getElementById('flagBlock').value.trim() : null,
                        plot: parcelType === 'titled' ? document.getElementById('flagPlot').value.trim() : null,
                        is_untitled: parcelType === 'untitled',
                        flag_type: document.getElementById('flagType').value,
                        reporter_name: document.getElementById('reporterName').value.trim(),
                        reporter_contact: document.getElementById('reporterContact').value.trim(),
                        reason: document.getElementById('flagReason').value.trim(),
                        lat: qualityFlagsState.selectedLocation.lat,
                        lng: qualityFlagsState.selectedLocation.lng
                    };

                    // Check for duplicate (same coordinates)
                    const existingFlags = await getFlags({ district: flagData.district }, 1, 100);
                    const isDuplicate = existingFlags.data.some(f => {
                        const coords = f.coordinates.match(/\(([^,]+),([^)]+)\)/);
                        if (!coords) return false;
                        const lat = parseFloat(coords[2]);
                        const lng = parseFloat(coords[1]);
                        const distance = Math.sqrt(Math.pow(lat - flagData.lat, 2) + Math.pow(lng - flagData.lng, 2));
                        return distance < 0.0001; // Very close coordinates
                    });

                    if (isDuplicate) {
                        showToast('A flag already exists at this location. Please check existing flags.', 'warning');
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-flag"></i> Submit Flag';
                        return;
                    }

                    const newFlag = await createFlag(flagData);

                    // Remove temporary pin
                    if (qualityFlagsState.tempPinFeature) {
                        qualityFlagsSource.removeFeature(qualityFlagsState.tempPinFeature);
                        qualityFlagsState.tempPinFeature = null;
                    }

                    // Create permanent pin
                    const coordinate = qualityFlagsState.selectedLocation.coordinate;
                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        flag_type: flagData.flag_type,
                        current_flag_type: flagData.flag_type,
                        id: newFlag.id,
                        district: flagData.district,
                        block: flagData.block,
                        plot: flagData.plot
                    });
                    qualityFlagsSource.addFeature(feature);

                    // Reset form
                    form.reset();
                    qualityFlagsState.selectedLocation = null;
                    document.getElementById('selectedLocationInfo').style.display = 'none';
                    document.getElementById('reasonCharCount').textContent = '0';

                    showToast('Flag submitted successfully!', 'success');
                    updateNotificationBadge();
                } catch (error) {
                    console.error('Error submitting flag:', error);
                    let errorMessage = 'Error submitting flag: ';
                    if (error.message) {
                        errorMessage += error.message;
                    } else if (error.details) {
                        errorMessage += error.details;
                    } else if (error.hint) {
                        errorMessage += error.hint;
                    } else {
                        errorMessage += 'Unknown error. Please check console for details.';
                    }
                    showToast(errorMessage, 'error');
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-flag"></i> Submit Flag';
                }
            }

            // Flag Search
            async function searchFlags() {
                const loadingDiv = document.getElementById('flagsLoading');
                const listDiv = document.getElementById('flagsList');
                const statsDiv = document.getElementById('statisticsSection');
                const exportDiv = document.getElementById('exportSection');

                loadingDiv.style.display = 'block';
                listDiv.innerHTML = '';
                statsDiv.style.display = 'none';
                exportDiv.style.display = 'none';
                qualityFlagsState.currentPage = 1;
                qualityFlagsState.hasMoreFlags = true;
                qualityFlagsState.selectedFlags.clear();

                try {
                    const filters = {
                        district: document.getElementById('checkDistrict').value || null,
                        county: document.getElementById('checkCounty') ? document.getElementById('checkCounty').value.trim() || null : null,
                        flag_type: document.getElementById('checkFlagType').value || null,
                        dateFrom: document.getElementById('dateFrom').value || null,
                        dateTo: document.getElementById('dateTo').value || null
                    };

                    const result = await getFlags(filters, 1, 20);
                    qualityFlagsState.flags = result.data;
                    qualityFlagsState.hasMoreFlags = result.hasMore;

                    // Clear existing pins
                    qualityFlagsSource.clear();

                    // Plot flags on map
                    result.data.forEach(flag => {
                        const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                        if (coords) {
                            const lng = parseFloat(coords[1]);
                            const lat = parseFloat(coords[2]);
                            const coordinate = ol.proj.fromLonLat([lng, lat]);

                            const feature = new ol.Feature({
                                geometry: new ol.geom.Point(coordinate),
                                flag_type: flag.flag_type,
                                current_flag_type: flag.current_flag_type,
                                id: flag.id,
                                district: flag.district,
                                block: flag.block,
                                plot: flag.plot
                            });
                            qualityFlagsSource.addFeature(feature);
                        }
                    });

                    // Calculate statistics
                    const stats = {
                        red: result.data.filter(f => f.current_flag_type === 'red').length,
                        yellow: result.data.filter(f => f.current_flag_type === 'yellow').length,
                        green: result.data.filter(f => f.current_flag_type === 'green').length
                    };

                    document.getElementById('statRed').textContent = stats.red;
                    document.getElementById('statYellow').textContent = stats.yellow;
                    document.getElementById('statGreen').textContent = stats.green;
                    statsDiv.style.display = 'block';

                    // Display flags list
                    if (result.data.length === 0) {
                        listDiv.innerHTML = '<div class="empty-state"><i class="fas fa-search"></i><p>No flags found matching your criteria</p></div>';
                    } else {
                        renderFlagsList(result.data);
                        exportDiv.style.display = 'flex';
                    }

                    savePanelState();
                } catch (error) {
                    console.error('Error searching flags:', error);
                    showToast('Error searching flags: ' + (error.message || 'Unknown error'), 'error');
                    listDiv.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading flags</p></div>';
                } finally {
                    loadingDiv.style.display = 'none';
                }
            }

            function renderFlagsList(flags) {
                const listDiv = document.getElementById('flagsList');
                listDiv.innerHTML = '';

                flags.forEach(flag => {
                    const item = document.createElement('div');
                    item.className = `flag-item ${flag.current_flag_type || flag.flag_type}`;
                    item.dataset.flagId = flag.id;

                    const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                    const locationText = coords ?
                        `${flag.district}${flag.county ? `, ${flag.county}` : ''}${flag.block ? `, Block ${flag.block}` : ''}${flag.plot ? `, Plot ${flag.plot}` : ''}` :
                        `${flag.district}${flag.county ? `, ${flag.county}` : ''}`;

                    item.innerHTML = `
                    <div class="flag-item-header">
                        <div class="flag-item-type">
                            <span class="flag-indicator ${flag.current_flag_type || flag.flag_type}"></span>
                            ${(flag.current_flag_type || flag.flag_type).toUpperCase()}
                        </div>
                        <div class="flag-item-date">${formatDate(flag.created_at)}</div>
                    </div>
                    <div class="flag-item-location">${locationText}</div>
                    <div class="flag-item-reason">${flag.reason.substring(0, 100)}${flag.reason.length > 100 ? '...' : ''}</div>
                `;

                    item.addEventListener('click', () => {
                        showFlagDetail(flag.id);
                    });

                    listDiv.appendChild(item);
                });
            }

            function loadMoreFlags() {
                if (!qualityFlagsState.hasMoreFlags) return;

                const loadingDiv = document.getElementById('flagsLoading');
                loadingDiv.style.display = 'block';

                const filters = {
                    district: document.getElementById('checkDistrict').value || null,
                    county: document.getElementById('checkCounty') ? document.getElementById('checkCounty').value.trim() || null : null,
                    flag_type: document.getElementById('checkFlagType').value || null,
                    dateFrom: document.getElementById('dateFrom').value || null,
                    dateTo: document.getElementById('dateTo').value || null
                };

                getFlags(filters, qualityFlagsState.currentPage + 1, 20)
                    .then(result => {
                        qualityFlagsState.flags.push(...result.data);
                        qualityFlagsState.hasMoreFlags = result.hasMore;
                        qualityFlagsState.currentPage++;

                        // Add to map
                        result.data.forEach(flag => {
                            const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                            if (coords) {
                                const lng = parseFloat(coords[1]);
                                const lat = parseFloat(coords[2]);
                                const coordinate = ol.proj.fromLonLat([lng, lat]);

                                const feature = new ol.Feature({
                                    geometry: new ol.geom.Point(coordinate),
                                    flag_type: flag.flag_type,
                                    current_flag_type: flag.current_flag_type,
                                    id: flag.id,
                                    district: flag.district,
                                    block: flag.block,
                                    plot: flag.plot
                                });
                                qualityFlagsSource.addFeature(feature);
                            }
                        });

                        renderFlagsList(qualityFlagsState.flags);
                    })
                    .catch(error => {
                        console.error('Error loading more flags:', error);
                        showToast('Error loading more flags', 'error');
                    })
                    .finally(() => {
                        loadingDiv.style.display = 'none';
                    });
            }

            // Flag Detail View
            async function showFlagDetail(flagId) {
                qualityFlagsState.selectedFlagId = flagId;

                // Hide list section, show detail section
                document.getElementById('checkSection').classList.remove('active');
                document.getElementById('flagDetailSection').style.display = 'block';
                document.getElementById('flagDetailSection').classList.add('active');

                const contentDiv = document.getElementById('flagDetailContent');
                contentDiv.innerHTML = '<div class="loading-state"><i class="fas fa-spinner fa-spin"></i> Loading flag details...</div>';

                try {
                    const flagData = await getFlagById(flagId);
                    const flag = flagData.flag;

                    const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                    const locationText = coords ?
                        `${flag.district}${flag.county ? `, ${flag.county}` : ''}${flag.block ? `, Block ${flag.block}` : ''}${flag.plot ? `, Plot ${flag.plot}` : ''}` :
                        `${flag.district}${flag.county ? `, ${flag.county}` : ''}`;

                    // Zoom to flag
                    if (coords) {
                        const lng = parseFloat(coords[1]);
                        const lat = parseFloat(coords[2]);
                        const coordinate = ol.proj.fromLonLat([lng, lat]);
                        map.getView().setCenter(coordinate);
                        map.getView().setZoom(Math.max(map.getView().getZoom(), 15));
                    }

                    let html = `
                    <div class="flag-detail-section">
                        <h5>Flag Information</h5>
                        <p><strong>Type:</strong> <span class="flag-indicator ${flag.current_flag_type}"></span> ${flag.current_flag_type.toUpperCase()}</p>
                        <p><strong>Location:</strong> ${locationText}</p>
                        <p><strong>Coordinates:</strong> ${coords ? formatCoordinates(parseFloat(coords[2]), parseFloat(coords[1])) : 'N/A'}</p>
                        <p><strong>Reporter:</strong> ${flag.reporter_name}</p>
                        <p><strong>Contact:</strong> ${flag.reporter_contact}</p>
                        <p><strong>Reason:</strong> ${flag.reason}</p>
                        <p><strong>Created:</strong> ${formatDate(flag.created_at)}</p>
                        <p><strong>Status:</strong> ${flag.status || 'active'}</p>
                    </div>
                `;

                    // Flag History
                    if (flagData.history && flagData.history.length > 0) {
                        html += `
                        <div class="flag-detail-section">
                            <h5>Flag History</h5>
                            ${flagData.history.map(h => `
                                <div class="flag-history-item ${h.new_flag_type}">
                                    <p><strong>Changed from ${h.old_flag_type || 'N/A'} to ${h.new_flag_type}</strong></p>
                                    <p><strong>By:</strong> ${h.changed_by_name} (${h.changed_by_contact})</p>
                                    <p><strong>Reason:</strong> ${h.change_reason}</p>
                                    <p><strong>Date:</strong> ${formatDate(h.changed_at)}</p>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    }

                    // Comments
                    html += `
                    <div class="flag-comments-section">
                        <div class="flag-detail-section">
                            <h5>Comments (${flagData.comments ? flagData.comments.length : 0})</h5>
                            ${flagData.comments && flagData.comments.length > 0 ?
                            flagData.comments.map(c => `
                                    <div class="comment-item">
                                        <div class="comment-header">
                                            <span class="comment-author">${c.commenter_name}</span>
                                            <span class="comment-date">${formatDate(c.created_at)}</span>
                                        </div>
                                        <div class="comment-text">${c.comment}</div>
                                    </div>
                                `).join('') :
                            '<p>No comments yet</p>'
                        }
                        </div>
                        
                        <div class="add-comment-form">
                            <h5>Add Comment</h5>
                            <div class="form-group">
                                <label for="commenterName">Your Name <span class="required">*</span></label>
                                <input type="text" id="commenterName" class="form-input" required>
                            </div>
                            <div class="form-group">
                                <label for="commenterContact">Contact (Optional)</label>
                                <input type="text" id="commenterContact" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="commentText">Comment <span class="required">*</span></label>
                                <textarea id="commentText" class="form-textarea" rows="3" required maxlength="1000"></textarea>
                            </div>
                            <button type="button" class="btn btn-primary" id="submitCommentBtn">
                                <i class="fas fa-comment"></i> Add Comment
                            </button>
                        </div>
                    </div>
                `;

                    // Change Flag Type Section
                    html += `
                    <div class="change-flag-section">
                        <h5>Change Flag Type</h5>
                        <div class="form-group">
                            <label for="newFlagType">New Flag Type <span class="required">*</span></label>
                            <select id="newFlagType" class="form-select" required>
                                <option value="">Select Type</option>
                                <option value="red">Bad/Untrusted Data</option>
                                <option value="yellow">Needs Review</option>
                                <option value="green">Verified/Trusted Data</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="changerName">Your Name <span class="required">*</span></label>
                            <input type="text" id="changerName" class="form-input" required>
                        </div>
                        <div class="form-group">
                            <label for="changerContact">Contact (Phone or Email) <span class="required">*</span></label>
                            <input type="text" id="changerContact" class="form-input" required>
                        </div>
                        <div class="form-group">
                            <label for="changeReason">Reason for Change <span class="required">*</span></label>
                            <textarea id="changeReason" class="form-textarea" rows="3" required maxlength="1000"></textarea>
                        </div>
                        <button type="button" class="btn btn-primary" id="submitChangeBtn">
                            <i class="fas fa-edit"></i> Update Flag Type
                        </button>
                    </div>
                `;

                    contentDiv.innerHTML = html;

                    // Attach event listeners
                    document.getElementById('submitCommentBtn').addEventListener('click', () => submitComment(flagId));
                    document.getElementById('submitChangeBtn').addEventListener('click', () => submitFlagTypeChange(flagId));
                } catch (error) {
                    console.error('Error loading flag detail:', error);
                    contentDiv.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading flag details</p></div>';
                    showToast('Error loading flag details', 'error');
                }
            }

            async function submitComment(flagId) {
                const name = document.getElementById('commenterName').value.trim();
                const contact = document.getElementById('commenterContact').value.trim();
                const comment = document.getElementById('commentText').value.trim();

                if (!name || !comment) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                if (comment.length > 1000) {
                    showToast('Comment must be 1000 characters or less', 'error');
                    return;
                }

                const btn = document.getElementById('submitCommentBtn');
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';

                try {
                    await addComment(flagId, { name, contact, comment });
                    showToast('Comment added successfully', 'success');
                    document.getElementById('commenterName').value = '';
                    document.getElementById('commenterContact').value = '';
                    document.getElementById('commentText').value = '';
                    // Reload flag detail
                    showFlagDetail(flagId);
                } catch (error) {
                    console.error('Error adding comment:', error);
                    showToast('Error adding comment: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-comment"></i> Add Comment';
                }
            }

            async function submitFlagTypeChange(flagId) {
                const newType = document.getElementById('newFlagType').value;
                const name = document.getElementById('changerName').value.trim();
                const contact = document.getElementById('changerContact').value.trim();
                const reason = document.getElementById('changeReason').value.trim();

                if (!newType || !name || !contact || !reason) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                if (!validateContact(contact)) {
                    showToast('Please enter a valid phone number or email address', 'error');
                    return;
                }

                if (reason.length > 1000) {
                    showToast('Reason must be 1000 characters or less', 'error');
                    return;
                }

                const btn = document.getElementById('submitChangeBtn');
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Updating...';

                try {
                    await updateFlagType(flagId, newType, { name, contact }, reason);
                    showToast('Flag type updated successfully', 'success');
                    // Update pin on map
                    const features = qualityFlagsSource.getFeatures();
                    const feature = features.find(f => f.get('id') === flagId);
                    if (feature) {
                        feature.set('current_flag_type', newType);
                        feature.set('flag_type', newType);
                    }
                    // Reload flag detail
                    showFlagDetail(flagId);
                } catch (error) {
                    console.error('Error updating flag type:', error);
                    showToast('Error updating flag type: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-edit"></i> Update Flag Type';
                }
            }

            // Pin Click Handler
            qualityFlagsLayer.getSource().on('addfeature', function () {
                map.on('singleclick', function (event) {
                    map.forEachFeatureAtPixel(event.pixel, function (feature, layer) {
                        if (layer === qualityFlagsLayer && feature.get('id')) {
                            showFlagDetail(feature.get('id'));
                        }
                    });
                });
            });

            // Notification Badge
            async function updateNotificationBadge() {
                if (!window.__currentValuationUserId) return;

                try {
                    // Get last viewed timestamp
                    const { data: viewData, error: viewError } = await supabase
                        .from('user_flag_views')
                        .select('last_viewed_at')
                        .eq('user_id', window.__currentValuationUserId)
                        .single();

                    const lastViewed = viewData?.last_viewed_at || '1970-01-01';
                    const count = await getUnreadCount(window.__currentValuationUserId, lastViewed);

                    qualityFlagsState.unreadCount = count;
                    const badge = document.getElementById('qualityFlagsBadge');
                    if (badge) {
                        badge.textContent = count > 9 ? '9+' : count.toString();
                        badge.classList.toggle('active', count > 0);
                    }
                } catch (error) {
                    console.error('Error updating notification badge:', error);
                }
            }

            // Export Functions
            function exportFlagsCSV() {
                if (qualityFlagsState.flags.length === 0) {
                    showToast('No flags to export', 'warning');
                    return;
                }

                const headers = ['ID', 'District', 'Block', 'Plot', 'Flag Type', 'Reporter Name', 'Reporter Contact', 'Reason', 'Created At', 'Status'];
                const rows = qualityFlagsState.flags.map(flag => {
                    const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                    return [
                        flag.id,
                        flag.district || '',
                        flag.block || '',
                        flag.plot || '',
                        flag.current_flag_type || flag.flag_type,
                        flag.reporter_name || '',
                        flag.reporter_contact || '',
                        `"${(flag.reason || '').replace(/"/g, '""')}"`,
                        flag.created_at || '',
                        flag.status || 'active'
                    ];
                });

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.join(','))
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `quality_flags_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();

                showToast('Flags exported to CSV', 'success');
            }

            function exportFlagsPDF() {
                if (qualityFlagsState.flags.length === 0) {
                    showToast('No flags to export', 'warning');
                    return;
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                doc.setFontSize(16);
                doc.text('Quality Flags Report', 14, 20);
                doc.setFontSize(10);
                doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 30);
                doc.text(`Total Flags: ${qualityFlagsState.flags.length}`, 14, 36);

                let y = 50;
                qualityFlagsState.flags.forEach((flag, index) => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }

                    const coords = flag.coordinates.match(/\(([^,]+),([^)]+)\)/);
                    const locationText = `${flag.district}${flag.block ? `, Block ${flag.block}` : ''}${flag.plot ? `, Plot ${flag.plot}` : ''}`;

                    doc.setFontSize(12);
                    doc.text(`Flag ${index + 1}`, 14, y);
                    y += 8;

                    doc.setFontSize(10);
                    doc.text(`Type: ${(flag.current_flag_type || flag.flag_type).toUpperCase()}`, 14, y);
                    y += 6;
                    doc.text(`Location: ${locationText}`, 14, y);
                    y += 6;
                    doc.text(`Reporter: ${flag.reporter_name}`, 14, y);
                    y += 6;
                    doc.text(`Contact: ${flag.reporter_contact}`, 14, y);
                    y += 6;
                    doc.text(`Reason: ${flag.reason.substring(0, 80)}${flag.reason.length > 80 ? '...' : ''}`, 14, y);
                    y += 6;
                    doc.text(`Created: ${formatDate(flag.created_at)}`, 14, y);
                    y += 10;
                });

                doc.save(`quality_flags_${new Date().toISOString().split('T')[0]}.pdf`);
                showToast('Flags exported to PDF', 'success');
            }

            // Auto-refresh
            function startAutoRefresh() {
                if (qualityFlagsState.autoRefreshInterval) {
                    clearInterval(qualityFlagsState.autoRefreshInterval);
                }

                qualityFlagsState.autoRefreshInterval = setInterval(() => {
                    if (!qualityFlagsState.isPanelOpen) {
                        updateNotificationBadge();
                    }
                }, 5 * 60 * 1000); // Every 5 minutes
            }

            // Event Listeners Setup
            function setupQualityFlagsEventListeners() {
                // Panel toggle
                const btn = document.getElementById('qualityFlagsBtn');
                const closeBtn = document.getElementById('qualityFlagsClose');
                if (btn) btn.addEventListener('click', toggleQualityFlagsPanel);
                if (closeBtn) closeBtn.addEventListener('click', toggleQualityFlagsPanel);

                // Tab switching - use event delegation for reliability
                const qualityTabs = document.querySelector('.quality-tabs');
                if (qualityTabs) {
                    qualityTabs.addEventListener('click', function (e) {
                        const tabBtn = e.target.closest('.quality-tab');
                        if (tabBtn) {
                            const tabName = tabBtn.getAttribute('data-tab');
                            if (tabName === 'flag' || tabName === 'check') {
                                e.preventDefault();
                                e.stopPropagation();
                                switchQualityFlagsTab(tabName);
                            }
                        }
                    });
                }

                // Also add direct listeners as backup
                const flagTabBtn = document.getElementById('flagTabBtn');
                const checkTabBtn = document.getElementById('checkTabBtn');
                if (flagTabBtn) {
                    flagTabBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        switchQualityFlagsTab('flag');
                    });
                } else {
                    console.error('Quality Flags: flagTabBtn not found');
                }
                if (checkTabBtn) {
                    checkTabBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        switchQualityFlagsTab('check');
                    });
                } else {
                    console.error('Quality Flags: checkTabBtn not found');
                }

                // Parcel type radio toggle
                document.querySelectorAll('input[name="parcelType"]').forEach(radio => {
                    radio.addEventListener('change', function () {
                        const isUntitled = this.value === 'untitled';
                        const blockPlotGroup = document.getElementById('blockPlotGroup');
                        const otherParcelGroup = document.getElementById('otherParcelGroup');
                        if (blockPlotGroup) blockPlotGroup.style.display = isUntitled ? 'none' : 'block';
                        if (otherParcelGroup) otherParcelGroup.style.display = isUntitled ? 'block' : 'none';
                    });
                });

                // Map selection
                const selectOnMapBtn = document.getElementById('selectOnMapBtn');
                const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
                if (selectOnMapBtn) selectOnMapBtn.addEventListener('click', enableMapSelectionMode);
                if (cancelSelectionBtn) cancelSelectionBtn.addEventListener('click', cancelMapSelection);

                // Character counter
                const reasonTextarea = document.getElementById('flagReason');
                if (reasonTextarea) {
                    reasonTextarea.addEventListener('input', function () {
                        const charCount = document.getElementById('reasonCharCount');
                        if (charCount) charCount.textContent = this.value.length;
                    });
                }

                // Form submission
                const flagParcelForm = document.getElementById('flagParcelForm');
                if (flagParcelForm) {
                    flagParcelForm.addEventListener('submit', function (e) {
                        e.preventDefault();
                        submitFlag();
                    });
                }

                // Search
                const searchFlagsBtn = document.getElementById('searchFlagsBtn');
                const clearFiltersBtn = document.getElementById('clearFiltersBtn');
                if (searchFlagsBtn) searchFlagsBtn.addEventListener('click', searchFlags);
                if (clearFiltersBtn) {
                    clearFiltersBtn.addEventListener('click', function () {
                        const checkDistrict = document.getElementById('checkDistrict');
                        const checkCounty = document.getElementById('checkCounty');
                        const checkFlagType = document.getElementById('checkFlagType');
                        const dateFrom = document.getElementById('dateFrom');
                        const dateTo = document.getElementById('dateTo');
                        const flagsList = document.getElementById('flagsList');
                        const statisticsSection = document.getElementById('statisticsSection');
                        const exportSection = document.getElementById('exportSection');
                        if (checkDistrict) checkDistrict.value = '';
                        if (checkCounty) checkCounty.value = '';
                        if (checkFlagType) checkFlagType.value = '';
                        if (dateFrom) dateFrom.value = '';
                        if (dateTo) dateTo.value = '';
                        if (flagsList) flagsList.innerHTML = '<div class="empty-state"><i class="fas fa-search"></i><p>Use filters above to search for flags</p></div>';
                        if (statisticsSection) statisticsSection.style.display = 'none';
                        if (exportSection) exportSection.style.display = 'none';
                        if (qualityFlagsSource) qualityFlagsSource.clear();
                    });
                }

                // Infinite scroll
                const flagsListContainer = document.querySelector('.flags-list-container');
                if (flagsListContainer) {
                    flagsListContainer.addEventListener('scroll', function () {
                        if (this.scrollTop + this.clientHeight >= this.scrollHeight - 50) {
                            loadMoreFlags();
                        }
                    });
                }

                // Back to list
                const backToListBtn = document.getElementById('backToListBtn');
                if (backToListBtn) {
                    backToListBtn.addEventListener('click', function () {
                        const flagDetailSection = document.getElementById('flagDetailSection');
                        const checkSection = document.getElementById('checkSection');
                        if (flagDetailSection) flagDetailSection.style.display = 'none';
                        if (checkSection) checkSection.classList.add('active');
                        switchQualityFlagsTab('check');
                    });
                }

                // Export
                const exportCSVBtn = document.getElementById('exportCSVBtn');
                const exportPDFBtn = document.getElementById('exportPDFBtn');
                if (exportCSVBtn) exportCSVBtn.addEventListener('click', exportFlagsCSV);
                if (exportPDFBtn) exportPDFBtn.addEventListener('click', exportFlagsPDF);
            }

            // Initialize on DOM ready
            function initQualityFlags() {
                try {
                    console.log('Quality Flags: Starting initialization...');

                    // Check if required elements exist
                    const dock = document.getElementById('qualityFlagsDock');
                    const flagSection = document.getElementById('flagSection');
                    const checkSection = document.getElementById('checkSection');
                    const flagTabBtn = document.getElementById('flagTabBtn');
                    const checkTabBtn = document.getElementById('checkTabBtn');

                    if (!dock) console.error('Quality Flags: Dock not found');
                    if (!flagSection) console.error('Quality Flags: Flag section not found');
                    if (!checkSection) console.error('Quality Flags: Check section not found');
                    if (!flagTabBtn) console.error('Quality Flags: Flag tab button not found');
                    if (!checkTabBtn) console.error('Quality Flags: Check tab button not found');

                    populateDistrictDropdowns();
                    loadPanelState();
                    setupQualityFlagsEventListeners();
                    updateNotificationBadge();
                    startAutoRefresh();
                    console.log('Quality Flags: Initialization complete');
                } catch (error) {
                    console.error('Quality Flags: Initialization error:', error);
                }
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function () {
                    // Small delay to ensure all other scripts have loaded
                    setTimeout(initQualityFlags, 100);
                });
            } else {
                // Small delay to ensure all other scripts have loaded
                setTimeout(initQualityFlags, 100);
            }

            // Modal control functions
            function openModal(modalId) {
                document.getElementById(modalId).style.display = 'flex';
            }

            function closeModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }

            // GSPNET.assist functionality (optional panel - only initialize if exists)
            const gspnetBtn = document.getElementById('gspnet-assist-btn');
            const gspnetPanel = document.getElementById('gspnet-assist-panel');
            const gspnetTabs = document.querySelectorAll('.gspnet-tab');
            const gspnetSections = document.querySelectorAll('.gspnet-section');
            const gspnetCloseBtn = document.getElementById('gspnet-panel-close');

            if (gspnetBtn && gspnetPanel) {
                gspnetBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    try {
                        if (gspnetPanel.style.display === 'block') {
                            gspnetPanel.style.display = 'none';
                        } else {
                            gspnetPanel.style.display = 'block';
                        }
                    } catch (error) {
                        console.error('GSP.NET ASSIST: Error toggling panel:', error);
                    }
                });
                console.log('GSP.NET ASSIST: Button handler attached');
            } else {
                console.warn('GSP.NET ASSIST: Button or panel not found');
            }

            if (gspnetCloseBtn && gspnetPanel) {
                gspnetCloseBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    try {
                        gspnetPanel.style.display = 'none';
                    } catch (error) {
                        console.error('GSP.NET ASSIST: Error closing panel:', error);
                    }
                });
                console.log('GSP.NET ASSIST: Close button handler attached');
            }

            if (gspnetTabs.length > 0) {
                gspnetTabs.forEach(tab => {
                    tab.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        try {
                            const targetTab = this.getAttribute('data-tab');

                            // Update active tab
                            gspnetTabs.forEach(t => t.classList.remove('active'));
                            this.classList.add('active');

                            // Show target section
                            gspnetSections.forEach(section => {
                                section.classList.remove('active');
                                // Handle new tab IDs: file-csv-upload and dwg-dxf-upload
                                if (targetTab === 'file-csv-upload' && section.id === 'file-csv-upload-section') {
                                    section.classList.add('active');
                                } else if (targetTab === 'dwg-dxf-upload' && section.id === 'dwg-dxf-upload-section') {
                                    section.classList.add('active');
                                } else if (section.id === `${targetTab}-section`) {
                                    section.classList.add('active');
                                }
                            });
                        } catch (error) {
                            console.error('GSP.NET ASSIST: Error switching tab:', error);
                        }
                    });
                });
                console.log('GSP.NET ASSIST: Tab handlers attached', gspnetTabs.length);
            }

            // File upload functionality to Supabase - FIXED BUCKET NAME
            function setupFileUpload(fileInputId, browseBtnId, dropAreaId, fileNameId, filePreviewId, uploadBtnId, progressBarId, statusId, fileType) {
                const fileInput = document.getElementById(fileInputId);
                const browseBtn = document.getElementById(browseBtnId);
                const dropArea = document.getElementById(dropAreaId);
                const fileName = document.getElementById(fileNameId);
                const filePreview = document.getElementById(filePreviewId);
                const uploadBtn = document.getElementById(uploadBtnId);
                const progressBar = document.getElementById(progressBarId);
                const statusDiv = document.getElementById(statusId);

                // Check if elements exist before attaching listeners
                if (!fileInput || !browseBtn) {
                    console.warn(`setupFileUpload: Elements not found for ${fileInputId} or ${browseBtnId}`);
                    return;
                }

                browseBtn.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', function () {
                    if (this.files.length > 0) {
                        const file = this.files[0];

                        // Validate file type
                        if (fileType === 'csv' && !file.name.endsWith('.csv')) {
                            statusDiv.textContent = 'Error: Please select a CSV file';
                            statusDiv.className = 'upload-status error';
                            statusDiv.style.display = 'block';
                            return;
                        }

                        if (fileType === 'dxf' && !file.name.endsWith('.dxf')) {
                            statusDiv.textContent = 'Error: Please select a DXF file';
                            statusDiv.className = 'upload-status error';
                            statusDiv.style.display = 'block';
                            return;
                        }

                        fileName.textContent = file.name;
                        filePreview.style.display = 'flex';
                        statusDiv.style.display = 'none';
                    }
                });

                // Drag and drop functionality
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropArea.addEventListener(eventName, preventDefaults, false);
                });

                function preventDefaults(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                ['dragenter', 'dragover'].forEach(eventName => {
                    dropArea.addEventListener(eventName, highlight, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    dropArea.addEventListener(eventName, unhighlight, false);
                });

                function highlight() {
                    dropArea.style.borderColor = '#3498db';
                    dropArea.style.backgroundColor = '#e3f2fd';
                }

                function unhighlight() {
                    dropArea.style.borderColor = '#3498db';
                    dropArea.style.backgroundColor = '#f8f9fa';
                }

                dropArea.addEventListener('drop', handleDrop, false);

                function handleDrop(e) {
                    const dt = e.dataTransfer;
                    const files = dt.files;

                    if (files.length > 0) {
                        const file = files[0];

                        // Validate file type
                        if (fileType === 'csv' && !file.name.endsWith('.csv')) {
                            statusDiv.textContent = 'Error: Please drop a CSV file';
                            statusDiv.className = 'upload-status error';
                            statusDiv.style.display = 'block';
                            return;
                        }

                        if (fileType === 'dxf' && !file.name.endsWith('.dxf')) {
                            statusDiv.textContent = 'Error: Please drop a DXF file';
                            statusDiv.className = 'upload-status error';
                            statusDiv.style.display = 'block';
                            return;
                        }

                        fileInput.files = files;
                        fileName.textContent = file.name;
                        filePreview.style.display = 'flex';
                        statusDiv.style.display = 'none';
                    }
                }

                // Upload button functionality to Supabase - FIXED BUCKET NAME
                uploadBtn.addEventListener('click', async function () {
                    if (!fileInput.files.length) {
                        statusDiv.textContent = 'Error: Please select a file first';
                        statusDiv.className = 'upload-status error';
                        statusDiv.style.display = 'block';
                        return;
                    }

                    const file = fileInput.files[0];
                    const folder = fileType === 'csv' ? 'csv' : 'dxf';
                    const filePath = `${folder}/${Date.now()}_${file.name}`;

                    // Show upload indicator
                    const originalText = uploadBtn.innerHTML;
                    uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
                    uploadBtn.disabled = true;
                    progressBar.parentElement.style.display = 'block';
                    statusDiv.style.display = 'none';

                    try {
                        // FIX: Use the correct bucket name 'uploads' instead of 'webmap-uploads'
                        const { data, error } = await supabase.storage
                            .from('uploads')
                            .upload(filePath, file, {
                                cacheControl: '3600',
                                upsert: true
                            });

                        if (error) {
                            if (error.message.includes('permission') || error.message.includes('policy')) {
                                throw new Error('Upload blocked by bucket policy. Ask the admin to allow INSERT for \'anon\' on bucket uploads.');
                            }
                            throw error;
                        }

                        // Get public URL
                        const { data: urlData } = supabase.storage
                            .from('uploads')
                            .getPublicUrl(filePath);

                        statusDiv.textContent = `File uploaded successfully!`;
                        statusDiv.className = 'upload-status success';
                        statusDiv.style.display = 'block';
                        showToast(`File uploaded successfully to ${folder} folder!`, 'success');

                    } catch (error) {
                        console.error('Upload error:', error);
                        statusDiv.textContent = error.message || `Upload failed due to security restrictions. Please contact the administrator.`;
                        statusDiv.className = 'upload-status error';
                        statusDiv.style.display = 'block';
                        showToast('Upload failed. Please check your connection and try again.', 'error');
                    } finally {
                        // Reset form
                        progressBar.parentElement.style.display = 'none';
                        uploadBtn.innerHTML = originalText;
                        uploadBtn.disabled = false;
                    }
                });
            }

            // Setup CSV and DXF uploads to Supabase - FIXED BUCKET NAME
            // NOTE: Old CSV/DXF upload setup removed - now handled by Project Library
            // Only setup if old elements still exist (for backward compatibility)
            try {
                const oldDxfInput = document.getElementById('dxf-file-input');
                const oldDxfBrowse = document.getElementById('dxf-browse-btn');
                if (oldDxfInput && oldDxfBrowse) {
                    setupFileUpload('dxf-file-input', 'dxf-browse-btn', 'dxf-drop-area', 'dxf-file-name', 'dxf-file-preview', 'dxf-upload-btn', 'dxf-progress-bar', 'dxf-upload-status', 'dxf');
                }
            } catch (error) {
                console.warn('Old DXF upload setup skipped (elements replaced by Project Library):', error);
            }

            /*
             * PGFEATURESERV INTEGRATION
             * 
             * Features:
             * - Direct pg_featureserv OGC API Features calls
             * - Collection management and feature operations
             * - GSP.NET UPDATES using pg_featureserv for create/update operations
             * - Coordinate Extractor using pg_featureserv for snapping
             * - Standard GeoJSON POST/PUT operations
             * - Robust error handling for server responses
             */

            // Coordinate Extractor functionality
            let extractionActive = false;
            let extractedPoints = [];
            let pointCounter = 1;
            let snappingEnabled = false;
            let snappingTolerance = 5; // Default 5 meters
            let snappingMode = 'both'; // 'vertex', 'edge', or 'both'
            let validationEnabled = true;
            let selectedSnappingLayer = null;

            // Initialize snap interactions array
            if (!window.currentSnapInteractions) {
                window.currentSnapInteractions = [];
            }
            const extractorSource = new ol.source.Vector();
            const extractorLayer = new ol.layer.Vector({
                source: extractorSource,
                style: new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 6,
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 0, 0, 0.7)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'red',
                            width: 2
                        })
                    }),
                    text: new ol.style.Text({
                        text: '',
                        offsetY: -15,
                        font: 'bold 12px sans-serif',
                        fill: new ol.style.Fill({ color: 'red' }),
                        stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                    })
                })
            });
            map.addLayer(extractorLayer);

            // ============================================
            // WFS/WFS-T CONFIGURATION - Nginx Proxy Implementation
            // ============================================

            // GeoServer WFS Configuration via nginx proxy
            const GEOSERVER_PROXY_BASE = 'https://webmap.geospatialnetworkug.xyz/geoserver-proxy';
            const GEOSERVER_WFS_URL = `${GEOSERVER_PROXY_BASE}/geospatial_network/wfs`;
            const WORKSPACE = 'geospatial_network';
            const NAMESPACE_URI = 'gsp.net';
            const MAP_PROJ = 'EPSG:3857';                  // Map projection (Web Mercator)
            const WFS_VERSION = '1.1.0';                   // WFS version
            const FEATURE_SRS = 'EPSG:4326';               // Feature CRS

            // WFS Feature Types Configuration
            const WFS_LAYERS = {
                'control_points': {
                    name: 'Control Points',
                    type: 'Point',
                    srs: 'EPSG:4326'
                },
                'title_tracts_36n_lines': {
                    name: 'Title Tracts 36N Lines',
                    type: 'LineString',
                    srs: 'EPSG:4326'
                },
                'title_tracts_36n_poly': {
                    name: 'Title Tracts 36N Polygons',
                    type: 'Polygon',
                    srs: 'EPSG:4326'
                },
                'title_tracts_36s_lines': {
                    name: 'Title Tracts 36S Lines',
                    type: 'LineString',
                    srs: 'EPSG:4326'
                },
                'title_tracts_36s_poly': {
                    name: 'Title Tracts 36S Polygons',
                    type: 'Polygon',
                    srs: 'EPSG:4326'
                },
                'untitled_lines': {
                    name: 'Untitled Lines',
                    type: 'LineString',
                    srs: 'EPSG:4326'
                },
                'untitled_polygons': {
                    name: 'Untitled Polygons',
                    type: 'Polygon',
                    srs: 'EPSG:4326'
                }
            };

            // Global error logging
            window.addEventListener('error', (e) => {
                console.error('🚨 JS Error:', e.message, e.filename, e.lineno);
            });

            console.log('✅ WFS Configuration:', {
                proxyUrl: GEOSERVER_WFS_URL,
                workspace: WORKSPACE,
                namespace: NAMESPACE_URI,
                version: WFS_VERSION,
                featureSRS: FEATURE_SRS
            });

            // WFS CONFIG END
            // ============================================

            // ============================================
            // WFS/WFS-T IMPLEMENTATION - Clean Proxy-Based Solution
            // ============================================

            // Global variables for WFS editing
            let currentWFSLayer = null;
            let currentFeatureType = null;
            let wfsEditSource = null;

            // WFS GetFeature - Load features from GeoServer via proxy
            async function loadWFSFeatures(featureType) {
                try {
                    console.log('🌐 Loading WFS features for:', featureType);

                    const getFeatureUrl = `${GEOSERVER_WFS_URL}?service=WFS&version=${WFS_VERSION}&request=GetFeature&typeName=${WORKSPACE}:${featureType}&outputFormat=application/json&srsName=${FEATURE_SRS}`;
                    console.log('🔗 GetFeature URL:', getFeatureUrl);

                    const response = await fetch(getFeatureUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`WFS GetFeature failed: ${response.status} ${response.statusText}`);
                    }

                    const geojson = await response.json();
                    console.log('✅ WFS features loaded:', geojson.features?.length || 0);

                    return geojson;

                } catch (error) {
                    console.error('❌ WFS GetFeature error:', error);
                    showUserMessage(`Error loading features: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Create WFS layer and add to map
            function createWFSLayer(featureType) {
                const layerConfig = WFS_LAYERS[featureType];
                if (!layerConfig) {
                    throw new Error(`Unknown feature type: ${featureType}`);
                }

                console.log('🎨 Creating WFS layer:', layerConfig.name);

                // Create vector source
                wfsEditSource = new ol.source.Vector();

                // Create vector layer with appropriate styling
                let style;
                if (layerConfig.type === 'Point') {
                    style = new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#ff6b35' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                        })
                    });
                } else {
                    style = new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#ff6b35',
                            width: 3
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 107, 53, 0.2)'
                        })
                    });
                }

                currentWFSLayer = new ol.layer.Vector({
                    source: wfsEditSource,
                    style: style,
                    title: layerConfig.name
                });

                map.addLayer(currentWFSLayer);
                currentFeatureType = featureType;

                console.log('✅ WFS layer created and added to map');
                return currentWFSLayer;
            }

            // Load features into the WFS layer
            async function loadFeaturesIntoLayer(featureType) {
                try {
                    const geojson = await loadWFSFeatures(featureType);

                    if (!geojson.features || geojson.features.length === 0) {
                        console.log('⚠️ No features found in layer');
                        showUserMessage('No features found in layer', 'warning');
                        return;
                    }

                    // Parse GeoJSON and add to source
                    const format = new ol.format.GeoJSON({
                        dataProjection: FEATURE_SRS,
                        featureProjection: MAP_PROJ
                    });

                    const features = format.readFeatures(geojson);
                    wfsEditSource.addFeatures(features);

                    console.log('✅ Features added to layer:', features.length);
                    showUserMessage(`Loaded ${features.length} features`, 'success');

                    // Zoom to layer extent
                    if (features.length > 0) {
                        const extent = wfsEditSource.getExtent();
                        map.getView().fit(extent, { padding: [50, 50, 50, 50] });
                    }

                } catch (error) {
                    console.error('❌ Error loading features into layer:', error);
                    showUserMessage(`Error loading features: ${error.message}`, 'error');
                }
            }

            console.log('✅ WFS implementation loaded');
            // WFS IMPLEMENTATION END
            // ============================================

            // ============================================
            // WFS-T TRANSACTION IMPLEMENTATION - Insert/Update/Delete
            // ============================================

            // WFS-T Insert - Add new feature
            async function wfsInsert(featureType, geometry, properties = {}) {
                try {
                    console.log('➕ WFS-T Insert:', featureType);

                    const insertXML = buildWFSInsertXML(featureType, geometry, properties);
                    console.log('📝 Insert XML:', insertXML);

                    const response = await fetch(GEOSERVER_WFS_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml'
                        },
                        body: insertXML
                    });

                    const responseText = await response.text();
                    console.log('📨 Insert Response:', response.status, responseText);

                    if (!response.ok) {
                        throw new Error(`WFS-T Insert failed: ${response.status} ${response.statusText}`);
                    }

                    // Parse response to get new feature ID
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(responseText, 'text/xml');
                    const featureId = xmlDoc.getElementsByTagName('ogc:FeatureId')[0]?.getAttribute('fid');

                    console.log('✅ Feature inserted with ID:', featureId);
                    showUserMessage('Feature inserted successfully', 'success');

                    return { success: true, featureId: featureId };

                } catch (error) {
                    console.error('❌ WFS-T Insert error:', error);
                    showUserMessage(`Insert failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            // WFS-T Update - Modify existing feature
            async function wfsUpdate(featureType, featureId, geometry, properties = {}) {
                try {
                    console.log('✏️ WFS-T Update:', featureType, featureId);

                    const updateXML = buildWFSUpdateXML(featureType, featureId, geometry, properties);
                    console.log('📝 Update XML:', updateXML);

                    const response = await fetch(GEOSERVER_WFS_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml'
                        },
                        body: updateXML
                    });

                    const responseText = await response.text();
                    console.log('📨 Update Response:', response.status, responseText);

                    if (!response.ok) {
                        throw new Error(`WFS-T Update failed: ${response.status} ${response.statusText}`);
                    }

                    console.log('✅ Feature updated successfully');
                    showUserMessage('Feature updated successfully', 'success');

                    return { success: true };

                } catch (error) {
                    console.error('❌ WFS-T Update error:', error);
                    showUserMessage(`Update failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            // WFS-T Delete - Remove feature
            async function wfsDelete(featureType, featureId) {
                try {
                    console.log('🗑️ WFS-T Delete:', featureType, featureId);

                    const deleteXML = buildWFSDeleteXML(featureType, featureId);
                    console.log('📝 Delete XML:', deleteXML);

                    const response = await fetch(GEOSERVER_WFS_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml'
                        },
                        body: deleteXML
                    });

                    const responseText = await response.text();
                    console.log('📨 Delete Response:', response.status, responseText);

                    if (!response.ok) {
                        throw new Error(`WFS-T Delete failed: ${response.status} ${response.statusText}`);
                    }

                    console.log('✅ Feature deleted successfully');
                    showUserMessage('Feature deleted successfully', 'success');

                    return { success: true };

                } catch (error) {
                    console.error('❌ WFS-T Delete error:', error);
                    showUserMessage(`Delete failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            console.log('✅ WFS-T transaction functions loaded');
            // WFS-T TRANSACTION END
            // ============================================

            // ============================================
            // WFS-T XML BUILDERS - Proper Namespace Implementation
            // ============================================

            // Build WFS-T Insert XML
            function buildWFSInsertXML(featureType, geometry, properties = {}) {
                const geometryGML = geometryToGML(geometry, FEATURE_SRS);

                let xml = `<?xml version="1.0" encoding="UTF-8"?>
<wfs:Transaction service="WFS" version="${WFS_VERSION}" 
    xmlns:wfs="http://www.opengis.net/wfs" 
    xmlns:gml="http://www.opengis.net/gml" 
    xmlns:geospatial_network="${NAMESPACE_URI}" 
    xmlns:ogc="http://www.opengis.net/ogc">
    <wfs:Insert>
        <geospatial_network:${featureType}>`;

                // Add geometry
                xml += `<geospatial_network:geom>${geometryGML}</geospatial_network:geom>`;

                // Add properties
                Object.keys(properties).forEach(key => {
                    const value = escapeXml(properties[key]);
                    xml += `<geospatial_network:${key}>${value}</geospatial_network:${key}>`;
                });

                xml += `
        </geospatial_network:${featureType}>
    </wfs:Insert>
</wfs:Transaction>`;

                return xml;
            }

            // Build WFS-T Update XML
            function buildWFSUpdateXML(featureType, featureId, geometry, properties = {}) {
                const geometryGML = geometryToGML(geometry, FEATURE_SRS);

                let xml = `<?xml version="1.0" encoding="UTF-8"?>
<wfs:Transaction service="WFS" version="${WFS_VERSION}" 
    xmlns:wfs="http://www.opengis.net/wfs" 
    xmlns:gml="http://www.opengis.net/gml" 
    xmlns:geospatial_network="${NAMESPACE_URI}" 
    xmlns:ogc="http://www.opengis.net/ogc">
    <wfs:Update typeName="geospatial_network:${featureType}">`;

                // Add geometry update
                xml += `
        <wfs:Property>
            <wfs:Name>geom</wfs:Name>
            <wfs:Value>${geometryGML}</wfs:Value>
        </wfs:Property>`;

                // Add property updates
                Object.keys(properties).forEach(key => {
                    const value = escapeXml(properties[key]);
                    xml += `
        <wfs:Property>
            <wfs:Name>${key}</wfs:Name>
            <wfs:Value>${value}</wfs:Value>
        </wfs:Property>`;
                });

                // Add filter
                xml += `
        <ogc:Filter>
            <ogc:FeatureId fid="${WORKSPACE}.${featureType}.${featureId}"/>
        </ogc:Filter>
    </wfs:Update>
</wfs:Transaction>`;

                return xml;
            }

            // Build WFS-T Delete XML
            function buildWFSDeleteXML(featureType, featureId) {
                return `<?xml version="1.0" encoding="UTF-8"?>
<wfs:Transaction service="WFS" version="${WFS_VERSION}" 
    xmlns:wfs="http://www.opengis.net/wfs" 
    xmlns:ogc="http://www.opengis.net/ogc">
    <wfs:Delete typeName="geospatial_network:${featureType}">
        <ogc:Filter>
            <ogc:FeatureId fid="${WORKSPACE}.${featureType}.${featureId}"/>
        </ogc:Filter>
    </wfs:Delete>
</wfs:Transaction>`;
            }

            // Convert OpenLayers geometry to GML
            function geometryToGML(geometry, srs) {
                const coords = geometry.getCoordinates();
                const type = geometry.getType();

                let gml = '';

                if (type === 'Point') {
                    gml = `<gml:Point srsName="${srs}"><gml:pos>${coords[0]} ${coords[1]}</gml:pos></gml:Point>`;
                } else if (type === 'LineString') {
                    gml = `<gml:LineString srsName="${srs}"><gml:posList>`;
                    coords.forEach(coord => {
                        gml += `${coord[0]} ${coord[1]} `;
                    });
                    gml += `</gml:posList></gml:LineString>`;
                } else if (type === 'Polygon') {
                    gml = `<gml:Polygon srsName="${srs}"><gml:exterior><gml:LinearRing><gml:posList>`;
                    coords[0].forEach(coord => {
                        gml += `${coord[0]} ${coord[1]} `;
                    });
                    gml += `</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>`;
                }

                return gml;
            }

            // Escape XML special characters
            function escapeXml(unsafe) {
                if (unsafe == null) return '';
                return String(unsafe)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }

            console.log('✅ WFS-T XML builders loaded');
            // WFS-T XML BUILDERS END
            // ============================================

            // ============================================
            // EDITING INTERACTIONS - Modify/Draw/Delete
            // ============================================

            // Global interaction variables
            let modifyInteraction = null;
            let drawInteraction = null;

            // Start editing mode
            function startWFSEditing() {
                if (!currentWFSLayer || !wfsEditSource) {
                    showUserMessage('Please load a WFS layer first', 'error');
                    return;
                }

                console.log('🎨 Starting WFS editing mode');

                // Remove existing interactions
                stopWFSEditing();

                // Add modify interaction
                modifyInteraction = new ol.interaction.Modify({
                    source: wfsEditSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: '#ff0000', width: 3 }),
                        fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.2)' })
                    })
                });

                // Track modifications
                modifyInteraction.on('modifyend', function (event) {
                    const features = event.features.getArray();
                    features.forEach(feature => {
                        console.log('📝 Feature modified:', feature.getId());
                        showUserMessage('Feature modified - click Save to commit changes', 'info');
                    });
                });

                map.addInteraction(modifyInteraction);
                showUserMessage('Editing mode active - click features to modify', 'success');
            }

            // Stop editing mode
            function stopWFSEditing() {
                console.log('🛑 Stopping WFS editing mode');

                if (modifyInteraction) {
                    map.removeInteraction(modifyInteraction);
                    modifyInteraction = null;
                }

                if (drawInteraction) {
                    map.removeInteraction(drawInteraction);
                    drawInteraction = null;
                }

                showUserMessage('Editing mode stopped', 'info');
            }

            // Add new feature (draw mode)
            function startDrawingNewFeature() {
                if (!currentWFSLayer || !wfsEditSource) {
                    showUserMessage('Please load a WFS layer first', 'error');
                    return;
                }

                const layerConfig = WFS_LAYERS[currentFeatureType];
                if (!layerConfig) {
                    showUserMessage('Unknown feature type', 'error');
                    return;
                }

                console.log('✏️ Starting draw mode for:', layerConfig.type);

                // Remove existing interactions
                stopWFSEditing();

                // Create draw interaction
                drawInteraction = new ol.interaction.Draw({
                    source: wfsEditSource,
                    type: layerConfig.type,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: '#00ff00', width: 3 }),
                        fill: new ol.style.Fill({ color: 'rgba(0, 255, 0, 0.2)' })
                    })
                });

                // Handle draw end
                drawInteraction.on('drawend', function (event) {
                    const feature = event.feature;
                    console.log('✏️ New feature drawn:', feature);
                    showUserMessage('New feature drawn - click Save to commit', 'success');
                });

                map.addInteraction(drawInteraction);
                showUserMessage(`Draw mode active - draw ${layerConfig.type.toLowerCase()}`, 'success');
            }

            // Save all changes to GeoServer
            async function saveWFSChanges() {
                if (!currentWFSLayer || !wfsEditSource || !currentFeatureType) {
                    showUserMessage('No WFS layer loaded for saving', 'error');
                    return;
                }

                try {
                    console.log('💾 Saving WFS changes...');

                    const features = wfsEditSource.getFeatures();
                    let savedCount = 0;

                    for (const feature of features) {
                        const featureId = feature.getId();
                        const geometry = feature.getGeometry();
                        const properties = feature.getProperties();

                        // Remove OpenLayers internal properties
                        delete properties.geometry;

                        if (featureId && featureId.includes('.')) {
                            // Existing feature - update
                            const id = featureId.split('.').pop();
                            await wfsUpdate(currentFeatureType, id, geometry, properties);
                            savedCount++;
                        } else {
                            // New feature - insert
                            await wfsInsert(currentFeatureType, geometry, properties);
                            savedCount++;
                        }
                    }

                    console.log('✅ All changes saved:', savedCount);
                    showUserMessage(`Saved ${savedCount} changes successfully`, 'success');

                    // Refresh layer
                    await refreshWFSLayer();

                } catch (error) {
                    console.error('❌ Error saving WFS changes:', error);
                    showUserMessage(`Save failed: ${error.message}`, 'error');
                }
            }

            // Refresh WFS layer from GeoServer
            async function refreshWFSLayer() {
                if (!currentFeatureType) return;

                try {
                    console.log('🔄 Refreshing WFS layer...');

                    // Clear current features
                    wfsEditSource.clear();

                    // Reload features
                    await loadFeaturesIntoLayer(currentFeatureType);

                    console.log('✅ WFS layer refreshed');

                } catch (error) {
                    console.error('❌ Error refreshing WFS layer:', error);
                    showUserMessage(`Refresh failed: ${error.message}`, 'error');
                }
            }

            console.log('✅ Editing interactions loaded');
            // EDITING INTERACTIONS END
            // ============================================

            // ============================================
            // USER INTERFACE FUNCTIONS
            // ============================================

            // Show user message on map
            function showUserMessage(message, type = 'info') {
                console.log(`💬 ${type.toUpperCase()}: ${message}`);

                // Create or update message element
                let messageEl = document.getElementById('wfs-user-message');
                if (!messageEl) {
                    messageEl = document.createElement('div');
                    messageEl.id = 'wfs-user-message';
                    messageEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 5px;
                    color: white;
                    font-weight: bold;
                    z-index: 10000;
                    max-width: 300px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;
                    document.body.appendChild(messageEl);
                }

                // Set message and style based on type
                messageEl.textContent = message;
                messageEl.style.backgroundColor = {
                    'success': '#27ae60',
                    'error': '#e74c3c',
                    'warning': '#f39c12',
                    'info': '#3498db'
                }[type] || '#3498db';

                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (messageEl && messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 5000);
            }

            // Load WFS layer with UI feedback
            async function loadWFSLayer(featureType) {
                try {
                    showUserMessage('Loading WFS layer...', 'info');

                    // Remove existing layer
                    if (currentWFSLayer) {
                        map.removeLayer(currentWFSLayer);
                        stopWFSEditing();
                    }

                    // Create and load new layer
                    createWFSLayer(featureType);
                    await loadFeaturesIntoLayer(featureType);

                    showUserMessage(`${WFS_LAYERS[featureType].name} loaded successfully`, 'success');

                } catch (error) {
                    console.error('❌ Error loading WFS layer:', error);
                    showUserMessage(`Error loading layer: ${error.message}`, 'error');
                }
            }

            console.log('✅ User interface functions loaded');
            // USER INTERFACE END
            // ============================================

            // ============================================
            // WFS TEST FUNCTIONS AND GLOBAL API
            // ============================================

            // Test WFS functionality
            async function testWFS() {
                try {
                    console.log('🧪 Testing WFS implementation...');

                    // Test with control_points layer
                    await loadWFSLayer('control_points');

                    console.log('✅ WFS test completed');

                } catch (error) {
                    console.error('❌ WFS test failed:', error);
                    showUserMessage(`WFS test failed: ${error.message}`, 'error');
                }
            }

            // Test WFS-T Insert
            async function testWFSInsert() {
                try {
                    console.log('🧪 Testing WFS-T Insert...');

                    if (!currentFeatureType) {
                        await loadWFSLayer('control_points');
                    }

                    // Create a test point
                    const testPoint = new ol.geom.Point([32.6, 0.35]); // Uganda coordinates
                    const testProperties = {
                        name: 'Test Point',
                        description: 'Created by WFS-T test'
                    };

                    await wfsInsert(currentFeatureType, testPoint, testProperties);
                    console.log('✅ WFS-T Insert test completed');

                } catch (error) {
                    console.error('❌ WFS-T Insert test failed:', error);
                    showUserMessage(`Insert test failed: ${error.message}`, 'error');
                }
            }

            // Make functions globally available for testing
            window.WFS = {
                // Configuration
                config: {
                    proxyUrl: GEOSERVER_WFS_URL,
                    workspace: WORKSPACE,
                    namespace: NAMESPACE_URI,
                    layers: WFS_LAYERS
                },

                // Layer functions
                loadLayer: loadWFSLayer,
                refreshLayer: refreshWFSLayer,

                // Editing functions
                startEditing: startWFSEditing,
                stopEditing: stopWFSEditing,
                startDrawing: startDrawingNewFeature,
                saveChanges: saveWFSChanges,

                // WFS-T functions
                insert: wfsInsert,
                update: wfsUpdate,
                delete: wfsDelete,

                // Test functions
                test: testWFS,
                testInsert: testWFSInsert,

                // Utility
                showMessage: showUserMessage
            };

            console.log('✅ WFS API available globally: window.WFS');
            console.log('📖 Available functions:', Object.keys(window.WFS));

            // WFS TEST AND API END
            // ============================================

            // EDITABLE LAYERS CONFIGURATION - Only these 7 layers from GeoServer
            // CRS values extracted from WFS GetCapabilities response
            const EDITABLE_LAYERS = [
                {
                    name: "Title Tracts 36N Lines 📏",
                    id: "geospatial_network:title_tracts_36n_lines",
                    shortId: "title_tracts_36n_lines",
                    geomType: "LineString",
                    crs: "EPSG:21096",  // UTM Zone 36N
                    geometryName: "geom"
                },
                {
                    name: "Title Tracts 36N Polygons 📐",
                    id: "geospatial_network:title_tracts_36n_poly",
                    shortId: "title_tracts_36n_poly",
                    geomType: "Polygon",
                    crs: "EPSG:21096",  // UTM Zone 36N
                    geometryName: "geom"
                },
                {
                    name: "Title Tracts 36S Lines 📏",
                    id: "geospatial_network:title_tracts_36s_lines",
                    shortId: "title_tracts_36s_lines",
                    geomType: "LineString",
                    crs: "EPSG:21036",  // UTM Zone 36S
                    geometryName: "geom"
                },
                {
                    name: "Title Tracts 36S Polygons 📐",
                    id: "geospatial_network:title_tracts_36s_poly",
                    shortId: "title_tracts_36s_poly",
                    geomType: "Polygon",
                    crs: "EPSG:21036",  // UTM Zone 36S
                    geometryName: "geom"
                },
                {
                    name: "Untitled Lines 📏",
                    id: "geospatial_network:untitled_lines",
                    shortId: "untitled_lines",
                    geomType: "LineString",
                    crs: "EPSG:32636",  // WGS 84 / UTM zone 36N
                    geometryName: "geom"
                },
                {
                    name: "Untitled Polygons 📐",
                    id: "geospatial_network:untitled_polygons",
                    shortId: "untitled_polygons",
                    geomType: "Polygon",
                    crs: "EPSG:32636",  // WGS 84 / UTM zone 36N
                    geometryName: "geom"
                },
                {
                    name: "Control Points 📍",
                    id: "geospatial_network:control_points",
                    shortId: "control_points",
                    geomType: "Point",
                    crs: "EPSG:4326",  // WGS 84 Geographic
                    geometryName: "geom"
                }
            ];

            // Editable layer IDs for quick filtering
            const EDITABLE_LAYER_IDS = EDITABLE_LAYERS.map(l => l.id);

            // ========================================
            //  EDITING SESSION STATE MANAGEMENT
            // ========================================
            const editingSession = {
                active: false,
                layerId: null,
                layerConfig: null,
                schema: null,
                editBuffer: {
                    adds: [],
                    updates: [],
                    deletes: []
                },
                referenceLayer: null,
                previewLayer: null,
                editLayer: null,
                interactions: {
                    draw: null,
                    modify: null,
                    select: null,
                    snap: []
                },
                currentDrawMode: null, // 'Point', 'LineString', or 'Polygon'
                selectedFeatures: []
            };

            // Snapping configuration
            const snappingConfig = {
                enabled: true,
                snapToCSV: true,
                snapToVertices: true,
                snapToEdges: true,
                tolerance: 10 // pixels
            };

            // Small helper to show confirm modal
            async function confirmDialog(message) {
                return confirm(message);
            }

            // Simple toast notification
            function showToast(msg, type = 'info') {
                const t = document.createElement('div');
                t.className = `toast-notification ${type}`;
                t.textContent = msg;
                t.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10000;
                padding: 12px 20px; border-radius: 6px; color: white; font-weight: 600;
                background: ${type === 'error' ? '#e74c3c' : type === 'success' ? '#27ae60' : type === 'warning' ? '#f39c12' : '#3498db'};
                box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 300px;
            `;
                document.body.appendChild(t);
                setTimeout(() => { t.remove(); }, 4000);
            }

            // Fetch list of collections from pg_featureserv
            async function fetchCollections() {
                try {
                    const resp = await fetch(`${pgfBaseUrl}/collections`);
                    if (!resp.ok) throw new Error('Failed to list collections: ' + resp.statusText);
                    const json = await resp.json();
                    return (json.collections || []).map(c => ({
                        id: c.id,
                        title: c.title || c.id,
                        description: c.description || ''
                    }));
                } catch (error) {
                    console.error('Error fetching collections:', error);
                    throw error;
                }
            }

            // Create a vector layer for a collection
            function createPgCollectionLayer(collectionId, options = {}) {
                const source = new ol.source.Vector({
                    format: new ol.format.GeoJSON(),
                    url: `${pgfBaseUrl}/collections/${encodeURIComponent(collectionId)}/items?limit=10000`,
                    strategy: ol.loadingstrategy.bbox
                });

                return new ol.layer.Vector({
                    source,
                    visible: options.visible !== undefined ? options.visible : true,
                    style: options.style || defaultPreviewStyle()
                });
            }

            // Default preview style for collections
            function defaultPreviewStyle() {
                return new ol.style.Style({
                    stroke: new ol.style.Stroke({ color: '#3498db', width: 2 }),
                    fill: new ol.style.Fill({ color: 'rgba(52,152,219,0.08)' }),
                    image: new ol.style.Circle({
                        radius: 6,
                        fill: new ol.style.Fill({ color: '#e74c3c' }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                    })
                });
            }

            // Snapping style for coordinate extractor
            function snappingStyle() {
                return new ol.style.Style({
                    stroke: new ol.style.Stroke({ color: '#f39c12', width: 2, lineDash: [5, 5] }),
                    fill: new ol.style.Fill({ color: 'rgba(243,156,18,0.1)' }),
                    image: new ol.style.Circle({
                        radius: 4,
                        fill: new ol.style.Fill({ color: '#f39c12' }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                    })
                });
            }

            // Create preview layer for GSP.NET UPDATES
            function createPreviewLayer(collectionId) {
                const source = createPgfsBboxSource(`${pgfBaseUrl}/collections/${collectionId}`);
                const layer = new ol.layer.Vector({
                    source: source,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: '#3498db', width: 1 }),
                        fill: new ol.style.Fill({ color: 'rgba(52,152,219,0.1)' }),
                        image: new ol.style.Circle({
                            radius: 3,
                            fill: new ol.style.Fill({ color: '#3498db' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                        })
                    }),
                    visible: true,
                    title: `Preview: ${collectionId}`
                });

                return layer;
            }

            // Convert OL features to GeoJSON FeatureCollection
            function featuresToGeoJSON(features) {
                const format = new ol.format.GeoJSON();
                return format.writeFeaturesObject(features, {
                    featureProjection: map.getView().getProjection(),
                    dataProjection: SERVER_PROJ
                });
            }

            // Utility: BBOX loader for PG-FeatureServer (OpenLayers source factory)
            function createPgfsBboxSource(pgfsEndpoint, outFields = '*') {
                const format = new ol.format.GeoJSON();
                const source = new ol.source.Vector({
                    format: format,
                    loader: function (extent, resolution, projection) {
                        // Convert extent from map projection to server projection
                        const mapProj = projection.getCode() || MAP_PROJ;
                        let bbox;
                        if (mapProj !== SERVER_PROJ) {
                            const ll = ol.proj.transform([extent[0], extent[1]], mapProj, SERVER_PROJ);
                            const ur = ol.proj.transform([extent[2], extent[3]], mapProj, SERVER_PROJ);
                            bbox = [ll[0], ll[1], ur[0], ur[1]];
                        } else {
                            bbox = [extent[0], extent[1], extent[2], extent[3]];
                        }

                        // Build PGFS query (ArcGIS REST style) returning GeoJSON
                        const url = `${pgfsEndpoint}/items?f=geojson` +
                            `&geometry=${bbox.join(',')}&geometryType=esriGeometryEnvelope&inSR=${SERVER_PROJ.split(':')[1]}` +
                            `&spatialRel=esriSpatialRelIntersects&outFields=${encodeURIComponent(outFields)}` +
                            `&resultRecordCount=${DEFAULT_LIMIT}`;

                        fetch(url)
                            .then(res => {
                                if (!res.ok) {
                                    throw new Error(`PGFS bbox load failed: ${res.status} ${res.statusText}`);
                                }
                                return res.json();
                            })
                            .then(geojson => {
                                if (!geojson || !geojson.features) {
                                    console.warn('No features returned from PG-FeatureServer');
                                    return;
                                }
                                const feats = format.readFeatures(geojson, {
                                    dataProjection: SERVER_PROJ,
                                    featureProjection: mapProj
                                });
                                // Set property for layer identification
                                feats.forEach(f => f.set('_pgfsEndpoint', pgfsEndpoint));
                                source.addFeatures(feats);
                                console.log(`Loaded ${feats.length} features from ${pgfsEndpoint}`);
                            })
                            .catch(err => {
                                console.error('createPgfsBboxSource error', err);
                                // Don't show toast for every failed request to avoid spam
                                if (err.message.includes('Failed to fetch')) {
                                    console.warn('Network error - server may be unavailable');
                                } else {
                                    showToast('Failed to load features: ' + err.message, 'error');
                                }
                            });
                    },
                    strategy: ol.loadingstrategy.bbox
                });

                return source;
            }

            // PGFEATURESERV LAYER MANAGEMENT (Legacy - not used with FlatGeobuf)
            const pgfBaseUrl = ''; // Not used - FlatGeobuf layers are used instead
            let pgfSnapLayer = null;
            let pgfPreviewLayer = null;
            let pgfEditLayer = null;
            let pgfEditSource = null;

            // Drawing and search sources for snapping (declared globally above)

            // Global snap interaction variables
            let snapInteraction = null;
            let snapTolerance = 10;
            let snappingPopup = null;

            // Global variables to manage state
            let currentEditable = null;           // { layer, source, config }
            let currentEditableSource = null;     // Current editable layer source
            let selectInteraction = null;
            let snapInteractions = [];            // list of snap interactions (one per source)
            let editBuffers = { adds: [], updates: [], deletes: [] };

            // Legacy edit buffer variables for compatibility
            let toAdd = [];
            let toUpdate = [];
            let toDelete = [];

            // Control points and CSV sources for snapping
            let controlPointsSource = null;
            let csvPointsSource = null;

            // PGFEATURESERV LAYER DROPDOWN MANAGEMENT
            const pgfLayerSelector = document.getElementById('coordExtractorLayerSelect');
            const pgfLayerUpdates = document.getElementById('gspnetUpdatesLayerSelect');

            // Function to populate pg_featureserv collections in dropdowns
            async function populatePgfLayerDropdowns() {
                const loadingIndicator = document.getElementById('pgf-loading-indicator');
                const statusText = document.getElementById('coord-status-text');

                loadingIndicator.style.display = 'inline-block';
                statusText.textContent = 'Loading pg_featureserv collections...';

                try {
                    const collections = await fetchCollections();

                    // Clear existing options (except the first one)
                    while (pgfLayerSelector.options.length > 1) {
                        pgfLayerSelector.remove(1);
                    }
                    while (pgfLayerUpdates.options.length > 1) {
                        pgfLayerUpdates.remove(1);
                    }

                    // Add ALL collections to coordinate extractor dropdown (for preview/snapping)
                    collections.forEach(collection => {
                        const option = document.createElement('option');
                        option.value = collection.id;
                        option.textContent = `${collection.title} (${collection.id})`;
                        pgfLayerSelector.appendChild(option);
                    });

                    // Add ONLY the 7 hardcoded editable layers to GSP.NET UPDATES dropdown
                    EDITABLE_LAYERS.forEach(layer => {
                        const option = document.createElement('option');
                        option.value = layer.id;
                        option.textContent = layer.name;
                        pgfLayerUpdates.appendChild(option);
                    });

                    statusText.textContent = `pg_featureserv collections loaded (${collections.length})`;
                    showToast(`pg_featureserv collections loaded (${collections.length})`, 'success');

                } catch (error) {
                    console.error('Failed to load pg_featureserv collections:', error);
                    statusText.textContent = 'Failed to load pg_featureserv collections';
                    showToast('Failed to load pg_featureserv collections: ' + error.message, 'error');
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }

            // Function to fetch pg_featureserv collections and populate dropdowns
            async function fetchPgfCapabilities() {
                return await populatePgfLayerDropdowns();
            }

            // Create editable OL layer for a chosen config entry
            function createEditableLayer(cfg) {
                // 1) create source (loader by bbox)
                const source = createPgfsBboxSource(cfg.endpoint, '*');

                // 2) create vector layer
                const layer = new ol.layer.Vector({
                    source: source,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: '#e74c3c', width: 2 }),
                        fill: new ol.style.Fill({ color: 'rgba(231, 76, 60, 0.1)' }),
                        image: new ol.style.Circle({
                            radius: 6,
                            fill: new ol.style.Fill({ color: '#e74c3c' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                        })
                    }),
                    zIndex: 1000
                });

                // 3) add to map
                map.addLayer(layer);

                // 4) interactions
                // ensure select exists
                if (selectInteraction) { map.removeInteraction(selectInteraction); selectInteraction = null; }
                selectInteraction = new ol.interaction.Select({ layers: [layer] });
                map.addInteraction(selectInteraction);

                if (modifyInteraction) { map.removeInteraction(modifyInteraction); modifyInteraction = null; }
                modifyInteraction = new ol.interaction.Modify({ features: selectInteraction.getFeatures() });
                map.addInteraction(modifyInteraction);

                // Remove old draw if exists
                if (drawInteraction) { map.removeInteraction(drawInteraction); drawInteraction = null; }

                // NOTE: Draw interaction is now created on-demand by mode buttons
                // This prevents conflicts and allows user to choose geometry type
                // See startDrawing() function for draw interaction creation

                // when modifying an existing feature -> buffer update
                modifyInteraction.on('modifyend', evt => {
                    evt.features.getArray().forEach(f => {
                        if (f.get('_pgfs_state') !== 'new') f.set('_pgfs_state', 'modified');
                        if (!editBuffers.updates.includes(f)) editBuffers.updates.push(f);
                    });
                });

                // remove selection or deletion logic to mark deletes (example delete key)
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        const features = selectInteraction.getFeatures().getArray().slice();
                        features.forEach(f => {
                            f.set('_pgfs_state', 'deleted');
                            if (!editBuffers.deletes.includes(f)) editBuffers.deletes.push(f);
                            // remove visually
                            source.removeFeature(f);
                        });
                        selectInteraction.getFeatures().clear();
                    }
                });

                // store current
                currentEditable = { layer, source, cfg };
                currentEditableSource = source;

                // Also store in editingSession for new QGIS-like editing
                editingSession.editLayer = layer;
                editingSession.previewLayer = layer; // For compatibility

                // Attach snapping (fix for Snap.js error — use source, not layer)
                // TEMPORARILY DISABLED DURING TESTING
                if (!window.snappingDisabled) {
                    const snapSources = [source];
                    if (controlPointsSource) snapSources.push(controlPointsSource);
                    if (csvPointsSource) snapSources.push(csvPointsSource);
                    safeAttachSnappingToCurrent(snapSources);
                } else {
                    console.log('Snapping disabled during testing');
                }

                // return object for reference
                return currentEditable;
            }

            // Ultra-strict source validation for snap interactions
            function isValidVectorSource(source) {
                if (!source) {
                    console.warn('isValidVectorSource: null/undefined source');
                    return false;
                }

                // Check if it's actually an OpenLayers source by checking for specific properties
                if (!source.constructor ||
                    !source.constructor.name ||
                    !source.constructor.name.includes('Vector') ||
                    source.constructor.name === 'Object' ||
                    source.constructor.name === 'uc') {
                    console.warn('isValidVectorSource: not a valid Vector source', source, 'constructor:', source.constructor?.name);
                    return false;
                }

                // Check if it's an instance of ol.source.Vector
                if (!(source instanceof ol.source.Vector)) {
                    console.warn('isValidVectorSource: not an instance of ol.source.Vector', source);
                    return false;
                }

                // Check if it has the required methods
                const requiredMethods = ['getFeatures', 'addFeature', 'removeFeature', 'clear', 'get'];
                for (const method of requiredMethods) {
                    if (!source[method] || typeof source[method] !== 'function') {
                        console.warn(`isValidVectorSource: source missing method '${method}'`, source);
                        return false;
                    }
                }

                // Test if getFeatures actually works and returns an array
                try {
                    const features = source.getFeatures();
                    if (!Array.isArray(features)) {
                        console.warn('isValidVectorSource: getFeatures does not return an array', source);
                        return false;
                    }
                    console.log(`isValidVectorSource: validation passed for source with ${features.length} features`);
                    return true;
                } catch (error) {
                    console.warn('isValidVectorSource: getFeatures method failed', error, source);
                    return false;
                }
            }

            // Create a safe snap interaction that won't fail
            function createSafeSnapInteraction(source) {
                try {
                    // Final validation before creating snap interaction
                    if (!isValidVectorSource(source)) {
                        console.error('createSafeSnapInteraction: invalid source provided', source);
                        return null;
                    }

                    // Test getFeatures one more time right before creating the interaction
                    const testFeatures = source.getFeatures();
                    if (!Array.isArray(testFeatures)) {
                        console.error('createSafeSnapInteraction: getFeatures test failed', source);
                        return null;
                    }

                    const snap = new ol.interaction.Snap({
                        source: source,
                        pixelTolerance: 10,
                        vertex: true,
                        edge: true
                    });

                    console.log('createSafeSnapInteraction: snap interaction created successfully');
                    return snap;
                } catch (error) {
                    console.error('createSafeSnapInteraction: failed to create snap interaction', error, source);
                    return null;
                }
            }

            // Debug function to identify invalid sources
            function debugSourceInfo(source, label = '') {
                console.log(`DEBUG SOURCE ${label}:`, {
                    source: source,
                    constructor: source?.constructor?.name,
                    isVector: source instanceof ol.source.Vector,
                    hasGetFeatures: typeof source?.getFeatures === 'function',
                    type: typeof source,
                    keys: source ? Object.keys(source) : 'N/A'
                });
            }

            // Ultra-safe wrapper for attachSnappingToCurrent that validates sources before calling
            function safeAttachSnappingToCurrent(sourceList = []) {
                console.log('safeAttachSnappingToCurrent called with sources:', sourceList);

                // Debug each source
                sourceList.forEach((src, index) => {
                    debugSourceInfo(src, `Source ${index + 1}`);
                });

                // First, check if we should disable snapping completely
                // Process all valid sources

                // Pre-filter sources with ultra-strict validation
                const cleanSources = sourceList.filter(src => {
                    if (!src) {
                        console.warn('safeAttachSnappingToCurrent: null/undefined source filtered out');
                        return false;
                    }

                    // Check constructor name to filter out invalid objects like 'uc'
                    if (src.constructor && src.constructor.name === 'uc') {
                        console.warn('safeAttachSnappingToCurrent: invalid source object "uc" filtered out', src);
                        return false;
                    }

                    // Check if it's an OpenLayers source
                    if (!(src instanceof ol.source.Vector)) {
                        console.warn('safeAttachSnappingToCurrent: not an ol.source.Vector instance', src);
                        return false;
                    }

                    // Ensure it's a proper OpenLayers source
                    if (!src.getFeatures || typeof src.getFeatures !== 'function') {
                        console.warn('safeAttachSnappingToCurrent: source missing getFeatures method', src);
                        return false;
                    }

                    // Test getFeatures method
                    try {
                        const features = src.getFeatures();
                        if (!Array.isArray(features)) {
                            console.warn('safeAttachSnappingToCurrent: getFeatures does not return array', src);
                            return false;
                        }
                        return true;
                    } catch (error) {
                        console.warn('safeAttachSnappingToCurrent: getFeatures test failed', error, src);
                        return false;
                    }
                });

                if (cleanSources.length === 0) {
                    console.warn('safeAttachSnappingToCurrent: no valid sources provided');
                    return;
                }

                // Call the actual function with cleaned sources
                try {
                    attachSnappingToCurrent(cleanSources);
                } catch (error) {
                    console.error('safeAttachSnappingToCurrent: error in attachSnappingToCurrent', error);
                    // Disable snapping to prevent further errors
                    window.snappingDisabled = true;
                    disableSnappingCompletely();
                }
            }

            // Bulletproof snapping function that will never cause Snap.js errors
            function attachSnappingToCurrent(sourceList = []) {
                // Remove existing snap interactions
                snapInteractions.forEach(si => {
                    try {
                        map.removeInteraction(si);
                    } catch (error) {
                        console.warn('Error removing snap interaction:', error);
                    }
                });
                snapInteractions = [];

                console.log('attachSnappingToCurrent called with sources:', sourceList);

                if (!sourceList || sourceList.length === 0) {
                    console.warn('attachSnappingToCurrent: no sources provided');
                    return;
                }

                // Filter and validate sources
                const validSources = sourceList.filter(src => {
                    if (!src) {
                        console.warn('attachSnappingToCurrent: null/undefined source filtered out');
                        return false;
                    }

                    // Check if it's a proper OpenLayers source
                    if (!src.getFeatures || typeof src.getFeatures !== 'function') {
                        console.warn('attachSnappingToCurrent: source missing getFeatures method', src);
                        return false;
                    }

                    // Test getFeatures method
                    try {
                        const features = src.getFeatures();
                        if (!Array.isArray(features)) {
                            console.warn('attachSnappingToCurrent: getFeatures does not return array', src);
                            return false;
                        }
                        return true;
                    } catch (error) {
                        console.warn('attachSnappingToCurrent: getFeatures test failed', error, src);
                        return false;
                    }
                });

                console.log('Creating snap interactions for valid sources:', validSources.length);

                if (validSources.length === 0) {
                    console.warn('attachSnappingToCurrent: no valid sources provided, skipping snap interaction creation');
                    return;
                }

                // Create snap interactions using the safe method
                validSources.forEach((src, index) => {
                    // Final debug check
                    debugSourceInfo(src, `Final Check ${index + 1}`);

                    const snap = createSafeSnapInteraction(src);
                    if (snap) {
                        try {
                            map.addInteraction(snap);
                            snapInteractions.push(snap);
                            console.log(`Snap interaction ${index + 1} created successfully`);
                        } catch (error) {
                            console.error(`Error adding snap interaction ${index + 1} to map:`, error);
                            // If adding to map fails, remove it from our array
                            const snapIndex = snapInteractions.indexOf(snap);
                            if (snapIndex > -1) {
                                snapInteractions.splice(snapIndex, 1);
                            }
                        }
                    } else {
                        console.error(`Failed to create snap interaction ${index + 1} for source:`, src);
                    }
                });
            }

            // Set up click handlers for editing workflow
            function setupEditingClickHandlers() {
                // Disable double-click zoom
                map.getInteractions().forEach(i => {
                    if (i instanceof ol.interaction.DoubleClickZoom) {
                        i.setActive(false);
                    }
                });

                // Single click - select feature for editing
                map.on('singleclick', function (evt) {
                    if (!isEditing || !currentEditable) return;

                    const feature = map.forEachFeatureAtPixel(evt.pixel, function (f) {
                        return f.getLayer() === currentEditable.layer ? f : null;
                    });

                    if (feature) {
                        selectInteraction.getFeatures().clear();
                        selectInteraction.getFeatures().push(feature);
                        showToast('Feature selected for editing', 'info');
                    }
                });

                // Double click - open attribute form
                map.on('dblclick', function (evt) {
                    if (!isEditing || !currentEditable) return;

                    const feature = selectInteraction.getFeatures().item(0);
                    if (feature) {
                        openAttributeForm(feature);
                    }
                });
            }

            // Clear editing interactions
            function clearEditingInteractions() {
                if (selectInteraction) {
                    map.removeInteraction(selectInteraction);
                    selectInteraction = null;
                }
                if (modifyInteraction) {
                    map.removeInteraction(modifyInteraction);
                    modifyInteraction = null;
                }
                if (drawInteraction) {
                    map.removeInteraction(drawInteraction);
                    drawInteraction = null;
                }
                snapInteractions.forEach(si => map.removeInteraction(si));
                snapInteractions = [];
                if (currentEditable && currentEditable.layer) {
                    map.removeLayer(currentEditable.layer);
                    currentEditable = null;
                }
                isEditing = false;
                currentEditingLayer = null;
            }

            // prevent default doubleClickZoom if present
            map.getInteractions().forEach(i => {
                if (i instanceof ol.interaction.DoubleClickZoom) i.setActive(false);
            });

            // map dblclick to open attributes for selected feature
            map.on('dblclick', function (evt) {
                if (selectInteraction && selectInteraction.getFeatures) {
                    const f = selectInteraction.getFeatures().item(0);
                    if (f) {
                        // finish editing if in draw mode: nothing extra needed for Modify
                        openAttributeForm(f);
                    }
                }
            });

            function openAttributeForm(feature) {
                // Build form dynamically from feature.getProperties() minus internal fields
                const props = feature.getProperties();
                // Remove geometry key (if present) and internal fields
                delete props.geometry;
                delete props.geometryName;

                // Build HTML form (simple example)
                const panel = document.querySelector('.gspnet-updates-form-panel');
                panel.innerHTML = '<h4>Edit attributes</h4>';
                const form = document.createElement('form');
                for (const k in props) {
                    if (k.startsWith('_pgfs')) continue; // internal
                    const group = document.createElement('div');
                    group.className = 'form-group';
                    group.innerHTML = `<label>${k}</label><input name="${k}" class="form-control" value="${props[k] !== undefined ? props[k] : ''}">`;
                    form.appendChild(group);
                }
                const saveBtn = document.createElement('button');
                saveBtn.className = 'btn btn-primary';
                saveBtn.textContent = 'Save Attributes';
                saveBtn.type = 'button';
                saveBtn.onclick = () => {
                    // update feature props
                    const fd = new FormData(form);
                    for (const [k, v] of fd.entries()) {
                        feature.set(k, v);
                    }
                    // mark modified
                    if (feature.get('_pgfs_state') !== 'new') feature.set('_pgfs_state', 'modified');
                    if (!editBuffers.updates.includes(feature)) editBuffers.updates.push(feature);
                    // optionally close panel
                    // show user feedback
                    showToast('Attributes saved locally. Click Save Updates to persist to DB.', 'info');
                };
                form.appendChild(saveBtn);
                panel.appendChild(form);
                panel.style.display = 'block';
            }

            // Show attribute form for feature
            function showAttributeFormForFeature(feature) {
                const formPanel = document.getElementById('attribute-form');
                const properties = feature.getProperties();

                // Remove geometry property for form
                delete properties.geometry;

                let formHTML = '<h4>Edit Attributes:</h4>';
                formHTML += '<form id="feature-attribute-form">';

                Object.keys(properties).forEach(key => {
                    if (key !== 'layerId') {
                        formHTML += `
                        <div class="form-group">
                            <label for="attr-${key}">${key}:</label>
                            <input type="text" id="attr-${key}" name="${key}" value="${properties[key] || ''}" class="form-control">
                        </div>
                    `;
                    }
                });

                formHTML += `
                <div class="form-actions">
                    <button type="button" id="save-attributes-btn" class="btn btn-primary">Save Changes</button>
                    <button type="button" id="cancel-attributes-btn" class="btn btn-secondary">Cancel</button>
                </div>
            </form>`;

                formPanel.innerHTML = formHTML;

                // Add event listeners
                document.getElementById('save-attributes-btn').addEventListener('click', function () {
                    saveFeatureAttributes(feature);
                });

                document.getElementById('cancel-attributes-btn').addEventListener('click', function () {
                    formPanel.innerHTML = '<p>Select a feature to edit attributes</p>';
                });
            }

            // Save feature attributes
            function saveFeatureAttributes(feature) {
                const form = document.getElementById('feature-attribute-form');
                const formData = new FormData(form);
                const newProperties = {};

                for (let [key, value] of formData.entries()) {
                    newProperties[key] = value;
                }

                // Update feature properties
                feature.setProperties(newProperties);

                // Mark as modified
                feature.set('gsp_modified', true);

                // Add to update buffer
                if (!editBuffers.updates.find(f => f === feature)) {
                    editBuffers.updates.push(feature);
                }

                // Update pending count
                updatePendingCount();

                showToast('Feature attributes updated', 'success');

                // Clear form
                document.getElementById('attribute-form').innerHTML = '<p>Select a feature to edit attributes</p>';
            }

            // Update pending edits count
            function updatePendingCount() {
                const pendingCount = editBuffers.adds.length + editBuffers.updates.length + editBuffers.deletes.length;
                const countElement = document.getElementById('gspnet-pending-count');
                if (countElement) {
                    countElement.textContent = pendingCount;
                }
            }

            // Save edits to PG-FeatureServer (applyEdits / fallback patterns)
            async function saveEditsToPgfs(cfgEndpoint, authToken = null) {
                // Build feature objects (GeoJSON geometry + attributes)
                const mapProj = map.getView().getProjection().getCode() || MAP_PROJ;
                const fmt = new ol.format.GeoJSON();

                const prepare = (feat) => {
                    const obj = fmt.writeFeatureObject(feat, {
                        dataProjection: SERVER_PROJ,
                        featureProjection: mapProj
                    });
                    // Some servers prefer attributes separate from geometry
                    return { attributes: obj.properties || {}, geometry: obj.geometry || null, id: feat.getId() || feat.get('_gid') || null };
                };

                const adds = editBuffers.adds.map(f => prepare(f));
                const updates = editBuffers.updates.map(f => prepare(f));
                const deletes = editBuffers.deletes.map(f => f.getId() || f.get('_gid') || null).filter(Boolean);

                // Option A: try ArcGIS-style applyEdits JSON post
                const applyEditsUrl = `${cfgEndpoint}/applyEdits?f=json`;

                const payloadArc = {
                    adds: adds.map(a => ({ attributes: a.attributes, geometry: a.geometry })),
                    updates: updates.map(u => ({ attributes: u.attributes, geometry: u.geometry })),
                    deletes: deletes.join(',')
                };

                try {
                    let resp = await fetch(applyEditsUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...(authToken ? { 'Authorization': 'Bearer ' + authToken } : {}) },
                        body: JSON.stringify(payloadArc)
                    });
                    const json = await resp.json();
                    if (!resp.ok || json.error) throw new Error('applyEdits failed: ' + JSON.stringify(json));
                    // success: clear buffers and refresh
                    editBuffers = { adds: [], updates: [], deletes: [] };
                    if (currentEditable && currentEditable.source) currentEditable.source.clear(true);
                    if (currentEditable) currentEditable.source.refresh?.();
                    showToast('Saved edits to server', 'success');
                    return json;
                } catch (err) {
                    console.warn('applyEdits attempt failed, trying fallback', err);
                }

                // Option B: fallback - form encoded arguments (ArcGIS sometimes expects 'adds' as JSON strings)
                try {
                    const form = new URLSearchParams();
                    form.append('adds', JSON.stringify(adds.map(a => ({ attributes: a.attributes, geometry: a.geometry }))));
                    form.append('updates', JSON.stringify(updates.map(u => ({ attributes: u.attributes, geometry: u.geometry }))));
                    form.append('deletes', deletes.join(','));
                    form.append('f', 'json');

                    const resp2 = await fetch(cfgEndpoint + '/applyEdits', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...(authToken ? { 'Authorization': 'Bearer ' + authToken } : {}) },
                        body: form.toString()
                    });
                    const j2 = await resp2.json();
                    if (!resp2.ok || j2.error) throw new Error('fallback applyEdits failed: ' + JSON.stringify(j2));
                    editBuffers = { adds: [], updates: [], deletes: [] };
                    if (currentEditable && currentEditable.source) currentEditable.source.clear(true);
                    if (currentEditable) currentEditable.source.refresh?.();
                    showToast('Saved edits to server (fallback)', 'success');
                    return j2;
                } catch (err) {
                    console.error('Save to PGFS failed', err);
                    showToast('Save failed: ' + err.message, 'error');
                    throw err;
                }
            }

            // Convert OL feature to server geometry/coordinates in server SRID
            function featureToServerGeom(feature) {
                const mapProj = map.getView().getProjection().getCode();
                const geojson = new ol.format.GeoJSON().writeFeatureObject(feature, {
                    dataProjection: SERVER_SRID,
                    featureProjection: mapProj
                });
                return geojson.geometry;
            }

            // Clear edit buffers after successful save
            function clearEditBuffers() {
                editBuffers.adds = [];
                editBuffers.updates = [];
                editBuffers.deletes = [];
                updatePendingCount();
            }

            // Refresh editable layer after successful save
            function refreshEditableLayer() {
                if (currentEditableSource) {
                    currentEditableSource.clear();
                    // Trigger reload by changing extent slightly
                    const extent = map.getView().calculateExtent();
                    currentEditableSource.loader(extent, map.getView().getResolution(), map.getView().getProjection());
                }
            }

            // Start drawing for a specific layer
            function startDrawingForLayer(layerId, mode) {
                // Find the layer configuration
                const layerConfig = EDITABLE_LAYERS.find(l => l.id === layerId);
                if (!layerConfig) {
                    showToast('Invalid layer selected', 'error');
                    return;
                }

                // Ensure editing is set up for this layer
                if (!currentEditable) {
                    const layerConfig = EDITABLE_LAYERS.find(l => l.id === layerId);
                    if (layerConfig) {
                        createEditableLayer(layerConfig);
                    }
                }

                // Remove existing draw interaction
                if (drawInteraction) {
                    map.removeInteraction(drawInteraction);
                }

                // Create draw interaction
                drawInteraction = new ol.interaction.Draw({
                    source: currentEditableSource,
                    type: mode === 'point' ? 'Point' : mode === 'line' ? 'LineString' : 'Polygon'
                });

                // Handle draw end event
                drawInteraction.on('drawend', function (evt) {
                    const feature = evt.feature;

                    // Mark as new feature
                    feature.set('gsp_new', true);

                    // Add to add buffer
                    toAdd.push(feature);

                    // Update pending count
                    updatePendingCount();

                    showToast(`New ${mode} added to ${layerConfig.name}`, 'success');
                });

                map.addInteraction(drawInteraction);

                // Update UI
                document.getElementById('start-editing-btn').disabled = true;
                document.getElementById('stop-editing-btn').disabled = false;
                document.getElementById('save-updates-btn').disabled = false;

                showToast(`Started drawing ${mode}s for ${layerConfig.name}`, 'success');
            }

            // PGFEATURESERV LAYER MANAGEMENT FUNCTIONS

            // Create a pg_featureserv collection layer
            function createPgCollectionLayer(collectionId, options = {}) {
                const source = new ol.source.Vector({
                    url: `https://pgf.geospatialnetworkug.xyz/collections/${collectionId}/items?f=geojson&limit=10000`,
                    format: new ol.format.GeoJSON()
                });

                const layer = new ol.layer.Vector({
                    title: `${collectionId}`,
                    source: source,
                    style: options.style || new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#ff6b6b',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 107, 107, 0.1)'
                        }),
                        image: new ol.style.Circle({
                            radius: 6,
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 2
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 107, 107, 0.3)'
                            })
                        })
                    }),
                    visible: options.visible !== false
                });

                return layer;
            }

            // Default preview style for pg_featureserv layers
            function defaultPreviewStyle() {
                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ff6b6b',
                        width: 2,
                        lineDash: [5, 5]
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 107, 107, 0.1)'
                    }),
                    image: new ol.style.Circle({
                        radius: 6,
                        stroke: new ol.style.Stroke({
                            color: '#ff6b6b',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 107, 107, 0.3)'
                        })
                    })
                });
            }

            // Snapping style for pg_featureserv layers
            function snappingStyle() {
                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#3498db',
                        width: 3
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(52, 152, 219, 0.2)'
                    }),
                    image: new ol.style.Circle({
                        radius: 8,
                        stroke: new ol.style.Stroke({
                            color: '#3498db',
                            width: 3
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(52, 152, 219, 0.4)'
                        })
                    })
                });
            }

            // Load collection preview for GSP.NET UPDATES
            function loadCollectionPreview(collectionId, targetLayerName) {
                // Remove existing preview layer
                if (pgfPreviewLayer) {
                    map.removeLayer(pgfPreviewLayer);
                    pgfPreviewLayer = null;
                }

                // Create new preview layer
                pgfPreviewLayer = createPgCollectionLayer(collectionId, {
                    style: defaultPreviewStyle(),
                    visible: true
                });

                map.addLayer(pgfPreviewLayer);

                // Fit map to layer extent when loaded
                pgfPreviewLayer.getSource().once('change', function () {
                    if (pgfPreviewLayer.getSource().getState() === 'ready') {
                        const extent = pgfPreviewLayer.getSource().getExtent();

                        if (extent && extent[0] !== Infinity) {
                            view.fit(extent, { padding: [50, 50, 50, 50], maxZoom: 16 });
                        }
                    }
                });

                return pgfPreviewLayer;
            }

            // Enable editing for a collection
            function enableEditingForLayer(collectionId) {
                // Remove existing edit layer
                if (pgfEditLayer) {
                    map.removeLayer(pgfEditLayer);
                    pgfEditLayer = null;
                }

                // Create edit layer for in-memory edits
                pgfEditSource = new ol.source.Vector({ features: [] });
                pgfEditLayer = new ol.layer.Vector({
                    source: pgfEditSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: '#27ae60', width: 2 }),
                        fill: new ol.style.Fill({ color: 'rgba(39,174,96,0.1)' }),
                        image: new ol.style.Circle({
                            radius: 6,
                            fill: new ol.style.Fill({ color: '#27ae60' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                        })
                    })
                });

                map.addLayer(pgfEditLayer);

                // NOTE: Draw interactions are now created on-demand by the mode buttons
                // This prevents conflicts and allows proper geometry type selection
                // See startDrawing() function for draw interaction creation

                // Track pending edits
                pgfEditSource.on(['addfeature', 'removefeature', 'changefeature'], () => {
                    updatePendingCount();
                });

                return { drawInteraction: null, modifyInteraction: null };
            }

            // Import CSV to editing layer
            function importCSVToLayer(file, collectionId) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const lines = text.split(/\r?\n/).filter(Boolean);
                    const headers = lines.shift().split(',').map(h => h.trim());

                    for (const line of lines) {
                        const vals = line.split(',');
                        const row = Object.fromEntries(headers.map((h, i) => [h, vals[i]]));

                        // Try different coordinate column names
                        const lon = parseFloat(row.lon || row.x || row.longitude || row.easting);
                        const lat = parseFloat(row.lat || row.y || row.latitude || row.northing);

                        if (isFinite(lon) && isFinite(lat)) {
                            const f = new ol.Feature({
                                geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                                ...row
                            });
                            f.set('_new', true); // Mark as new feature
                            pgfEditSource.addFeature(f);
                        }
                    }
                    updatePendingCount();
                    showToast(`CSV imported: ${lines.length} features added to edit layer`, 'success');
                };
                reader.readAsText(file);
            }

            // Update pending edits counter
            function updatePendingCount() {
                const count = pgfEditSource ? pgfEditSource.getFeatures().length : 0;
                const counterElement = document.getElementById('gspnet-pending-count');
                if (counterElement) {
                    counterElement.textContent = count;
                }
            }

            // Save pending edits to pg_featureserv
            async function savePendingEdits(collectionId) {
                if (!pgfEditSource) {
                    showToast('No edit layer found', 'error');
                    return;
                }

                const features = pgfEditSource.getFeatures();
                if (features.length === 0) {
                    showToast('No edits to save', 'warning');
                    return;
                }

                const confirmed = await confirmDialog(`Save ${features.length} feature(s) to ${collectionId}?`);
                if (!confirmed) return;

                const format = new ol.format.GeoJSON();
                const newFeatures = features.filter(f => f.get('_new'));
                const updateFeatures = features.filter(f => !f.get('_new') && f.getId());

                try {
                    // Create new features
                    if (newFeatures.length > 0) {
                        const fc = format.writeFeaturesObject(newFeatures, {
                            featureProjection: map.getView().getProjection(),
                            dataProjection: 'EPSG:4326'
                        });

                        const resp = await fetch(`${pgfBaseUrl}/collections/${encodeURIComponent(collectionId)}/items`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/geo+json',
                                'Accept': 'application/geo+json'
                            },
                            body: JSON.stringify(fc)
                        });

                        if (!resp.ok) {
                            if (resp.status === 405 || resp.status === 403 || resp.status === 501) {
                                throw new Error('Server does not accept write requests via pg_featureserv. Contact admin to enable writes or use server-side write endpoint.');
                            }
                            throw new Error('Failed to create new features: ' + resp.statusText);
                        }

                        // Mark new features as persisted
                        newFeatures.forEach(f => f.set('_new', false));
                        showToast(`Created ${newFeatures.length} new features`, 'success');
                    }

                    // Update existing features
                    for (const f of updateFeatures) {
                        const id = f.getId();
                        if (!id) continue;

                        const geo = format.writeFeatureObject(f, {
                            featureProjection: map.getView().getProjection(),
                            dataProjection: 'EPSG:4326'
                        });

                        const resp = await fetch(`${pgfBaseUrl}/collections/${encodeURIComponent(collectionId)}/items/${encodeURIComponent(id)}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/geo+json',
                                'Accept': 'application/geo+json'
                            },
                            body: JSON.stringify(geo)
                        });

                        if (!resp.ok) {
                            if (resp.status === 405 || resp.status === 403 || resp.status === 501) {
                                throw new Error('Server does not accept write requests via pg_featureserv. Contact admin to enable writes or use server-side write endpoint.');
                            }
                            throw new Error('Failed to update feature ' + id + ': ' + resp.status);
                        }
                    }

                    if (updateFeatures.length > 0) {
                        showToast(`Updated ${updateFeatures.length} existing features`, 'success');
                    }

                    showToast('All edits saved successfully', 'success');
                    updatePendingCount();

                } catch (err) {
                    console.error('Save error:', err);
                    showToast('Save failed: ' + err.message, 'error');
                }
            }

            // Coordinate Extractor - enhanced FlatGeobuf snapping
            let previewSource = null;
            let previewLayer = null;
            let previewDebounce = null;

            // Enhanced FlatGeobuf snapping with configurable options
            function setupFlatGeobufSnapping() {
                // Remove existing coordinate extractor snap interactions
                if (window.currentSnapInteractions) {
                    window.currentSnapInteractions.forEach(interaction => {
                        map.removeInteraction(interaction);
                    });
                    window.currentSnapInteractions = [];
                    window.currentSnapInteraction = null; // Backward compatibility
                }

                // Get snapping tolerance from UI
                snappingTolerance = parseInt(document.getElementById('snapping-tolerance').value) || 5;
                snappingMode = document.getElementById('snapping-mode').value || 'both';

                // Get selected layer or use all visible layers
                const selectedLayerId = document.getElementById('coordExtractorLayerSelect').value;
                let snapSources = [];

                if (selectedLayerId) {
                    // Use only selected layer
                    selectedSnappingLayer = findLayerById(selectedLayerId);
                    console.log('Selected layer:', selectedLayerId, 'Found layer:', selectedSnappingLayer);
                    if (selectedSnappingLayer && selectedSnappingLayer.getVisible()) {
                        snapSources.push(selectedSnappingLayer.getSource());
                        console.log('Added source for selected layer:', selectedSnappingLayer.getSource());
                    } else {
                        console.warn('Selected layer not found or not visible:', selectedLayerId);
                    }
                } else {
                    // Use all visible FlatGeobuf layers (priority: GSPNET first, then Survey Polygons)
                    const visibleGspnetLayers = gspnetLayers.filter(layer => layer.getVisible());
                    const visibleSurveyLayers = Object.values(polygonLayers).filter(layer => layer.getVisible());

                    console.log('Visible GSPNET layers:', visibleGspnetLayers.length);
                    console.log('Visible Survey layers:', visibleSurveyLayers.length);

                    visibleGspnetLayers.forEach(layer => {
                        if (layer.getSource()) {
                            const source = layer.getSource();
                            const features = source.getFeatures();
                            console.log('GSPNET layer:', layer.get('title'), 'has', features.length, 'features');
                            snapSources.push(source);
                        }
                    });

                    visibleSurveyLayers.forEach(layer => {
                        if (layer.getSource()) {
                            const source = layer.getSource();
                            const features = source.getFeatures();
                            console.log('Survey layer:', layer.get('title'), 'has', features.length, 'features');
                            snapSources.push(source);
                        }
                    });
                }

                if (snapSources.length > 0) {
                    // Create coordinate extractor specific snap interactions
                    // Remove existing interactions first
                    if (window.currentSnapInteractions) {
                        window.currentSnapInteractions.forEach(interaction => {
                            map.removeInteraction(interaction);
                        });
                    }
                    window.currentSnapInteractions = [];

                    try {
                        console.log('Creating snap interactions with:', {
                            sources: snapSources.length,
                            tolerance: snappingTolerance,
                            mode: snappingMode,
                            vertex: snappingMode === 'vertex' || snappingMode === 'both',
                            edge: snappingMode === 'edge' || snappingMode === 'both'
                        });

                        // Create separate snap interaction for each source
                        snapSources.forEach((source, index) => {
                            const snapInteraction = new ol.interaction.Snap({
                                source: source,
                                pixelTolerance: snappingTolerance,
                                vertex: snappingMode === 'vertex' || snappingMode === 'both',
                                edge: snappingMode === 'edge' || snappingMode === 'both'
                            });

                            map.addInteraction(snapInteraction);
                            window.currentSnapInteractions.push(snapInteraction);
                            console.log(`Created snap interaction ${index + 1} for source with ${source.getFeatures().length} features`);
                        });

                        // Keep backward compatibility
                        window.currentSnapInteraction = window.currentSnapInteractions[0];

                        console.log('Coordinate extractor snapping enabled successfully with', snapSources.length, 'sources');
                        updateSnappingStatus();
                        return true;
                    } catch (error) {
                        console.error('Error creating coordinate extractor snap interactions:', error);
                        return false;
                    }
                } else {
                    console.warn('No snap sources available for coordinate extractor');
                }

                return false;
            }

            function findLayerById(layerId) {
                // Check GSPNET layers
                const gspnetLayer = gspnetLayers.find(layer => layer.get('title') === layerId);
                if (gspnetLayer) return gspnetLayer;

                // Check Survey Polygon layers
                return Object.values(polygonLayers).find(layer => layer.get('title') === layerId);
            }

            function updateSnappingStatus() {
                const statusEl = document.getElementById('coord-extractor-status');
                const statusTextEl = document.getElementById('coord-status-text');
                const snappingInfoEl = document.getElementById('snapping-layers');

                if (!statusTextEl) return;

                let statusMessage = 'Coordinate extraction active. ';
                let layerInfo = '';

                if (snappingEnabled) {
                    statusMessage += `Snapping: ${snappingTolerance}m tolerance, ${snappingMode} mode. `;

                    if (selectedSnappingLayer) {
                        layerInfo = `Snapping to: ${selectedSnappingLayer.get('title')}`;
                    } else {
                        const visibleGspnet = gspnetLayers.filter(l => l.getVisible()).length;
                        const visibleSurvey = Object.values(polygonLayers).filter(l => l.getVisible()).length;

                        if (visibleGspnet > 0 || visibleSurvey > 0) {
                            layerInfo = 'Snapping to: ';
                            if (visibleGspnet > 0) layerInfo += `${visibleGspnet} GSPNET layer(s)`;
                            if (visibleGspnet > 0 && visibleSurvey > 0) layerInfo += ', ';
                            if (visibleSurvey > 0) layerInfo += `${visibleSurvey} Survey layer(s)`;
                        } else {
                            layerInfo = 'No snapping layers visible';
                        }
                    }
                } else {
                    statusMessage += 'Free placement mode. ';
                    layerInfo = 'Snapping disabled';
                }

                if (validationEnabled) {
                    statusMessage += 'Validation enabled.';
                } else {
                    statusMessage += 'Validation disabled.';
                }

                statusTextEl.textContent = statusMessage;
                if (snappingInfoEl) {
                    snappingInfoEl.textContent = layerInfo;
                }
            }

            // Coordinate validation function
            function validateCoordinateWithinLayers(coordinate) {
                // Get all visible layers for validation
                const visibleLayers = [];

                gspnetLayers.forEach(layer => {
                    if (layer.getVisible()) visibleLayers.push(layer);
                });

                Object.values(polygonLayers).forEach(layer => {
                    if (layer.getVisible()) visibleLayers.push(layer);
                });

                // Check if coordinate is within any visible layer's features
                for (const layer of visibleLayers) {
                    const source = layer.getSource();
                    if (source) {
                        const features = source.getFeatures();
                        for (const feature of features) {
                            const geometry = feature.getGeometry();
                            if (geometry && geometry.getType() === 'Polygon') {
                                if (geometry.intersectsCoordinate(coordinate)) {
                                    return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }

            // Batch operations functions
            function extractPolygonVertices(layer) {
                const source = layer.getSource();
                if (!source) {
                    showToast('No source available for selected layer', 'error');
                    return;
                }

                const features = source.getFeatures();
                let vertexCount = 0;

                features.forEach(feature => {
                    const geometry = feature.getGeometry();
                    if (geometry && geometry.getType() === 'Polygon') {
                        const coordinates = geometry.getCoordinates()[0]; // Get outer ring

                        coordinates.forEach(coord => {
                            // Convert to selected CRS
                            const selectedCrs = document.getElementById('crs-selector').value;
                            const viewProjection = view.getProjection();
                            const viewCode = viewProjection.getCode();

                            try {
                                const transformedCoord = ol.proj.transform(coord, 'EPSG:4326', selectedCrs);
                                const lonLat = ol.proj.transform(coord, 'EPSG:4326', 'EPSG:4326');

                                const extractedPoint = {
                                    id: pointCounter++,
                                    easting: selectedCrs === 'EPSG:4326' ? transformedCoord[0].toFixed(6) : transformedCoord[0].toFixed(3),
                                    northing: selectedCrs === 'EPSG:4326' ? transformedCoord[1].toFixed(6) : transformedCoord[1].toFixed(3),
                                    lat: lonLat[1].toFixed(6),
                                    lon: lonLat[0].toFixed(6),
                                    crs: selectedCrs,
                                    layer: layer.get('title'),
                                    validated: true
                                };

                                extractedPoints.push(extractedPoint);
                                vertexCount++;
                            } catch (error) {
                                console.error('Error transforming vertex coordinate:', error);
                            }
                        });
                    }
                });

                // Update UI
                updateExtractedPointsDisplay();
                showToast(`Extracted ${vertexCount} vertices from ${features.length} polygons`, 'success');
            }

            function enableEdgeExtractionMode(layer) {
                // Create a temporary interaction for edge selection
                const edgeSelectInteraction = new ol.interaction.Select({
                    layers: [layer],
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: 'red',
                            width: 3
                        })
                    })
                });

                map.addInteraction(edgeSelectInteraction);

                // Listen for feature selection
                edgeSelectInteraction.on('select', function (event) {
                    if (event.selected.length > 0) {
                        const feature = event.selected[0];
                        map.removeInteraction(edgeSelectInteraction);

                        // Show edge selection dialog
                        showEdgeSelectionDialog(feature);
                    }
                });

                // Cancel on right click or escape
                const cancelEdgeSelection = function () {
                    map.removeInteraction(edgeSelectInteraction);
                    map.un('pointerdown', cancelEdgeSelection);
                    document.removeEventListener('keydown', handleEscape);
                    showToast('Edge extraction cancelled', 'info');
                };

                const handleEscape = function (e) {
                    if (e.key === 'Escape') {
                        cancelEdgeSelection();
                    }
                };

                map.on('pointerdown', function (e) {
                    if (e.originalEvent.button === 2) { // Right click
                        cancelEdgeSelection();
                    }
                });

                document.addEventListener('keydown', handleEscape);

                showToast('Click on a polygon edge to select it for coordinate extraction', 'info');
            }

            function showEdgeSelectionDialog(feature) {
                // Create a simple modal for edge selection
                const modal = document.createElement('div');
                modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 400px;
                width: 90%;
            `;

                modalContent.innerHTML = `
                <h3>Select Edge Extraction Options</h3>
                <div style="margin: 15px 0;">
                    <label>Number of points to extract:</label>
                    <input type="number" id="edge-point-count" value="10" min="2" max="100" style="width: 100%; padding: 5px; margin: 5px 0;">
                </div>
                <div style="margin: 15px 0;">
                    <label>Spacing method:</label>
                    <select id="edge-spacing-method" style="width: 100%; padding: 5px;">
                        <option value="equal">Equal spacing</option>
                        <option value="distance">Fixed distance (meters)</option>
                    </select>
                </div>
                <div style="margin: 15px 0;">
                    <label>Distance between points (meters):</label>
                    <input type="number" id="edge-distance" value="50" min="1" step="0.1" style="width: 100%; padding: 5px;">
                </div>
                <div style="text-align: right; margin-top: 20px;">
                    <button id="cancel-edge-extraction" style="margin-right: 10px;">Cancel</button>
                    <button id="confirm-edge-extraction" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px;">Extract</button>
                </div>
            `;

                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                // Event handlers
                document.getElementById('cancel-edge-extraction').onclick = function () {
                    document.body.removeChild(modal);
                };

                document.getElementById('confirm-edge-extraction').onclick = function () {
                    const pointCount = parseInt(document.getElementById('edge-point-count').value);
                    const spacingMethod = document.getElementById('edge-spacing-method').value;
                    const distance = parseFloat(document.getElementById('edge-distance').value);

                    extractPointsAlongEdge(feature, pointCount, spacingMethod, distance);
                    document.body.removeChild(modal);
                };
            }

            function extractPointsAlongEdge(feature, pointCount, spacingMethod, distance) {
                const geometry = feature.getGeometry();
                if (!geometry || geometry.getType() !== 'Polygon') {
                    showToast('Selected feature is not a polygon', 'error');
                    return;
                }

                // For simplicity, we'll extract along the longest edge
                const coordinates = geometry.getCoordinates()[0];
                let longestEdge = { start: null, end: null, length: 0 };

                for (let i = 0; i < coordinates.length - 1; i++) {
                    const start = coordinates[i];
                    const end = coordinates[i + 1];
                    const edgeLength = ol.sphere.getDistance(
                        ol.proj.transform(start, 'EPSG:4326', 'EPSG:4326'),
                        ol.proj.transform(end, 'EPSG:4326', 'EPSG:4326')
                    );

                    if (edgeLength > longestEdge.length) {
                        longestEdge = { start, end, length: edgeLength };
                    }
                }

                if (!longestEdge.start) {
                    showToast('Could not find suitable edge', 'error');
                    return;
                }

                // Generate points along the edge
                const points = [];
                const selectedCrs = document.getElementById('crs-selector').value;
                const viewProjection = view.getProjection();
                const viewCode = viewProjection.getCode();

                if (spacingMethod === 'equal') {
                    // Equal spacing
                    for (let i = 0; i < pointCount; i++) {
                        const ratio = i / (pointCount - 1);
                        const point = [
                            longestEdge.start[0] + (longestEdge.end[0] - longestEdge.start[0]) * ratio,
                            longestEdge.start[1] + (longestEdge.end[1] - longestEdge.start[1]) * ratio
                        ];
                        points.push(point);
                    }
                } else {
                    // Fixed distance spacing
                    const edgeVector = [
                        longestEdge.end[0] - longestEdge.start[0],
                        longestEdge.end[1] - longestEdge.start[1]
                    ];
                    const edgeLength = Math.sqrt(edgeVector[0] * edgeVector[0] + edgeVector[1] * edgeVector[1]);

                    // Convert distance to coordinate units (approximate)
                    const coordDistance = distance / 111000; // Rough conversion meters to degrees

                    const stepCount = Math.floor(edgeLength / coordDistance);
                    for (let i = 0; i <= stepCount; i++) {
                        const ratio = i * coordDistance / edgeLength;
                        if (ratio <= 1) {
                            const point = [
                                longestEdge.start[0] + edgeVector[0] * ratio,
                                longestEdge.start[1] + edgeVector[1] * ratio
                            ];
                            points.push(point);
                        }
                    }
                }

                // Extract coordinates for each point
                points.forEach(point => {
                    try {
                        const transformedCoord = ol.proj.transform(point, 'EPSG:4326', selectedCrs);
                        const lonLat = ol.proj.transform(point, 'EPSG:4326', 'EPSG:4326');

                        const extractedPoint = {
                            id: pointCounter++,
                            easting: selectedCrs === 'EPSG:4326' ? transformedCoord[0].toFixed(6) : transformedCoord[0].toFixed(3),
                            northing: selectedCrs === 'EPSG:4326' ? transformedCoord[1].toFixed(6) : transformedCoord[1].toFixed(3),
                            lat: lonLat[1].toFixed(6),
                            lon: lonLat[0].toFixed(6),
                            crs: selectedCrs,
                            layer: selectedSnappingLayer.get('title'),
                            validated: true
                        };

                        extractedPoints.push(extractedPoint);
                    } catch (error) {
                        console.error('Error transforming edge coordinate:', error);
                    }
                });

                // Update UI
                updateExtractedPointsDisplay();
                showToast(`Extracted ${points.length} points along polygon edge`, 'success');
            }

            // Layer population and UI update functions
            function populateLayerSelector() {
                const selector = document.getElementById('coordExtractorLayerSelect');
                selector.innerHTML = '<option value="">-- Select Layer --</option>';

                console.log('Populating coordinate extractor layer selector...');
                console.log('Available GSPNET layers:', gspnetLayers.length);
                console.log('Available Survey layers:', Object.keys(polygonLayers).length);

                // Add GSPNET layers
                gspnetLayers.forEach(layer => {
                    const option = document.createElement('option');
                    option.value = layer.get('title');
                    option.textContent = `GSPNET: ${layer.get('title')}`;
                    selector.appendChild(option);
                    console.log('Added GSPNET layer:', layer.get('title'));
                });

                // Add Survey Polygon layers
                Object.values(polygonLayers).forEach(layer => {
                    const option = document.createElement('option');
                    option.value = layer.get('title');
                    option.textContent = `Survey: ${layer.get('title')}`;
                    selector.appendChild(option);
                    console.log('Added Survey layer:', layer.get('title'));
                });

                console.log('Layer selector populated with', selector.options.length - 1, 'layers');
            }

            function updateExtractedPointsDisplay() {
                // Update button states
                const exportBtn = document.getElementById('export-csv-btn');
                const undoBtn = document.getElementById('undo-btn');
                const clearBtn = document.getElementById('clear-all-btn');

                const hasPoints = extractedPoints.length > 0;
                exportBtn.disabled = !hasPoints;
                undoBtn.disabled = !hasPoints;
                clearBtn.disabled = !hasPoints;

                // Update tolerance display
                document.getElementById('tolerance-value').textContent = snappingTolerance + 'm';
            }

            // Setup layer visibility monitoring
            function setupLayerVisibilityMonitoring() {
                // Monitor GSPNET layer visibility changes
                gspnetLayers.forEach(layer => {
                    layer.on('change:visible', function () {
                        if (extractionActive && snappingEnabled) {
                            setupFlatGeobufSnapping();
                        }
                        if (coordExtractorModal.style.display === 'block') {
                            populateLayerSelector();
                        }
                    });
                });

                // Monitor Survey Polygon layer visibility changes
                Object.values(polygonLayers).forEach(layer => {
                    layer.on('change:visible', function () {
                        if (extractionActive && snappingEnabled) {
                            setupFlatGeobufSnapping();
                        }
                        if (coordExtractorModal.style.display === 'block') {
                            populateLayerSelector();
                        }
                    });
                });
            }

            // Legacy function (kept for compatibility)
            function showPreviewForLayer(cfg) {
                if (previewLayer) {
                    map.removeLayer(previewLayer);
                    previewLayer = null;
                    previewSource = null;
                }
                previewSource = createPgfsBboxSource(cfg.endpoint);
                previewLayer = new ol.layer.Vector({
                    source: previewSource,
                    style: snappingStyle()
                });
                map.addLayer(previewLayer);

                // load initial extent
                const ext = map.getView().calculateExtent(map.getSize());
                previewSource.clear(true);
                // Trigger the loader by changing the extent slightly to force reload
                const currentExtent = map.getView().calculateExtent();
                map.getView().fit(currentExtent, { duration: 0 });

                // refresh on moveend (debounced)
                map.on('moveend', () => {
                    if (previewDebounce) clearTimeout(previewDebounce);
                    previewDebounce = setTimeout(() => {
                        previewSource.clear(true);
                        // Trigger reload by changing extent slightly
                        const currentExtent = map.getView().calculateExtent();
                        map.getView().fit(currentExtent, { duration: 0 });
                    }, 350);
                });

                const snapSources = [previewSource];
                if (controlPointsSource) snapSources.push(controlPointsSource);
                if (csvPointsSource) snapSources.push(csvPointsSource);
                safeAttachSnappingToCurrent(snapSources);
                showToast(`Preview enabled for ${cfg.name} (extent-based loading)`, 'success');
            }

            // Enable snapping for coordinate extractor (legacy function)
            function enableSnappingForLayer(collectionId) {
                // Since we're using FlatGeobuf layers now, snapping is handled by setupFlatGeobufSnapping()
                console.log(`Snapping enabled for layer: ${collectionId} (FlatGeobuf layer)`);
            }

            // Disable snapping
            function disableSnapping() {
                snapInteractions.forEach(si => map.removeInteraction(si));
                snapInteractions = [];

                if (pgfSnapLayer) {
                    map.removeLayer(pgfSnapLayer);
                    pgfSnapLayer = null;
                }

                snappingEnabled = false;
                showToast('Snapping disabled', 'info');
            }

            // PATCH: Global error handler for CORS and network issues
            window.addEventListener('error', function (event) {
                if (event.message && (event.message.includes('CORS') || event.message.includes('Cross-Origin'))) {
                    console.warn('CORS error detected globally:', event.message);
                    // Don't show toast for every CORS error to avoid spam
                }

                // Handle snap interaction errors specifically
                if (event.message && (event.message.includes('getFeatures is not a function') ||
                    event.message.includes('this.source_.getFeatures'))) {
                    console.error('Snap interaction error detected:', event.message);
                    console.error('This usually means an invalid source was passed to ol.interaction.Snap');
                    console.error('Stack trace:', event.error);

                    // Emergency cleanup of all snap interactions
                    emergencyCleanupSnapInteractions();

                    // Disable snapping temporarily to prevent further errors
                    disableSnappingCompletely();

                    // Show user-friendly message
                    showToast('Snapping temporarily disabled due to error', 'warning');
                }
            });

            // Safe snap interaction creation with source validation
            function createSafeSnapInteraction(sources, options = {}) {
                // TEMPORARILY DISABLED - Return null to prevent snap errors
                console.log('Snap interactions temporarily disabled to prevent errors');
                return null;

                // Filter out invalid sources
                const validSources = sources.filter(source => {
                    if (!source || typeof source.getFeatures !== 'function') {
                        console.warn('Invalid source for snap interaction:', source);
                        return false;
                    }
                    return true;
                });

                if (validSources.length === 0) {
                    console.warn('No valid sources for snap interaction');
                    return null;
                }

                try {
                    return new ol.interaction.Snap({
                        source: validSources,
                        pixelTolerance: options.pixelTolerance || 10,
                        vertex: options.vertex !== false,
                        edge: options.edge !== false
                    });
                } catch (error) {
                    console.error('Error creating snap interaction:', error);
                    return null;
                }
            }

            // Emergency cleanup function for snap interactions
            function emergencyCleanupSnapInteractions() {
                try {
                    // Remove all snap interactions from map
                    const interactions = map.getInteractions().getArray();
                    interactions.forEach(interaction => {
                        if (interaction instanceof ol.interaction.Snap) {
                            map.removeInteraction(interaction);
                        }
                    });

                    // Clear our snap interactions array
                    snapInteractions = [];
                    console.log('Emergency cleanup: removed all snap interactions');
                } catch (error) {
                    console.error('Error during emergency cleanup:', error);
                }
            }

            // Completely disable snapping to prevent errors
            function disableSnappingCompletely() {
                try {
                    emergencyCleanupSnapInteractions();
                    window.snappingDisabled = true;
                    showToast('Snapping disabled due to error. Please refresh the page.', 'warning');
                    console.log('Snapping completely disabled to prevent further errors');
                } catch (error) {
                    console.error('Error disabling snapping:', error);
                }
            }

            // PATCH: Global fetch error handler for unhandled promise rejections
            window.addEventListener('unhandledrejection', function (event) {
                if (event.reason && event.reason.message &&
                    (event.reason.message.includes('CORS') || event.reason.message.includes('NetworkError'))) {
                    console.warn('Unhandled CORS/Network error:', event.reason.message);
                    // Prevent the default unhandled rejection error
                    event.preventDefault();
                }
            });

            // Environment check for file:// protocol
            if (window.location.protocol === 'file:') {
                showToast('This app must be served over HTTP/HTTPS. File:// protocol restrictions apply.', 'error', 9000);
                console.warn('Skipping server requests under file://');
            } else {
                // Call the function to fetch capabilities when the page loads
                fetchPgfCapabilities();
            }

            // PGFEATURESERV layer loading function
            function loadPgfLayerDirectly(collectionId) {
                try {
                    return createPgCollectionLayer(collectionId, {
                        style: new ol.style.Style({
                            fill: new ol.style.Fill({ color: 'rgba(255, 255, 0, 0.1)' }),
                            stroke: new ol.style.Stroke({ color: '#ffcc00', width: 2 }),
                            image: new ol.style.Circle({
                                radius: 5,
                                fill: new ol.style.Fill({ color: '#ffcc00' })
                            })
                        })
                    });
                } catch (error) {
                    console.error('Error creating pg_featureserv layer:', error);
                    return null;
                }
            }

            // PGFEATURESERV snapping toggle functionality
            const snappingToggleBtn = document.getElementById('snapping-toggle-btn');
            snappingToggleBtn.addEventListener('click', function () {
                const selectedCollection = pgfLayerSelector.value;
                if (!selectedCollection) {
                    showToast('Please select a collection first', 'warning');
                    return;
                }

                if (snappingEnabled) {
                    // Disable snapping
                    disableSnapping();
                    this.innerHTML = '<i class="fas fa-magnet"></i> Snapping: OFF';
                    this.style.background = '';
                } else {
                    // Enable snapping
                    enableSnappingForLayer(selectedCollection);
                    this.innerHTML = '<i class="fas fa-magnet"></i> Snapping: ON';
                    this.style.background = 'linear-gradient(to bottom, #2ecc71, #27ae60)';
                }
            });

            // Coordinate Extractor event handlers
            document.getElementById('start-extraction-btn').addEventListener('click', function () {
                extractionActive = !extractionActive;

                if (extractionActive) {
                    // Start extraction
                    this.innerHTML = '<i class="fas fa-stop"></i> Stop Extraction';
                    this.style.background = 'linear-gradient(to bottom, #e74c3c, #c0392b)';
                    document.getElementById('coord-extractor-status').style.display = 'block';

                    // Setup snapping if enabled
                    if (snappingEnabled) {
                        setupFlatGeobufSnapping();
                    }

                    // Enable crosshair cursor
                    enableCrosshair();

                    map.on('click', handleMapClickForExtraction);
                    showToast('Coordinate extraction started. Click on the map to extract points.', 'info');
                } else {
                    // Stop extraction
                    this.innerHTML = '<i class="fas fa-play"></i> Start Extraction';
                    this.style.background = 'linear-gradient(to bottom, #3498db, #2980b9)';
                    document.getElementById('coord-status-text').textContent = 'Extraction stopped';

                    // Disable crosshair cursor
                    disableCrosshair();

                    // Remove snapping
                    if (window.currentSnapInteractions) {
                        window.currentSnapInteractions.forEach(interaction => {
                            map.removeInteraction(interaction);
                        });
                        window.currentSnapInteractions = [];
                        window.currentSnapInteraction = null; // Backward compatibility
                    }

                    map.un('click', handleMapClickForExtraction);
                    showToast('Coordinate extraction stopped', 'info');
                }
            });

            // Snapping tolerance slider
            document.getElementById('snapping-tolerance').addEventListener('input', function () {
                const value = this.value;
                document.getElementById('tolerance-value').textContent = value + 'm';
                snappingTolerance = parseInt(value);

                // Update snapping if active
                if (extractionActive && snappingEnabled) {
                    setupFlatGeobufSnapping();
                }
            });

            // Snapping mode selector
            document.getElementById('snapping-mode').addEventListener('change', function () {
                snappingMode = this.value;

                // Update snapping if active
                if (extractionActive && snappingEnabled) {
                    setupFlatGeobufSnapping();
                }
            });

            // Layer selection for snapping
            document.getElementById('coordExtractorLayerSelect').addEventListener('change', function () {
                const selectedLayerId = this.value;
                selectedSnappingLayer = selectedLayerId ? findLayerById(selectedLayerId) : null;

                // Update snapping if active
                if (extractionActive && snappingEnabled) {
                    setupFlatGeobufSnapping();
                }

                // Enable/disable start button based on selection
                const startBtn = document.getElementById('start-extraction-btn');
                if (startBtn) {
                    startBtn.disabled = !this.value;
                }
            });

            // Snapping toggle
            document.getElementById('snapping-toggle-btn').addEventListener('click', function () {
                snappingEnabled = !snappingEnabled;
                this.innerHTML = `<i class="fas fa-magnet"></i> Snapping: ${snappingEnabled ? 'ON' : 'OFF'}`;
                this.style.background = snappingEnabled ?
                    'linear-gradient(to bottom, #27ae60, #229954)' :
                    'linear-gradient(to bottom, #95a5a6, #7f8c8d)';

                if (extractionActive) {
                    if (snappingEnabled) {
                        setupFlatGeobufSnapping();
                    } else {
                        // Remove snapping
                        if (window.currentSnapInteractions) {
                            window.currentSnapInteractions.forEach(interaction => {
                                map.removeInteraction(interaction);
                            });
                            window.currentSnapInteractions = [];
                            window.currentSnapInteraction = null; // Backward compatibility
                        }
                    }
                    updateSnappingStatus();
                }
            });

            // Validation toggle
            document.getElementById('validation-toggle-btn').addEventListener('click', function () {
                validationEnabled = !validationEnabled;
                this.innerHTML = `<i class="fas fa-check-circle"></i> Validation: ${validationEnabled ? 'ON' : 'OFF'}`;
                this.style.background = validationEnabled ?
                    'linear-gradient(to bottom, #3498db, #2980b9)' :
                    'linear-gradient(to bottom, #95a5a6, #7f8c8d)';

                if (extractionActive) {
                    updateSnappingStatus();
                }
            });

            // Batch operations
            document.getElementById('extract-polygon-vertices-btn').addEventListener('click', function () {
                if (!selectedSnappingLayer) {
                    showToast('Please select a layer first', 'warning');
                    return;
                }

                extractPolygonVertices(selectedSnappingLayer);
            });

            document.getElementById('extract-along-edge-btn').addEventListener('click', function () {
                if (!selectedSnappingLayer) {
                    showToast('Please select a layer first', 'warning');
                    return;
                }

                showToast('Click on a polygon edge to extract coordinates along it', 'info');
                enableEdgeExtractionMode(selectedSnappingLayer);
            });

            document.getElementById('export-csv-btn').addEventListener('click', function () {
                if (extractedPoints.length === 0) {
                    alert('No points to export');
                    return;
                }

                let csvContent = "Point ID,Easting,Northing,Latitude,Longitude,Layer,Validation\n";
                extractedPoints.forEach(point => {
                    csvContent += `${point.id},${point.easting},${point.northing},${point.lat},${point.lon},${point.layer || ''},${point.validated ? 'Yes' : 'No'}\n`;
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "GSPNET-EXTRACT-CSV.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('CSV exported successfully!', 'success');
            });

            document.getElementById('undo-btn').addEventListener('click', function () {
                if (extractedPoints.length > 0) {
                    extractedPoints.pop();
                    pointCounter--;
                    updateExtractorLayer();
                    updateResultsTable();

                    if (extractedPoints.length === 0) {
                        this.disabled = true;
                        document.getElementById('clear-all-btn').disabled = true;
                        document.getElementById('export-csv-btn').disabled = true;
                    }
                    showToast('Last point removed', 'info');
                }
            });

            document.getElementById('clear-all-btn').addEventListener('click', function () {
                extractedPoints = [];
                pointCounter = 1;
                extractorSource.clear();
                updateResultsTable();
                this.disabled = true;
                document.getElementById('undo-btn').disabled = true;
                document.getElementById('export-csv-btn').disabled = true;
                showToast('All points cleared', 'info');
            });

            // Test transform button
            document.getElementById('test-transform-btn').addEventListener('click', function () {
                const selectedCrs = document.getElementById('crs-selector').value;
                const testCoord = [32.5, 0.5]; // Uganda coordinates in WGS84

                try {
                    console.log('Testing coordinate transformation...');
                    console.log('Input coordinate (WGS84):', testCoord);
                    console.log('Selected CRS:', selectedCrs);

                    const transformedCoord = ol.proj.transform(testCoord, 'EPSG:4326', selectedCrs);
                    console.log('Transformed coordinate:', transformedCoord);

                    // Test reverse transformation
                    const backToWGS84 = ol.proj.transform(transformedCoord, selectedCrs, 'EPSG:4326');
                    console.log('Back to WGS84:', backToWGS84);

                    showToast(`Test successful! ${selectedCrs}: ${transformedCoord[0].toFixed(3)}, ${transformedCoord[1].toFixed(3)}`, 'success');

                } catch (error) {
                    console.error('Test transformation failed:', error);
                    showToast('Test transformation failed: ' + error.message, 'error');
                }
            });

            function handleMapClickForExtraction(evt) {
                const coordinate = evt.coordinate;
                const viewProjection = view.getProjection();
                const selectedCrs = document.getElementById('crs-selector').value;

                // PATCH: direct transform to selected CRS for coordinate extractor
                const viewCode = viewProjection.getCode();
                const clickCoord = evt.coordinate; // map coordinate in view projection

                // Direct transform to selected CRS
                let transformedCoord;
                let lonLat;

                try {
                    // Direct transform to selected CRS
                    transformedCoord = ol.proj.transform(clickCoord, viewCode, selectedCrs);

                    // Also get WGS84 for lat/lon display
                    lonLat = ol.proj.transform(clickCoord, viewCode, 'EPSG:4326');

                    // Validate the transformation result
                    if (!transformedCoord || isNaN(transformedCoord[0]) || isNaN(transformedCoord[1])) {
                        throw new Error('Invalid transformation result');
                    }
                } catch (error) {
                    console.error('Error transforming coordinate:', error);
                    console.error('Error details:', error.message);
                    showToast('Error transforming coordinate to selected CRS. Please try another CRS.', 'error');
                    return;
                }

                // Coordinate validation (if enabled)
                if (validationEnabled && !validateCoordinateWithinLayers(clickCoord)) {
                    showToast('Coordinate is outside visible layer boundaries. Disable validation to place anywhere.', 'warning');
                    return;
                }

                // Add to points array with proper coordinate formatting
                // PATCH: ensure order: for projected CRSs result is [easting, northing]; for EPSG:4326 it's [lon,lat]
                const easting = Number(transformedCoord[0].toFixed(3));
                const northing = Number(transformedCoord[1].toFixed(3));

                const extractedPoint = {
                    id: pointCounter,
                    easting: selectedCrs === 'EPSG:4326' ? transformedCoord[0].toFixed(6) : easting,
                    northing: selectedCrs === 'EPSG:4326' ? transformedCoord[1].toFixed(6) : northing,
                    lat: lonLat[1].toFixed(6),
                    lon: lonLat[0].toFixed(6),
                    crs: selectedCrs,
                    layer: selectedSnappingLayer ? selectedSnappingLayer.get('title') : 'Free placement',
                    validated: validationEnabled,
                    // Add raw coordinates for debugging
                    rawEasting: transformedCoord[0],
                    rawNorthing: transformedCoord[1]
                };

                extractedPoints.push(extractedPoint);
                console.log('Added point:', extractedPoint);

                // Update the extractor layer
                updateExtractorLayer();

                // Update results table
                updateResultsTable();

                // Enable buttons
                document.getElementById('undo-btn').disabled = false;
                document.getElementById('clear-all-btn').disabled = false;
                document.getElementById('export-csv-btn').disabled = false;

                pointCounter++;
                showToast(`Point ${pointCounter - 1} extracted in ${selectedCrs}`, 'success', 2000);
            }

            function updateExtractorLayer() {
                extractorSource.clear();

                extractedPoints.forEach(point => {
                    const viewProjection = view.getProjection();
                    const selectedCrs = point.crs || document.getElementById('crs-selector').value;

                    try {
                        // Create point in the selected CRS and transform to map view
                        const pointFeature = new ol.Feature({
                            geometry: new ol.geom.Point(
                                ol.proj.transform([parseFloat(point.easting), parseFloat(point.northing)], selectedCrs, viewProjection)
                            )
                        });

                        pointFeature.setStyle(new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 6,
                                fill: new ol.style.Fill({
                                    color: 'rgba(255, 0, 0, 0.7)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: 'red',
                                    width: 2
                                })
                            }),
                            text: new ol.style.Text({
                                text: point.id.toString(),
                                offsetY: -15,
                                font: 'bold 12px sans-serif',
                                fill: new ol.style.Fill({ color: 'red' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                            })
                        }));

                        extractorSource.addFeature(pointFeature);
                    } catch (error) {
                        console.error('Error updating extractor layer for point', point.id, error);
                    }
                });
            }

            function updateResultsTable() {
                const tbody = document.getElementById('coord-results-body');
                tbody.innerHTML = '';

                extractedPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                    <td>${point.id}</td>
                    <td>${point.easting}</td>
                    <td>${point.northing}</td>
                    <td>${point.lat}</td>
                    <td>${point.lon}</td>
                `;
                    tbody.appendChild(row);
                });
            }

            // Coordinate Extractor Modal Control
            const coordExtractorMainBtn = document.getElementById('coordExtractorMainBtn');
            const coordExtractorModal = document.getElementById('coordExtractorModal');
            const coordExtractorClose = document.getElementById('coordExtractorClose');

            coordExtractorMainBtn.addEventListener('click', function () {
                coordExtractorModal.style.display = 'block';
                // Populate layer selector when modal opens
                populateLayerSelector();
            });

            coordExtractorClose.addEventListener('click', function () {
                coordExtractorModal.style.display = 'none';

                // Stop extraction if active
                if (extractionActive) {
                    document.getElementById('start-extraction-btn').click();
                }
            });

            // Initialize layer visibility monitoring
            setupLayerVisibilityMonitoring();

            // ========================================
            //  GSP.NET UPDATES - NEW IMPLEMENTATION
            //  Clean, modular, backend-driven editing system
            // ========================================

            // Backend API no longer needed - using direct WFS-T to GeoServer
            // const API_BASE_URL = 'http://localhost:3001';

            // ========================================
            //  WFS HELPER FUNCTIONS - XML Sanitization
            // ========================================

            /**
             * Strip control characters that are illegal in XML
             * @param {string} s - Input string
             * @returns {string} - Cleaned string
             */
            function stripControlChars(s) {
                return s == null ? s : String(s).replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
            }

            /**
             * Escape XML special characters
             * @param {string} unsafe - Input string
             * @returns {string} - XML-safe string
             */
            function escapeXml(unsafe) {
                if (unsafe == null) return '';
                return String(unsafe)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }

            // ============================================
            // WFS FIX START - Enhanced fetch wrapper
            // ============================================
            /**
             * Safe WFS fetch wrapper - handles exceptions and parses JSON
             * Uses nginx proxy to avoid CORS/403 issues
             * @param {string} url - WFS URL to fetch (should use proxy)
             * @returns {Promise<Object>} - Parsed GeoJSON
             */
            async function safeFetchWFS(url) {
                try {
                    console.log('🌐 safeFetchWFS: Fetching URL:', url);
                    console.log('🔗 Using proxy:', url.includes('geoserver-proxy') ? '✅ YES' : '❌ NO (may fail!)');

                    const res = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache',
                        headers: {
                            'Accept': 'application/json, text/plain, */*'
                        }
                    });

                    const text = await res.text();
                    console.log('📥 WFS Response status:', res.status, res.statusText);
                    console.log('📊 WFS Response length:', text.length, 'bytes');
                    console.log('📝 WFS Response preview:', text.substring(0, 500));

                    if (!res.ok) {
                        console.error('WFS request failed with status:', res.status);
                        console.error('WFS error response:', text);
                        console.error('Request URL was:', url);

                        // Show more helpful 403/405 error
                        if (res.status === 403 || res.status === 405) {
                            if (text.includes('ExceptionReport') || text.includes('Exception')) {
                                // Try to extract the actual error message
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(text, 'text/xml');
                                const exceptionText = xmlDoc.getElementsByTagName('ows:ExceptionText')[0] ||
                                    xmlDoc.getElementsByTagName('ExceptionText')[0];
                                if (exceptionText) {
                                    console.error('❌ GeoServer exception:', exceptionText.textContent);
                                    throw new Error(`GeoServer ${res.status}: ${exceptionText.textContent}`);
                                }
                            }
                            const usingProxy = url.includes('geoserver-proxy');
                            const errorMsg = usingProxy
                                ? `WFS ${res.status} Forbidden. Check nginx proxy configuration and GeoServer security settings.`
                                : `WFS ${res.status} Forbidden. URL is not using proxy! Should use: https://webmap.geospatialnetworkug.xyz/geoserver-proxy/...`;
                            console.error('❌', errorMsg);
                            throw new Error(`${errorMsg}\nResponse: ${text.substring(0, 200)}`);
                        }

                        throw new Error(`WFS failed: ${res.status} ${res.statusText} - ${text.substring(0, 200)}`);
                    }

                    // Check for XML exception reports
                    if (text.includes('ExceptionReport') || text.includes('ows:Exception')) {
                        console.error('GeoServer returned ExceptionReport:', text);

                        // Try to extract exception message
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, 'text/xml');
                        const exceptionText = xmlDoc.getElementsByTagName('ows:ExceptionText')[0] ||
                            xmlDoc.getElementsByTagName('ExceptionText')[0];
                        const exceptionMsg = exceptionText ? exceptionText.textContent : 'Unknown error';

                        throw new Error('GeoServer Exception: ' + exceptionMsg);
                    }

                    // Parse JSON
                    try {
                        const json = JSON.parse(text);
                        console.log('✅ JSON parsed successfully, features:', json.features?.length || 0);
                        return json;
                    } catch (parseError) {
                        console.error('❌ Invalid JSON from WFS:', text.substring(0, 500));
                        throw new Error('Invalid JSON in WFS response: ' + parseError.message);
                    }
                } catch (error) {
                    console.error('❌ safeFetchWFS error:', {
                        message: error.message,
                        url: url,
                        usingProxy: url.includes('geoserver-proxy')
                    });
                    throw error;
                }
            }
            // WFS FIX END
            // ============================================

            /**
             * Build correct WFS GetFeature URL
             * @param {string} layerName - Full layer name (e.g., 'geospatial_network:control_points')
             * @param {number} count - Max features to return
             * @returns {string} - Complete WFS URL
             */
            function buildWFSUrl(layerName, count = 5000) {
                const params = new URLSearchParams({
                    service: 'WFS',
                    version: '1.1.0',
                    request: 'GetFeature',
                    typeName: layerName,
                    outputFormat: 'application/json',
                    maxFeatures: count.toString()
                });
                return `${GEOSERVER_WFS_URL}?${params.toString()}`;
            }

            // Global editing state (declare outside DOMContentLoaded so it's accessible)
            const editingState = {
                active: false,
                collectionId: null,
                collectionConfig: null,
                editSource: null,
                editLayer: null,
                csvSource: null,
                csvLayer: null,
                modifiedFeatures: new Map(), // id -> feature
                newFeatures: [],
                deletedIds: new Set(),
                interactions: {
                    modify: null,
                    draw: null,
                    snap: null,
                    select: null
                },
                selectedGeometryType: 'Point'
            };

            // Initialize GSP.NET UPDATES when DOM is ready
            document.addEventListener('DOMContentLoaded', function () {
                console.log('Initializing GSP.NET UPDATES...');

                // ========================================
                //  DOCK PANEL TOGGLE
                // ========================================

                // GSP.NET UPDATES Button - Opens right panel for project information
                const gspnetToggleBtn = document.getElementById('gspnet-updates-toggle');
                if (gspnetToggleBtn) {
                    gspnetToggleBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('GSP.NET UPDATES button clicked');
                        // Open polygon import form panel (right side)
                        const modal = document.getElementById('polygonImportModal');
                        const mainContent = document.querySelector('.main-content');
                        console.log('Modal element:', modal);
                        if (modal) {
                            // Close other panels first
                            document.querySelectorAll('.project-library-panel, .polygon-import-panel, .parcel-search-panel').forEach(p => {
                                p.classList.remove('active');
                            });
                            // Open this panel
                            modal.classList.add('active');
                            // Add panel-open class to main-content to push map
                            if (mainContent) {
                                mainContent.classList.add('panel-open');
                            }
                            console.log('Panel opened on right side');
                            populatePolygonImportForm();
                            console.log('Panel opened and form populated');
                        } else {
                            console.error('Polygon import modal not found');
                        }
                    });
                    console.log('✅ GSP.NET UPDATES button handler attached');
                } else {
                    console.error('❌ GSP.NET UPDATES button not found');
                }

                // PARCEL SEARCH Button - Opens right panel
                const parcelSearchBtn = document.getElementById('parcelSearchBtn');
                if (parcelSearchBtn) {
                    parcelSearchBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Parcel Search button clicked');
                        const panel = document.getElementById('parcelSearchPanel');
                        if (panel) {
                            panel.style.display = 'flex';
                            populateParcelSearchForm();
                            console.log('Parcel search panel opened');
                        } else {
                            console.error('Parcel search panel not found');
                        }
                    });
                    console.log('✅ Parcel Search button handler attached');
                } else {
                    console.error('❌ Parcel Search button not found');
                }

                // Polygon Import Modal handlers
                const polygonImportModal = document.getElementById('polygonImportModal');
                const polygonImportClose = document.getElementById('polygonImportClose');
                const polygonFormCancel = document.getElementById('polygonFormCancel');

                if (polygonImportClose) {
                    polygonImportClose.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const modal = document.getElementById('polygonImportModal');
                        const mainContent = document.querySelector('.main-content');
                        if (modal) {
                            modal.classList.remove('active');
                            // Remove panel-open class if no other panels are open
                            if (mainContent && !document.querySelector('.project-library-panel.active, .polygon-import-panel.active, .parcel-search-panel.active, .polygon-import-modal.active')) {
                                mainContent.classList.remove('panel-open');
                            }
                            console.log('Polygon import panel closed');
                        }
                    });
                }

                if (polygonFormCancel) {
                    polygonFormCancel.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const modal = document.getElementById('polygonImportModal');
                        const mainContent = document.querySelector('.main-content');
                        if (modal) {
                            modal.classList.remove('active');
                            // Remove panel-open class if no other panels are open
                            if (mainContent && !document.querySelector('.project-library-panel.active, .polygon-import-panel.active, .parcel-search-panel.active, .polygon-import-modal.active')) {
                                mainContent.classList.remove('panel-open');
                            }
                            console.log('Polygon import panel closed (cancel)');
                        }
                    });
                }

                // Note: Removed "click outside to close" since it's now a right-side panel

                // Close polygon import panel
                const polygonImportPanelClose = document.getElementById('polygonImportPanelClose');
                if (polygonImportPanelClose) {
                    polygonImportPanelClose.addEventListener('click', function () {
                        const panel = document.getElementById('polygonImportPanel');
                        const mainContent = document.querySelector('.main-content');
                        if (panel) {
                            panel.classList.remove('active');
                            panel.style.display = 'none';
                            // Reset workflow state
                            if (typeof polygonImportState !== 'undefined') {
                                polygonImportState.selectedLayer = null;
                                polygonImportState.csvData = null;
                                polygonImportState.csvFileId = null;
                                polygonImportState.selectedParcel = null;
                                polygonImportState.createdPolygons = [];
                                polygonImportState.validationErrors = [];
                            }
                            // Hide all workflow sections
                            const plotSection = panel.querySelector('#gsp-plot-section');
                            const polygonSection = panel.querySelector('#gsp-polygon-section');
                            const saveSection = panel.querySelector('#gsp-save-polygon-section');
                            if (plotSection) plotSection.style.display = 'none';
                            if (polygonSection) polygonSection.style.display = 'none';
                            if (saveSection) saveSection.style.display = 'none';
                            // Clear any plotted points from map if needed
                            if (typeof clearPolygonPoints === 'function') {
                                clearPolygonPoints();
                            }
                        }
                        // Remove panel-open class only if no other panels are open
                        if (mainContent && !document.querySelector('.project-library-panel.active, .parcel-search-panel.active')) {
                            mainContent.classList.remove('panel-open');
                        }
                    });
                }

                // Back button to return to project information modal
                const polygonImportPanelBack = document.getElementById('polygonImportPanelBack');
                if (polygonImportPanelBack) {
                    polygonImportPanelBack.addEventListener('click', function () {
                        const panel = document.getElementById('polygonImportPanel');
                        const modal = document.getElementById('polygonImportModal');
                        const mainContent = document.querySelector('.main-content');

                        // Close the workflow panel
                        if (panel) {
                            panel.classList.remove('active');
                            panel.style.display = 'none';
                        }

                        // Show the project information modal
                        if (modal) {
                            modal.classList.add('active');
                            if (mainContent && !document.querySelector('.project-library-panel.active, .parcel-search-panel.active')) {
                                mainContent.classList.add('panel-open');
                            }
                        }
                    });
                }

                // Populate form dropdowns
                function populatePolygonImportForm() {
                    // Populate coordinate systems
                    const coordSystemSelect = document.getElementById('polygonCoordinateSystem');
                    if (coordSystemSelect && typeof UGANDA_COORDINATE_SYSTEMS !== 'undefined') {
                        coordSystemSelect.innerHTML = '';
                        UGANDA_COORDINATE_SYSTEMS.forEach(crs => {
                            const option = document.createElement('option');
                            option.value = crs.value;
                            option.textContent = crs.label;
                            coordSystemSelect.appendChild(option);
                        });
                    }

                    // Populate districts
                    const districtSelect = document.getElementById('polygonDistrict');
                    if (districtSelect && typeof UGANDA_DISTRICTS !== 'undefined') {
                        // Keep the first option (-- Select District --)
                        const firstOption = districtSelect.querySelector('option[value=""]');
                        districtSelect.innerHTML = '';
                        if (firstOption) {
                            districtSelect.appendChild(firstOption);
                        }
                        UGANDA_DISTRICTS.forEach(district => {
                            const option = document.createElement('option');
                            option.value = district;
                            option.textContent = district;
                            districtSelect.appendChild(option);
                        });
                    }
                }

                // Polygon Import State
                let polygonImportState = {
                    formData: null,
                    selectedLayer: null,
                    csvData: null,
                    csvFileId: null,
                    selectedParcel: null,
                    createdPolygons: [],
                    validationErrors: []
                };

                // Handle form submission
                const polygonImportForm = document.getElementById('polygonImportForm');
                if (polygonImportForm) {
                    polygonImportForm.addEventListener('submit', function (e) {
                        e.preventDefault();

                        // Collect form data
                        const formData = {
                            client: document.getElementById('polygonClient').value.trim(),
                            projectName: document.getElementById('polygonProjectName').value.trim(),
                            coordinateSystem: document.getElementById('polygonCoordinateSystem').value,
                            district: document.getElementById('polygonDistrict').value,
                            blockNumber: document.getElementById('polygonBlockNumber').value.trim(),
                            plotNumber: document.getElementById('polygonPlotNumber').value.trim(),
                            county: document.getElementById('polygonCounty').value.trim(),
                            surveyor: document.getElementById('polygonSurveyor').value.trim(),
                            supervisor: document.getElementById('polygonSupervisor').value.trim(),
                            company: document.getElementById('polygonCompany').value.trim(),
                            additionalInfo: document.getElementById('polygonAdditionalInfo').value.trim()
                        };

                        // Validate required fields
                        if (!formData.client || !formData.projectName || !formData.coordinateSystem || !formData.district || !formData.surveyor || !formData.supervisor) {
                            showToast('Please fill in all required fields', 'error');
                            return;
                        }

                        // Store form data in state
                        polygonImportState.formData = formData;

                        // Close project information panel and open workflow panel
                        const polygonImportModal = document.getElementById('polygonImportModal');
                        const polygonImportPanel = document.getElementById('polygonImportPanel');
                        const mainContent = document.querySelector('.main-content');

                        if (polygonImportModal) {
                            polygonImportModal.classList.remove('active');
                            if (mainContent && !document.querySelector('.project-library-panel.active, .polygon-import-panel.active, .parcel-search-panel.active')) {
                                mainContent.classList.remove('panel-open');
                            }
                        }

                        // Open right panel for workflow
                        if (polygonImportPanel) {
                            // Close other panels first
                            document.querySelectorAll('.project-library-panel, .parcel-search-panel').forEach(p => {
                                p.classList.remove('active');
                                p.style.display = 'none';
                            });
                            polygonImportPanel.classList.add('active');
                            polygonImportPanel.style.display = 'flex';
                            // Keep panel-open class since we're opening another panel
                            if (mainContent) mainContent.classList.add('panel-open');

                            // Initialize workflow
                            initializePolygonImportWorkflow();

                            // Also initialize CSV handlers when panel becomes visible
                            // Use a small delay to ensure DOM is ready
                            setTimeout(function () {
                                console.log('⏰ Panel should be visible now, initializing CSV handlers...');
                                initializePolygonCSVHandlers();
                            }, 500);
                        } else {
                            console.error('Polygon import panel not found');
                        }
                    });
                }

                // Initialize polygon import workflow in right panel
                function initializePolygonImportWorkflow() {
                    console.log('Initializing polygon import workflow...');

                    // Get the polygon import panel first
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    if (!polygonImportPanel) {
                        console.error('Polygon import panel not found');
                        return;
                    }

                    // Pre-fill coordinate system in panel - find within the panel
                    const polygonCrsConfirm = polygonImportPanel.querySelector('#polygon-crs-confirm');
                    console.log('Coordinate system dropdown element:', polygonCrsConfirm);
                    if (polygonCrsConfirm) {
                        polygonCrsConfirm.innerHTML = '<option value="">-- Select Coordinate System --</option>';

                        // Default Uganda coordinate systems (always available)
                        const defaultSystems = [
                            { value: 'EPSG:32636', label: 'WGS84 UTM Zone 36N (EPSG:32636)' },
                            { value: 'EPSG:21096', label: 'Arc1960 UTM Zone 36N (EPSG:21096)' },
                            { value: 'EPSG:21036', label: 'Arc1960 UTM Zone 36S (EPSG:21036)' },
                            { value: 'EPSG:32736', label: 'WGS84 UTM Zone 36S (EPSG:32736)' },
                            { value: 'EPSG:4326', label: 'WGS84 Geographic Lat/Lon (EPSG:4326)' }
                        ];

                        // Check for UGANDA_COORDINATE_SYSTEMS in multiple ways
                        let coordinateSystems = null;
                        if (typeof UGANDA_COORDINATE_SYSTEMS !== 'undefined' && UGANDA_COORDINATE_SYSTEMS.length > 0) {
                            coordinateSystems = UGANDA_COORDINATE_SYSTEMS;
                            console.log('✅ Found UGANDA_COORDINATE_SYSTEMS:', coordinateSystems.length);
                        } else if (typeof window !== 'undefined' && typeof window.UGANDA_COORDINATE_SYSTEMS !== 'undefined' && window.UGANDA_COORDINATE_SYSTEMS.length > 0) {
                            coordinateSystems = window.UGANDA_COORDINATE_SYSTEMS;
                            console.log('✅ Found window.UGANDA_COORDINATE_SYSTEMS:', coordinateSystems.length);
                        } else {
                            console.warn('⚠️ UGANDA_COORDINATE_SYSTEMS not found, using defaults');
                            coordinateSystems = defaultSystems;
                        }

                        // Populate dropdown
                        if (coordinateSystems && coordinateSystems.length > 0) {
                            coordinateSystems.forEach(crs => {
                                const option = document.createElement('option');
                                option.value = crs.value;
                                option.textContent = crs.label;
                                if (polygonImportState.formData && crs.value === polygonImportState.formData.coordinateSystem) {
                                    option.selected = true;
                                }
                                polygonCrsConfirm.appendChild(option);
                            });
                            console.log('✅ Coordinate system dropdown populated with', coordinateSystems.length, 'options');
                        } else {
                            console.error('❌ No coordinate systems available');
                        }
                        const crsInfo = polygonImportPanel.querySelector('#crs-info');
                        if (crsInfo && polygonImportState.formData) {
                            crsInfo.textContent = `Selected: ${polygonImportState.formData.coordinateSystem || 'Not selected'}`;
                        }
                    } else {
                        console.error('polygon-crs-confirm dropdown not found in polygon-import-panel');
                    }

                    // Reset workflow state
                    polygonImportState.selectedLayer = null;
                    polygonImportState.csvData = null;
                    polygonImportState.csvFileId = null;
                    polygonImportState.selectedParcel = null;
                    polygonImportState.createdPolygons = [];
                    polygonImportState.validationErrors = [];

                    // Hide all workflow sections initially - find within panel
                    const plotSection = polygonImportPanel.querySelector('#gsp-plot-section');
                    const polygonSection = polygonImportPanel.querySelector('#gsp-polygon-section');
                    const saveSection = polygonImportPanel.querySelector('#gsp-save-polygon-section');
                    if (plotSection) plotSection.style.display = 'none';
                    if (polygonSection) polygonSection.style.display = 'none';
                    if (saveSection) saveSection.style.display = 'none';

                    // Initialize button handlers when panel opens
                    initializePolygonWorkflowHandlers();

                    showToast('Form submitted. Please select a layer and import CSV.', 'success');
                }

                // Initialize polygon workflow button handlers
                function initializePolygonWorkflowHandlers() {
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    if (!polygonImportPanel) return;

                    // Plot Points button
                    const plotPointsBtn = polygonImportPanel.querySelector('#plot-points-btn');
                    if (plotPointsBtn && !plotPointsBtn.hasAttribute('data-handler-attached')) {
                        plotPointsBtn.setAttribute('data-handler-attached', 'true');
                        plotPointsBtn.addEventListener('click', function () {
                            if (!polygonImportState.selectedParcel) {
                                showToast('Please select a parcel first', 'warning');
                                return;
                            }
                            plotPolygonPointsOnMap(polygonImportState.selectedParcel);
                        });
                    }

                    // Clear Points button
                    const clearPointsBtn = polygonImportPanel.querySelector('#clear-points-btn');
                    if (clearPointsBtn && !clearPointsBtn.hasAttribute('data-handler-attached')) {
                        clearPointsBtn.setAttribute('data-handler-attached', 'true');
                        clearPointsBtn.addEventListener('click', function () {
                            clearPolygonPoints();
                        });
                    }

                    // Create Polygon button
                    const createPolygonBtn = polygonImportPanel.querySelector('#create-polygon-btn');
                    if (createPolygonBtn && !createPolygonBtn.hasAttribute('data-handler-attached')) {
                        createPolygonBtn.setAttribute('data-handler-attached', 'true');
                        createPolygonBtn.addEventListener('click', async function () {
                            await createPolygonFromPoints();
                        });
                    }

                    // Save Polygon button
                    const savePolygonBtn = polygonImportPanel.querySelector('#save-polygon-btn');
                    if (savePolygonBtn && !savePolygonBtn.hasAttribute('data-handler-attached')) {
                        savePolygonBtn.setAttribute('data-handler-attached', 'true');
                        savePolygonBtn.addEventListener('click', async function () {
                            await savePolygonToDatabase();
                        });
                    }

                    // Create Another button
                    const createAnotherBtn = polygonImportPanel.querySelector('#create-another-btn');
                    if (createAnotherBtn && !createAnotherBtn.hasAttribute('data-handler-attached')) {
                        createAnotherBtn.setAttribute('data-handler-attached', 'true');
                        createAnotherBtn.addEventListener('click', function () {
                            // Reset for next polygon
                            clearPolygonPoints();
                            const polygonSection = polygonImportPanel.querySelector('#gsp-polygon-section');
                            const saveSection = polygonImportPanel.querySelector('#gsp-save-polygon-section');
                            const plotSection = polygonImportPanel.querySelector('#gsp-plot-section');
                            if (polygonSection) polygonSection.style.display = 'none';
                            if (saveSection) saveSection.style.display = 'none';
                            if (plotSection) plotSection.style.display = 'block';
                            polygonImportState.selectedParcel = null;
                            const parcelSelector = polygonImportPanel.querySelector('#parcel-selector');
                            if (parcelSelector) parcelSelector.value = '';
                        });
                    }

                    console.log('✅ Polygon workflow button handlers initialized');
                }

                // Initialize CSV file handlers - copied from GSP.NET ASSIST working implementation
                function initializePolygonCSVHandlers() {
                    console.log('🔧 Initializing CSV handlers (using GSP.NET ASSIST pattern)...');

                    // Get the polygon import panel
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    if (!polygonImportPanel) {
                        console.error('❌ Polygon import panel not found');
                        return;
                    }

                    // Get elements from within the panel
                    const polygonCsvDropArea = polygonImportPanel.querySelector('#polygon-csv-drop-area');
                    const polygonCsvBrowseBtn = polygonImportPanel.querySelector('#polygon-csv-browse-btn');
                    const polygonCsvFileInput = polygonImportPanel.querySelector('#polygon-csv-file-input');

                    if (!polygonCsvDropArea || !polygonCsvBrowseBtn || !polygonCsvFileInput) {
                        console.error('❌ CSV elements not found:', {
                            dropArea: !!polygonCsvDropArea,
                            browseBtn: !!polygonCsvBrowseBtn,
                            fileInput: !!polygonCsvFileInput
                        });
                        return;
                    }

                    console.log('✅ All CSV elements found');

                    // Browse button handler - simple and direct (like GSP.NET ASSIST)
                    polygonCsvBrowseBtn.addEventListener('click', function () {
                        console.log('🖱️ Browse button clicked');
                        polygonCsvFileInput.click();
                    });

                    // File input change handler - simple and direct (like GSP.NET ASSIST)
                    polygonCsvFileInput.addEventListener('change', function () {
                        if (this.files.length > 0) {
                            const file = this.files[0];
                            console.log('📄 File selected:', file.name);
                            if (file.name.toLowerCase().endsWith('.csv')) {
                                handlePolygonCSVFile(file);
                            } else {
                                showToast('Please select a CSV file', 'error');
                            }
                        }
                    });

                    // Drag and drop handlers - using the proven pattern from other working implementations
                    function preventDefaults(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    function highlight() {
                        polygonCsvDropArea.style.borderColor = '#3498db';
                        polygonCsvDropArea.style.background = '#e3f2fd';
                    }

                    function unhighlight() {
                        polygonCsvDropArea.style.borderColor = '#ddd';
                        polygonCsvDropArea.style.background = '#f8f9fa';
                    }

                    // Prevent default drag behaviors
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        polygonCsvDropArea.addEventListener(eventName, preventDefaults, false);
                    });

                    // Highlight drop area when dragging over
                    ['dragenter', 'dragover'].forEach(eventName => {
                        polygonCsvDropArea.addEventListener(eventName, highlight, false);
                    });

                    // Unhighlight when leaving or dropping
                    ['dragleave', 'drop'].forEach(eventName => {
                        polygonCsvDropArea.addEventListener(eventName, unhighlight, false);
                    });

                    // Handle file drop
                    polygonCsvDropArea.addEventListener('drop', function (e) {
                        const dt = e.dataTransfer;
                        const files = dt.files;

                        console.log('📦 Files dropped:', files.length);
                        if (files.length > 0) {
                            const file = files[0];
                            console.log('📄 Dropped file:', file.name);
                            if (file.name.toLowerCase().endsWith('.csv')) {
                                handlePolygonCSVFile(file);
                            } else {
                                showToast('Please drop a CSV file', 'error');
                            }
                        }
                    }, false);

                    console.log('✅✅✅ CSV handlers initialized successfully (GSP.NET ASSIST pattern)');
                }

                // ========================================
                // POLYGON IMPORT WORKFLOW HANDLERS
                // ========================================

                // Layer selection handler
                const layerRadios = document.querySelectorAll('input[name="polygonLayer"]');
                layerRadios.forEach(radio => {
                    radio.addEventListener('change', function () {
                        if (this.checked) {
                            polygonImportState.selectedLayer = this.value;
                            const layerInfo = document.getElementById('layer-info');
                            if (layerInfo) {
                                layerInfo.textContent = `Selected: ${this.value}`;
                                layerInfo.style.display = 'block';
                            }
                        }
                    });
                });

                // Handle CSV file upload
                async function handlePolygonCSVFile(file) {
                    console.log('📂 Handling CSV file:', file.name);

                    // Find elements within the polygon import panel
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    const polygonCsvFilename = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-csv-filename') : document.getElementById('polygon-csv-filename');
                    const polygonCsvStatus = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-csv-status') : document.getElementById('polygon-csv-status');

                    console.log('📋 Status elements found:', {
                        filename: !!polygonCsvFilename,
                        status: !!polygonCsvStatus
                    });

                    if (polygonCsvFilename) {
                        polygonCsvFilename.textContent = file.name;
                        polygonCsvFilename.style.color = '#27ae60';
                    }

                    if (polygonCsvStatus) {
                        polygonCsvStatus.textContent = 'Reading CSV file...';
                        polygonCsvStatus.className = 'status-message';
                    }

                    try {
                        // Read CSV file
                        const csvText = await file.text();

                        // Parse CSV
                        const parsedData = parsePolygonCSV(csvText);

                        if (!parsedData || !parsedData.parcels || parsedData.parcels.length === 0) {
                            throw new Error('No valid parcels found in CSV');
                        }

                        // Store parsed data
                        polygonImportState.csvData = parsedData;

                        // Auto-save to Supabase (similar to PROJECT LIBRARY)
                        if (polygonImportState.formData) {
                            await savePolygonCSVToSupabase(file, csvText, parsedData);
                        }

                        // Update UI
                        if (polygonCsvStatus) {
                            polygonCsvStatus.textContent = `Loaded ${parsedData.parcels.length} parcel(s) with ${parsedData.totalPoints} total points`;
                            polygonCsvStatus.className = 'status-message success';
                        }

                        // Show plot section and populate parcel selector
                        const polygonImportPanel = document.getElementById('polygonImportPanel');
                        const plotSection = polygonImportPanel ? polygonImportPanel.querySelector('#gsp-plot-section') : document.getElementById('gsp-plot-section');
                        if (plotSection) {
                            plotSection.style.display = 'block';
                            console.log('✅ Plot section shown');
                        } else {
                            console.error('❌ Plot section not found');
                        }

                        populateParcelSelector(parsedData.parcels);

                    } catch (error) {
                        console.error('Error handling CSV file:', error);
                        if (polygonCsvStatus) {
                            polygonCsvStatus.textContent = 'Error: ' + error.message;
                            polygonCsvStatus.className = 'status-message error';
                        }
                        showToast('Error processing CSV: ' + error.message, 'error');
                    }
                }

                // Save CSV to Supabase
                async function savePolygonCSVToSupabase(file, csvText, parsedData) {
                    try {
                        // Get current user
                        const { data: { user } } = await supabase.auth.getUser();
                        if (!user) {
                            throw new Error('User not authenticated');
                        }

                        // Upload file to storage
                        const filePath = `polygon-imports/${user.id}/${Date.now()}_${file.name}`;
                        const { data: uploadData, error: uploadError } = await supabase.storage
                            .from('uploads')
                            .upload(filePath, csvText, {
                                contentType: 'text/csv',
                                upsert: false
                            });

                        if (uploadError) throw uploadError;

                        // Get public URL
                        const { data: urlData } = supabase.storage
                            .from('uploads')
                            .getPublicUrl(filePath);

                        // Save metadata to project_files table
                        const { data: fileData, error: fileError } = await supabase
                            .from('project_files')
                            .insert({
                                file_name: file.name,
                                file_path: filePath,
                                file_type: 'csv',
                                nature: 'other',
                                client: polygonImportState.formData.client,
                                project_name: polygonImportState.formData.projectName,
                                district: polygonImportState.formData.district,
                                county: polygonImportState.formData.county || null,
                                block_number: polygonImportState.formData.blockNumber || null,
                                plot_number: polygonImportState.formData.plotNumber || null,
                                surveyor: polygonImportState.formData.surveyor,
                                supervisor: polygonImportState.formData.supervisor,
                                company: polygonImportState.formData.company || null,
                                coordinate_system: polygonImportState.formData.coordinateSystem,
                                additional_info: polygonImportState.formData.additionalInfo || null,
                                number_of_points: parsedData.totalPoints,
                                latitude: 0, // Will be calculated from polygon center
                                longitude: 0,
                                uploaded_by: user.id
                            })
                            .select()
                            .single();

                        if (fileError) throw fileError;

                        polygonImportState.csvFileId = fileData.id;

                        console.log('CSV saved to Supabase:', fileData.id);

                    } catch (error) {
                        console.error('Error saving CSV to Supabase:', error);
                        // Don't throw - allow workflow to continue even if save fails
                    }
                }

                // Populate parcel selector dropdown
                function populateParcelSelector(parcels) {
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    const parcelSelector = polygonImportPanel ? polygonImportPanel.querySelector('#parcel-selector') : document.getElementById('parcel-selector');
                    if (!parcelSelector) {
                        console.error('Parcel selector not found');
                        return;
                    }

                    parcelSelector.innerHTML = '<option value="">-- Select Parcel --</option>';
                    parcels.forEach(parcel => {
                        const option = document.createElement('option');
                        option.value = parcel.id;
                        option.textContent = `Parcel ${parcel.id} (${parcel.points.length} points)`;
                        parcelSelector.appendChild(option);
                    });

                    // Remove existing listener if any
                    const newSelector = parcelSelector.cloneNode(true);
                    parcelSelector.parentNode.replaceChild(newSelector, parcelSelector);

                    newSelector.addEventListener('change', function () {
                        const parcelId = this.value;
                        if (parcelId) {
                            const parcel = parcels.find(p => p.id === parcelId);
                            if (parcel) {
                                polygonImportState.selectedParcel = parcel;
                                updatePointCountDisplay(parcel.points.length);
                                const plotBtn = polygonImportPanel ? polygonImportPanel.querySelector('#plot-points-btn') : document.getElementById('plot-points-btn');
                                if (plotBtn) plotBtn.disabled = false;
                            }
                        } else {
                            polygonImportState.selectedParcel = null;
                            const plotBtn = polygonImportPanel ? polygonImportPanel.querySelector('#plot-points-btn') : document.getElementById('plot-points-btn');
                            if (plotBtn) plotBtn.disabled = true;
                        }
                    });
                }

                // Update point count display
                function updatePointCountDisplay(count) {
                    const pointCountValue = document.getElementById('point-count-value');
                    if (pointCountValue) {
                        pointCountValue.textContent = count;
                    }
                }

                // Plot points on map
                let polygonPointsLayer = null;
                let polygonPointsSource = null;

                document.addEventListener('DOMContentLoaded', function () {
                    const plotPointsBtn = document.getElementById('plot-points-btn');
                    const clearPointsBtn = document.getElementById('clear-points-btn');

                    if (plotPointsBtn) {
                        plotPointsBtn.addEventListener('click', function () {
                            if (!polygonImportState.selectedParcel) {
                                showToast('Please select a parcel first', 'warning');
                                return;
                            }

                            plotPolygonPointsOnMap(polygonImportState.selectedParcel);
                        });
                    }

                    if (clearPointsBtn) {
                        clearPointsBtn.addEventListener('click', function () {
                            clearPolygonPoints();
                        });
                    }
                });

                // Plot points function
                function plotPolygonPointsOnMap(parcel) {
                    if (!parcel || !parcel.points || parcel.points.length === 0) {
                        showToast('No points to plot', 'warning');
                        return;
                    }

                    // Remove existing layer
                    if (polygonPointsLayer) {
                        map.removeLayer(polygonPointsLayer);
                    }

                    // Create new source and layer
                    polygonPointsSource = new ol.source.Vector();
                    polygonPointsLayer = new ol.layer.Vector({
                        source: polygonPointsSource,
                        zIndex: 1000,
                        style: function (feature) {
                            return new ol.style.Style({
                                image: new ol.style.Circle({
                                    radius: 6,
                                    fill: new ol.style.Fill({ color: '#f39c12' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                                }),
                                text: new ol.style.Text({
                                    text: feature.get('point_number') || '',
                                    font: '12px sans-serif',
                                    fill: new ol.style.Fill({ color: '#000' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                                    offsetY: -15
                                })
                            });
                        }
                    });

                    map.addLayer(polygonPointsLayer);

                    // Get coordinate system
                    const crs = document.getElementById('polygon-crs-confirm').value || polygonImportState.formData.coordinateSystem;

                    // Add points to source
                    const features = [];
                    const extent = [Infinity, Infinity, -Infinity, -Infinity];

                    parcel.points.forEach(point => {
                        let coord = [point.eastings, point.northings];

                        // Transform to map projection if needed
                        if (crs !== 'EPSG:3857') {
                            try {
                                coord = ol.proj.transform(coord, crs, 'EPSG:3857');
                            } catch (e) {
                                console.warn('Could not transform coordinate:', e);
                            }
                        }

                        const feature = new ol.Feature({
                            geometry: new ol.geom.Point(coord),
                            point_number: point.point_number,
                            eastings: point.eastings,
                            northings: point.northings,
                            description: point.description
                        });

                        features.push(feature);

                        // Update extent
                        extent[0] = Math.min(extent[0], coord[0]);
                        extent[1] = Math.min(extent[1], coord[1]);
                        extent[2] = Math.max(extent[2], coord[0]);
                        extent[3] = Math.max(extent[3], coord[1]);
                    });

                    polygonPointsSource.addFeatures(features);

                    // Zoom to points
                    if (extent[0] !== Infinity) {
                        map.getView().fit(extent, { padding: [50, 50, 50, 50], maxZoom: 18 });
                    }

                    // Enable polygon creation section - find within panel
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    const polygonSection = polygonImportPanel ? polygonImportPanel.querySelector('#gsp-polygon-section') : document.getElementById('gsp-polygon-section');
                    if (polygonSection) {
                        polygonSection.style.display = 'block';
                        console.log('✅ Polygon creation section shown');
                    } else {
                        console.error('❌ Polygon section not found');
                    }

                    const selectedParcelId = polygonImportPanel ? polygonImportPanel.querySelector('#selected-parcel-id') : document.getElementById('selected-parcel-id');
                    if (selectedParcelId) {
                        selectedParcelId.textContent = parcel.id;
                    }

                    const createPolygonBtn = polygonImportPanel ? polygonImportPanel.querySelector('#create-polygon-btn') : document.getElementById('create-polygon-btn');
                    const clearPointsBtn = polygonImportPanel ? polygonImportPanel.querySelector('#clear-points-btn') : document.getElementById('clear-points-btn');
                    if (createPolygonBtn) createPolygonBtn.disabled = false;
                    if (clearPointsBtn) clearPointsBtn.disabled = false;

                    showToast(`Plotted ${parcel.points.length} points on map`, 'success');
                }

                // Clear points
                function clearPolygonPoints() {
                    if (polygonPointsLayer) {
                        map.removeLayer(polygonPointsLayer);
                        polygonPointsLayer = null;
                        polygonPointsSource = null;
                    }

                    // Clear polygon preview if exists
                    if (polygonPreviewLayer) {
                        map.removeLayer(polygonPreviewLayer);
                        polygonPreviewLayer = null;
                        polygonPreviewSource = null;
                    }

                    document.getElementById('clear-points-btn').disabled = true;
                    document.getElementById('create-polygon-btn').disabled = true;
                }

                // ========================================
                // POLYGON CREATION USING EDGE FUNCTION
                // ========================================
                let polygonPreviewLayer = null;
                let polygonPreviewSource = null;
                let currentPolygonData = null;

                document.addEventListener('DOMContentLoaded', function () {
                    const createPolygonBtn = document.getElementById('create-polygon-btn');
                    const savePolygonBtn = document.getElementById('save-polygon-btn');
                    const createAnotherBtn = document.getElementById('create-another-btn');

                    if (createPolygonBtn) {
                        createPolygonBtn.addEventListener('click', async function () {
                            await createPolygonFromPoints();
                        });
                    }

                    if (savePolygonBtn) {
                        savePolygonBtn.addEventListener('click', async function () {
                            await savePolygonToDatabase();
                        });
                    }

                    if (createAnotherBtn) {
                        createAnotherBtn.addEventListener('click', function () {
                            // Reset for next polygon
                            clearPolygonPoints();
                            document.getElementById('gsp-polygon-section').style.display = 'none';
                            document.getElementById('gsp-save-polygon-section').style.display = 'none';
                            document.getElementById('gsp-plot-section').style.display = 'block';
                            polygonImportState.selectedParcel = null;
                            document.getElementById('parcel-selector').value = '';
                        });
                    }
                });

                // Create polygon from points using edge function
                async function createPolygonFromPoints() {
                    // Get panel reference first
                    const polygonImportPanel = document.getElementById('polygonImportPanel');

                    if (!polygonImportState.selectedParcel || !polygonImportState.selectedParcel.points) {
                        showToast('No points selected', 'error');
                        return;
                    }

                    // Check if layer is selected
                    if (!polygonImportState.selectedLayer) {
                        showToast('Please select a layer first', 'error');
                        return;
                    }

                    const createBtn = polygonImportPanel ? polygonImportPanel.querySelector('#create-polygon-btn') : document.getElementById('create-polygon-btn');
                    const validationResults = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-validation-results') : document.getElementById('polygon-validation-results');
                    const previewInfo = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-preview-info') : document.getElementById('polygon-preview-info');

                    if (!createBtn) {
                        console.error('Create polygon button not found');
                        return;
                    }

                    createBtn.disabled = true;
                    createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating Polygon...';

                    if (validationResults) {
                        validationResults.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Validating and creating polygon...</p>';
                    }

                    try {
                        const crsSelect = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-crs-confirm') : document.getElementById('polygon-crs-confirm');
                        const crs = crsSelect ? crsSelect.value : (polygonImportState.formData ? polygonImportState.formData.coordinateSystem : null);

                        if (!crs) {
                            showToast('Please select a coordinate system', 'error');
                            createBtn.disabled = false;
                            createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                            return;
                        }

                        // Check if user wants to skip self-intersection check
                        const skipSelfIntersectionCheckbox = polygonImportPanel ? polygonImportPanel.querySelector('#skip-self-intersection-check') : document.getElementById('skip-self-intersection-check');
                        const skipSelfIntersectionCheck = skipSelfIntersectionCheckbox ? skipSelfIntersectionCheckbox.checked : false;

                        // Transform coordinates to WGS84 on client side using OpenLayers proj4
                        const points = polygonImportState.selectedParcel.points.map(p => {
                            // Ensure coordinates are numbers
                            const x = parseFloat(p.eastings);
                            const y = parseFloat(p.northings);

                            if (isNaN(x) || isNaN(y)) {
                                throw new Error(`Invalid coordinates: eastings=${p.eastings}, northings=${p.northings}`);
                            }

                            // Transform from source CRS to WGS84 using OpenLayers proj4
                            let wgs84Coord;
                            try {
                                wgs84Coord = ol.proj.transform([x, y], crs, 'EPSG:4326');
                                console.log(`Transformed [${x}, ${y}] from ${crs} to WGS84: [${wgs84Coord[0]}, ${wgs84Coord[1]}]`);
                            } catch (error) {
                                console.error('Error transforming coordinate:', error);
                                throw new Error(`Failed to transform coordinates from ${crs} to WGS84: ${error.message}`);
                            }

                            return {
                                x: wgs84Coord[0], // Longitude
                                y: wgs84Coord[1], // Latitude
                                parcelnumber: p.parcelnumber,
                                point_number: p.point_number,
                                description: p.description
                            };
                        });

                        // Validate we have at least 3 points
                        if (points.length < 3) {
                            showToast('At least 3 points are required to create a polygon', 'error');
                            createBtn.disabled = false;
                            createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                            return;
                        }

                        // Call edge function
                        console.log('📞 Calling polygon-creator edge function with:', {
                            pointsCount: points.length,
                            crs: crs,
                            firstPoint: points[0],
                            lastPoint: points[points.length - 1],
                            allPoints: points.map(p => ({ x: p.x, y: p.y }))
                        });

                        // Use fetch directly to access full response including error bodies
                        // Use existing supabase instance (already declared at top of file)
                        const { data: { session } } = await supabase.auth.getSession();
                        const key = window.supabaseKey || supabaseKey;
                        const token = session?.access_token || key;

                        let responseData = null;
                        let responseError = null;

                        try {
                            // Use window.supabaseUrl as fallback if supabaseUrl is not in scope
                            const url = (typeof supabaseUrl !== 'undefined' ? supabaseUrl : window.supabaseUrl) || 'https://kwssgfanbntfjdclchfi.supabase.co';
                            const response = await fetch(`${url}/functions/v1/polygon-creator`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${token}`,
                                    'apikey': key
                                },
                                body: JSON.stringify({
                                    points: points,
                                    crs: 'EPSG:4326', // Always send WGS84 since we transform on client side
                                    validate: true,
                                    skipSelfIntersectionCheck: skipSelfIntersectionCheck
                                })
                            });

                            const responseText = await response.text();
                            console.log('📥 Edge function raw response:', {
                                status: response.status,
                                statusText: response.statusText,
                                body: responseText.substring(0, 500)
                            });

                            let parsedData;
                            try {
                                parsedData = JSON.parse(responseText);
                            } catch (e) {
                                console.error('Failed to parse response as JSON:', e);
                                throw new Error('Invalid response from edge function: ' + responseText.substring(0, 200));
                            }

                            // Check if response indicates error
                            if (!response.ok || !parsedData.success) {
                                responseError = {
                                    status: response.status,
                                    data: parsedData
                                };
                            } else {
                                responseData = parsedData;
                            }

                            console.log('📥 Edge function response:', { data: responseData, error: responseError });
                        } catch (err) {
                            console.error('❌ Exception calling edge function:', err);
                            responseError = err;
                        }

                        // Handle error response - edge function may return 400/500 with JSON body
                        if (responseError) {
                            console.error('❌ Edge function error:', responseError);

                            // Extract errors from response (using fetch, errors are in responseError.data)
                            let validationErrors = [];
                            if (responseError.data && responseError.data.errors && Array.isArray(responseError.data.errors)) {
                                validationErrors = responseError.data.errors;
                                console.error('📋 Validation errors:', validationErrors);
                            } else if (responseError.data && responseError.data.error) {
                                validationErrors = [responseError.data.error];
                                console.error('📋 Error message:', responseError.data.error);
                            } else if (responseError.message) {
                                validationErrors = [responseError.message];
                                console.error('📋 Error message:', responseError.message);
                            } else if (responseError.data) {
                                // Try to extract any error information from data
                                const errorStr = JSON.stringify(responseError.data);
                                validationErrors = [`Error: ${errorStr.substring(0, 200)}`];
                                console.error('📋 Error data:', responseError.data);
                            } else {
                                validationErrors = ['Unknown error occurred. Please check the console for details.'];
                                console.error('📋 Unknown error structure:', responseError);
                            }

                            // Show validation errors nicely
                            if (validationResults) {
                                validationResults.innerHTML = '<div class="status-message error"><strong>Validation Errors:</strong><ul>' +
                                    validationErrors.map(e => `<li>${e}</li>`).join('') + '</ul></div>';
                            }

                            const errorMessage = validationErrors.length > 0 ? validationErrors[0] : 'Polygon validation failed';
                            showToast(errorMessage, 'error');
                            createBtn.disabled = false;
                            createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                            return;
                        }

                        // OLD CODE BELOW - REMOVED (removed unclosed comment block)
                        /*
                            // Check if error has a response body we can parse
                            if (responseError.context) {
                                try {
                                    // Try to get error details from context
                                    if (responseError.context.body) {
                                        const errorBody = typeof responseError.context.body === 'string' 
                                            ? JSON.parse(responseError.context.body) 
                                            : responseError.context.body;
                                        if (errorBody.errors && Array.isArray(errorBody.errors)) {
                                            validationErrors = errorBody.errors;
                                            errorMessage = validationErrors.join(', ');
                                        } else if (errorBody.message) {
                                            errorMessage = errorBody.message;
                                        }
                                    }
                                } catch (e) {
                                    console.warn('Could not parse error body:', e);
                                }
                            }
                            
                            // If we have validation errors, show them nicely
                            if (validationErrors.length > 0) {
                                if (validationResults) {
                                    validationResults.innerHTML = '<div class="status-message error"><strong>Validation Errors:</strong><ul>' +
                                        validationErrors.map(e => `<li>${e}</li>`).join('') + '</ul></div>';
                                }
                                showToast('Polygon validation failed. Please check the errors.', 'error');
                                createBtn.disabled = false;
                                createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                                return;
                            }
                            
                            throw new Error(errorMessage);
                        }
                        */

                        // Check if data indicates failure
                        if (!responseData || !responseData.success) {
                            // Validation failed
                            const errors = responseData?.errors || ['Unknown validation error'];
                            if (validationResults) {
                                validationResults.innerHTML = '<div class="status-message error"><strong>Validation Errors:</strong><ul>' +
                                    errors.map(e => `<li>${e}</li>`).join('') + '</ul></div>';
                            }

                            // Highlight problematic points (could be enhanced)
                            showToast('Polygon validation failed. Please check the errors.', 'error');
                            createBtn.disabled = false;
                            createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                            return;
                        }

                        // Use responseData as data for the rest of the function
                        const data = responseData;

                        // Polygon created successfully
                        currentPolygonData = data;

                        console.log('✅ Polygon created successfully:', {
                            hasGeometry: !!data.geometry,
                            area: data.area_hectares,
                            vertices: data.num_vertices,
                            edgeDistances: data.edge_distances?.length
                        });

                        // Display polygon on map
                        if (data.geometry) {
                            displayPolygonPreview(data.geometry, data.edge_distances, data.area_hectares);
                        } else {
                            console.error('❌ No geometry in response');
                            showToast('Error: No geometry returned from edge function', 'error');
                        }

                        // Show preview info
                        if (previewInfo) {
                            const polygonAreaDisplay = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-area-display') : document.getElementById('polygon-area-display');
                            const polygonVerticesDisplay = polygonImportPanel ? polygonImportPanel.querySelector('#polygon-vertices-display') : document.getElementById('polygon-vertices-display');
                            if (polygonAreaDisplay) polygonAreaDisplay.textContent = data.area_hectares.toFixed(4);
                            if (polygonVerticesDisplay) polygonVerticesDisplay.textContent = data.num_vertices;
                            previewInfo.style.display = 'block';
                        }

                        if (validationResults) {
                            validationResults.innerHTML = '<div class="status-message success"><i class="fas fa-check-circle"></i> Polygon created successfully!</div>';
                        }

                        // Show save section - find within panel (reuse existing polygonImportPanel variable)
                        const saveSection = polygonImportPanel ? polygonImportPanel.querySelector('#gsp-save-polygon-section') : document.getElementById('gsp-save-polygon-section');
                        if (saveSection) {
                            saveSection.style.display = 'block';
                            console.log('✅ Save section shown');
                        } else {
                            console.error('❌ Save section not found');
                        }

                        // Generate unique ID (will be confirmed on save)
                        const layerName = polygonImportState.selectedLayer;
                        if (!layerName) {
                            showToast('Please select a layer first', 'error');
                            return;
                        }
                        const uniqueId = await generatePolygonUniqueId(layerName);

                        const saveUniqueId = polygonImportPanel ? polygonImportPanel.querySelector('#save-unique-id') : document.getElementById('save-unique-id');
                        const saveLayerName = polygonImportPanel ? polygonImportPanel.querySelector('#save-layer-name') : document.getElementById('save-layer-name');
                        const saveArea = polygonImportPanel ? polygonImportPanel.querySelector('#save-area') : document.getElementById('save-area');
                        const savePolygonBtn = polygonImportPanel ? polygonImportPanel.querySelector('#save-polygon-btn') : document.getElementById('save-polygon-btn');
                        const createAnotherBtn = polygonImportPanel ? polygonImportPanel.querySelector('#create-another-btn') : document.getElementById('create-another-btn');

                        if (saveUniqueId) saveUniqueId.textContent = uniqueId;
                        if (saveLayerName) saveLayerName.textContent = layerName;
                        if (saveArea) saveArea.textContent = data.area_hectares.toFixed(4);
                        if (savePolygonBtn) {
                            savePolygonBtn.disabled = false;
                            console.log('✅ Save polygon button enabled');
                        } else {
                            console.error('❌ Save polygon button not found');
                        }
                        if (createAnotherBtn) createAnotherBtn.disabled = false;

                        createBtn.disabled = false;
                        createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';

                        showToast('Polygon created successfully!', 'success');

                    } catch (error) {
                        console.error('Error creating polygon:', error);
                        if (validationResults) {
                            validationResults.innerHTML = '<div class="status-message error">Error: ' + error.message + '</div>';
                        }
                        createBtn.disabled = false;
                        createBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Polygon';
                        showToast('Error creating polygon: ' + error.message, 'error');
                    }
                }

                // Display polygon preview on map
                function displayPolygonPreview(geometry, edgeDistances, areaHectares) {
                    console.log('🎨 Displaying polygon preview:', {
                        geometryType: geometry?.type,
                        coordinates: geometry?.coordinates?.length,
                        edgeDistances: edgeDistances?.length,
                        area: areaHectares
                    });

                    // Remove existing preview
                    if (polygonPreviewLayer) {
                        map.removeLayer(polygonPreviewLayer);
                        polygonPreviewLayer = null;
                        polygonPreviewSource = null;
                    }

                    if (!geometry) {
                        console.error('❌ No geometry provided to displayPolygonPreview');
                        showToast('Error: No geometry to display', 'error');
                        return;
                    }

                    // Create GeoJSON format
                    const format = new ol.format.GeoJSON();
                    let features;
                    try {
                        features = format.readFeatures({
                            type: 'FeatureCollection',
                            features: [{
                                type: 'Feature',
                                geometry: geometry
                            }]
                        }, {
                            dataProjection: 'EPSG:4326',
                            featureProjection: 'EPSG:3857'
                        });
                        console.log('✅ Features created:', features.length);
                    } catch (e) {
                        console.error('❌ Error reading features:', e);
                        showToast('Error displaying polygon: ' + e.message, 'error');
                        return;
                    }

                    if (!features || features.length === 0) {
                        console.error('❌ No features created from geometry');
                        showToast('Error: Could not create features from geometry', 'error');
                        return;
                    }

                    polygonPreviewSource = new ol.source.Vector({
                        features: features
                    });

                    polygonPreviewLayer = new ol.layer.Vector({
                        source: polygonPreviewSource,
                        zIndex: 1001,
                        style: function (feature) {
                            const styles = [
                                new ol.style.Style({
                                    stroke: new ol.style.Stroke({
                                        color: '#3498db',
                                        width: 3
                                    })
                                    // No fill as specified
                                })
                            ];

                            // Add distance labels on edges with rotation
                            if (edgeDistances && edgeDistances.length > 0) {
                                const coords = feature.getGeometry().getCoordinates()[0];
                                edgeDistances.forEach((edge, index) => {
                                    if (index < coords.length - 1) {
                                        // Get the two points that form this edge in map coordinates
                                        const p1 = coords[index];
                                        const p2 = coords[(index + 1) % (coords.length - 1)]; // Wrap around, exclude closing point

                                        // Use LineString geometry for automatic text alignment along the edge
                                        // Create a LineString for this edge
                                        const edgeLine = new ol.geom.LineString([p1, p2]);

                                        styles.push(new ol.style.Style({
                                            text: new ol.style.Text({
                                                text: edge.label,
                                                font: '12px sans-serif',
                                                fill: new ol.style.Fill({ color: '#333' }),
                                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                                                offsetY: -10, // Offset perpendicular to line
                                                placement: 'line', // Automatically aligns text along the line
                                                textAlign: 'center',
                                                textBaseline: 'middle',
                                                overflow: true,
                                                maxAngle: Math.PI / 4 // Only show text if line is not too steep
                                            }),
                                            geometry: edgeLine // Use line geometry instead of point
                                        }));
                                    }
                                });
                            }

                            // Add area label in center
                            const center = ol.extent.getCenter(feature.getGeometry().getExtent());
                            styles.push(new ol.style.Style({
                                text: new ol.style.Text({
                                    text: `${areaHectares.toFixed(4)} ha`,
                                    font: 'bold 14px sans-serif',
                                    fill: new ol.style.Fill({ color: '#000' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                                    placement: 'point'
                                }),
                                geometry: new ol.geom.Point(center)
                            }));

                            return styles;
                        }
                    });

                    // Add layer to map
                    map.addLayer(polygonPreviewLayer);
                    console.log('✅ Polygon preview layer added to map');

                    // Zoom to polygon extent
                    if (features.length > 0) {
                        const extent = features[0].getGeometry().getExtent();
                        if (extent && extent[0] !== Infinity) {
                            map.getView().fit(extent, { padding: [50, 50, 50, 50], maxZoom: 18 });
                            console.log('✅ Map zoomed to polygon extent');
                        }
                    } else {
                        console.warn('⚠️ No features to zoom to');
                    }
                }

                // Generate unique ID (call database function)
                async function generatePolygonUniqueId(layerName) {
                    try {
                        const { data, error } = await supabase.rpc('generate_polygon_unique_id', {
                            layer_name: layerName
                        });

                        if (error) throw error;
                        return data;
                    } catch (error) {
                        console.error('Error generating unique ID:', error);
                        // Fallback: generate client-side
                        const prefix = {
                            'TITLE TRACTS UTM ZONE 36N': 'TT36N',
                            'TITLE TRACTS UTM ZONE 36S': 'TT36S',
                            'UNTITLED UTM ZONE 36N': 'UT36N',
                            'UNTITLED UTM ZONE 36S': 'UT36S',
                            'BLB-UNTITLED': 'BLB'
                        }[layerName] || 'POLY';

                        return `${prefix}-${Date.now().toString().slice(-3)}`;
                    }
                }

                // Save polygon to database
                async function savePolygonToDatabase() {
                    if (!currentPolygonData || !polygonImportState.formData || !polygonImportState.selectedLayer) {
                        showToast('Missing required data', 'error');
                        return;
                    }

                    // Find elements within the polygon import panel
                    const polygonImportPanel = document.getElementById('polygonImportPanel');
                    console.log('🔍 Looking for save button and status in panel:', polygonImportPanel ? 'found' : 'not found');

                    const saveBtn = polygonImportPanel ? polygonImportPanel.querySelector('#save-polygon-btn') : document.getElementById('save-polygon-btn');
                    const saveStatus = polygonImportPanel ? polygonImportPanel.querySelector('#save-status') : document.getElementById('save-status');

                    console.log('🔍 Save button found:', saveBtn ? 'yes' : 'no');
                    console.log('🔍 Save status found:', saveStatus ? 'yes' : 'no');

                    if (!saveBtn) {
                        console.error('❌ Save button not found');
                        showToast('Error: Save button not found', 'error');
                        return;
                    }

                    if (!saveStatus) {
                        console.error('❌ Save status element not found');
                    }

                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

                    if (saveStatus) {
                        saveStatus.innerHTML = '<div style="padding: 10px; background: #fff3cd; border-radius: 4px; color: #856404;"><i class="fas fa-spinner fa-spin"></i> Saving polygon to database...</div>';
                        saveStatus.className = 'status-message';
                        saveStatus.style.display = 'block';
                        saveStatus.style.visibility = 'visible';
                        saveStatus.style.opacity = '1';
                    }

                    try {
                        // Get current user
                        const { data: { user } } = await supabase.auth.getUser();
                        if (!user) {
                            throw new Error('User not authenticated');
                        }

                        // Generate unique ID
                        const uniqueId = await generatePolygonUniqueId(polygonImportState.selectedLayer);

                        // Prepare geometry (already in WGS84 from edge function)
                        const geometry = currentPolygonData.geometry;

                        // Insert polygon into database
                        const { data, error } = await supabase
                            .from('polygon_features')
                            .insert({
                                unique_id: uniqueId,
                                layer_name: polygonImportState.selectedLayer,
                                client: polygonImportState.formData.client,
                                project_name: polygonImportState.formData.projectName,
                                district: polygonImportState.formData.district,
                                county: polygonImportState.formData.county || null,
                                block_number: polygonImportState.formData.blockNumber || null,
                                plot_number: polygonImportState.formData.plotNumber || null,
                                surveyor: polygonImportState.formData.surveyor,
                                supervisor: polygonImportState.formData.supervisor,
                                company: polygonImportState.formData.company || null,
                                coordinate_system: polygonImportState.formData.coordinateSystem,
                                additional_info: polygonImportState.formData.additionalInfo || null,
                                csv_file_id: polygonImportState.csvFileId,
                                geometry: geometry,
                                area_hectares: currentPolygonData.area_hectares,
                                num_vertices: currentPolygonData.num_vertices,
                                edge_distances: currentPolygonData.edge_distances || null, // Store pre-calculated edge distances
                                created_by: user.id
                            })
                            .select()
                            .single();

                        if (error) throw error;

                        // Show prominent success message
                        if (saveStatus) {
                            console.log('✅ Displaying success message in save-status element');
                            saveStatus.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; padding: 15px; background: linear-gradient(135deg, #4caf50, #45a049); color: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); animation: slideInSuccess 0.5s ease;">
                            <i class="fas fa-check-circle" style="font-size: 1.5rem;"></i>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 1.1rem; margin-bottom: 5px;">✓ Polygon Saved Successfully!</div>
                                <div style="font-size: 0.9rem; opacity: 0.95;">
                                    <strong>Unique ID:</strong> ${uniqueId}<br>
                                    <strong>Layer:</strong> ${polygonImportState.selectedLayer}<br>
                                    <strong>Area:</strong> ${currentPolygonData.area_hectares.toFixed(4)} hectares
                                </div>
                            </div>
                        </div>
                    `;
                            saveStatus.className = 'status-message success';
                            saveStatus.style.display = 'block';
                            saveStatus.style.visibility = 'visible';
                            saveStatus.style.opacity = '1';
                            saveStatus.style.marginTop = '15px';
                            saveStatus.style.marginBottom = '10px';

                            console.log('✅ Success message displayed, className:', saveStatus.className, 'display:', saveStatus.style.display);

                            // Scroll to success message
                            setTimeout(() => {
                                saveStatus.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }, 100);
                        } else {
                            console.error('❌ Save status element not found - cannot display success message');
                        }

                        // Add to created polygons list
                        polygonImportState.createdPolygons.push(data);

                        showToast(`Polygon ${uniqueId} saved successfully!`, 'success');

                        // Refresh polygon layers if they're visible
                        refreshPolygonLayers();

                        // Disable save button to prevent duplicate saves
                        if (saveBtn) {
                            saveBtn.disabled = true;
                            saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved';
                            saveBtn.style.background = '#95a5a6';
                            saveBtn.style.cursor = 'not-allowed';
                            saveBtn.style.opacity = '0.7';
                            console.log('✅ Save button disabled after successful save');
                        } else {
                            console.error('❌ Save button not found when trying to disable');
                        }

                    } catch (error) {
                        console.error('Error saving polygon:', error);
                        if (saveStatus) {
                            saveStatus.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8d7da; color: #721c24; border-radius: 8px; border: 1px solid #f5c6cb;">
                            <i class="fas fa-exclamation-circle" style="font-size: 1.5rem;"></i>
                            <div>
                                <div style="font-weight: 600; margin-bottom: 5px;">Error Saving Polygon</div>
                                <div style="font-size: 0.9rem;">${error.message}</div>
                            </div>
                        </div>
                    `;
                            saveStatus.className = 'status-message error';
                        }
                        showToast('Error saving polygon: ' + error.message, 'error');

                        // Re-enable save button on error so user can retry
                        if (saveBtn) {
                            saveBtn.disabled = false;
                            saveBtn.innerHTML = '<i class="fas fa-cloud-upload-alt"></i> Save to Database';
                            saveBtn.style.background = '';
                            saveBtn.style.cursor = '';
                        }
                    }
                }

                // Refresh polygon layers (will be implemented in Phase 8)
                function refreshPolygonLayers() {
                    // This will be implemented when we add layer switcher integration
                    console.log('Polygon layers refreshed');
                }

                // OLD CODE - Removed (left dock no longer used for polygon import)

                // ========================================
                //  CSV IMPORT & PLOTTING
                // ========================================

                // OLD CSV HANDLERS - REMOVED (replaced with polygon import workflow)
                // CSV file handling is now done in the polygon import workflow section

                // ========================================
                // POLYGON CSV PARSING FUNCTION
                // Format: parcelnumber,point_number,eastings,northings,description
                // ========================================
                function parsePolygonCSV(csvText) {
                    const lines = csvText.split(/\r?\n/).filter(line => line.trim().length > 0);
                    if (lines.length < 2) {
                        throw new Error('CSV must have at least a header row and one data row');
                    }

                    const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

                    // Find column indices (case-insensitive, flexible naming)
                    function findColumnIndex(headers, possibleNames) {
                        for (const name of possibleNames) {
                            const idx = headers.findIndex(h => h.includes(name.toLowerCase()));
                            if (idx !== -1) return idx;
                        }
                        return -1;
                    }

                    const parcelIdx = findColumnIndex(headers, ['parcelnumber', 'parcel', 'plot', 'parcel_id', 'plot_id']);
                    const pointIdx = findColumnIndex(headers, ['point_number', 'point', 'pt', 'pointnumber', 'pt_no']);
                    const eastIdx = findColumnIndex(headers, ['eastings', 'easting', 'x', 'e', 'east']);
                    const northIdx = findColumnIndex(headers, ['northings', 'northing', 'y', 'n', 'north']);
                    const descIdx = findColumnIndex(headers, ['description', 'desc', 'remarks', 'note', 'comment']);

                    // Validate required columns
                    if (parcelIdx === -1 || pointIdx === -1 || eastIdx === -1 || northIdx === -1) {
                        const missing = [];
                        if (parcelIdx === -1) missing.push('parcelnumber/parcel/plot');
                        if (pointIdx === -1) missing.push('point_number/point/pt');
                        if (eastIdx === -1) missing.push('eastings/easting/x');
                        if (northIdx === -1) missing.push('northings/northing/y');
                        throw new Error(`CSV must contain columns: parcelnumber, point_number, eastings, northings. Missing: ${missing.join(', ')}. Found columns: ${headers.join(', ')}`);
                    }

                    // Parse data and group by parcel
                    const parcelsMap = new Map();

                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',').map(v => v.trim());

                        if (values.length < Math.max(parcelIdx, pointIdx, eastIdx, northIdx) + 1) {
                            console.warn(`Skipping row ${i + 1}: insufficient columns`);
                            continue;
                        }

                        const parcelNumber = values[parcelIdx];
                        const pointNumber = values[pointIdx];
                        const easting = parseFloat(values[eastIdx]);
                        const northing = parseFloat(values[northIdx]);
                        const description = descIdx !== -1 ? values[descIdx] : '';

                        if (!parcelNumber || isNaN(easting) || isNaN(northing)) {
                            console.warn(`Skipping row ${i + 1}: invalid data`);
                            continue;
                        }

                        if (!parcelsMap.has(parcelNumber)) {
                            parcelsMap.set(parcelNumber, []);
                        }

                        parcelsMap.get(parcelNumber).push({
                            parcelnumber: parcelNumber,
                            point_number: pointNumber,
                            eastings: easting,
                            northings: northing,
                            description: description
                        });
                    }

                    // Convert map to array
                    const parcels = Array.from(parcelsMap.entries()).map(([id, points]) => ({
                        id: id,
                        points: points.sort((a, b) => {
                            // Sort by point number if numeric, otherwise by original order
                            const aNum = parseInt(a.point_number) || 0;
                            const bNum = parseInt(b.point_number) || 0;
                            return aNum - bNum;
                        })
                    }));

                    return {
                        parcels: parcels,
                        totalPoints: Array.from(parcelsMap.values()).reduce((sum, points) => sum + points.length, 0),
                        headers: headers
                    };
                }

                // Parse CSV file - Copied from working Coordinate Search implementation
                function parseGSPCSV(csvText) {
                    const lines = csvText.split('\n').filter(line => line.trim().length > 0);
                    if (lines.length === 0) return [];

                    // Auto-detect delimiter
                    const delimiters = [',', ';', '\t'];
                    let delimiter = ',';
                    for (const d of delimiters) {
                        if (lines[0].includes(d)) {
                            delimiter = d;
                            break;
                        }
                    }

                    const data = [];
                    const hasHeader = lines[0].toLowerCase().includes('name') ||
                        lines[0].toLowerCase().includes('easting') ||
                        lines[0].toLowerCase().includes('northing');

                    const startIndex = hasHeader ? 1 : 0;

                    for (let i = startIndex; i < lines.length; i++) {
                        const parts = lines[i].split(delimiter).map(p => p.trim().replace(/"/g, ''));
                        if (parts.length >= 3) {
                            const name = parts[0];
                            const x = parseFloat(parts[1]);
                            const y = parseFloat(parts[2]);

                            if (!isNaN(x) && !isNaN(y)) {
                                data.push({ name, x, y });
                            }
                        }
                    }

                    return data;
                }

                // Plot CSV on map with labels - Copied from working Coordinate Search implementation
                function plotCSVOnMap(data, crs) {
                    try {
                        console.log('plotCSVOnMap called with', data.length, 'rows, projection:', crs);
                        console.log('Sample data:', data[0]);

                        // Remove existing CSV layer
                        if (editingState.csvLayer) {
                            console.log('Removing existing CSV layer');
                            map.removeLayer(editingState.csvLayer);
                            editingState.csvSource = null;
                            editingState.csvLayer = null;
                        }

                        // Create new source
                        editingState.csvSource = new ol.source.Vector();

                        let plotted = 0;
                        let skipped = 0;
                        const features = [];

                        data.forEach((point, idx) => {
                            // Validate and transform coordinates using the working function
                            const numX = parseFloat(point.x);
                            const numY = parseFloat(point.y);

                            if (isNaN(numX) || isNaN(numY)) {
                                console.warn(`Row ${idx + 1}: Invalid coordinates - x:${point.x}, y:${point.y}`);
                                skipped++;
                                return;
                            }

                            // Handle EPSG:4326 coordinate order detection (same as Coordinate Search)
                            let coord = [numX, numY];
                            if (crs === 'EPSG:4326') {
                                // Heuristic: if first value is between -90 and 90 and second is outside that range, assume lat,lon
                                if (numX >= -90 && numX <= 90 && (numY < -90 || numY > 90)) {
                                    coord = [numY, numX]; // Swap to lon,lat
                                    console.log('Swapped lat,lon to lon,lat:', [numX, numY], '->', coord);
                                }
                            }

                            try {
                                // Transform to map projection (same as Coordinate Search)
                                const mapCrs = map.getView().getProjection().getCode();
                                const transformed = ol.proj.transform(coord, crs, mapCrs);

                                console.log(`Row ${idx + 1}: [${coord[0]},${coord[1]}] in ${crs} -> [${transformed[0]},${transformed[1]}] in ${mapCrs}`);

                                const feature = new ol.Feature({
                                    geometry: new ol.geom.Point(transformed),
                                    name: point.name || `Point ${idx + 1}`,
                                    originalCoord: coord,
                                    crs: crs
                                });

                                features.push(feature);
                                editingState.csvSource.addFeature(feature);
                                plotted++;
                            } catch (error) {
                                console.error(`Row ${idx + 1}: Transformation failed -`, error);
                                skipped++;
                            }
                        });

                        // Create CSV layer with labels (same style as Coordinate Search but yellow instead of red)
                        editingState.csvLayer = new ol.layer.Vector({
                            title: 'CSV Reference Points',
                            source: editingState.csvSource,
                            style: function (feature) {
                                return new ol.style.Style({
                                    image: new ol.style.Circle({
                                        radius: 8,
                                        fill: new ol.style.Fill({ color: '#FFD700' }),  // Gold
                                        stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                                    }),
                                    text: new ol.style.Text({
                                        text: feature.get('name') || 'Point',
                                        offsetY: -20,
                                        font: 'bold 12px sans-serif',
                                        fill: new ol.style.Fill({ color: '#000' }),
                                        stroke: new ol.style.Stroke({ color: '#FFD700', width: 3 })
                                    })
                                });
                            },
                            zIndex: 999
                        });

                        console.log('Adding CSV layer to map with', features.length, 'features');
                        map.addLayer(editingState.csvLayer);
                        console.log('✅ CSV layer added to map');

                        // Zoom to extent (same as Coordinate Search)
                        if (features.length > 0) {
                            const extent = editingState.csvSource.getExtent();
                            console.log('Zooming to extent:', extent);
                            map.getView().fit(extent, { padding: [50, 50, 50, 50], maxZoom: 18 });
                        }

                        // Update status
                        let message = `CSV: ${plotted} plotted`;
                        if (skipped > 0) {
                            message += `, ${skipped} skipped`;
                        }

                        if (csvStatus) {
                            csvStatus.textContent = message;
                            csvStatus.className = 'status-message success';
                        }
                        showToast(message, 'success');
                        console.log(`✅ ${message}`, features.map(f => ({ name: f.get('name'), coords: f.getGeometry().getCoordinates() })));

                    } catch (error) {
                        console.error('❌ Error plotting CSV:', error);
                        if (csvStatus) {
                            csvStatus.textContent = 'Error plotting CSV: ' + error.message;
                            csvStatus.className = 'status-message error';
                        }
                        showToast('Failed to plot CSV: ' + error.message, 'error');
                    }
                }

                // ========================================
                //  LOAD PG_FEATURESERV COLLECTIONS
                // ========================================

                const pgfsLayerSelect = document.getElementById('pgfs-layer-select');
                const loadLayerBtn = document.getElementById('load-layer-btn');
                const layerInfo = document.getElementById('layer-info');

                // Load collections from GeoServer WFS GetCapabilities
                async function loadPgfsCollections() {
                    try {
                        // Populate dropdown directly from EDITABLE_LAYERS configuration
                        // This is more reliable than parsing GetCapabilities XML
                        pgfsLayerSelect.innerHTML = '<option value="">-- Select Layer --</option>';

                        EDITABLE_LAYERS.forEach(layer => {
                            const option = document.createElement('option');
                            option.value = layer.id;
                            option.textContent = layer.name;
                            option.dataset.crs = layer.crs;
                            option.dataset.geomType = layer.geomType;
                            pgfsLayerSelect.appendChild(option);
                        });

                        showToast(`${EDITABLE_LAYERS.length} editable layers ready`, 'success');
                        console.log('Editable WFS-T layers loaded:', EDITABLE_LAYERS.map(l => l.id));
                    } catch (error) {
                        console.error('Error loading WFS layers:', error);
                        showToast('Failed to load WFS layers', 'error');
                    }
                }

                if (pgfsLayerSelect) {
                    pgfsLayerSelect.addEventListener('change', function () {
                        if (this.value) {
                            loadLayerBtn.disabled = false;
                            layerInfo.textContent = `Selected: ${this.options[this.selectedIndex].text}`;
                            layerInfo.className = 'info-box active';
                        } else {
                            loadLayerBtn.disabled = true;
                            layerInfo.className = 'info-box';
                        }
                    });
                }

                if (loadLayerBtn) {
                    loadLayerBtn.addEventListener('click', async function () {
                        const collectionId = pgfsLayerSelect.value;
                        if (!collectionId) return;

                        await loadLayerForEditing(collectionId);
                    });
                }

                // Load layer for editing using WFS GetFeature and DescribeFeatureType
                async function loadLayerForEditing(collectionId) {
                    try {
                        // Remove existing edit layer
                        if (editingState.editLayer) {
                            map.removeLayer(editingState.editLayer);
                        }

                        // Find layer config
                        const layerConfig = EDITABLE_LAYERS.find(l => l.id === collectionId);
                        if (!layerConfig) {
                            throw new Error('Layer not found in configuration');
                        }

                        console.log('🚀 Modern WFS: Loading layer for editing:', layerConfig.name, layerConfig.id);
                        layerInfo.textContent = `Loading ${layerConfig.name} with modern WFS...`;
                        layerInfo.className = 'info-box active';

                        // Try to fetch schema using WFS DescribeFeatureType (optional, may fail with 403)
                        let columns = [];

                        try {
                            const params = new URLSearchParams({
                                service: 'WFS',
                                version: WFS_VERSION,
                                request: 'DescribeFeatureType',
                                typeName: collectionId
                            });
                            const schemaUrl = `${GEOSERVER_WFS_URL}?${params.toString()}`;
                            console.log('Fetching layer schema from:', schemaUrl);

                            const schemaResponse = await fetch(schemaUrl, {
                                method: 'GET',
                                mode: 'cors',
                                headers: {
                                    'Accept': 'application/xml, text/xml'
                                }
                            });
                            console.log('Schema response status:', schemaResponse.status, schemaResponse.statusText);

                            if (schemaResponse.ok) {
                                const schemaXML = await schemaResponse.text();
                                console.log('Schema XML received, length:', schemaXML.length);

                                const parser = new DOMParser();
                                const schemaDoc = parser.parseFromString(schemaXML, 'text/xml');

                                // Check for XML parsing errors
                                const parseError = schemaDoc.getElementsByTagName('parsererror');
                                if (parseError.length === 0) {
                                    // Extract columns from XML schema
                                    const elements = schemaDoc.getElementsByTagName('xsd:element') || schemaDoc.getElementsByTagName('element');
                                    console.log('Found', elements.length, 'elements in schema');

                                    for (let i = 0; i < elements.length; i++) {
                                        const el = elements[i];
                                        const name = el.getAttribute('name');
                                        const type = el.getAttribute('type');
                                        const nillable = el.getAttribute('nillable');

                                        // Skip geometry column
                                        if (name && name !== layerConfig.geometryName && !type?.includes('gml:')) {
                                            columns.push({
                                                name: name,
                                                type: type || 'string',
                                                nullable: nillable !== 'false'
                                            });
                                        }
                                    }

                                    console.log('✅ Extracted', columns.length, 'columns:', columns.map(c => c.name));
                                } else {
                                    console.warn('Schema XML parsing error, will use fallback columns');
                                }
                            } else {
                                console.warn(`⚠️ Schema fetch returned ${schemaResponse.status}, will use fallback columns`);
                            }
                        } catch (schemaError) {
                            console.warn('⚠️ DescribeFeatureType failed (this is OK, will use fallback):', schemaError.message);
                        }

                        // If no columns from schema, use default fallback columns
                        if (columns.length === 0) {
                            console.log('Using fallback columns: gid, name, description');
                            columns = [
                                { name: 'gid', type: 'int', nullable: false },
                                { name: 'name', type: 'string', nullable: true },
                                { name: 'description', type: 'string', nullable: true }
                            ];
                        }

                        // Store metadata
                        editingState.collectionId = collectionId;
                        editingState.collectionConfig = {
                            table: layerConfig.shortId,
                            geomColumn: layerConfig.geometryName,
                            srid: layerConfig.crs.split(':')[1],
                            crs: layerConfig.crs,
                            geomType: layerConfig.geomType,
                            primaryKey: 'gid',  // Standard GeoServer primary key
                            columns: columns
                        };

                        // Fetch features using WFS GetFeature with safe wrapper
                        const getFeatureUrl = buildWFSUrl(collectionId, 5000);
                        console.log('Fetching features from:', getFeatureUrl);
                        console.log('🔗 Test URL (copy and paste in browser):', getFeatureUrl);
                        console.log('Layer native CRS:', layerConfig.crs);

                        // Use safe fetch wrapper to handle exceptions and JSON parsing
                        const geojsonData = await safeFetchWFS(getFeatureUrl);

                        console.log('✅ GeoJSON data received:', geojsonData.features?.length || 0, 'features');
                        console.log('GeoJSON CRS:', geojsonData.crs);
                        console.log('First feature sample:', geojsonData.features?.[0]);

                        // Create edit source and layer
                        const geojsonFormat = new ol.format.GeoJSON();

                        // Determine the actual CRS from GeoJSON response
                        let sourceCRS = layerConfig.crs;
                        if (geojsonData.crs && geojsonData.crs.properties && geojsonData.crs.properties.name) {
                            const crsName = geojsonData.crs.properties.name;
                            // Extract EPSG code from URN like "urn:ogc:def:crs:EPSG::4326"
                            if (crsName.includes('EPSG::')) {
                                const epsgCode = crsName.split('EPSG::')[1];
                                sourceCRS = `EPSG:${epsgCode}`;
                                console.log('Detected CRS from GeoJSON:', sourceCRS);
                            }
                        }

                        console.log('Reading features with:', {
                            dataProjection: sourceCRS,
                            featureProjection: MAP_PROJ
                        });

                        // Read features with proper CRS transformation
                        const features = geojsonFormat.readFeatures(geojsonData, {
                            dataProjection: sourceCRS,           // Features are in this CRS
                            featureProjection: MAP_PROJ          // Transform to map projection (EPSG:3857)
                        });

                        console.log('✅ Transformed', features.length, 'features from', sourceCRS, 'to', MAP_PROJ);
                        if (features.length > 0) {
                            console.log('First feature after transformation:', {
                                id: features[0].getId(),
                                geom: features[0].getGeometry().getCoordinates(),
                                props: features[0].getProperties()
                            });
                        }

                        console.log('Creating vector source with', features.length, 'features...');
                        editingState.editSource = new ol.source.Vector({
                            features: features
                        });
                        console.log('Vector source created, extent:', editingState.editSource.getExtent());

                        console.log('Creating vector layer with green style...');
                        editingState.editLayer = new ol.layer.Vector({
                            title: 'Editing Layer - ' + layerConfig.name,
                            source: editingState.editSource,
                            style: new ol.style.Style({
                                stroke: new ol.style.Stroke({ color: '#27ae60', width: 3 }),
                                fill: new ol.style.Fill({ color: 'rgba(39, 174, 96, 0.2)' }),
                                image: new ol.style.Circle({
                                    radius: 7,
                                    fill: new ol.style.Fill({ color: '#27ae60' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                                })
                            }),
                            zIndex: 998,
                            visible: true
                        });
                        console.log('Vector layer created');

                        console.log('Adding layer to map...');
                        map.addLayer(editingState.editLayer);
                        console.log('✅ Layer added to map');

                        // Verify layer was added
                        const mapLayers = map.getLayers().getArray();
                        console.log('Total layers on map:', mapLayers.length);
                        console.log('Edit layer visible?', editingState.editLayer.getVisible());
                        console.log('Edit layer zIndex:', editingState.editLayer.getZIndex());

                        // Zoom to layer extent if features exist
                        if (features.length > 0) {
                            const extent = editingState.editSource.getExtent();
                            console.log('Layer extent:', extent);
                            console.log('Zooming to extent...');
                            map.getView().fit(extent, {
                                padding: [100, 100, 100, 100],
                                maxZoom: 16,
                                duration: 1000
                            });
                            console.log('✅ Zoom complete');
                        } else {
                            console.warn('No features to zoom to');
                        }

                        // Enable edit tools
                        const editStartBtn = document.getElementById('edit-start-btn');
                        if (editStartBtn) {
                            editStartBtn.disabled = false;
                            console.log('✅ Edit Start button enabled');
                        }

                        layerInfo.textContent = `Layer loaded: ${layerConfig.name} (${features.length} features, ${sourceCRS})`;
                        layerInfo.className = 'info-box active';
                        showToast(`✅ Layer ${layerConfig.name} loaded: ${features.length} features`, 'success', 5000);
                        console.log('🎉 Layer loading complete!');

                    } catch (error) {
                        console.error('❌ Error loading layer:', error);

                        // Show user-friendly error message
                        if (error.message.includes('403')) {
                            layerInfo.innerHTML = `<strong>🔒 Access Denied (403)</strong><br>` +
                                `GeoServer is blocking WFS access.<br>` +
                                `<small>Fix: Enable public WFS read access in GeoServer Security settings.<br>` +
                                `See FIX-403-ERROR.md for step-by-step guide.</small>`;
                            layerInfo.className = 'info-box error';
                            showToast('GeoServer 403 Error - See FIX-403-ERROR.md to enable WFS access', 'error', 10000);
                        } else {
                            layerInfo.textContent = 'Error: ' + error.message;
                            layerInfo.className = 'info-box error';
                            showToast('Failed to load layer: ' + error.message, 'error');
                        }
                    }
                }

                // Auth helpers no longer needed - WFS-T is public (as configured)
                // function getAuthToken() {
                //     const cookieToken = getCookie('supabase_auth_token');
                //     const storageToken = localStorage.getItem('supabase.auth.token');
                //     return cookieToken || storageToken || '';
                // }
                // 
                // function getCookie(name) {
                //     const value = `; ${document.cookie}`;
                //     const parts = value.split(`; ${name}=`);
                //     if (parts.length === 2) return parts.pop().split(';').shift();
                //     return '';
                // }

                // ========================================
                //  EDITING INTERACTIONS
                // ========================================

                const editStartBtn = document.getElementById('edit-start-btn');
                const editStopBtn = document.getElementById('edit-stop-btn');
                const saveEditsBtn = document.getElementById('save-edits-btn');
                const geomTypeRadios = document.querySelectorAll('input[name="geomType"]');
                const snapToCSVCheckbox = document.getElementById('snap-to-csv');
                const snapToleranceRange = document.getElementById('snap-tolerance-range');
                const snapToleranceDisplay = document.getElementById('snap-tolerance-display');

                // Update geometry type selection
                geomTypeRadios.forEach(radio => {
                    radio.addEventListener('change', function () {
                        editingState.selectedGeometryType = this.value;
                        if (editingState.active) {
                            // Restart drawing with new type
                            stopEditing();
                            startEditing();
                        }
                    });
                });

                // Snap tolerance slider
                if (snapToleranceRange && snapToleranceDisplay) {
                    snapToleranceRange.addEventListener('input', function () {
                        snapToleranceDisplay.textContent = this.value;
                        if (editingState.interactions.snap) {
                            editingState.interactions.snap.setPixelTolerance(parseInt(this.value));
                        }
                    });
                }

                // Start editing
                if (editStartBtn) {
                    editStartBtn.addEventListener('click', function () {
                        // Use modern editing mode
                        startModernEditing();
                    });
                }

                // Stop editing
                if (editStopBtn) {
                    editStopBtn.addEventListener('click', function () {
                        // Use modern editing mode
                        stopModernEditing();
                    });
                }

                // Save edits with modern WFS-T
                if (saveEditsBtn) {
                    saveEditsBtn.addEventListener('click', function () {
                        // Use modern WFS-T save
                        saveModernEdits();
                    });
                }

                function startEditing() {
                    if (!editingState.editSource) {
                        showToast('Please load a layer first', 'warning');
                        return;
                    }

                    // Clear existing interactions
                    if (editingState.interactions.modify) {
                        map.removeInteraction(editingState.interactions.modify);
                    }
                    if (editingState.interactions.draw) {
                        map.removeInteraction(editingState.interactions.draw);
                    }
                    if (editingState.interactions.snap) {
                        map.removeInteraction(editingState.interactions.snap);
                    }
                    if (editingState.interactions.select) {
                        map.removeInteraction(editingState.interactions.select);
                    }

                    // Create Select interaction
                    editingState.interactions.select = new ol.interaction.Select({
                        layers: [editingState.editLayer],
                        style: new ol.style.Style({
                            stroke: new ol.style.Stroke({ color: '#FFA500', width: 3 }),
                            fill: new ol.style.Fill({ color: 'rgba(255, 165, 0, 0.3)' }),
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({ color: '#FFA500' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            })
                        })
                    });

                    editingState.interactions.select.on('select', (evt) => {
                        if (evt.selected.length > 0) {
                            const feature = evt.selected[0];
                            generateAttributeFormForFeature(feature);
                        }
                    });

                    map.addInteraction(editingState.interactions.select);

                    // Create Modify interaction
                    editingState.interactions.modify = new ol.interaction.Modify({
                        source: editingState.editSource
                    });

                    editingState.interactions.modify.on('modifyend', (evt) => {
                        evt.features.forEach(feature => {
                            const id = feature.get('id') || feature.getId();
                            if (id && !editingState.newFeatures.includes(feature)) {
                                editingState.modifiedFeatures.set(id, feature);
                            }
                        });
                        updatePendingChangesDisplay();
                        showToast('Feature modified', 'info');
                    });

                    map.addInteraction(editingState.interactions.modify);

                    // Create Draw interaction
                    editingState.interactions.draw = new ol.interaction.Draw({
                        source: editingState.editSource,
                        type: editingState.selectedGeometryType
                    });

                    editingState.interactions.draw.on('drawend', (evt) => {
                        const feature = evt.feature;
                        editingState.newFeatures.push(feature);
                        updatePendingChangesDisplay();

                        // Open attribute form
                        setTimeout(() => {
                            generateAttributeFormForFeature(feature);
                        }, 100);
                    });

                    map.addInteraction(editingState.interactions.draw);

                    // Add snapping
                    if (snapToCSVCheckbox.checked && editingState.csvSource) {
                        editingState.interactions.snap = new ol.interaction.Snap({
                            source: editingState.csvSource,
                            pixelTolerance: parseInt(snapToleranceRange.value)
                        });
                        map.addInteraction(editingState.interactions.snap);
                    }

                    // Enable crosshair
                    enableCrosshair();
                    editingState.active = true;

                    // Update UI
                    editStartBtn.disabled = true;
                    editStopBtn.disabled = false;
                    document.getElementById('commit-edits-btn').disabled = false;
                    document.getElementById('cancel-edits-btn').disabled = false;

                    showToast('Editing started. Draw or modify features.', 'success');
                }

                function stopEditing() {
                    // Remove interactions
                    Object.values(editingState.interactions).forEach(interaction => {
                        if (interaction) {
                            map.removeInteraction(interaction);
                        }
                    });

                    editingState.interactions = {
                        modify: null,
                        draw: null,
                        snap: null,
                        select: null
                    };

                    // Disable crosshair
                    disableCrosshair();
                    editingState.active = false;

                    // Update UI
                    editStartBtn.disabled = false;
                    editStopBtn.disabled = true;

                    showToast('Editing stopped', 'info');
                }

                // ========================================
                //  ATTRIBUTE EDITOR
                // ========================================

                function generateAttributeFormForFeature(feature) {
                    const container = document.getElementById('attr-form-container');
                    if (!container) return;

                    const schema = editingState.collectionConfig;
                    if (!schema || !schema.columns) {
                        container.innerHTML = '<p class="help-text">No schema available</p>';
                        return;
                    }

                    container.innerHTML = '<h5 style="margin-top: 0;">Edit Feature Attributes</h5>';

                    const form = document.createElement('form');
                    form.id = 'attr-edit-form';

                    schema.columns.forEach(col => {
                        if (col.column_name === schema.geomColumn || col.column_name === schema.primaryKey) {
                            return; // Skip geometry and PK
                        }

                        const fieldDiv = document.createElement('div');
                        fieldDiv.className = 'form-group';

                        const label = document.createElement('label');
                        label.textContent = col.column_name.replace(/_/g, ' ').toUpperCase();
                        fieldDiv.appendChild(label);

                        let input;
                        if (col.data_type.includes('int') || col.data_type.includes('numeric')) {
                            input = document.createElement('input');
                            input.type = 'number';
                        } else if (col.data_type === 'boolean') {
                            input = document.createElement('input');
                            input.type = 'checkbox';
                        } else {
                            input = document.createElement('input');
                            input.type = 'text';
                        }

                        input.name = col.column_name;
                        input.value = feature.get(col.column_name) || '';
                        input.className = 'form-control';

                        fieldDiv.appendChild(input);
                        form.appendChild(fieldDiv);
                    });

                    const saveBtn = document.createElement('button');
                    saveBtn.type = 'button';
                    saveBtn.className = 'btn btn-primary';
                    saveBtn.innerHTML = '<i class="fas fa-check"></i> Save Attributes';
                    saveBtn.onclick = () => saveAttributesToFeature(feature, form);

                    form.appendChild(saveBtn);
                    container.appendChild(form);
                }

                function saveAttributesToFeature(feature, form) {
                    const formData = new FormData(form);

                    formData.forEach((value, key) => {
                        feature.set(key, value);
                    });

                    // Mark as modified if not new
                    const id = feature.get('id') || feature.getId();
                    if (id && !editingState.newFeatures.includes(feature)) {
                        editingState.modifiedFeatures.set(id, feature);
                    }

                    updatePendingChangesDisplay();
                    showToast('Attributes saved to feature', 'success');
                }

                // ========================================
                //  CHANGE TRACKING
                // ========================================

                function updatePendingChangesDisplay() {
                    document.getElementById('new-count').textContent = editingState.newFeatures.length;
                    document.getElementById('modified-count').textContent = editingState.modifiedFeatures.size;
                    document.getElementById('deleted-count').textContent = editingState.deletedIds.size;
                }

                // Handle feature deletion with Delete key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' && editingState.active && editingState.interactions.select) {
                        const selected = editingState.interactions.select.getFeatures().getArray();
                        selected.forEach(feature => {
                            const id = feature.get('id') || feature.getId();
                            if (id) {
                                editingState.deletedIds.add(id);
                                editingState.modifiedFeatures.delete(id);
                            }
                            editingState.editSource.removeFeature(feature);
                        });

                        editingState.interactions.select.getFeatures().clear();
                        updatePendingChangesDisplay();
                        showToast(`Deleted ${selected.length} feature(s)`, 'warning');
                    }
                });

                // ========================================
                //  WFS-T HELPER FUNCTIONS
                // ========================================

                /**
                 * Transform geometry from map projection to layer's native CRS
                 * @param {ol.geom.Geometry} geometry - OpenLayers geometry object
                 * @param {string} targetCRS - Target CRS (e.g., 'EPSG:21096')
                 * @returns {ol.geom.Geometry} - Transformed geometry
                 */
                function transformGeometryToLayerCRS(geometry, targetCRS) {
                    const clonedGeom = geometry.clone();
                    clonedGeom.transform(MAP_PROJ, targetCRS);
                    return clonedGeom;
                }

                /**
                 * Convert OpenLayers geometry to GML 3.2 format for WFS-T
                 * @param {ol.geom.Geometry} geometry - OpenLayers geometry
                 * @param {string} srid - SRID for the geometry
                 * @returns {string} - GML XML string
                 */
                function geometryToGML(geometry, srid) {
                    const type = geometry.getType();
                    const coords = geometry.getCoordinates();

                    let gml = '';
                    const srsName = `http://www.opengis.net/gml/srs/epsg.xml#${srid}`;

                    if (type === 'Point') {
                        gml = `<gml:Point srsName="${srsName}">`;
                        gml += `<gml:pos>${coords[0]} ${coords[1]}</gml:pos>`;
                        gml += `</gml:Point>`;
                    } else if (type === 'LineString') {
                        gml = `<gml:LineString srsName="${srsName}">`;
                        gml += `<gml:posList>`;
                        coords.forEach(coord => {
                            gml += `${coord[0]} ${coord[1]} `;
                        });
                        gml += `</gml:posList>`;
                        gml += `</gml:LineString>`;
                    } else if (type === 'Polygon') {
                        gml = `<gml:Polygon srsName="${srsName}">`;
                        gml += `<gml:exterior><gml:LinearRing><gml:posList>`;
                        coords[0].forEach(coord => {
                            gml += `${coord[0]} ${coord[1]} `;
                        });
                        gml += `</gml:posList></gml:LinearRing></gml:exterior>`;
                        // Handle holes if present
                        for (let i = 1; i < coords.length; i++) {
                            gml += `<gml:interior><gml:LinearRing><gml:posList>`;
                            coords[i].forEach(coord => {
                                gml += `${coord[0]} ${coord[1]} `;
                            });
                            gml += `</gml:posList></gml:LinearRing></gml:interior>`;
                        }
                        gml += `</gml:Polygon>`;
                    }

                    return gml;
                }

                // ============================================
                // WFS FIX START - Updated transaction builder
                // ============================================
                /**
                 * Build WFS-T Transaction XML for Insert, Update, Delete operations
                 * Using WFS 1.1.0 with proper namespace and XML sanitization
                 * Updated to use nginx proxy and correct namespace URI
                 * @param {Array} inserts - Array of features to insert
                 * @param {Array} updates - Array of features to update
                 * @param {Array} deletes - Array of feature IDs to delete
                 * @param {string} typeName - Layer name (e.g., 'geospatial_network:control_points')
                 * @param {string} geometryName - Geometry column name
                 * @param {string} srid - SRID of the layer
                 * @param {string} targetCRS - Target CRS for coordinate transformation
                 * @returns {string} - WFS-T XML string
                 */
                function buildWFSTransaction(inserts, updates, deletes, typeName, geometryName, srid, targetCRS) {
                    console.log('🔨 Building WFS-T transaction:', {
                        inserts: inserts.length,
                        updates: updates.length,
                        deletes: deletes.length,
                        typeName,
                        srid,
                        targetCRS
                    });

                    let xml = `<?xml version="1.0" encoding="UTF-8"?>`;
                    xml += `<wfs:Transaction service="WFS" version="1.1.0" `;
                    xml += `xmlns:wfs="http://www.opengis.net/wfs" `;
                    xml += `xmlns:ogc="http://www.opengis.net/ogc" `;
                    xml += `xmlns:gml="http://www.opengis.net/gml" `;
                    xml += `xmlns:${GEOSERVER_NAMESPACE}="${GEOSERVER_FEATURE_NS}" `;
                    xml += `xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" `;
                    xml += `xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd">`;

                    // INSERT operations
                    inserts.forEach(feature => {
                        const geom = feature.getGeometry();
                        const transformedGeom = transformGeometryToLayerCRS(geom, targetCRS);
                        const props = feature.getProperties();

                        xml += `<wfs:Insert>`;
                        xml += `<${typeName}>`;

                        // Add geometry
                        xml += `<${GEOSERVER_NAMESPACE}:${geometryName}>`;
                        xml += geometryToGML(transformedGeom, srid);
                        xml += `</${GEOSERVER_NAMESPACE}:${geometryName}>`;

                        // Add other properties with sanitization (exclude geometry and id)
                        Object.keys(props).forEach(key => {
                            if (key !== 'geometry' && key !== geometryName && key !== 'gid' && key !== 'id') {
                                const value = props[key];
                                if (value !== null && value !== undefined) {
                                    // Strip control chars and escape XML
                                    const sanitized = escapeXml(stripControlChars(String(value)));
                                    xml += `<${GEOSERVER_NAMESPACE}:${key}>${sanitized}</${GEOSERVER_NAMESPACE}:${key}>`;
                                }
                            }
                        });

                        xml += `</${typeName}>`;
                        xml += `</wfs:Insert>`;
                    });

                    // UPDATE operations
                    updates.forEach(feature => {
                        const featureId = feature.get('gid') || feature.getId();
                        if (!featureId) {
                            console.warn('Feature missing ID, skipping update:', feature);
                            return;
                        }

                        const geom = feature.getGeometry();
                        const transformedGeom = transformGeometryToLayerCRS(geom, targetCRS);
                        const props = feature.getProperties();

                        xml += `<wfs:Update typeName="${typeName}">`;

                        // Update geometry
                        xml += `<wfs:Property>`;
                        xml += `<wfs:Name>${geometryName}</wfs:Name>`;
                        xml += `<wfs:Value>`;
                        xml += geometryToGML(transformedGeom, srid);
                        xml += `</wfs:Value>`;
                        xml += `</wfs:Property>`;

                        // Update other properties with sanitization
                        Object.keys(props).forEach(key => {
                            if (key !== 'geometry' && key !== geometryName && key !== 'gid' && key !== 'id') {
                                const value = props[key];
                                if (value !== null && value !== undefined) {
                                    // Strip control chars and escape XML
                                    const sanitized = escapeXml(stripControlChars(String(value)));
                                    xml += `<wfs:Property>`;
                                    xml += `<wfs:Name>${key}</wfs:Name>`;
                                    xml += `<wfs:Value>${sanitized}</wfs:Value>`;
                                    xml += `</wfs:Property>`;
                                }
                            }
                        });

                        // Filter by feature ID using WFS 1.1.0 syntax
                        xml += `<ogc:Filter>`;
                        xml += `<ogc:FeatureId fid="${typeName}.${featureId}"/>`;
                        xml += `</ogc:Filter>`;
                        xml += `</wfs:Update>`;
                    });

                    // DELETE operations
                    deletes.forEach(featureId => {
                        xml += `<wfs:Delete typeName="${typeName}">`;
                        xml += `<ogc:Filter>`;
                        xml += `<ogc:FeatureId fid="${typeName}.${featureId}"/>`;
                        xml += `</ogc:Filter>`;
                        xml += `</wfs:Delete>`;
                    });

                    xml += `</wfs:Transaction>`;

                    console.log('✅ WFS-T XML built successfully, length:', xml.length);
                    return xml;
                }
                // WFS FIX END
                // ============================================

                // ============================================
                // WFS FIX START - Updated transaction sender
                // ============================================
                /**
                 * Send WFS-T transaction to GeoServer via nginx proxy
                 * Updated for WFS 1.1.0 with proper error handling and logging
                 * @param {string} transactionXML - WFS-T XML string
                 * @returns {Promise<Object>} - Transaction result
                 */
                async function sendWFSTransaction(transactionXML) {
                    try {
                        console.log('📤 Sending WFS-T transaction to:', GEOSERVER_WFS_URL);
                        console.log('📝 Transaction XML preview:', transactionXML.substring(0, 500) + '...');
                        console.log('📊 Transaction size:', transactionXML.length, 'bytes');

                        const response = await fetch(GEOSERVER_WFS_URL, {
                            method: 'POST',
                            mode: 'cors',
                            credentials: 'include',
                            headers: {
                                'Content-Type': 'text/xml; charset=utf-8',
                                'Accept': 'application/xml, text/xml, */*',
                                'Authorization': 'Basic ' + WFS_AUTH.encoded
                            },
                            body: transactionXML
                        });

                        const responseText = await response.text();
                        console.log('📨 WFS-T Response status:', response.status, response.statusText);
                        console.log('📨 WFS-T Response headers:', {
                            contentType: response.headers.get('content-type'),
                            contentLength: response.headers.get('content-length')
                        });
                        console.log('📨 WFS-T Response preview:', responseText.substring(0, 500));

                        if (!response.ok) {
                            console.error('❌ WFS-T request failed:', {
                                status: response.status,
                                statusText: response.statusText,
                                url: GEOSERVER_WFS_URL,
                                response: responseText
                            });
                            throw new Error(`WFS-T request failed: ${response.status} ${response.statusText}\n${responseText.substring(0, 200)}`);
                        }

                        // Parse XML response
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(responseText, 'text/xml');

                        // Check for parsing errors
                        const parseError = xmlDoc.getElementsByTagName('parsererror');
                        if (parseError.length > 0) {
                            console.error('XML parsing error:', parseError[0].textContent);
                            throw new Error('Failed to parse WFS-T response XML');
                        }

                        // Check for exceptions
                        const exception = xmlDoc.getElementsByTagName('ows:Exception')[0] ||
                            xmlDoc.getElementsByTagName('Exception')[0] ||
                            xmlDoc.getElementsByTagName('ServiceException')[0];
                        if (exception) {
                            const exceptionText = exception.getElementsByTagName('ows:ExceptionText')[0] ||
                                exception.getElementsByTagName('ExceptionText')[0] ||
                                exception.textContent;
                            const errorMsg = exceptionText ? (exceptionText.textContent || exceptionText) : 'Unknown WFS-T error';
                            console.error('WFS-T Exception:', errorMsg);
                            throw new Error(`WFS-T Exception: ${errorMsg}`);
                        }

                        // Extract transaction summary (WFS 1.1.0 format)
                        const summary = xmlDoc.getElementsByTagName('wfs:TransactionSummary')[0];
                        const result = {
                            totalInserted: 0,
                            totalUpdated: 0,
                            totalDeleted: 0,
                            insertIds: []
                        };

                        if (summary) {
                            const inserted = summary.getElementsByTagName('wfs:totalInserted')[0];
                            const updated = summary.getElementsByTagName('wfs:totalUpdated')[0];
                            const deleted = summary.getElementsByTagName('wfs:totalDeleted')[0];

                            result.totalInserted = inserted ? parseInt(inserted.textContent) : 0;
                            result.totalUpdated = updated ? parseInt(updated.textContent) : 0;
                            result.totalDeleted = deleted ? parseInt(deleted.textContent) : 0;

                            console.log('Transaction summary:', result);
                        }

                        // Extract inserted feature IDs (WFS 1.1.0 format)
                        const insertResults = xmlDoc.getElementsByTagName('wfs:InsertResults')[0];
                        if (insertResults) {
                            const featureIds = insertResults.getElementsByTagName('ogc:FeatureId');
                            for (let i = 0; i < featureIds.length; i++) {
                                const fid = featureIds[i].getAttribute('fid');
                                if (fid) {
                                    result.insertIds.push(fid);
                                    console.log('Inserted feature ID:', fid);
                                }
                            }
                        }

                        console.log('✅ WFS-T transaction successful:', result);
                        return result;

                    } catch (error) {
                        console.error('❌ WFS-T Transaction Error:', {
                            message: error.message,
                            stack: error.stack,
                            url: GEOSERVER_WFS_URL
                        });
                        throw error;
                    }
                }
                // WFS FIX END
                // ============================================

                // ========================================
                //  COMMIT TO DATABASE
                // ========================================

                const commitBtn = document.getElementById('commit-edits-btn');
                const cancelBtn = document.getElementById('cancel-edits-btn');
                const commitStatus = document.getElementById('commit-status');

                if (commitBtn) {
                    commitBtn.addEventListener('click', async function () {
                        await commitEditsToDatabase();
                    });
                }

                if (cancelBtn) {
                    cancelBtn.addEventListener('click', function () {
                        if (confirm('Discard all changes? This cannot be undone.')) {
                            cancelEdits();
                        }
                    });
                }

                async function commitEditsToDatabase() {
                    const totalChanges = editingState.newFeatures.length +
                        editingState.modifiedFeatures.size +
                        editingState.deletedIds.size;

                    if (totalChanges === 0) {
                        showToast('No changes to commit', 'info');
                        return;
                    }

                    if (!editingState.collectionConfig) {
                        showToast('No layer loaded', 'error');
                        return;
                    }

                    const confirmed = confirm(
                        `Commit via WFS-T:\n` +
                        `${editingState.newFeatures.length} new features\n` +
                        `${editingState.modifiedFeatures.size} modified features\n` +
                        `${editingState.deletedIds.size} deleted features\n\n` +
                        `This will directly modify the database. Continue?`
                    );

                    if (!confirmed) return;

                    commitStatus.textContent = 'Building WFS-T transaction...';
                    commitStatus.className = 'status-message info';

                    try {
                        const config = editingState.collectionConfig;
                        const typeName = editingState.collectionId;
                        const geometryName = config.geomColumn;
                        const srid = config.srid;
                        const targetCRS = config.crs;

                        // Build WFS-T XML
                        const transactionXML = buildWFSTransaction(
                            editingState.newFeatures,
                            Array.from(editingState.modifiedFeatures.values()),
                            Array.from(editingState.deletedIds),
                            typeName,
                            geometryName,
                            srid,
                            targetCRS
                        );

                        console.log('WFS-T Transaction XML:', transactionXML);

                        commitStatus.textContent = 'Sending to GeoServer...';

                        // Send transaction
                        const result = await sendWFSTransaction(transactionXML);

                        console.log('WFS-T Transaction Result:', result);

                        // Clear edit buffers
                        editingState.newFeatures = [];
                        editingState.modifiedFeatures.clear();
                        editingState.deletedIds.clear();
                        updatePendingChangesDisplay();

                        commitStatus.textContent = `✓ WFS-T Success: ${result.totalInserted} inserted, ${result.totalUpdated} updated, ${result.totalDeleted} deleted`;
                        commitStatus.className = 'status-message success';
                        showToast(`Changes committed to GeoServer successfully!`, 'success');

                        // Refresh layer to show updated data
                        setTimeout(async () => {
                            await loadLayerForEditing(editingState.collectionId);
                        }, 500);

                    } catch (error) {
                        console.error('WFS-T Commit error:', error);
                        commitStatus.textContent = 'Error: ' + error.message;
                        commitStatus.className = 'status-message error';
                        showToast('WFS-T Failed: ' + error.message, 'error');
                    }
                }

                function cancelEdits() {
                    // Clear buffers
                    editingState.newFeatures = [];
                    editingState.modifiedFeatures.clear();
                    editingState.deletedIds.clear();

                    // Clear edit layer
                    if (editingState.editSource) {
                        editingState.editSource.clear();
                    }

                    updatePendingChangesDisplay();
                    showToast('Changes discarded', 'info');
                }

                // Initialize collections immediately so dropdown is ready
                if (pgfsLayerSelect) {
                    console.log('Initializing WFS-T layer dropdown...');
                    loadPgfsCollections();
                }

                // OLD CODE - Removed duplicate handler (handled above in DOMContentLoaded)

                console.log('✅ GSP.NET UPDATES initialized successfully');

            }); // End of DOMContentLoaded for GSP.NET UPDATES

            // Old GSP.NET UPDATES code removed - see new implementation above in DOMContentLoaded block

            // ========================================
            //  NEW QGIS-LIKE EDITING FUNCTIONS
            // ========================================

            // Fetch layer schema from pg-featureserver
            async function fetchLayerSchema(collectionId) {
                try {
                    const response = await fetch(`https://pgf.geospatialnetworkug.xyz/collections/${collectionId}`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch schema: ${response.status}`);
                    }
                    const metadata = await response.json();

                    // Extract properties schema
                    const schema = {
                        properties: metadata.properties || {},
                        geometryType: metadata.geometryType || 'Unknown'
                    };

                    console.log('Fetched schema for', collectionId, schema);
                    return schema;
                } catch (error) {
                    console.error('Error fetching layer schema:', error);
                    showToast('Failed to fetch layer schema', 'error');
                    return null;
                }
            }

            // Create reference layer from CSV points (for snapping only)
            function createReferenceLayer(csvFeatures) {
                // Remove existing reference layer
                if (editingSession.referenceLayer) {
                    map.removeLayer(editingSession.referenceLayer);
                }

                const referenceSource = new ol.source.Vector({
                    features: csvFeatures
                });

                const referenceLayer = new ol.layer.Vector({
                    source: referenceSource,
                    style: new ol.style.Style({
                        image: new ol.style.Icon({
                            anchor: [0.5, 0.5],
                            src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="%23FFD700" stroke="%23FF8C00" stroke-width="2"/><circle cx="12" cy="12" r="3" fill="%23FF8C00"/></svg>',
                            scale: 0.8
                        }),
                        text: new ol.style.Text({
                            font: 'bold 10px Arial',
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#FFD700', width: 2 }),
                            offsetY: -15,
                            textBaseline: 'bottom'
                        })
                    }),
                    zIndex: 999
                });

                // Add labels if features have IDs
                referenceLayer.setStyle((feature) => {
                    const id = feature.get('id') || feature.get('name') || '';
                    return new ol.style.Style({
                        image: new ol.style.Icon({
                            anchor: [0.5, 0.5],
                            src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="%23FFD700" stroke="%23FF8C00" stroke-width="2"/><circle cx="12" cy="12" r="3" fill="%23FF8C00"/></svg>',
                            scale: 0.8
                        }),
                        text: id ? new ol.style.Text({
                            text: String(id),
                            font: 'bold 10px Arial',
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#FFD700', width: 2 }),
                            offsetY: -15,
                            textBaseline: 'bottom'
                        }) : null
                    });
                });

                map.addLayer(referenceLayer);
                editingSession.referenceLayer = referenceLayer;

                // Store globally for CSV-focused editing system
                csvLayer = referenceLayer;
                csvSource = referenceSource;

                // Add snapping to reference layer
                if (snappingConfig.enabled && snappingConfig.snapToCSV) {
                    const snapInteraction = new ol.interaction.Snap({
                        source: referenceSource,
                        pixelTolerance: snappingConfig.tolerance
                    });
                    map.addInteraction(snapInteraction);
                    editingSession.interactions.snap.push(snapInteraction);
                }

                showToast(`CSV layer created with ${csvFeatures.length} points - Ready for editing!`, 'success');
                return referenceLayer;
            }

            // Setup right-click to finish drawing (QGIS-like)
            function setupRightClickFinish() {
                // Remove existing listener
                if (window.rightClickFinishHandler) {
                    map.un('contextmenu', window.rightClickFinishHandler);
                }

                // Create new handler
                window.rightClickFinishHandler = function (evt) {
                    evt.preventDefault();

                    const drawInteraction = editingSession.interactions.draw;
                    if (drawInteraction && drawInteraction.getActive()) {
                        // Finish the current drawing
                        drawInteraction.finishDrawing();
                        showToast('Drawing finished (right-click)', 'info');
                    }

                    return false;
                };

                // Attach to map
                map.on('contextmenu', window.rightClickFinishHandler);
            }

            // Enhanced snapping manager
            function updateSnapping() {
                // Remove all existing snap interactions
                editingSession.interactions.snap.forEach(snap => {
                    map.removeInteraction(snap);
                });
                editingSession.interactions.snap = [];

                if (!snappingConfig.enabled) return;

                // Snap to CSV reference layer
                if (snappingConfig.snapToCSV && editingSession.referenceLayer) {
                    const csvSnap = new ol.interaction.Snap({
                        source: editingSession.referenceLayer.getSource(),
                        pixelTolerance: snappingConfig.tolerance
                    });
                    map.addInteraction(csvSnap);
                    editingSession.interactions.snap.push(csvSnap);
                }

                // Snap to edit layer vertices and edges
                if (editingSession.editLayer) {
                    const editSource = editingSession.editLayer.getSource();

                    if (snappingConfig.snapToVertices || snappingConfig.snapToEdges) {
                        const editSnap = new ol.interaction.Snap({
                            source: editSource,
                            pixelTolerance: snappingConfig.tolerance,
                            vertex: snappingConfig.snapToVertices,
                            edge: snappingConfig.snapToEdges
                        });
                        map.addInteraction(editSnap);
                        editingSession.interactions.snap.push(editSnap);
                    }
                }
            }

            // Generate dynamic attribute form based on schema
            function generateAttributeForm(feature, schema) {
                const formContainer = document.getElementById('attribute-form-container');
                if (!formContainer) {
                    console.warn('Attribute form container not found');
                    return;
                }

                formContainer.innerHTML = '<h4>Edit Attributes</h4>';

                if (!schema || !schema.properties) {
                    formContainer.innerHTML += '<p>No schema available</p>';
                    return;
                }

                // Create form fields for each property
                Object.keys(schema.properties).forEach(propName => {
                    const propDef = schema.properties[propName];
                    const currentValue = feature.get(propName) || '';

                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'form-group';

                    const label = document.createElement('label');
                    label.textContent = propName.replace(/_/g, ' ').toUpperCase();
                    if (propDef.required) {
                        label.innerHTML += ' <span style="color: red;">*</span>';
                    }
                    fieldDiv.appendChild(label);

                    let input;
                    if (propDef.type === 'integer' || propDef.type === 'number') {
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = currentValue;
                    } else if (propDef.type === 'boolean') {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = currentValue === true;
                    } else {
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = currentValue;
                    }

                    input.name = propName;
                    input.className = 'form-control';
                    if (propDef.required) {
                        input.required = true;
                    }

                    fieldDiv.appendChild(input);
                    formContainer.appendChild(fieldDiv);
                });

                // Add save and cancel buttons
                const buttonDiv = document.createElement('div');
                buttonDiv.className = 'form-actions';
                buttonDiv.innerHTML = `
                <button type="button" class="btn btn-primary" onclick="saveFeatureAttributes()">Save</button>
                <button type="button" class="btn btn-secondary" onclick="closeAttributeForm()">Cancel</button>
            `;
                formContainer.appendChild(buttonDiv);

                // Show the form
                formContainer.style.display = 'block';
            }

            // Save feature attributes from form
            window.saveFeatureAttributes = function () {
                const formContainer = document.getElementById('attribute-form-container');
                const inputs = formContainer.querySelectorAll('input, select, textarea');

                if (editingSession.selectedFeatures.length === 0) {
                    showToast('No feature selected', 'warning');
                    return;
                }

                const feature = editingSession.selectedFeatures[0];

                inputs.forEach(input => {
                    const propName = input.name;
                    let value;

                    if (input.type === 'checkbox') {
                        value = input.checked;
                    } else if (input.type === 'number') {
                        value = parseFloat(input.value) || null;
                    } else {
                        value = input.value;
                    }

                    feature.set(propName, value);
                });

                // Mark as updated if not new
                if (feature.get('_pgfs_state') !== 'new') {
                    feature.set('_pgfs_state', 'modified');
                    if (!editingSession.editBuffer.updates.includes(feature)) {
                        editingSession.editBuffer.updates.push(feature);
                    }
                }

                showToast('Attributes saved', 'success');
                closeAttributeForm();
            };

            // Close attribute form
            window.closeAttributeForm = function () {
                const formContainer = document.getElementById('attribute-form-container');
                if (formContainer) {
                    formContainer.style.display = 'none';
                }
            };

            // Import CSV to editing layer
            async function importCSVToLayer(file, collectionId) {
                try {
                    const csvText = await file.text();
                    const rows = parseCSV(csvText);

                    if (rows.length === 0) {
                        showToast('No valid coordinates found in CSV file', 'error');
                        return;
                    }

                    // Get the selected CRS
                    const selectedCrs = document.getElementById('csv-crs-selector').value;

                    // Enable editing for the collection if not already enabled
                    if (!currentEditable) {
                        const layerConfig = EDITABLE_LAYERS.find(l => l.id === collectionId);
                        if (layerConfig) {
                            createEditableLayer(layerConfig);
                        } else {
                            showToast('Invalid layer selected for CSV import', 'error');
                            return;
                        }
                    }

                    // Ensure we have a valid editable layer
                    if (!currentEditable || !currentEditable.source) {
                        showToast('No editable layer available for CSV import', 'error');
                        return;
                    }

                    // Create features array for reference layer
                    const csvFeatures = [];

                    rows.forEach((row, index) => {
                        try {
                            // Transform coordinates to map projection
                            const inputCoord = [row.x, row.y];
                            const mapCoord = ol.proj.transform(inputCoord, selectedCrs, view.getProjection());

                            // Create feature for reference layer (snapping only, not for editing)
                            const feature = new ol.Feature({
                                geometry: new ol.geom.Point(mapCoord),
                                id: row.id || `csv_${index + 1}`,
                                name: row.id || `Point ${index + 1}`,
                                description: row.description || '',
                                _isReference: true // Mark as reference point
                            });

                            csvFeatures.push(feature);

                        } catch (error) {
                            console.error(`Error processing row ${index + 1}:`, error);
                        }
                    });

                    // Create reference layer for snapping (not editable)
                    if (csvFeatures.length > 0) {
                        createReferenceLayer(csvFeatures);

                        // Fit map to features
                        const extent = ol.extent.boundingExtent(
                            csvFeatures.map(f => f.getGeometry().getCoordinates())
                        );
                        view.fit(extent, { padding: [50, 50, 50, 50], maxZoom: 16 });

                        showToast(`Imported ${csvFeatures.length} reference points for snapping`, 'success');
                        document.getElementById('updates-status-text').textContent = `Reference layer: ${csvFeatures.length} points loaded`;

                        // Update snapping with new reference layer
                        updateSnapping();
                    }

                } catch (error) {
                    console.error('Error importing CSV:', error);
                    showToast('Error importing CSV: ' + error.message, 'error');
                }
            }

            // Unified CSV parsing and plotting utilities
            function detectDelimiter(sampleText) {
                // Try comma, tab, semicolon; pick the one yielding most columns on header line
                const firstLine = (sampleText.split(/\r?\n/)[0] || '');
                const candidates = [',', '\t', ';'];
                let best = ',', bestCount = 1;
                candidates.forEach(d => {
                    const c = firstLine.split(d).length;
                    if (c > bestCount) { best = d; bestCount = c; }
                });
                return best;
            }

            function normalizeHeader(h) {
                return (h || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '');
            }

            function parseCSV(csvText) {
                const delimiter = detectDelimiter(csvText);
                const lines = csvText.split(/\r?\n/).filter(l => l.trim().length > 0);
                if (lines.length === 0) return [];

                const headerParts = lines[0].split(delimiter).map(h => h.trim());
                const hasHeader = headerParts.some(h => /lon|lat|x|y|easting|northing|id|name|desc/i.test(h));

                let headers = [];
                let startIndex = 0;
                if (hasHeader) {
                    headers = headerParts;
                    startIndex = 1;
                }

                // Build header index map, fallback to column positions
                const normToIndex = {};
                if (hasHeader) {
                    headers.forEach((h, i) => { normToIndex[normalizeHeader(h)] = i; });
                }

                function getIndex(candidates, fallbackIndex) {
                    for (const key of candidates) {
                        if (key in normToIndex) return normToIndex[key];
                    }
                    return fallbackIndex;
                }

                const idxId = hasHeader ? getIndex(['id', 'point', 'pointid', 'name'], 0) : 0;
                const idxX = hasHeader ? getIndex(['lon', 'longitude', 'lng', 'x', 'easting', 'eastings'], 1) : 1;
                const idxY = hasHeader ? getIndex(['lat', 'latitude', 'y', 'northing', 'northings'], 2) : 2;
                const idxDesc = hasHeader ? getIndex(['description', 'desc', 'label', 'remarks', 'remark'], 3) : 3;

                const rows = [];
                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(delimiter);
                    if (parts.length < 2) continue;

                    const toNum = v => {
                        if (v == null) return NaN;
                        const t = String(v).trim().replace(/^[\"\']|[\"\']$/g, '');
                        const n = Number(t);
                        return isNaN(n) ? NaN : n;
                    };

                    const id = (parts[idxId] || '').trim();
                    const x = toNum(parts[idxX]);
                    const y = toNum(parts[idxY]);
                    const description = (parts[idxDesc] || '').trim();

                    if (!isNaN(x) && !isNaN(y)) {
                        rows.push({ id, x, y, description });
                    }
                }

                return rows;
            }

            function processCSVDataForPlotting(csvText, userSelectedCrs) {
                try {
                    const rows = parseCSV(csvText);
                    if (rows.length === 0) {
                        alert('No valid coordinates found in CSV file');
                        return;
                    }

                    // Clear previous markers
                    markerSource.clear();

                    const mapCode = view.getProjection().getCode();
                    const features = [];
                    let outOfBoundsCount = 0;

                    rows.forEach((r, index) => {
                        let inputCoord = [r.x, r.y];

                        // Only swap coordinates in EPSG:4326 when first column looks like latitude (|value| ≤ 90)
                        if (userSelectedCrs === 'EPSG:4326' && Math.abs(inputCoord[0]) <= 90) {
                            // CSV likely lat,lon; transform expects lon,lat
                            inputCoord = [inputCoord[1], inputCoord[0]];
                        }

                        // PATCH: transform CSV input coords (csvCrs -> map projection) before plotting - direct transform
                        let mapCoord;
                        try {
                            // Direct transform from CSV CRS to map projection
                            mapCoord = ol.proj.transform(inputCoord, userSelectedCrs, mapCode);
                            console.log('CSV row transformed', inputCoord, 'from', userSelectedCrs, 'to map', mapCoord);
                            if (!mapCoord || isNaN(mapCoord[0]) || isNaN(mapCoord[1])) throw new Error('Invalid transform');
                        } catch (e) {
                            console.warn(`Skipping row ${index + 1} due to transform error`, e);
                            return;
                        }

                        const feat = new ol.Feature({
                            geometry: new ol.geom.Point(mapCoord),
                            type: 'coordinate',
                            label: r.id || `Point ${index + 1}`,
                            description: r.description || '',
                            originalCoord: [r.x, r.y],
                            crs: userSelectedCrs
                        });
                        features.push(feat);
                        markerSource.addFeature(feat);

                        // Bounds check in EPSG:4326 lon/lat
                        const lonLat = ol.proj.transform(mapCoord, mapCode, 'EPSG:4326');
                        if (lonLat[0] < 28 || lonLat[0] > 36 || lonLat[1] < -3 || lonLat[1] > 5) {
                            outOfBoundsCount++;
                        }
                    });

                    // Warning if >50% outside Uganda bounds
                    if (features.length > 0 && outOfBoundsCount > features.length * 0.5) {
                        showToast('Warning: >50% of CSV points are outside Uganda bounds (Lon 28–36, Lat -3–5).', 'warning', 7000);
                    }

                    if (features.length > 0) {
                        const extent = markerSource.getExtent();
                        view.fit(extent, { padding: [50, 50, 50, 50], maxZoom: 16 });
                        const msg = `Plotted ${features.length} coordinates (CRS ${userSelectedCrs})` + (outOfBoundsCount ? `, ${outOfBoundsCount} outside bounds` : '');
                        document.getElementById('updates-status-text').textContent = msg;
                        showToast(msg, 'success');
                    } else {
                        showToast('No valid coordinates could be plotted', 'error');
                    }
                } catch (error) {
                    console.error('Error processing CSV:', error);
                    alert('Error processing CSV file: ' + error.message);
                    showToast('Error processing CSV file', 'error');
                }
            }

            function loadAttributeForm(layerName) {
                const attributeForm = document.getElementById('attribute-form');

                // Simple placeholder for attribute form
                // In a real implementation, you would fetch the layer schema from pg_featureserv
                attributeForm.innerHTML = `
                <label for="attribute-name">Name:</label>
                <input type="text" id="attribute-name" placeholder="Enter feature name">
                
                <label for="attribute-id">ID:</label>
                <input type="text" id="attribute-id" placeholder="Enter feature ID">
                
                <label for="attribute-description">Description:</label>
                <input type="text" id="attribute-description" placeholder="Enter description">
            `;
            }

            // Editing toggle functionality (OLD - may not exist in new implementation)
            const editingToggleBtn = document.getElementById('editing-toggle-btn');
            if (editingToggleBtn) {
                editingToggleBtn.addEventListener('click', function () {
                    const editingEnabled = this.innerHTML.includes('ON');
                    const selectedCollection = document.getElementById('gspnetUpdatesLayerSelect').value;

                    if (!selectedCollection) {
                        showToast('Please select a collection first', 'warning');
                        return;
                    }

                    if (!editingEnabled) {
                        this.innerHTML = '<i class="fas fa-toggle-on"></i> Editing: ON';
                        this.style.background = 'linear-gradient(to bottom, #2ecc71, #27ae60)';

                        // Enable editing tools
                        document.getElementById('undo-editing-btn').disabled = false;
                        document.getElementById('save-updates-btn').disabled = false;

                        // Enable editing for the selected collection
                        enableEditingForLayer(selectedCollection);
                        showToast(`${selectedEditMode.charAt(0).toUpperCase() + selectedEditMode.slice(1)} editing mode enabled for ${selectedCollection}`, 'success');
                    } else {
                        this.innerHTML = '<i class="fas fa-toggle-off"></i> Editing: OFF';
                        this.style.background = '';

                        // Disable editing tools
                        document.getElementById('undo-editing-btn').disabled = true;
                        document.getElementById('save-updates-btn').disabled = true;

                        // Remove edit layer
                        if (pgfEditLayer) {
                            map.removeLayer(pgfEditLayer);
                            pgfEditLayer = null;
                            pgfEditSource = null;
                        }

                        showToast('Editing mode disabled', 'info');
                    }
                });
            } // End if editingToggleBtn

            // ========================================
            //  TRANSACTIONAL SAVE SYSTEM
            // ========================================

            // Validate changes before saving
            function validateChanges() {
                const errors = [];

                // Validate new features
                editingSession.editBuffer.adds.forEach((feature, index) => {
                    const geom = feature.getGeometry();
                    if (!geom) {
                        errors.push(`Feature ${index + 1}: Missing geometry`);
                        return;
                    }

                    // Check for required attributes if schema available
                    if (editingSession.schema && editingSession.schema.properties) {
                        Object.keys(editingSession.schema.properties).forEach(propName => {
                            const propDef = editingSession.schema.properties[propName];
                            if (propDef.required && !feature.get(propName)) {
                                errors.push(`Feature ${index + 1}: Missing required field "${propName}"`);
                            }
                        });
                    }

                    // Validate geometry for polygons
                    if (geom.getType() === 'Polygon') {
                        const coords = geom.getCoordinates()[0];
                        if (coords.length < 4) {
                            errors.push(`Feature ${index + 1}: Polygon must have at least 3 vertices`);
                        }
                    }
                });

                return errors;
            }

            // Show confirmation dialog before saving
            async function showSaveConfirmation() {
                const adds = editingSession.editBuffer.adds.length || editBuffers.adds.length;
                const updates = editingSession.editBuffer.updates.length || editBuffers.updates.length;
                const deletes = editingSession.editBuffer.deletes.length || editBuffers.deletes.length;

                if (adds === 0 && updates === 0 && deletes === 0) {
                    showToast('No changes to save', 'info');
                    return false;
                }

                const message = `Save changes to ${editingSession.layerConfig?.name || 'layer'}?\n\n` +
                    `✓ New features: ${adds}\n` +
                    `✓ Modified features: ${updates}\n` +
                    `✓ Deleted features: ${deletes}\n\n` +
                    `This action cannot be undone.`;

                return confirm(message);
            }

            // Save updates functionality using pg_featureserv with transaction management (OLD - may not exist)
            const saveUpdatesBtn = document.getElementById('save-updates-btn');
            if (saveUpdatesBtn) {
                saveUpdatesBtn.addEventListener('click', async function () {
                    if (!currentEditable) {
                        showToast('Please select a layer first', 'error');
                        return;
                    }

                    // Validate changes
                    const validationErrors = validateChanges();
                    if (validationErrors.length > 0) {
                        const errorMsg = 'Validation errors:\n' + validationErrors.join('\n');
                        alert(errorMsg);
                        return;
                    }

                    // Show confirmation
                    const confirmed = await showSaveConfirmation();
                    if (!confirmed) {
                        showToast('Save cancelled', 'info');
                        return;
                    }

                    // Show loading indicator
                    const loadingIndicator = document.getElementById('updates-loading-indicator');
                    const statusText = document.getElementById('updates-status-text');

                    loadingIndicator.style.display = 'inline-block';
                    statusText.textContent = 'Saving updates...';

                    try {
                        // Save edits to PG-FeatureServer
                        await saveEditsToPgfs(currentEditable.cfg.endpoint);

                        statusText.textContent = `Saved: ${editBuffers.adds.length} added, ${editBuffers.updates.length} updated, ${editBuffers.deletes.length} deleted`;
                        showToast('All edits saved successfully', 'success');

                    } catch (error) {
                        console.error('Save error:', error);
                        statusText.textContent = 'Save failed: ' + error.message;
                        showToast('Save failed: ' + error.message, 'error');
                    } finally {
                        loadingIndicator.style.display = 'none';
                    }
                });

                // pg_featureserv transaction function for saving edits
                async function performPgfTransaction(collectionId, loadingIndicator, statusText) {
                    try {
                        const source = pgfUpdateLayer.getSource();
                        const allFeatures = source.getFeatures();

                        // Classify features for pg_featureserv
                        const inserts = [], updates = [];
                        allFeatures.forEach(f => {
                            const id = f.getId();
                            if (!id || id.toString().startsWith('temp') || id.toString().includes('new')) {
                                inserts.push(f);
                            } else if (f.get('gsp_modified') === true) {
                                updates.push(f);
                            }
                        });

                        // Process inserts (POST)
                        for (const feature of inserts) {
                            const featureData = {
                                type: "Feature",
                                geometry: feature.getGeometry(),
                                properties: feature.getProperties()
                            };
                            delete featureData.properties.geometry; // Remove geometry from properties

                            const response = await fetch(`https://pgf.geospatialnetworkug.xyz/collections/${collectionId}/items`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/geo+json'
                                },
                                body: JSON.stringify(featureData)
                            });

                            if (!response.ok) {
                                throw new Error(`Failed to insert feature: ${response.status} ${response.statusText}`);
                            }
                        }

                        // Process updates (PUT)
                        for (const feature of updates) {
                            const featureId = feature.getId();
                            const featureData = {
                                type: "Feature",
                                id: featureId,
                                geometry: feature.getGeometry(),
                                properties: feature.getProperties()
                            };
                            delete featureData.properties.geometry; // Remove geometry from properties

                            const response = await fetch(`https://pgf.geospatialnetworkug.xyz/collections/${collectionId}/items/${featureId}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/geo+json'
                                },
                                body: JSON.stringify(featureData)
                            });

                            if (!response.ok) {
                                throw new Error(`Failed to update feature ${featureId}: ${response.status} ${response.statusText}`);
                            }
                        }

                        loadingIndicator.style.display = 'none';
                        statusText.textContent = 'Successfully saved ' + inserts.length + ' inserts, ' + updates.length + ' updates to pg_featureserv';
                        showToast('Successfully saved ' + inserts.length + ' inserts, ' + updates.length + ' updates to pg_featureserv', 'success');

                    } catch (error) {
                        console.error('pg_featureserv error:', error);
                        loadingIndicator.style.display = 'none';
                        statusText.textContent = 'Error saving: ' + error.message;
                        showToast('Error saving: ' + error.message, 'error');
                    }
                }

                // Add modify interaction to mark features as modified when edited

                function setupModifyInteraction() {
                    if (pgfUpdateLayer && pgfUpdateLayer.getSource()) {
                        // Remove existing modify interaction if any
                        if (modifyInteraction) {
                            map.removeInteraction(modifyInteraction);
                        }

                        // Create new modify interaction
                        modifyInteraction = new ol.interaction.Modify({
                            source: pgfUpdateLayer.getSource()
                        });

                        // Mark features as modified when edited
                        modifyInteraction.on('modifyend', function (evt) {
                            evt.features.forEach(f => f.set('gsp_modified', true));
                            console.log('Features marked as modified:', evt.features.length);
                        });

                        map.addInteraction(modifyInteraction);
                        console.log('Modify interaction setup for pg_featureserv layer');
                    }
                }

                // pg_featureserv doesn't need DescribeFeatureType - it uses standard GeoJSON

                // Call setup when pg_featureserv layer is loaded
                document.getElementById('gspnetUpdatesLayerSelect').addEventListener('change', async function () {
                    if (this.value) {
                        // Find the layer configuration
                        const layerConfig = EDITABLE_LAYERS.find(l => l.id === this.value);
                        if (layerConfig) {
                            // Clear existing editing
                            clearEditingInteractions();
                            // Create new editable layer
                            createEditableLayer(layerConfig);

                            // Fetch and store schema for attribute form
                            editingSession.layerId = this.value;
                            editingSession.layerConfig = layerConfig;
                            editingSession.schema = await fetchLayerSchema(this.value);

                            // Setup right-click finish
                            setupRightClickFinish();

                            // Update snapping
                            updateSnapping();

                            // Enable UI buttons
                            const startEditBtn = document.getElementById('start-editing-btn');
                            const plotBtn = document.getElementById('plot-csv-btn');
                            if (startEditBtn) startEditBtn.disabled = false;
                            if (plotBtn) plotBtn.disabled = false;

                            showToast(`Editing enabled for ${layerConfig.name}`, 'success');
                        }
                    } else {
                        // Clear state when no layer selected
                        editingSession.layerId = null;
                        editingSession.layerConfig = null;
                        editingSession.schema = null;

                        // Disable UI buttons
                        const startEditBtn = document.getElementById('start-editing-btn');
                        const plotBtn = document.getElementById('plot-csv-btn');
                        if (startEditBtn) startEditBtn.disabled = true;
                        if (plotBtn) plotBtn.disabled = true;
                    }
                });
            } // End if saveUpdatesBtn

            // ========================================
            //  SNAPPING SETTINGS EVENT LISTENERS
            // ========================================

            // Snapping enabled checkbox
            const snapEnabledCheckbox = document.getElementById('snap-enabled-checkbox');
            if (snapEnabledCheckbox) {
                snapEnabledCheckbox.addEventListener('change', function () {
                    snappingConfig.enabled = this.checked;
                    updateSnapping();
                    showToast(`Snapping ${this.checked ? 'enabled' : 'disabled'}`, 'info');
                });
            }

            // Snap to CSV checkbox
            const snapCSVCheckbox = document.getElementById('snap-csv-checkbox');
            if (snapCSVCheckbox) {
                snapCSVCheckbox.addEventListener('change', function () {
                    snappingConfig.snapToCSV = this.checked;
                    updateSnapping();
                });
            }

            // Snap to vertices checkbox
            const snapVerticesCheckbox = document.getElementById('snap-vertices-checkbox');
            if (snapVerticesCheckbox) {
                snapVerticesCheckbox.addEventListener('change', function () {
                    snappingConfig.snapToVertices = this.checked;
                    updateSnapping();
                });
            }

            // Snap to edges checkbox
            const snapEdgesCheckbox = document.getElementById('snap-edges-checkbox');
            if (snapEdgesCheckbox) {
                snapEdgesCheckbox.addEventListener('change', function () {
                    snappingConfig.snapToEdges = this.checked;
                    updateSnapping();
                });
            }

            // Snap tolerance slider
            const snapToleranceSlider = document.getElementById('snap-tolerance-slider');
            const snapToleranceValue = document.getElementById('snap-tolerance-value');
            if (snapToleranceSlider && snapToleranceValue) {
                snapToleranceSlider.addEventListener('input', function () {
                    snappingConfig.tolerance = parseInt(this.value);
                    snapToleranceValue.textContent = this.value;
                    updateSnapping();
                });
            }

            // ========================================
            //  KEYBOARD SHORTCUTS
            // ========================================

            document.addEventListener('keydown', function (e) {
                // ESC - Cancel current operation
                if (e.key === 'Escape') {
                    if (editingSession.interactions.draw && editingSession.interactions.draw.getActive()) {
                        editingSession.interactions.draw.abortDrawing();
                        showToast('Drawing cancelled', 'info');
                    }
                    closeAttributeForm();
                }

                // S - Toggle snapping
                if (e.key === 's' || e.key === 'S') {
                    if (!e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        const snapCheckbox = document.getElementById('snap-enabled-checkbox');
                        if (snapCheckbox) {
                            snapCheckbox.checked = !snapCheckbox.checked;
                            snapCheckbox.dispatchEvent(new Event('change'));
                        }
                    }
                }

                // Ctrl/Cmd + S - Save changes
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    const saveBtn = document.getElementById('save-updates-btn');
                    if (saveBtn && !saveBtn.disabled) {
                        saveBtn.click();
                    }
                }

                // Delete - Delete selected feature
                if (e.key === 'Delete' && editingSession.selectedFeatures.length > 0) {
                    editingSession.selectedFeatures.forEach(feature => {
                        feature.set('_pgfs_state', 'deleted');
                        if (!editingSession.editBuffer.deletes.includes(feature)) {
                            editingSession.editBuffer.deletes.push(feature);
                        }
                        // Remove from map
                        if (editingSession.editLayer) {
                            editingSession.editLayer.getSource().removeFeature(feature);
                        }
                    });
                    showToast(`Deleted ${editingSession.selectedFeatures.length} feature(s)`, 'warning');
                    editingSession.selectedFeatures = [];
                    updatePendingCount();
                }
            });

            // Event listeners for existing modals

            window.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal')) {
                    e.target.style.display = 'none';
                }
            });

            // SIMPLIFIED PRINT FUNCTIONALITY - REMOVED (replaced with enhanced print dialog)
            // The print functionality is now handled by the enhanced print dialog modal

            // Handle Enter key press for search inputs
            function handleKeyPress(e, buttonId) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById(buttonId).click();
                }
            }

            // Place name search functionality with improved accuracy
            document.getElementById('placeSearchBtn').addEventListener('click', function () {
                const query = document.getElementById('placeSearch').value;
                if (!query) {
                    alert('Please enter a place name to search.');
                    return;
                }

                fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&countrycodes=ug&q=${encodeURIComponent(query)}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    signal: AbortSignal.timeout(10000) // 10 second timeout
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.length > 0) {
                            const result = data[0];
                            const lon = parseFloat(result.lon);
                            const lat = parseFloat(result.lat);

                            if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
                                throw new Error('Invalid coordinates returned');
                            }

                            // Clear previous markers
                            markerSource.clear();

                            // Add new marker
                            const marker = new ol.Feature({
                                geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                                type: 'coordinate',
                                label: result.display_name
                            });
                            markerSource.addFeature(marker);

                            // Zoom to location with higher precision
                            view.animate({
                                center: ol.proj.fromLonLat([lon, lat]),
                                zoom: 16,
                                duration: 1500
                            });
                            showToast(`Location found: ${result.display_name}`, 'success');
                        } else {
                            alert('Location not found. Please try another search term.');
                            showToast('Location not found. Please try another search term.', 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error during geocoding:', error);
                        const errorMsg = error.name === 'AbortError'
                            ? 'Search request timed out. Please try again.'
                            : error.message?.includes('Failed to fetch')
                                ? 'Network error. Please check your connection and try again.'
                                : 'Error during search. Please try again.';
                        alert(errorMsg);
                        showToast(errorMsg, 'error');
                    });
            });

            // PATCH: Enhanced Coordinate search functionality with split-panel popup
            // Open coordinate search popup (now in bottom controls)
            document.getElementById('coordSearchBtn').addEventListener('click', function () {
                document.getElementById('coordinate-search-popup').style.display = 'block';
                loadStoredCRS(); // Load saved CRS selections
            });

            // PATCH: Close coordinate search popup
            document.getElementById('search-popup-close').addEventListener('click', function () {
                document.getElementById('coordinate-search-popup').style.display = 'none';
            });

            // PATCH: Coordinate Search Functionality - Complete implementation with CRS handling and CSV support
            let coordSearchDebug = false; // Debug mode toggle

            // Load stored CRS selections from localStorage
            function loadStoredCRS() {
                const manualCRS = localStorage.getItem('coordsearch_manual_crs');
                const csvCRS = localStorage.getItem('coordsearch_csv_crs');

                if (manualCRS) {
                    document.getElementById('search-manual-crs').value = manualCRS;
                }
                if (csvCRS) {
                    document.getElementById('search-csv-crs').value = csvCRS;
                }
            }

            // Save CRS selections to localStorage
            function saveCRS() {
                localStorage.setItem('coordsearch_manual_crs', document.getElementById('search-manual-crs').value);
                localStorage.setItem('coordsearch_csv_crs', document.getElementById('search-csv-crs').value);
            }

            // Coordinate validation and transformation
            function validateAndTransformCoordinate(x, y, crs) {
                const numX = parseFloat(x);
                const numY = parseFloat(y);

                if (isNaN(numX) || isNaN(numY)) {
                    return { valid: false, message: 'Please enter valid numeric values' };
                }

                // Handle EPSG:4326 coordinate order detection
                let coord = [numX, numY];
                if (crs === 'EPSG:4326') {
                    // Heuristic: if first value is between -90 and 90 and second is outside that range, assume lat,lon
                    if (numX >= -90 && numX <= 90 && (numY < -90 || numY > 90)) {
                        coord = [numY, numX]; // Swap to lon,lat
                        if (coordSearchDebug) console.log('DEBUG: Swapped lat,lon to lon,lat:', [numX, numY], '->', coord);
                    }
                }

                try {
                    const mapCrs = view.getProjection().getCode();
                    const transformed = ol.proj.transform(coord, crs, mapCrs);

                    if (coordSearchDebug) {
                        console.log(`DEBUG: input [${coord[0]},${coord[1]}] in CRS ${crs} -> transformed to map [${transformed[0]},${transformed[1]}]`);
                    }

                    return { valid: true, coord: transformed, original: coord };
                } catch (error) {
                    console.error('Projection transformation failed:', error);
                    return { valid: false, message: `Invalid coordinates for ${crs}: ${error.message}` };
                }
            }

            // Manual coordinate plotting
            document.getElementById('search-manual-enter').addEventListener('click', function () {
                const x = document.getElementById('search-manual-easting').value.trim();
                const y = document.getElementById('search-manual-northing').value.trim();
                const crs = document.getElementById('search-manual-crs').value;
                const statusEl = document.getElementById('search-manual-status');

                if (!x || !y) {
                    statusEl.textContent = 'Please enter both coordinates';
                    statusEl.className = 'coordsearch-status error';
                    return;
                }

                const result = validateAndTransformCoordinate(x, y, crs);
                if (!result.valid) {
                    statusEl.textContent = result.message;
                    statusEl.className = 'coordsearch-status error';
                    return;
                }

                // Clear previous results if not in append mode
                searchSource.clear();

                // Create and add feature
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(result.coord),
                    name: `Point (${result.original[0]}, ${result.original[1]})`,
                    originalCoord: result.original,
                    crs: crs
                });
                searchSource.addFeature(feature);

                // Zoom to point
                view.animate({
                    center: result.coord,
                    zoom: 16,
                    duration: 1500
                });

                statusEl.textContent = 'Point plotted successfully';
                statusEl.className = 'coordsearch-status success';
                showToast('1 point plotted', 'success');
                saveCRS();
            });

            // Enter key support for manual input
            document.getElementById('search-manual-easting').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    document.getElementById('search-manual-northing').focus();
                }
            });

            document.getElementById('search-manual-northing').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    document.getElementById('search-manual-enter').click();
                }
            });

            // CSV file handling
            document.getElementById('search-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file && file.name.endsWith('.csv')) {
                    const statusEl = document.getElementById('search-csv-status');
                    statusEl.textContent = `File selected: ${file.name}`;
                    statusEl.className = 'coordsearch-status success';
                }
            });

            // CSV plotting
            document.getElementById('search-csv-plot').addEventListener('click', function () {
                const fileInput = document.getElementById('search-csv-file');
                const crs = document.getElementById('search-csv-crs').value;
                const appendMode = document.getElementById('search-csv-append').checked;
                const statusEl = document.getElementById('search-csv-status');

                if (!fileInput.files[0]) {
                    statusEl.textContent = 'Please select a CSV file first';
                    statusEl.className = 'coordsearch-status error';
                    return;
                }

                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = function (e) {
                    try {
                        const csvData = parseCSV(e.target.result);
                        plotCSVCoordinates(csvData, crs, appendMode);
                    } catch (error) {
                        console.error('Error parsing CSV:', error);
                        statusEl.textContent = 'Error parsing CSV file';
                        statusEl.className = 'coordsearch-status error';
                    }
                };

                reader.readAsText(file);
            });

            // CSV parsing function
            function parseCSV(csvText) {
                const lines = csvText.split('\n').filter(line => line.trim().length > 0);
                if (lines.length === 0) return [];

                // Auto-detect delimiter
                const delimiters = [',', ';', '\t'];
                let delimiter = ',';
                for (const d of delimiters) {
                    if (lines[0].includes(d)) {
                        delimiter = d;
                        break;
                    }
                }

                const data = [];
                const hasHeader = lines[0].toLowerCase().includes('name') ||
                    lines[0].toLowerCase().includes('easting') ||
                    lines[0].toLowerCase().includes('northing');

                const startIndex = hasHeader ? 1 : 0;

                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(delimiter).map(p => p.trim().replace(/"/g, ''));
                    if (parts.length >= 3) {
                        const name = parts[0];
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);

                        if (!isNaN(x) && !isNaN(y)) {
                            data.push({ name, x, y });
                        }
                    }
                }

                return data;
            }

            // Plot CSV coordinates
            function plotCSVCoordinates(data, crs, appendMode) {
                const statusEl = document.getElementById('search-csv-status');

                if (!appendMode) {
                    searchSource.clear();
                }

                let plotted = 0;
                let skipped = 0;
                let outOfBounds = 0;
                const features = [];

                data.forEach(point => {
                    const result = validateAndTransformCoordinate(point.x, point.y, crs);
                    if (!result.valid) {
                        skipped++;
                        return;
                    }

                    // Check Uganda bounds
                    const lonLat = ol.proj.transform(result.coord, view.getProjection().getCode(), 'EPSG:4326');
                    if (lonLat[0] < 28 || lonLat[0] > 36 || lonLat[1] < -3 || lonLat[1] > 5) {
                        outOfBounds++;
                    }

                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(result.coord),
                        name: point.name,
                        originalCoord: result.original,
                        crs: crs
                    });

                    features.push(feature);
                    searchSource.addFeature(feature);
                    plotted++;
                });

                if (features.length > 0) {
                    // Zoom to extent
                    const extent = searchSource.getExtent();
                    view.fit(extent, { padding: [50, 50, 50, 50], maxZoom: 18 });
                }

                let message = `CSV: ${plotted} plotted, ${skipped} skipped`;
                if (outOfBounds > 0) {
                    message += ` (${outOfBounds} outside Uganda bounds)`;
                }

                statusEl.textContent = message;
                statusEl.className = 'coordsearch-status success';
                showToast(message, 'success');
                saveCRS();
            }

            // Clear results
            document.getElementById('search-clear-results').addEventListener('click', function () {
                searchSource.clear();
                const statusEl = document.getElementById('search-csv-status');
                statusEl.textContent = 'Results cleared';
                statusEl.className = 'coordsearch-status';
                showToast('Results cleared', 'info');
            });

            // Close coordinate search modal (legacy)
            document.getElementById('coordSearchClose').addEventListener('click', function () {
                document.getElementById('coordSearchModal').style.display = 'none';
            });

            // Parcel Search functionality - Replaces NLIS
            document.addEventListener('DOMContentLoaded', function () {
                const parcelSearchBtn = document.getElementById('parcelSearchBtn');
                if (parcelSearchBtn) {
                    parcelSearchBtn.addEventListener('click', function () {
                        const panel = document.getElementById('parcelSearchPanel');
                        const mainContent = document.querySelector('.main-content');
                        if (panel) {
                            // Close other panels first
                            document.querySelectorAll('.project-library-panel, .polygon-import-panel, .parcel-search-panel').forEach(p => {
                                p.classList.remove('active');
                                p.style.display = 'none';
                            });
                            panel.classList.add('active');
                            panel.style.display = 'flex';
                            if (mainContent) mainContent.classList.add('panel-open');
                            populateParcelSearchForm();
                        } else {
                            console.error('Parcel search panel not found');
                        }
                    });
                }

                // Close parcel search panel function
                function closeParcelSearchPanel() {
                    const panel = document.getElementById('parcelSearchPanel');
                    const mainContent = document.querySelector('.main-content');
                    if (panel) {
                        panel.classList.remove('active');
                        panel.style.display = 'none';
                        // Clear search form/results if needed
                        const searchForm = panel.querySelector('#parcelSearchForm');
                        if (searchForm) {
                            searchForm.reset();
                        }
                        // Clear any search results
                        const resultsContainer = panel.querySelector('.parcel-search-results');
                        if (resultsContainer) {
                            resultsContainer.innerHTML = '';
                        }
                    }
                    // Remove panel-open class only if no other panels are open
                    if (mainContent && !document.querySelector('.project-library-panel.active, .polygon-import-panel.active')) {
                        mainContent.classList.remove('panel-open');
                    }
                    console.log('Parcel search panel closed');
                }

                // Close button handler
                const parcelSearchPanelClose = document.getElementById('parcelSearchPanelClose');
                if (parcelSearchPanelClose) {
                    parcelSearchPanelClose.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        closeParcelSearchPanel();
                    });
                    console.log('Parcel search panel close button handler attached');
                } else {
                    console.warn('Parcel search panel close button not found');
                }

                // ESC key to close panel
                document.addEventListener('keydown', function (e) {
                    if (e.key === 'Escape' || e.keyCode === 27) {
                        const panel = document.getElementById('parcelSearchPanel');
                        if (panel && panel.classList.contains('active')) {
                            closeParcelSearchPanel();
                        }
                    }
                });
            });

            // OLD NLIS CODE - REMOVED (replaced with parcel search above)

            // Parcel Search Modal handlers
            const parcelSearchModal = document.getElementById('parcelSearchModal');
            const parcelSearchClose = document.getElementById('parcelSearchClose');
            const parcelSearchCancel = document.getElementById('parcelSearchCancel');
            const parcelSearchForm = document.getElementById('parcelSearchForm');

            if (parcelSearchClose) {
                parcelSearchClose.addEventListener('click', function () {
                    if (parcelSearchModal) {
                        parcelSearchModal.classList.remove('show');
                    }
                });
            }

            if (parcelSearchCancel) {
                parcelSearchCancel.addEventListener('click', function () {
                    if (parcelSearchForm) {
                        parcelSearchForm.reset();
                    }
                    const results = document.getElementById('parcelSearchResults');
                    if (results) {
                        results.style.display = 'none';
                    }
                });
            }

            if (parcelSearchModal) {
                parcelSearchModal.addEventListener('click', function (e) {
                    if (e.target === parcelSearchModal) {
                        parcelSearchModal.classList.remove('show');
                    }
                });
            }

            if (parcelSearchForm) {
                parcelSearchForm.addEventListener('submit', async function (e) {
                    e.preventDefault();
                    await searchParcels();
                });
            }

            // Populate parcel search form
            function populateParcelSearchForm() {
                const districtSelect = document.getElementById('parcelSearchDistrict');
                if (districtSelect && typeof UGANDA_DISTRICTS !== 'undefined') {
                    const firstOption = districtSelect.querySelector('option[value=""]');
                    districtSelect.innerHTML = '';
                    if (firstOption) {
                        districtSelect.appendChild(firstOption);
                    }
                    UGANDA_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        districtSelect.appendChild(option);
                    });
                }
            }

            // Search parcels function
            async function searchParcels() {
                const district = document.getElementById('parcelSearchDistrict').value;
                const uniqueId = document.getElementById('parcelSearchUniqueId').value.trim();
                const client = document.getElementById('parcelSearchClient').value.trim();
                const project = document.getElementById('parcelSearchProject').value.trim();
                const surveyor = document.getElementById('parcelSearchSurveyor').value.trim();
                const layer = document.getElementById('parcelSearchLayer').value;

                const resultsDiv = document.getElementById('parcelSearchResults');
                const resultsTable = document.getElementById('parcelResultsTable');

                if (resultsDiv) {
                    resultsDiv.style.display = 'block';
                    resultsTable.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Searching...</p>';
                }

                try {
                    let query = supabase
                        .from('polygon_features')
                        .select('*')
                        .eq('is_archived', false);

                    if (district) query = query.eq('district', district);
                    if (uniqueId) query = query.ilike('unique_id', `%${uniqueId}%`);
                    if (client) query = query.ilike('client', `%${client}%`);
                    if (project) query = query.ilike('project_name', `%${project}%`);
                    if (surveyor) query = query.ilike('surveyor', `%${surveyor}%`);
                    if (layer) query = query.eq('layer_name', layer);

                    const { data, error } = await query;

                    if (error) throw error;

                    if (!data || data.length === 0) {
                        resultsTable.innerHTML = '<p>No parcels found matching your criteria.</p>';
                        return;
                    }

                    // Display results in table
                    let tableHTML = '<table class="parcel-results-table"><thead><tr>' +
                        '<th>Unique ID</th><th>Client</th><th>Project</th><th>District</th><th>Area (ha)</th><th>Layer</th>' +
                        '</tr></thead><tbody>';

                    data.forEach(parcel => {
                        tableHTML += `<tr data-parcel-id="${parcel.id}" data-unique-id="${parcel.unique_id}">` +
                            `<td>${parcel.unique_id}</td>` +
                            `<td>${parcel.client}</td>` +
                            `<td>${parcel.project_name}</td>` +
                            `<td>${parcel.district}</td>` +
                            `<td>${parcel.area_hectares.toFixed(4)}</td>` +
                            `<td>${parcel.layer_name}</td>` +
                            `</tr>`;
                    });

                    tableHTML += '</tbody></table>';
                    resultsTable.innerHTML = tableHTML;

                    // Add click handlers to rows
                    const rows = resultsTable.querySelectorAll('tr[data-parcel-id]');
                    rows.forEach(row => {
                        row.addEventListener('click', function () {
                            const parcelId = this.getAttribute('data-parcel-id');
                            const uniqueId = this.getAttribute('data-unique-id');
                            zoomToParcel(parcelId, uniqueId);
                        });
                    });

                } catch (error) {
                    console.error('Error searching parcels:', error);
                    if (resultsTable) {
                        resultsTable.innerHTML = '<p class="status-message error">Error: ' + error.message + '</p>';
                    }
                }
            }

            // Zoom to parcel
            let parcelHighlightLayer = null;
            async function zoomToParcel(parcelId, uniqueId) {
                try {
                    const { data, error } = await supabase
                        .from('polygon_features')
                        .select('geometry, layer_name')
                        .eq('id', parcelId)
                        .single();

                    if (error) throw error;

                    if (!data || !data.geometry) {
                        showToast('Polygon geometry not found', 'error');
                        return;
                    }

                    // Parse geometry and zoom to it
                    const format = new ol.format.GeoJSON();
                    const feature = format.readFeature({
                        type: 'Feature',
                        geometry: data.geometry
                    }, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: 'EPSG:3857'
                    });

                    const extent = feature.getGeometry().getExtent();
                    if (extent && extent[0] !== Infinity) {
                        map.getView().fit(extent, { padding: [100, 100, 100, 100], maxZoom: 18 });

                        // Highlight the polygon temporarily
                        highlightParcelPolygon(feature, data.layer_name);

                        showToast(`Zoomed to parcel ${uniqueId}`, 'success');
                    }

                } catch (error) {
                    console.error('Error zooming to parcel:', error);
                    showToast('Error loading parcel: ' + error.message, 'error');
                }
            }

            // Highlight parcel polygon
            function highlightParcelPolygon(feature, layerName) {
                if (parcelHighlightLayer) {
                    map.removeLayer(parcelHighlightLayer);
                }

                const source = new ol.source.Vector({
                    features: [feature]
                });

                parcelHighlightLayer = new ol.layer.Vector({
                    source: source,
                    zIndex: 2000,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#f39c12',
                            width: 4
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(243, 156, 18, 0.2)'
                        })
                    })
                });

                map.addLayer(parcelHighlightLayer);

                // Remove highlight after 5 seconds
                setTimeout(() => {
                    if (parcelHighlightLayer) {
                        map.removeLayer(parcelHighlightLayer);
                        parcelHighlightLayer = null;
                    }
                }, 5000);
            }

            // Tab switching functionality
            document.querySelectorAll('.coord-search-tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    const targetTab = this.getAttribute('data-tab');

                    // Update active tab
                    document.querySelectorAll('.coord-search-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');

                    // Show target content
                    document.querySelectorAll('.coord-search-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(targetTab + '-tab').classList.add('active');
                });
            });

            // Manual coordinate plotting
            document.getElementById('plotCoordBtn').addEventListener('click', function () {
                const x = document.getElementById('coordX').value.trim();
                const y = document.getElementById('coordY').value.trim();
                const crs = document.getElementById('coordCrs').value;

                if (!x || !y || isNaN(x) || isNaN(y)) {
                    alert('Please enter valid numeric values for both coordinates.');
                    return;
                }

                try {
                    // Transform to Web Mercator
                    const coord = ol.proj.transform([parseFloat(x), parseFloat(y)], crs, 'EPSG:3857');

                    // Clear previous markers
                    markerSource.clear();

                    // Add marker
                    const marker = new ol.Feature({
                        geometry: new ol.geom.Point(coord),
                        type: 'coordinate',
                        label: `${crs}: ${x}, ${y}`
                    });
                    markerSource.addFeature(marker);

                    // Zoom to location
                    view.animate({
                        center: coord,
                        zoom: 16,
                        duration: 1500
                    });

                    // Update results table
                    updateCoordResults([{ id: 1, x: x, y: y, crs: crs }]);

                    showToast(`Plotted coordinate: ${x}, ${y} (${crs})`, 'success');
                } catch (error) {
                    console.error('Error plotting coordinate:', error);
                    showToast('Error plotting coordinate. Please check your input.', 'error');
                }
            });

            // CSV file handling
            const csvFileInput = document.getElementById('csvFileInput');
            const csvBrowseBtn = document.getElementById('csvBrowseBtn');
            const csvDropArea = document.getElementById('csvDropArea');
            const plotCsvBtn = document.getElementById('plotCsvBtn');
            const csvWarning = document.getElementById('csvWarning');
            const csvContinueBtn = document.getElementById('csvContinueBtn');
            const csvCancelBtn = document.getElementById('csvCancelBtn');

            let csvData = null;
            let pendingCsvData = null;

            // Browse button
            csvBrowseBtn.addEventListener('click', function () {
                csvFileInput.click();
            });

            // File input change
            csvFileInput.addEventListener('change', function () {
                if (this.files.length > 0) {
                    handleCsvFile(this.files[0]);
                }
            });

            // Drag and drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                csvDropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                csvDropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                csvDropArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                csvDropArea.classList.add('dragover');
            }

            function unhighlight() {
                csvDropArea.classList.remove('dragover');
            }

            csvDropArea.addEventListener('drop', function (e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    handleCsvFile(files[0]);
                }
            });

            function handleCsvFile(file) {
                if (!file.name.endsWith('.csv')) {
                    alert('Please select a CSV file.');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        csvData = parseCsvData(e.target.result);
                        plotCsvBtn.disabled = false;
                        showToast('CSV file loaded successfully', 'success');
                    } catch (error) {
                        console.error('Error parsing CSV:', error);
                        showToast('Error parsing CSV file', 'error');
                    }
                };
                reader.readAsText(file);
            }

            function parseCsvData(csvText) {
                const lines = csvText.split('\n').filter(line => line.trim().length > 0);
                if (lines.length === 0) return [];

                const data = [];
                const hasHeader = lines[0].toLowerCase().includes('lon') || lines[0].toLowerCase().includes('lat') ||
                    lines[0].toLowerCase().includes('x') || lines[0].toLowerCase().includes('y');

                const startIndex = hasHeader ? 1 : 0;

                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(',').map(p => p.trim().replace(/"/g, ''));
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            data.push({
                                id: data.length + 1,
                                x: x,
                                y: y,
                                description: parts[2] || ''
                            });
                        }
                    }
                }

                return data;
            }

            // Plot CSV coordinates
            plotCsvBtn.addEventListener('click', function () {
                if (!csvData || csvData.length === 0) {
                    alert('Please load a CSV file first.');
                    return;
                }

                const crs = document.getElementById('csvCrs').value;

                // Check Uganda bounds
                const outOfBounds = csvData.filter(point => {
                    try {
                        const coord = ol.proj.transform([point.x, point.y], crs, 'EPSG:4326');
                        const lon = coord[0];
                        const lat = coord[1];
                        return lon < 28 || lon > 36 || lat < -3 || lat > 5;
                    } catch (e) {
                        return false;
                    }
                });

                if (outOfBounds.length > csvData.length * 0.5) {
                    // Show warning
                    pendingCsvData = { data: csvData, crs: crs };
                    csvWarning.classList.add('show');
                    return;
                }

                plotCsvCoordinates(csvData, crs);
            });

            // Warning buttons
            csvContinueBtn.addEventListener('click', function () {
                if (pendingCsvData) {
                    plotCsvCoordinates(pendingCsvData.data, pendingCsvData.crs);
                    pendingCsvData = null;
                }
                csvWarning.classList.remove('show');
            });

            csvCancelBtn.addEventListener('click', function () {
                pendingCsvData = null;
                csvWarning.classList.remove('show');
            });

            function plotCsvCoordinates(data, crs) {
                try {
                    // Clear previous markers
                    markerSource.clear();

                    const features = [];
                    let outOfBoundsCount = 0;

                    data.forEach(point => {
                        try {
                            // Transform to Web Mercator
                            const coord = ol.proj.transform([point.x, point.y], crs, 'EPSG:3857');

                            // Check bounds
                            const lonLat = ol.proj.transform(coord, 'EPSG:3857', 'EPSG:4326');
                            if (lonLat[0] < 28 || lonLat[0] > 36 || lonLat[1] < -3 || lonLat[1] > 5) {
                                outOfBoundsCount++;
                            }

                            const feature = new ol.Feature({
                                geometry: new ol.geom.Point(coord),
                                type: 'coordinate',
                                label: point.description || `Point ${point.id}`,
                                description: point.description || ''
                            });

                            features.push(feature);
                            markerSource.addFeature(feature);
                        } catch (error) {
                            console.warn('Error processing point:', point, error);
                        }
                    });

                    if (features.length > 0) {
                        // Zoom to extent
                        const extent = markerSource.getExtent();
                        view.fit(extent, { padding: [50, 50, 50, 50], maxZoom: 16 });

                        // Update results
                        updateCoordResults(data.map(p => ({ ...p, crs: crs })));

                        const message = `Plotted ${features.length} coordinates (${outOfBoundsCount} outside Uganda bounds)`;
                        showToast(message, 'success');
                    } else {
                        showToast('No valid coordinates could be plotted', 'error');
                    }
                } catch (error) {
                    console.error('Error plotting CSV coordinates:', error);
                    showToast('Error plotting CSV coordinates', 'error');
                }
            }

            function updateCoordResults(data) {
                const resultsDiv = document.getElementById('coordResults');
                const statsDiv = document.getElementById('coordStats');
                const tableBody = document.getElementById('coordTableBody');

                // Update stats
                statsDiv.textContent = `Total points: ${data.length}`;

                // Update table
                tableBody.innerHTML = '';
                data.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                    <td>${point.id}</td>
                    <td>${point.x}</td>
                    <td>${point.y}</td>
                    <td>${point.lat || ''}</td>
                    <td>${point.lon || ''}</td>
                `;
                    tableBody.appendChild(row);
                });

                resultsDiv.classList.add('show');
            }

            // Clear results
            document.getElementById('clearResultsBtn').addEventListener('click', function () {
                markerSource.clear();
                document.getElementById('coordResults').classList.remove('show');
                showToast('Results cleared', 'info');
            });


            // User location functionality with improved permissions handling
            document.getElementById('locateBtn').addEventListener('click', function () {
                if (!navigator.geolocation) {
                    alert('Geolocation is not supported by your browser');
                    showToast('Geolocation is not supported by your browser', 'error');
                    return;
                }

                // Check if we have permission
                if (navigator.permissions) {
                    navigator.permissions.query({ name: 'geolocation' }).then(function (result) {
                        if (result.state === 'denied') {
                            showToast('Geolocation access denied. Please enable location access in your browser settings.', 'error', 8000);
                            return;
                        }
                        attemptGeolocation();
                    }).catch(function (error) {
                        console.warn('Permissions API not fully supported, attempting geolocation anyway');
                        attemptGeolocation();
                    });
                } else {
                    attemptGeolocation();
                }
            });

            // Add high accuracy location button (right-click on locate button for this)
            document.getElementById('locateBtn').addEventListener('contextmenu', function (e) {
                e.preventDefault();
                if (!navigator.geolocation) {
                    alert('Geolocation is not supported by your browser');
                    showToast('Geolocation is not supported by your browser', 'error');
                    return;
                }

                showToast('Starting high accuracy location tracking...', 'info', 3000);
                attemptHighAccuracyGeolocation();
            });

            function attemptHighAccuracyGeolocation() {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 60000,  // 60 seconds for maximum accuracy
                    maximumAge: 0
                };

                // Use watchPosition for continuous updates and better accuracy
                const watchId = navigator.geolocation.watchPosition(
                    function (position) {
                        const lon = position.coords.longitude;
                        const lat = position.coords.latitude;
                        const accuracy = position.coords.accuracy;

                        console.log('High accuracy location update:', { lon, lat, accuracy });

                        // Process the location
                        processHighAccuracyLocation(position);

                        // Stop watching after getting a good position
                        if (accuracy <= 20) {
                            navigator.geolocation.clearWatch(watchId);
                            showToast('High accuracy location obtained!', 'success');
                        }
                    },
                    function (error) {
                        console.error('High accuracy geolocation error:', error);
                        navigator.geolocation.clearWatch(watchId);

                        let errorMessage = 'High accuracy location failed: ';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Location access denied.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out.';
                                break;
                            default:
                                errorMessage += 'Unknown error occurred.';
                                break;
                        }
                        showToast(errorMessage, 'error', 8000);
                    },
                    options
                );

                // Stop watching after 60 seconds
                setTimeout(() => {
                    navigator.geolocation.clearWatch(watchId);
                }, 60000);
            }

            function processHighAccuracyLocation(position) {
                const lon = position.coords.longitude;
                const lat = position.coords.latitude;
                const accuracy = position.coords.accuracy;

                const coord = ol.proj.fromLonLat([lon, lat]);

                // Clear previous markers
                markerSource.clear();

                // Add user location marker with accuracy circle
                const marker = new ol.Feature({
                    geometry: new ol.geom.Point(coord),
                    type: 'user'
                });
                markerSource.addFeature(marker);

                // Add accuracy circle
                if (accuracy) {
                    const accuracyCircle = new ol.Feature({
                        geometry: new ol.geom.Circle(coord, accuracy),
                        type: 'accuracy'
                    });
                    markerSource.addFeature(accuracyCircle);
                }

                // Zoom to location
                view.animate({
                    center: coord,
                    zoom: 17,  // Higher zoom for high accuracy
                    duration: 1000
                });
            }

            function attemptGeolocation() {
                showToast('Requesting your precise location...', 'info', 3000);

                // Enhanced geolocation with maximum accuracy settings
                const options = {
                    enableHighAccuracy: true,    // Use GPS if available
                    timeout: 30000,             // Increased timeout to 30 seconds for better accuracy
                    maximumAge: 0               // Don't use cached location
                };

                // Try multiple attempts for better accuracy
                let attempts = 0;
                const maxAttempts = 3;
                let bestPosition = null;
                let bestAccuracy = Infinity;

                function tryGeolocation() {
                    attempts++;
                    showToast(`Attempting to get your location (${attempts}/${maxAttempts})...`, 'info', 2000);

                    navigator.geolocation.getCurrentPosition(function (position) {
                        const lon = position.coords.longitude;
                        const lat = position.coords.latitude;
                        const accuracy = position.coords.accuracy;

                        console.log(`Location attempt ${attempts}:`, { lon, lat, accuracy });

                        // Keep track of the best position
                        if (accuracy < bestAccuracy) {
                            bestPosition = position;
                            bestAccuracy = accuracy;
                        }

                        // If accuracy is very good (under 10 meters), use it immediately
                        if (accuracy <= 10) {
                            processLocation(position);
                            return;
                        }

                        // If this is the last attempt or accuracy is acceptable, use the best position
                        if (attempts >= maxAttempts || accuracy <= 50) {
                            if (bestPosition) {
                                processLocation(bestPosition);
                            } else {
                                processLocation(position);
                            }
                            return;
                        }

                        // Try again with a longer timeout
                        setTimeout(() => {
                            tryGeolocation();
                        }, 2000);

                    }, function (error) {
                        console.error(`Geolocation error (attempt ${attempts}):`, error);

                        // If this is the last attempt, show error
                        if (attempts >= maxAttempts) {
                            let errorMessage = 'Unable to retrieve your location: ';
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMessage += 'Location access denied. Please enable location access in your browser settings and try again.';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMessage += 'Location information is unavailable. Please check your GPS/network connection.';
                                    break;
                                case error.TIMEOUT:
                                    errorMessage += 'Location request timed out. Please try again.';
                                    break;
                                default:
                                    errorMessage += 'Unknown error occurred.';
                                    break;
                            }
                            showToast(errorMessage, 'error', 8000);
                            return;
                        }

                        // Try again after a short delay
                        setTimeout(() => {
                            tryGeolocation();
                        }, 3000);
                    }, options);
                }

                function processLocation(position) {
                    const lon = position.coords.longitude;
                    const lat = position.coords.latitude;
                    const accuracy = position.coords.accuracy;

                    console.log('Final location obtained:', { lon, lat, accuracy });

                    // Check if accuracy is reasonable
                    let accuracyMessage = '';
                    if (accuracy <= 10) {
                        accuracyMessage = ' (Very High Accuracy)';
                    } else if (accuracy <= 50) {
                        accuracyMessage = ' (High Accuracy)';
                    } else if (accuracy <= 100) {
                        accuracyMessage = ' (Good Accuracy)';
                    } else {
                        accuracyMessage = ` (Accuracy: ${Math.round(accuracy)}m - May not be precise)`;
                    }

                    const coord = ol.proj.fromLonLat([lon, lat]);

                    // Clear previous markers
                    markerSource.clear();

                    // Add user location marker with accuracy circle
                    const marker = new ol.Feature({
                        geometry: new ol.geom.Point(coord),
                        type: 'user'
                    });
                    markerSource.addFeature(marker);

                    // Add accuracy circle if accuracy is available
                    if (accuracy) {
                        const accuracyCircle = new ol.Feature({
                            geometry: new ol.geom.Circle(coord, accuracy),
                            type: 'accuracy'
                        });
                        markerSource.addFeature(accuracyCircle);
                    }

                    // Zoom to location with appropriate zoom level based on accuracy
                    let zoomLevel = 16;
                    if (accuracy > 100) zoomLevel = 14;
                    else if (accuracy > 50) zoomLevel = 15;

                    view.animate({
                        center: coord,
                        zoom: zoomLevel,
                        duration: 1500
                    });

                    showToast(`Your location has been marked on the map${accuracyMessage}`, 'success');
                }

                // Start the geolocation attempts
                tryGeolocation();
            }

            // Full screen functionality
            document.getElementById('fullScreenBtn').addEventListener('click', function () {
                const mapElement = document.getElementById('map');

                if (!document.fullscreenElement) {
                    if (mapElement.requestFullscreen) {
                        mapElement.requestFullscreen();
                    } else if (mapElement.mozRequestFullScreen) {
                        mapElement.mozRequestFullScreen();
                    } else if (mapElement.webkitRequestFullscreen) {
                        mapElement.webkitRequestFullscreen();
                    } else if (mapElement.msRequestFullscreen) {
                        mapElement.msRequestFullscreen();
                    }
                    showToast('Full screen mode enabled', 'info');
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                    showToast('Full screen mode disabled', 'info');
                }
            });

            // Feature info functionality
            const featureInfo = document.getElementById('featureInfo');
            const featureInfoContent = document.getElementById('featureInfoContent');
            const closeFeatureInfo = document.getElementById('closeFeatureInfo');

            // Ensure feature info panel is hidden by default
            featureInfo.style.display = 'none';

            document.getElementById('infoBtn').addEventListener('click', function () {
                const infoActive = featureInfo.style.display === 'block';
                if (infoActive) {
                    featureInfo.style.display = 'none';
                    this.classList.remove('active');
                } else {
                    featureInfo.style.display = 'block';
                    this.classList.add('active');
                    featureInfoContent.innerHTML = '<p>Click on a feature to get information about it.<br><small>Supports: Survey Polygons and GSPNET LAYERS (FlatGeobuf)</small></p>';
                }
            });

            closeFeatureInfo.addEventListener('click', function () {
                featureInfo.style.display = 'none';
                document.getElementById('infoBtn').classList.remove('active');
            });


            // ========================================
            // PROJECT INFORMATION MODAL FUNCTIONALITY
            // ========================================

            // Global state for current terrain project
            let currentTerrainProject = null;
            const TERRAIN_PROJECT_STORAGE_KEY = 'lastTerrainProject';

            // Show project information modal
            function showTerrainProjectModal() {
                const modal = document.getElementById('terrainProjectModal');
                if (!modal) {
                    console.error('Project modal not found');
                    return;
                }

                // Populate districts dropdown
                populateTerrainProjectDistricts();

                // Load last used values from localStorage
                loadLastTerrainProject();

                modal.classList.add('show');
            }

            // Hide project information modal
            function hideTerrainProjectModal() {
                const modal = document.getElementById('terrainProjectModal');
                if (modal) {
                    modal.classList.remove('show');
                }
            }

            // Populate districts dropdown for project modal
            async function populateTerrainProjectDistricts() {
                const districtSelect = document.getElementById('terrainProjectDistrict');
                if (!districtSelect) return;

                // Clear existing options except the first one
                while (districtSelect.children.length > 1) {
                    districtSelect.removeChild(districtSelect.lastChild);
                }

                // Use UGANDA_DISTRICTS if available (complete list of all districts)
                if (typeof window !== 'undefined' && typeof window.UGANDA_DISTRICTS !== 'undefined' && Array.isArray(window.UGANDA_DISTRICTS)) {
                    window.UGANDA_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        districtSelect.appendChild(option);
                    });
                    return;
                }

                // Fallback: Try to get districts from database, then use common districts if that fails
                try {
                    const { data: projects, error } = await supabase
                        .from('project_files')
                        .select('district')
                        .not('district', 'is', null)
                        .limit(1000);

                    if (!error && projects && projects.length > 0) {
                        const uniqueDistricts = [...new Set(projects.map(p => p.district).filter(Boolean))].sort();
                        uniqueDistricts.forEach(district => {
                            const option = document.createElement('option');
                            option.value = district;
                            option.textContent = district;
                            districtSelect.appendChild(option);
                        });
                        return;
                    }
                } catch (error) {
                    console.warn('Error loading districts from database:', error);
                }

                // Final fallback: common Uganda districts
                const commonDistricts = [
                    'Kampala', 'Wakiso', 'Mukono', 'Jinja', 'Mbale', 'Gulu',
                    'Lira', 'Arua', 'Mbarara', 'Masaka', 'Fort Portal', 'Hoima'
                ];
                commonDistricts.forEach(district => {
                    const option = document.createElement('option');
                    option.value = district;
                    option.textContent = district;
                    districtSelect.appendChild(option);
                });
            }

            // Load last used project values from localStorage
            function loadLastTerrainProject() {
                try {
                    const saved = localStorage.getItem(TERRAIN_PROJECT_STORAGE_KEY);
                    if (saved) {
                        const projectData = JSON.parse(saved);
                        document.getElementById('terrainProjectClient').value = projectData.client || '';
                        document.getElementById('terrainProjectName').value = projectData.project_name || '';
                        document.getElementById('terrainProjectCRS').value = projectData.coordinate_system || '';
                        document.getElementById('terrainProjectDistrict').value = projectData.district || '';
                        document.getElementById('terrainProjectSurveyor').value = projectData.surveyor || '';
                        document.getElementById('terrainProjectSupervisor').value = projectData.supervisor || '';
                    }
                } catch (error) {
                    console.warn('Error loading last project from localStorage:', error);
                }
            }

            // Save project values to localStorage
            function saveLastTerrainProject(projectData) {
                try {
                    localStorage.setItem(TERRAIN_PROJECT_STORAGE_KEY, JSON.stringify(projectData));
                } catch (error) {
                    console.warn('Error saving project to localStorage:', error);
                }
            }

            // Save project to Supabase
            async function saveTerrainProject(projectData) {
                try {
                    const user = await supabase.auth.getUser();
                    if (!user?.data?.user) {
                        throw new Error('User not authenticated');
                    }

                    const { data, error } = await supabase
                        .from('terrain_projects')
                        .insert([{
                            ...projectData,
                            created_by: user.data.user.id
                        }])
                        .select()
                        .single();

                    if (error) {
                        // If duplicate project name, try to update instead
                        if (error.code === '23505') { // Unique violation
                            const { data: updated, error: updateError } = await supabase
                                .from('terrain_projects')
                                .update(projectData)
                                .eq('project_name', projectData.project_name)
                                .eq('created_by', user.data.user.id)
                                .select()
                                .single();

                            if (updateError) throw updateError;
                            return updated;
                        }
                        throw error;
                    }

                    return data;
                } catch (error) {
                    console.error('Error saving terrain project:', error);
                    throw error;
                }
            }

            // Modal close handlers
            document.getElementById('terrainProjectModalClose')?.addEventListener('click', hideTerrainProjectModal);
            document.getElementById('terrainProjectCancel')?.addEventListener('click', hideTerrainProjectModal);

            // Close modal when clicking outside
            document.getElementById('terrainProjectModal')?.addEventListener('click', function (e) {
                if (e.target === this) {
                    hideTerrainProjectModal();
                }
            });

            // Form submission handler
            document.getElementById('terrainProjectForm')?.addEventListener('submit', async function (e) {
                e.preventDefault();

                const projectData = {
                    client: document.getElementById('terrainProjectClient').value.trim(),
                    project_name: document.getElementById('terrainProjectName').value.trim(),
                    coordinate_system: document.getElementById('terrainProjectCRS').value,
                    district: document.getElementById('terrainProjectDistrict').value,
                    surveyor: document.getElementById('terrainProjectSurveyor').value.trim(),
                    supervisor: document.getElementById('terrainProjectSupervisor').value.trim()
                };

                // Validate
                if (!projectData.client || !projectData.project_name || !projectData.coordinate_system ||
                    !projectData.district || !projectData.surveyor || !projectData.supervisor) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Saving project information...');

                    // Save to Supabase
                    const savedProject = await saveTerrainProject(projectData);
                    currentTerrainProject = savedProject;

                    // Save to localStorage for next time
                    saveLastTerrainProject(projectData);

                    // Close modal and open terrain dock
                    hideTerrainProjectModal();

                    // Open terrain dock
                    const terrainDock = document.getElementById('terrain-3d-dock');
                    const terrainToggle = document.getElementById('terrainToggle');
                    if (terrainDock && terrainToggle) {
                        terrainDock.classList.add('active');
                        terrainToggle.classList.add('active');

                        // Close other panels if open
                        const gspnetUpdatesDock = document.getElementById('gspnet-updates-dock');
                        const projectLibraryPanel = document.getElementById('projectLibraryPanel');
                        if (gspnetUpdatesDock) {
                            gspnetUpdatesDock.style.display = 'none';
                        }
                        if (projectLibraryPanel) {
                            projectLibraryPanel.classList.remove('active');
                            const mainContent = document.querySelector('.main-content');
                            if (mainContent) mainContent.classList.remove('panel-open');
                        }

                        // Initialize districts dropdown if not already done
                        initializeTerrainDistricts();

                        showToast('Project information saved', 'success');
                    }
                } catch (error) {
                    console.error('Error saving project:', error);
                    showToast('Error saving project: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    hideLoadingIndicator();
                }
            });

            // ========================================
            // 3D TERRAIN DTM & CONTOURS DOCK FUNCTIONALITY
            // ========================================

            const terrainDock = document.getElementById('terrain-3d-dock');
            const terrainDockClose = document.getElementById('terrain-3d-close');
            const terrainToggle = document.getElementById('terrainToggle');

            // Terrain button click - show project modal first, then open dock
            terrainToggle.addEventListener('click', function () {
                if (terrainDock.classList.contains('active')) {
                    terrainDock.classList.remove('active');
                    terrainToggle.classList.remove('active');
                } else {
                    // Check if we have a current project
                    if (!currentTerrainProject) {
                        // Show project modal first
                        showTerrainProjectModal();
                    } else {
                        // Open dock directly if project exists
                        terrainDock.classList.add('active');
                        terrainToggle.classList.add('active');

                        // Close other panels if open
                        const gspnetUpdatesDock = document.getElementById('gspnet-updates-dock');
                        const projectLibraryPanel = document.getElementById('projectLibraryPanel');
                        if (gspnetUpdatesDock) {
                            gspnetUpdatesDock.style.display = 'none';
                        }
                        if (projectLibraryPanel) {
                            projectLibraryPanel.classList.remove('active');
                            const mainContent = document.querySelector('.main-content');
                            if (mainContent) mainContent.classList.remove('panel-open');
                        }

                        // Initialize districts dropdown if not already done
                        initializeTerrainDistricts();

                        showToast('3D Terrain panel opened', 'info');
                    }
                }
            });

            // Close button handler
            if (terrainDockClose) {
                terrainDockClose.addEventListener('click', function () {
                    terrainDock.classList.remove('active');
                    terrainToggle.classList.remove('active');
                });
            }

            // ========================================
            // PROFILE PANEL EVENT HANDLERS
            // ========================================

            // Profile panel toggle
            document.getElementById('generateProfileBtn')?.addEventListener('click', function () {
                const profilePanel = document.getElementById('profile-generation-panel');
                if (profilePanel.classList.contains('active')) {
                    profilePanel.classList.remove('active');
                } else {
                    profilePanel.classList.add('active');
                    // Close other panels
                    document.getElementById('terrain-3d-dock')?.classList.remove('active');
                    document.getElementById('gspnet-updates-dock')?.classList.remove('active');
                    const projLib = document.getElementById('projectLibraryPanel');
                    if (projLib) projLib.style.display = 'none';
                }
            });

            // Profile panel close
            document.getElementById('profile-panel-close')?.addEventListener('click', function () {
                document.getElementById('profile-generation-panel')?.classList.remove('active');
            });

            // Start drawing alignment
            document.getElementById('startDrawingBtn')?.addEventListener('click', function () {
                startProfileDrawing();
            });

            // Clear alignment
            document.getElementById('clearAlignmentBtn')?.addEventListener('click', function () {
                if (confirm('Clear current alignment?')) {
                    clearAlignment();
                }
            });

            // Enable design grade toggle
            document.getElementById('enableDesignGrade')?.addEventListener('change', function () {
                const designInputs = document.getElementById('designGradeInputs');
                profileState.enableDesignGrade = this.checked;
                designInputs.style.display = this.checked ? 'block' : 'none';
            });

            // Enable cross sections toggle
            document.getElementById('enableCrossSections')?.addEventListener('change', function () {
                const crossSectionInputs = document.getElementById('crossSectionInputs');
                profileState.enableCrossSections = this.checked;
                crossSectionInputs.style.display = this.checked ? 'block' : 'none';
            });

            document.getElementById('crossSectionInterval')?.addEventListener('change', function () {
                profileState.crossSectionInterval = parseFloat(this.value) || 50;
            });

            document.getElementById('crossSectionWidth')?.addEventListener('change', function () {
                profileState.crossSectionWidth = parseFloat(this.value) || 30;
            });

            // Update profile state from inputs
            document.getElementById('samplingInterval')?.addEventListener('change', function () {
                profileState.samplingInterval = parseFloat(this.value) || 10;
            });

            document.getElementById('stationInterval')?.addEventListener('change', function () {
                profileState.stationInterval = parseFloat(this.value) || 50;
            });

            document.getElementById('designGrade')?.addEventListener('change', function () {
                profileState.designGrade = parseFloat(this.value) / 100;
            });

            document.getElementById('designStartElevation')?.addEventListener('change', function () {
                profileState.designStartElevation = parseFloat(this.value);
            });

            document.getElementById('sideSlope')?.addEventListener('change', function () {
                profileState.sideSlope = parseFloat(this.value) || 2;
            });

            document.getElementById('roadWidth')?.addEventListener('change', function () {
                profileState.roadWidth = parseFloat(this.value) || 6;
            });

            // Generate profile button
            document.getElementById('generateProfileDataBtn')?.addEventListener('click', async function () {
                await generateProfileFromAlignment();
            });

            // Export buttons
            document.getElementById('exportCSVBtn')?.addEventListener('click', function () {
                exportProfileCSV();
            });

            document.getElementById('exportPDFBtn')?.addEventListener('click', function () {
                exportProfilePDF();
            });

            document.getElementById('exportDXFBtn')?.addEventListener('click', function () {
                exportProfileDXF();
            });

            // ========================================
            // 3D TERRAIN DTM CORE FUNCTIONS
            // ========================================

            // A. CSV PARSING & VALIDATION FUNCTIONS

            function parseCSVFile(file, coordinateSystem) {
                return new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function (results) {
                            try {
                                if (!results.data || results.data.length === 0) {
                                    reject(new Error('CSV file is empty'));
                                    return;
                                }

                                const validatedData = validateCSVStructure(results.data);

                                resolve({
                                    data: validatedData,
                                    coordinateSystem: coordinateSystem,
                                    count: validatedData.length,
                                    fileName: file.name
                                });
                            } catch (error) {
                                reject(error);
                            }
                        },
                        error: function (error) {
                            reject(new Error('Failed to parse CSV: ' + error.message));
                        }
                    });
                });
            }

            function validateCSVStructure(data) {
                // Check for required columns (case-insensitive)
                const firstRow = data[0];
                const keys = Object.keys(firstRow).map(k => k.toLowerCase());

                const hasEasting = keys.some(k => k.includes('easting') || k === 'x' || k === 'e');
                const hasNorthing = keys.some(k => k.includes('northing') || k === 'y' || k === 'n');
                const hasElevation = keys.some(k => k.includes('z') || k.includes('elevation') || k.includes('height'));

                if (!hasEasting || !hasNorthing || !hasElevation) {
                    throw new Error('CSV must contain columns for Easting, Northing, and Z/Elevation');
                }

                // Map and validate data
                const validatedData = [];
                data.forEach((row, index) => {
                    const rowData = {};

                    // Find easting value
                    for (const key of Object.keys(row)) {
                        const lowerKey = key.toLowerCase();
                        if (lowerKey.includes('easting') || lowerKey === 'x' || lowerKey === 'e') {
                            rowData.easting = parseFloat(row[key]);
                        } else if (lowerKey.includes('northing') || lowerKey === 'y' || lowerKey === 'n') {
                            rowData.northing = parseFloat(row[key]);
                        } else if (lowerKey.includes('z') || lowerKey.includes('elevation') || lowerKey.includes('height')) {
                            rowData.elevation = parseFloat(row[key]);
                        } else if (lowerKey.includes('point') || lowerKey === 'id' || lowerKey === 'name') {
                            rowData.point = row[key];
                        } else if (lowerKey.includes('description') || lowerKey.includes('desc') || lowerKey === 'remarks') {
                            rowData.description = row[key];
                        }
                    }

                    // Validate that we have valid numbers
                    if (isNaN(rowData.easting) || isNaN(rowData.northing) || isNaN(rowData.elevation)) {
                        console.warn(`Skipping row ${index + 1}: Invalid numeric values`);
                        return;
                    }

                    // Set defaults
                    if (!rowData.point) rowData.point = `Point ${index + 1}`;
                    if (!rowData.description) rowData.description = '';

                    validatedData.push(rowData);
                });

                if (validatedData.length === 0) {
                    throw new Error('No valid data rows found in CSV');
                }

                return validatedData;
            }

            function transformCoordinates(data, sourceEPSG, targetEPSG = 'EPSG:3857') {
                return data.map(point => {
                    try {
                        const transformed = ol.proj.transform(
                            [point.easting, point.northing],
                            sourceEPSG,
                            targetEPSG
                        );
                        return {
                            ...point,
                            x: transformed[0],
                            y: transformed[1]
                        };
                    } catch (error) {
                        console.error('Coordinate transformation error:', error);
                        return null;
                    }
                }).filter(p => p !== null);
            }

            // B. SEARCH & FETCH EXISTING DATA FUNCTIONS

            async function searchExistingTerrainData(filters) {
                try {
                    const user = await supabase.auth.getUser();
                    if (!user?.data?.user) {
                        throw new Error('User not authenticated');
                    }

                    const results = [];

                    // 1. First, load merged datasets (priority)
                    let mergedQuery = supabase
                        .from('merged_csv_datasets')
                        .select('*')
                        .eq('created_by', user.data.user.id)
                        .order('last_merged_at', { ascending: false });

                    // Filter by coordinate system if specified in filters
                    if (filters.coordinateSystem) {
                        mergedQuery = mergedQuery.eq('coordinate_system', filters.coordinateSystem);
                    }

                    const { data: mergedDatasets, error: mergedError } = await mergedQuery;

                    if (!mergedError && mergedDatasets) {
                        mergedDatasets.forEach(dataset => {
                            results.push({
                                ...dataset,
                                isMerged: true,
                                type: 'merged',
                                project_name: dataset.dataset_name,
                                number_of_points: dataset.total_points,
                                uploaded_at: dataset.last_merged_at
                            });
                        });
                    }

                    // 2. Then load individual CSVs
                    let query = supabase
                        .from('project_files')
                        .select('*')
                        .eq('file_type', 'csv')
                        .in('nature', ['control_points', 'other'])
                        .eq('uploaded_by', user.data.user.id);

                    if (filters.district) {
                        query = query.eq('district', filters.district);
                    }
                    if (filters.nature) {
                        query = query.eq('nature', filters.nature);
                    }
                    if (filters.projectName) {
                        query = query.ilike('project_name', `%${filters.projectName}%`);
                    }
                    if (filters.surveyor) {
                        query = query.ilike('surveyor', `%${filters.surveyor}%`);
                    }
                    if (filters.dateFrom) {
                        query = query.gte('uploaded_at', filters.dateFrom);
                    }
                    if (filters.dateTo) {
                        query = query.lte('uploaded_at', filters.dateTo);
                    }

                    query = query.order('uploaded_at', { ascending: false }).limit(100);

                    const { data: individualCsvs, error: csvError } = await query;

                    if (!csvError && individualCsvs) {
                        individualCsvs.forEach(csv => {
                            results.push({
                                ...csv,
                                isMerged: false,
                                type: 'individual'
                            });
                        });
                    }

                    if (mergedError || csvError) {
                        throw mergedError || csvError;
                    }

                    return results;
                } catch (error) {
                    console.error('Search error:', error);
                    throw error;
                }
            }

            async function fetchCSVFromSupabase(fileUrl) {
                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) {
                        throw new Error('Failed to fetch CSV file');
                    }
                    const csvText = await response.text();
                    const blob = new Blob([csvText], { type: 'text/csv' });
                    const file = new File([blob], 'existing_data.csv', { type: 'text/csv' });
                    return file;
                } catch (error) {
                    console.error('Fetch CSV error:', error);
                    throw error;
                }
            }

            function displayAvailableDatasets(datasets) {
                const container = document.getElementById('datasetsList');
                const countSpan = document.getElementById('datasetsCount');

                countSpan.textContent = `(${datasets.length})`;

                if (datasets.length === 0) {
                    container.innerHTML = '<p class="no-results">No datasets found matching your criteria</p>';
                    return;
                }

                container.innerHTML = '';

                datasets.forEach((dataset, index) => {
                    const item = document.createElement('div');
                    item.className = 'dataset-item';
                    if (dataset.isMerged) {
                        item.classList.add('merged-dataset');
                    }
                    item.dataset.datasetId = dataset.id;

                    const pointCount = dataset.number_of_points || 'N/A';
                    const uploadDate = new Date(dataset.uploaded_at).toLocaleDateString();
                    const mergedBadge = dataset.isMerged ? '<span class="merged-badge">MERGED</span>' : '';

                    item.innerHTML = `
                    <input type="checkbox" class="dataset-checkbox" data-dataset-id="${dataset.id}">
                    <div class="dataset-info">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <strong>${dataset.project_name || 'Unnamed Project'}</strong>
                            ${mergedBadge}
                        </div>
                        <small>${pointCount} points | ${dataset.coordinate_system || 'N/A'} | ${uploadDate}</small>
                        ${dataset.isMerged ? '<small style="color: #3498db;">Combined dataset from multiple sources</small>' : ''}
                    </div>
                `;

                    item.addEventListener('click', function (e) {
                        if (e.target.tagName !== 'INPUT') {
                            const checkbox = item.querySelector('.dataset-checkbox');
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });

                    const checkbox = item.querySelector('.dataset-checkbox');
                    checkbox.addEventListener('change', async function () {
                        if (this.checked) {
                            item.classList.add('selected');
                            try {
                                await loadExistingDatasetData(dataset, item);
                                addToSelectedDatasets(dataset);
                                refreshTerrainPointsLayer(true);
                            } catch (error) {
                                console.error('Failed to load dataset:', error);
                                showToast('Failed to load dataset: ' + error.message, 'error');
                                this.checked = false;
                                item.classList.remove('selected');
                            }
                        } else {
                            item.classList.remove('selected');
                            removeFromSelectedDatasets(dataset.id);
                            refreshTerrainPointsLayer(false);
                        }
                    });

                    container.appendChild(item);
                });
            }

            function plotDatasetPinsOnMap(datasets) {
                // This will be implemented with proper pin layer
                // For now, just log
                console.log('Plot pins for datasets:', datasets.length);
            }

            async function loadExistingDatasetData(dataset, listItem) {
                if (dataset.data && dataset.data.length) {
                    return dataset.data;
                }

                if (!dataset.file_path) {
                    throw new Error('Dataset is missing its file path. Please re-upload it in the library.');
                }

                const checkbox = listItem?.querySelector('.dataset-checkbox');
                listItem?.classList.add('loading');
                if (checkbox) checkbox.disabled = true;

                try {
                    // For merged datasets, download from storage
                    const { data: publicUrlData, error } = supabase
                        .storage
                        .from('uploads')
                        .getPublicUrl(dataset.file_path);

                    if (error) {
                        throw error;
                    }
                    if (!publicUrlData || !publicUrlData.publicUrl) {
                        throw new Error('Unable to generate a public download URL for this dataset.');
                    }

                    const targetCRS = (dataset.coordinate_system || terrain3DState.coordinateSystem || 'EPSG:32636').toUpperCase();

                    const importedCRS = terrain3DState.importedData.length > 0 ? terrain3DState.coordinateSystem : null;
                    if (importedCRS && importedCRS !== targetCRS) {
                        throw new Error(`Dataset uses ${targetCRS} but the imported CSV uses ${importedCRS}. Clear the CSV data or convert to a common CRS before combining.`);
                    }

                    const conflictingDataset = terrain3DState.selectedDatasets.find(d =>
                        d.coordinate_system && d.coordinate_system !== targetCRS
                    );
                    if (conflictingDataset) {
                        throw new Error(`Dataset uses ${targetCRS} but another selected dataset uses ${conflictingDataset.coordinate_system}. Deselect the other dataset or ensure they share the same CRS.`);
                    }

                    const file = await fetchCSVFromSupabase(publicUrlData.publicUrl);
                    const parsed = await parseCSVFile(file, targetCRS);

                    dataset.data = parsed.data;
                    dataset.coordinate_system = targetCRS;
                    dataset.loadedPointCount = parsed.count;

                    terrain3DState.coordinateSystem = targetCRS;
                    const crsSelect = document.getElementById('csvCoordinateSystem');
                    if (crsSelect) {
                        crsSelect.value = targetCRS;
                    }

                    showToast(`${dataset.project_name || 'Dataset'} loaded (${parsed.count} points)`, 'success');
                    return dataset.data;
                } finally {
                    if (checkbox) checkbox.disabled = false;
                    listItem?.classList.remove('loading');
                }
            }

            function addToSelectedDatasets(dataset) {
                if (!terrain3DState.selectedDatasets.find(d => d.id === dataset.id)) {
                    terrain3DState.selectedDatasets.push(dataset);
                }
            }

            function removeFromSelectedDatasets(datasetId) {
                terrain3DState.selectedDatasets = terrain3DState.selectedDatasets.filter(d => d.id !== datasetId);
            }

            // C. DATA COMBINATION FUNCTIONS

            function getCombinedData() {
                let combined = [];

                const dataSource = terrain3DState.dataSource;

                if (dataSource === 'import' || dataSource === 'both') {
                    if (terrain3DState.importedData && terrain3DState.importedData.length > 0) {
                        combined = combined.concat(terrain3DState.importedData);
                    }
                }

                if (dataSource === 'existing' || dataSource === 'both') {
                    const selected = terrain3DState.selectedDatasets || [];
                    if (selected.length > 0) {
                        selected.forEach(dataset => {
                            if (dataset.data && dataset.data.length) {
                                combined = combined.concat(dataset.data);
                            }
                        });
                    } else if (terrain3DState.existingDatasets && terrain3DState.existingDatasets.length > 0) {
                        // Fallback: include any datasets that already have data cached
                        terrain3DState.existingDatasets.forEach(dataset => {
                            if (dataset.data && dataset.data.length) {
                                combined = combined.concat(dataset.data);
                            }
                        });
                    }
                }

                // Filter by custom extent if enabled
                if (terrain3DState.useCustomExtent && terrain3DState.customExtent) {
                    const polygon = terrain3DState.customExtent.getGeometry();

                    // Transform combined data to map projection first
                    const transformedForFilter = transformCoordinates(
                        combined,
                        terrain3DState.coordinateSystem,
                        'EPSG:3857'
                    );

                    // Filter points that are inside the polygon
                    const filteredOriginal = combined.filter((point, idx) => {
                        const transformed = transformedForFilter[idx];
                        return polygon.intersectsCoordinate([transformed.x, transformed.y]);
                    });

                    console.log(`Filtered by extent: ${filteredOriginal.length} of ${combined.length} points inside`);
                    return filteredOriginal;
                }

                return combined;
            }

            function refreshTerrainPointsLayer(fitToView = false) {
                const combinedData = getCombinedData();

                if (!combinedData || combinedData.length === 0) {
                    if (terrain3DState.pointsLayer) {
                        map.removeLayer(terrain3DState.pointsLayer);
                        terrain3DState.pointsLayer = null;
                    }
                    return;
                }

                const layer = addPointsLayer(
                    combinedData,
                    terrain3DState.showPointNumbers,
                    terrain3DState.showDescriptions
                );

                if (fitToView && layer) {
                    const extent = layer.getSource().getExtent();
                    if (extent && isFinite(extent[0])) {
                        map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 800 });
                    }
                }
            }

            // Call terrain processor edge function
            async function callTerrainProcessor(action, params) {
                try {
                    // Add timeout to prevent hanging
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Request timeout after 60 seconds')), 60000)
                    );

                    const invokePromise = supabase.functions.invoke('terrain-processor', {
                        body: { action, ...params }
                    });

                    const { data, error } = await Promise.race([invokePromise, timeoutPromise]);

                    if (error) {
                        console.error(`Edge function error for ${action}:`, error);
                        // Don't throw - let caller handle fallback
                        return null;
                    }
                    return data;
                } catch (error) {
                    console.error(`Error calling terrain-processor (${action}):`, error);
                    console.error('Error details:', error.message, error.stack);
                    // Return null instead of throwing to allow fallback
                    return null;
                }
            }

            // Trigger CSV merge after upload
            async function triggerCSVMerge(newCsvId, projectData) {
                try {
                    const user = await supabase.auth.getUser();
                    if (!user?.data?.user) {
                        throw new Error('User not authenticated');
                    }

                    showLoadingIndicator('Merging with existing datasets...');

                    // Call edge function to merge CSVs
                    await callTerrainProcessor('merge-csvs', {
                        newCsvId: newCsvId,
                        coordinateSystem: projectData.coordinate_system,
                        userId: user.data.user.id
                    });

                    showToast('CSV merged with existing datasets', 'success');
                } catch (error) {
                    console.error('Error triggering CSV merge:', error);
                    showToast('Warning: CSV uploaded but merge failed: ' + (error.message || 'Unknown error'), 'warning');
                } finally {
                    hideLoadingIndicator();
                }
            }

            function calculateDataBounds(data) {
                if (!data || data.length === 0) {
                    return null;
                }

                const bounds = {
                    minX: Infinity,
                    maxX: -Infinity,
                    minY: Infinity,
                    maxY: -Infinity,
                    minZ: Infinity,
                    maxZ: -Infinity
                };

                data.forEach(point => {
                    const x = point.x !== undefined ? point.x : point.easting;
                    const y = point.y !== undefined ? point.y : point.northing;
                    const z = point.elevation;

                    if (x < bounds.minX) bounds.minX = x;
                    if (x > bounds.maxX) bounds.maxX = x;
                    if (y < bounds.minY) bounds.minY = y;
                    if (y > bounds.maxY) bounds.maxY = y;
                    if (z < bounds.minZ) bounds.minZ = z;
                    if (z > bounds.maxZ) bounds.maxZ = z;
                });

                return bounds;
            }

            // IDW RASTER GRID GENERATION FUNCTIONS

            function createRasterGrid(points, bounds, cellSize, options) {
                // ENHANCED: If using extent, expand bounds with buffer to ensure edge coverage
                let originalBounds = { ...bounds };
                let isUsingExtent = false;
                let extentPolygon = null;

                if (terrain3DState.useCustomExtent && terrain3DState.customExtent) {
                    isUsingExtent = true;
                    extentPolygon = terrain3DState.customExtent.getGeometry().clone();
                    const polygonExtent = extentPolygon.getExtent();

                    // Use polygon's rectangular extent with light buffer as raster envelope
                    const buffer = cellSize * 2;
                    bounds = {
                        minX: polygonExtent[0] - buffer,
                        maxX: polygonExtent[2] + buffer,
                        minY: polygonExtent[1] - buffer,
                        maxY: polygonExtent[3] + buffer,
                        minZ: bounds.minZ,
                        maxZ: bounds.maxZ
                    };

                    console.log(`Raster envelope buffer: ${buffer.toFixed(2)} meters around custom extent`);
                }

                const width = Math.ceil((bounds.maxX - bounds.minX) / cellSize);
                const height = Math.ceil((bounds.maxY - bounds.minY) / cellSize);

                const alignedMaxX = bounds.minX + width * cellSize;
                const alignedMaxY = bounds.minY + height * cellSize;
                if (alignedMaxX !== bounds.maxX || alignedMaxY !== bounds.maxY) {
                    console.log('Adjusting raster bounds to align with cell size',
                        `old maxX: ${bounds.maxX}, new maxX: ${alignedMaxX}`,
                        `old maxY: ${bounds.maxY}, new maxY: ${alignedMaxY}`);
                    bounds = {
                        ...bounds,
                        maxX: alignedMaxX,
                        maxY: alignedMaxY
                    };
                }

                const grid = [];
                const method = terrain3DState.interpolationMethod || 'idw';
                const power = options.idwPower || 2;
                const maxDistance = options.idwMaxDistance || 1000;

                updateLoadingProgress(`Creating ${width}x${height} elevation grid using ${method.toUpperCase()}...`);

                // Create elevation grid - interpolate ALL cells (even in buffer zone)
                for (let row = 0; row < height; row++) {
                    grid[row] = [];
                    for (let col = 0; col < width; col++) {
                        const x = bounds.minX + (col * cellSize) + (cellSize / 2);
                        const y = bounds.minY + (row * cellSize) + (cellSize / 2);

                        // ALWAYS interpolate - never skip cells
                        let elevation = null;

                        // Select interpolation method
                        if (method === 'tin') {
                            elevation = tinInterpolate(x, y, points);
                        } else if (method === 'idw-sharp') {
                            elevation = idwInterpolate(x, y, points, 4, maxDistance);
                        } else if (method === 'nearest') {
                            elevation = nearestNeighborInterpolate(x, y, points);
                        } else {
                            elevation = idwInterpolate(x, y, points, power, maxDistance);
                        }

                        grid[row][col] = elevation;
                    }

                    // Update progress periodically
                    if (row % 10 === 0) {
                        const progress = Math.round((row / height) * 100);
                        updateLoadingProgress(`Grid interpolation: ${progress}%`);
                    }
                }

                let gridData = {
                    grid,
                    width,
                    height,
                    cellSize,
                    bounds,
                    originalBounds: isUsingExtent ? originalBounds : bounds,
                    clipPolygon: extentPolygon // Store polygon for clipping at render time
                };

                // Apply breaklines if any exist
                if (terrain3DState.breaklines && terrain3DState.breaklines.length > 0) {
                    gridData = applyBreaklinesToGrid(gridData, terrain3DState.breaklines);
                }

                return gridData;
            }

            function idwInterpolate(x, y, points, power, maxDistance) {
                let numerator = 0;
                let denominator = 0;
                let exactMatch = null;

                for (const point of points) {
                    const dx = point.x - x;
                    const dy = point.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // If we're exactly at a point, return its elevation
                    if (distance < 0.001) {
                        exactMatch = point.elevation;
                        break;
                    }

                    // Skip points beyond max distance
                    if (distance > maxDistance) continue;

                    const weight = 1 / Math.pow(distance, power);
                    numerator += weight * point.elevation;
                    denominator += weight;
                }

                if (exactMatch !== null) return exactMatch;
                return denominator > 0 ? numerator / denominator : null;
            }

            // TIN (Triangulated Irregular Network) Interpolation - Sharp terrain representation
            function tinInterpolate(x, y, points) {
                // Find 3 nearest points to form a triangle
                const distances = points.map(p => ({
                    point: p,
                    dist: Math.sqrt((p.x - x) * (p.x - x) + (p.y - y) * (p.y - y))
                })).sort((a, b) => a.dist - b.dist);

                if (distances.length < 3) {
                    return distances[0] ? distances[0].point.elevation : null;
                }

                // If we're exactly at a point, return its elevation
                if (distances[0].dist < 0.001) {
                    return distances[0].point.elevation;
                }

                const p1 = distances[0].point;
                const p2 = distances[1].point;
                const p3 = distances[2].point;

                // Calculate barycentric coordinates for planar interpolation within triangle
                const denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);

                // Check for collinear points
                if (Math.abs(denom) < 0.0001) {
                    // Fallback to weighted average of 3 nearest points
                    const totalDist = distances[0].dist + distances[1].dist + distances[2].dist;
                    if (totalDist < 0.001) return p1.elevation;

                    const w1 = (totalDist - distances[0].dist) / (2 * totalDist);
                    const w2 = (totalDist - distances[1].dist) / (2 * totalDist);
                    const w3 = (totalDist - distances[2].dist) / (2 * totalDist);
                    return (w1 * p1.elevation + w2 * p2.elevation + w3 * p3.elevation) / (w1 + w2 + w3);
                }

                // Barycentric coordinates
                const w1 = ((p2.y - p3.y) * (x - p3.x) + (p3.x - p2.x) * (y - p3.y)) / denom;
                const w2 = ((p3.y - p1.y) * (x - p3.x) + (p1.x - p3.x) * (y - p3.y)) / denom;
                const w3 = 1 - w1 - w2;

                // Check if point is inside the triangle (all weights positive)
                // If outside, use distance-weighted interpolation of nearest points
                if (w1 >= 0 && w2 >= 0 && w3 >= 0) {
                    // Inside triangle - use planar interpolation
                    return w1 * p1.elevation + w2 * p2.elevation + w3 * p3.elevation;
                } else {
                    // Outside triangle - use IDW with 3 nearest points
                    const d1 = distances[0].dist || 0.001;
                    const d2 = distances[1].dist || 0.001;
                    const d3 = distances[2].dist || 0.001;

                    const weight1 = 1 / (d1 * d1);
                    const weight2 = 1 / (d2 * d2);
                    const weight3 = 1 / (d3 * d3);
                    const totalWeight = weight1 + weight2 + weight3;

                    return (weight1 * p1.elevation + weight2 * p2.elevation + weight3 * p3.elevation) / totalWeight;
                }
            }

            // Nearest Neighbor Interpolation - Blocky but fast
            function nearestNeighborInterpolate(x, y, points) {
                let nearestDist = Infinity;
                let nearestElevation = null;

                for (const point of points) {
                    const dx = point.x - x;
                    const dy = point.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < nearestDist) {
                        nearestDist = distance;
                        nearestElevation = point.elevation;
                    }
                }

                return nearestElevation;
            }

            // HILLSHADE CALCULATION - Enhanced for dramatic 3D effect

            function calculateHillshade(gridData, azimuth, altitude, zFactor) {
                const { grid, width, height, cellSize, bounds, clipPolygon } = gridData;
                const hillshade = [];

                const azimuthRad = (azimuth - 90) * Math.PI / 180;
                const altitudeRad = altitude * Math.PI / 180;

                // ENHANCED: Double the z-factor for more dramatic terrain roughness
                const effectiveZFactor = zFactor * 2;

                // Use multidirectional hillshade for better 3D effect
                const useMultidirectional = terrain3DState.multidirectionalHillshade !== false;

                for (let row = 1; row < height - 1; row++) {
                    hillshade[row] = [];
                    for (let col = 1; col < width - 1; col++) {
                        // ENHANCED: Check if cell is outside clip polygon
                        if (clipPolygon) {
                            const x = bounds.minX + (col * cellSize) + (cellSize / 2);
                            const y = bounds.minY + (row * cellSize) + (cellSize / 2);

                            if (!clipPolygon.intersectsCoordinate([x, y])) {
                                hillshade[row][col] = 127; // Neutral value for clipped cells
                                continue;
                            }
                        }

                        // Skip if center cell is null
                        if (grid[row][col] === null || grid[row][col] === undefined) {
                            hillshade[row][col] = 127; // Neutral value for null cells
                            continue;
                        }

                        // Skip if any neighbor is null - use neutral shading
                        const hasNullNeighbor = [
                            grid[row - 1][col - 1], grid[row - 1][col], grid[row - 1][col + 1],
                            grid[row][col - 1], grid[row][col + 1],
                            grid[row + 1][col - 1], grid[row + 1][col], grid[row + 1][col + 1]
                        ].some(v => v === null || v === undefined);

                        if (hasNullNeighbor) {
                            hillshade[row][col] = 127; // Neutral shading near boundaries
                            continue;
                        }

                        // Horn's method for calculating slope and aspect with 3x3 kernel
                        const dzdx = ((grid[row - 1][col + 1] + 2 * grid[row][col + 1] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row][col - 1] + grid[row + 1][col - 1])) / (8 * cellSize);

                        const dzdy = ((grid[row + 1][col - 1] + 2 * grid[row + 1][col] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row - 1][col] + grid[row - 1][col + 1])) / (8 * cellSize);

                        // ENHANCED: Use doubled z-factor for slope calculation
                        const slope = Math.atan(effectiveZFactor * Math.sqrt(dzdx * dzdx + dzdy * dzdy));
                        const aspect = Math.atan2(dzdy, -dzdx);

                        let hillshadeValue;

                        if (useMultidirectional) {
                            // Multidirectional hillshade - combines 4 light sources for enhanced 3D effect
                            const angles = [
                                { az: azimuthRad, weight: 0.6 },  // Primary light
                                { az: azimuthRad + Math.PI / 2, weight: 0.2 },  // Side light 1
                                { az: azimuthRad - Math.PI / 2, weight: 0.2 },  // Side light 2
                                { az: azimuthRad + Math.PI, weight: 0.1 }  // Back light (subtle fill)
                            ];

                            let combined = 0;
                            for (const light of angles) {
                                const value = (
                                    (Math.cos(altitudeRad) * Math.cos(slope)) +
                                    (Math.sin(altitudeRad) * Math.sin(slope) * Math.cos(light.az - aspect))
                                );
                                combined += value * light.weight;
                            }

                            // ENHANCED: Gamma correction at 0.7 for more dramatic contrast
                            hillshadeValue = 255 * Math.pow(Math.max(0, (combined + 1) / 2), 0.7);

                        } else {
                            // Standard single-source hillshade
                            const value = (
                                (Math.cos(altitudeRad) * Math.cos(slope)) +
                                (Math.sin(altitudeRad) * Math.sin(slope) * Math.cos(azimuthRad - aspect))
                            );
                            // ENHANCED: Apply gamma correction to single-source too
                            hillshadeValue = 255 * Math.pow(Math.max(0, (value + 1) / 2), 0.7);
                        }

                        hillshade[row][col] = Math.max(0, Math.min(255, hillshadeValue));
                    }
                }

                // Fill in edges with nearest neighbor values
                for (let col = 0; col < width; col++) {
                    hillshade[0] = hillshade[0] || [];
                    hillshade[height - 1] = hillshade[height - 1] || [];
                    hillshade[0][col] = hillshade[1] ? hillshade[1][col] : 128;
                    hillshade[height - 1][col] = hillshade[height - 2] ? hillshade[height - 2][col] : 128;
                }
                for (let row = 0; row < height; row++) {
                    if (!hillshade[row]) hillshade[row] = [];
                    hillshade[row][0] = hillshade[row][1] || 128;
                    hillshade[row][width - 1] = hillshade[row][width - 2] || 128;
                }

                return hillshade;
            }

            // TERRAIN ANALYSIS FUNCTIONS

            // Calculate Slope Map - Returns slope in degrees or percent
            function calculateSlopeMap(gridData, unit = 'degrees') {
                const { grid, width, height, cellSize } = gridData;
                const slopeMap = [];

                for (let row = 1; row < height - 1; row++) {
                    slopeMap[row] = [];
                    for (let col = 1; col < width - 1; col++) {
                        // Horn's method for calculating slope
                        const dzdx = ((grid[row - 1][col + 1] + 2 * grid[row][col + 1] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row][col - 1] + grid[row + 1][col - 1])) / (8 * cellSize);

                        const dzdy = ((grid[row + 1][col - 1] + 2 * grid[row + 1][col] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row - 1][col] + grid[row - 1][col + 1])) / (8 * cellSize);

                        const slopeRadians = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));

                        if (unit === 'percent') {
                            slopeMap[row][col] = Math.tan(slopeRadians) * 100; // Percent slope
                        } else {
                            slopeMap[row][col] = slopeRadians * 180 / Math.PI; // Degrees
                        }
                    }
                }

                // Fill edges
                for (let col = 0; col < width; col++) {
                    slopeMap[0] = slopeMap[0] || [];
                    slopeMap[height - 1] = slopeMap[height - 1] || [];
                    slopeMap[0][col] = slopeMap[1] ? slopeMap[1][col] : 0;
                    slopeMap[height - 1][col] = slopeMap[height - 2] ? slopeMap[height - 2][col] : 0;
                }
                for (let row = 0; row < height; row++) {
                    if (!slopeMap[row]) slopeMap[row] = [];
                    slopeMap[row][0] = slopeMap[row][1] || 0;
                    slopeMap[row][width - 1] = slopeMap[row][width - 2] || 0;
                }

                return { data: slopeMap, width, height };
            }

            // Calculate Aspect Map - Returns aspect direction in degrees (0-360)
            function calculateAspectMap(gridData) {
                const { grid, width, height, cellSize } = gridData;
                const aspectMap = [];

                for (let row = 1; row < height - 1; row++) {
                    aspectMap[row] = [];
                    for (let col = 1; col < width - 1; col++) {
                        const dzdx = ((grid[row - 1][col + 1] + 2 * grid[row][col + 1] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row][col - 1] + grid[row + 1][col - 1])) / (8 * cellSize);

                        const dzdy = ((grid[row + 1][col - 1] + 2 * grid[row + 1][col] + grid[row + 1][col + 1]) -
                            (grid[row - 1][col - 1] + 2 * grid[row - 1][col] + grid[row - 1][col + 1])) / (8 * cellSize);

                        // Calculate aspect (direction of slope)
                        let aspect = Math.atan2(dzdy, -dzdx) * 180 / Math.PI;

                        // Convert to compass bearing (0-360 degrees, 0=North, 90=East)
                        aspect = 90 - aspect;
                        if (aspect < 0) aspect += 360;
                        if (aspect >= 360) aspect -= 360;

                        // Flat areas have undefined aspect, set to -1
                        if (Math.abs(dzdx) < 0.0001 && Math.abs(dzdy) < 0.0001) {
                            aspect = -1;
                        }

                        aspectMap[row][col] = aspect;
                    }
                }

                // Fill edges
                for (let col = 0; col < width; col++) {
                    aspectMap[0] = aspectMap[0] || [];
                    aspectMap[height - 1] = aspectMap[height - 1] || [];
                    aspectMap[0][col] = aspectMap[1] ? aspectMap[1][col] : -1;
                    aspectMap[height - 1][col] = aspectMap[height - 2] ? aspectMap[height - 2][col] : -1;
                }
                for (let row = 0; row < height; row++) {
                    if (!aspectMap[row]) aspectMap[row] = [];
                    aspectMap[row][0] = aspectMap[row][1] || -1;
                    aspectMap[row][width - 1] = aspectMap[row][width - 2] || -1;
                }

                return { data: aspectMap, width, height };
            }

            // Calculate Curvature Map - Profile and Plan curvature
            function calculateCurvatureMap(gridData) {
                const { grid, width, height, cellSize } = gridData;
                const curvatureMap = [];

                for (let row = 1; row < height - 1; row++) {
                    curvatureMap[row] = [];
                    for (let col = 1; col < width - 1; col++) {
                        // Second derivatives for curvature
                        const z = grid[row][col];
                        const zxx = (grid[row][col + 1] + grid[row][col - 1] - 2 * z) / (cellSize * cellSize);
                        const zyy = (grid[row + 1][col] + grid[row - 1][col] - 2 * z) / (cellSize * cellSize);
                        const zxy = (grid[row + 1][col + 1] + grid[row - 1][col - 1] -
                            grid[row + 1][col - 1] - grid[row - 1][col + 1]) / (4 * cellSize * cellSize);

                        // First derivatives
                        const zx = (grid[row][col + 1] - grid[row][col - 1]) / (2 * cellSize);
                        const zy = (grid[row + 1][col] - grid[row - 1][col]) / (2 * cellSize);

                        const p = zx * zx;
                        const q = zy * zy;
                        const pq = p + q;

                        // Profile curvature (in direction of slope)
                        let profileCurv = 0;
                        if (pq > 0.0001) {
                            profileCurv = -(p * zxx + 2 * zx * zy * zxy + q * zyy) / (pq * Math.pow(1 + pq, 1.5));
                        }

                        // Plan curvature (perpendicular to slope)
                        let planCurv = 0;
                        if (pq > 0.0001) {
                            planCurv = -(q * zxx - 2 * zx * zy * zxy + p * zyy) / (pq * Math.pow(1 + pq, 0.5));
                        }

                        // Total curvature (mean curvature)
                        const totalCurv = (profileCurv + planCurv) / 2;

                        curvatureMap[row][col] = totalCurv * 100; // Scale for visualization
                    }
                }

                // Fill edges
                for (let col = 0; col < width; col++) {
                    curvatureMap[0] = curvatureMap[0] || [];
                    curvatureMap[height - 1] = curvatureMap[height - 1] || [];
                    curvatureMap[0][col] = curvatureMap[1] ? curvatureMap[1][col] : 0;
                    curvatureMap[height - 1][col] = curvatureMap[height - 2] ? curvatureMap[height - 2][col] : 0;
                }
                for (let row = 0; row < height; row++) {
                    if (!curvatureMap[row]) curvatureMap[row] = [];
                    curvatureMap[row][0] = curvatureMap[row][1] || 0;
                    curvatureMap[row][width - 1] = curvatureMap[row][width - 2] || 0;
                }

                return { data: curvatureMap, width, height };
            }

            // Generate Analysis Layer - Renders analysis to canvas and creates map layer
            async function generateAnalysisLayer(analysisType, unit = 'degrees') {
                try {
                    if (!terrain3DState.gridData) {
                        showToast('Please generate DTM first', 'error');
                        return;
                    }

                    showLoadingIndicator(`Calculating ${analysisType} map...`);

                    const gridData = terrain3DState.gridData;
                    let analysisResult;
                    let colorRamp;
                    let stats = {};

                    // Calculate analysis
                    if (analysisType === 'slope') {
                        analysisResult = calculateSlopeMap(gridData, unit);
                        colorRamp = getSlopeColorRamp();
                    } else if (analysisType === 'aspect') {
                        analysisResult = calculateAspectMap(gridData);
                        colorRamp = getAspectColorRamp();
                        unit = 'degrees'; // Aspect is always in degrees
                    } else if (analysisType === 'curvature') {
                        analysisResult = calculateCurvatureMap(gridData);
                        colorRamp = getCurvatureColorRamp();
                        unit = 'index';
                    }

                    // Calculate statistics
                    const values = [];
                    for (let row = 0; row < analysisResult.height; row++) {
                        for (let col = 0; col < analysisResult.width; col++) {
                            const val = analysisResult.data[row][col];
                            if (Number.isFinite(val)) {
                                values.push(val);
                            }
                        }
                    }

                    if (values.length === 0) {
                        throw new Error('No valid analysis values found. Please regenerate the DTM.');
                    }

                    values.sort((a, b) => a - b);

                    const minValue = values[0];
                    const maxValue = values[values.length - 1];
                    const sumValues = values.reduce((acc, val) => acc + val, 0);
                    const midIndex = Math.floor(values.length / 2);
                    const medianValue = values.length % 2 === 0
                        ? (values[midIndex - 1] + values[midIndex]) / 2
                        : values[midIndex];

                    stats.min = minValue.toFixed(2);
                    stats.max = maxValue.toFixed(2);
                    stats.mean = (sumValues / values.length).toFixed(2);
                    stats.median = medianValue.toFixed(2);

                    // Render to canvas
                    const canvas = renderAnalysisToCanvas(analysisResult, colorRamp, minValue, maxValue, gridData);

                    // Create OpenLayers layer
                    const bounds = gridData.bounds;
                    const extent = [bounds.minX, bounds.minY, bounds.maxX, bounds.maxY];

                    const analysisLayer = new ol.layer.Image({
                        source: new ol.source.ImageStatic({
                            url: canvas.toDataURL(),
                            imageExtent: extent,
                            projection: 'EPSG:3857'
                        }),
                        title: `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} Map`,
                        zIndex: 55,
                        opacity: 0.7
                    });

                    // Remove old analysis layer
                    if (terrain3DState.analysisLayer) {
                        map.removeLayer(terrain3DState.analysisLayer);
                    }

                    terrain3DState.analysisLayer = analysisLayer;
                    map.addLayer(analysisLayer);

                    const analysisToggle = document.getElementById('analysisLayerToggle');
                    let shouldShowLayer = true;
                    if (analysisToggle) {
                        if (analysisToggle.disabled) {
                            analysisToggle.checked = true;
                        }
                        analysisToggle.disabled = false;
                        shouldShowLayer = analysisToggle.checked;
                    }

                    terrain3DState.analysisLayerVisible = shouldShowLayer;
                    analysisLayer.setVisible(shouldShowLayer);

                    // Display statistics if enabled
                    if (document.getElementById('showAnalysisStats')?.checked) {
                        displayAnalysisStats(analysisType, stats, unit);
                    }

                    hideLoadingIndicator();
                    showToast(`${analysisType} map generated successfully!`, 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('Analysis generation error:', error);
                    showToast('Error generating analysis: ' + error.message, 'error');
                }
            }

            // Helper functions for color ramps
            function getSlopeColorRamp() {
                // Green (flat) to Yellow to Red (steep)
                return [
                    { value: 0, color: [0, 255, 0] },
                    { value: 15, color: [255, 255, 0] },
                    { value: 30, color: [255, 128, 0] },
                    { value: 45, color: [255, 0, 0] },
                    { value: 90, color: [128, 0, 0] }
                ];
            }

            function getAspectColorRamp() {
                // Compass colors: N=Red, E=Yellow, S=Green, W=Blue
                return [
                    { value: 0, color: [255, 0, 0] },     // North - Red
                    { value: 90, color: [255, 255, 0] },  // East - Yellow
                    { value: 180, color: [0, 255, 0] },   // South - Green
                    { value: 270, color: [0, 0, 255] },   // West - Blue
                    { value: 360, color: [255, 0, 0] }    // North - Red
                ];
            }

            function getCurvatureColorRamp() {
                // Blue (concave/valley) to White (flat) to Red (convex/ridge)
                return [
                    { value: -5, color: [0, 0, 255] },
                    { value: -2, color: [100, 149, 237] },
                    { value: 0, color: [255, 255, 255] },
                    { value: 2, color: [255, 165, 0] },
                    { value: 5, color: [255, 0, 0] }
                ];
            }

            function renderAnalysisToCanvas(analysisResult, colorRamp, minVal, maxVal, gridData) {
                const canvas = document.createElement('canvas');
                canvas.width = analysisResult.width;
                canvas.height = analysisResult.height;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(canvas.width, canvas.height);

                for (let row = 0; row < analysisResult.height; row++) {
                    for (let col = 0; col < analysisResult.width; col++) {
                        const value = analysisResult.data[row][col];
                        let r = 0, g = 0, b = 0, a = 255;

                        if (!Number.isFinite(value)) {
                            a = 0; // Transparent for no-data
                        } else {
                            // Interpolate color from ramp
                            const [red, green, blue] = interpolateColor(value, colorRamp, minVal, maxVal);
                            r = red;
                            g = green;
                            b = blue;
                        }

                        const idx = (row * canvas.width + col) * 4;
                        imageData.data[idx] = r;
                        imageData.data[idx + 1] = g;
                        imageData.data[idx + 2] = b;
                        imageData.data[idx + 3] = a;
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                if (gridData && gridData.clipPolygon) {
                    const bounds = gridData.bounds || terrain3DState.gridData?.bounds;
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-in';

                    const polygonCoords = gridData.clipPolygon.getType() === 'Polygon'
                        ? [gridData.clipPolygon.getCoordinates()]
                        : gridData.clipPolygon.getCoordinates();

                    ctx.beginPath();
                    polygonCoords.forEach(rings => {
                        rings.forEach(ring => {
                            if (!ring || !ring.length) return;
                            ring.forEach((coord, idx) => {
                                const px = (coord[0] - bounds.minX) / gridData.cellSize;
                                const py = (bounds.maxY - coord[1]) / gridData.cellSize;
                                if (idx === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            });
                            ctx.closePath();
                        });
                    });

                    ctx.fill('evenodd');
                    ctx.restore();
                }

                return canvas;
            }

            function interpolateColor(value, colorRamp, minVal, maxVal) {
                // Normalize value to ramp range
                const range = maxVal - minVal;
                const normalized = range === 0 ? 0 : (value - minVal) / range;
                const clamped = Math.min(Math.max(normalized, 0), 1);
                const rampVal = clamped * (colorRamp[colorRamp.length - 1].value - colorRamp[0].value) + colorRamp[0].value;

                // Find surrounding ramp stops
                let i = 0;
                for (i = 0; i < colorRamp.length - 1; i++) {
                    if (rampVal <= colorRamp[i + 1].value) break;
                }

                if (i >= colorRamp.length - 1) {
                    return colorRamp[colorRamp.length - 1].color;
                }

                const lower = colorRamp[i];
                const upper = colorRamp[i + 1];
                const t = (rampVal - lower.value) / (upper.value - lower.value);

                return [
                    Math.round(lower.color[0] + t * (upper.color[0] - lower.color[0])),
                    Math.round(lower.color[1] + t * (upper.color[1] - lower.color[1])),
                    Math.round(lower.color[2] + t * (upper.color[2] - lower.color[2]))
                ];
            }

            function displayAnalysisStats(analysisType, stats, unit) {
                const panel = document.getElementById('analysisStatsPanel');
                const content = document.getElementById('analysisStatsContent');

                const unitStr = unit === 'degrees' ? '°' : unit === 'percent' ? '%' : '';

                content.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85rem;">
                    <div><strong>Min:</strong> ${stats.min}${unitStr}</div>
                    <div><strong>Max:</strong> ${stats.max}${unitStr}</div>
                    <div><strong>Mean:</strong> ${stats.mean}${unitStr}</div>
                    <div><strong>Median:</strong> ${stats.median}${unitStr}</div>
                </div>
            `;

                panel.style.display = 'block';
            }

            // D. DTM GENERATION FUNCTIONS - QGIS COLOR RAMPS

            const QGIS_COLOR_RAMPS = {
                viridis: [
                    { stop: 0.0, color: [68, 1, 84] },
                    { stop: 0.25, color: [59, 82, 139] },
                    { stop: 0.5, color: [33, 145, 140] },
                    { stop: 0.75, color: [94, 201, 98] },
                    { stop: 1.0, color: [253, 231, 37] }
                ],
                grayscale: [
                    { stop: 0.0, color: [30, 30, 30] },
                    { stop: 0.25, color: [80, 80, 80] },
                    { stop: 0.5, color: [140, 140, 140] },
                    { stop: 0.75, color: [200, 200, 200] },
                    { stop: 1.0, color: [255, 255, 255] }
                ],
                terrain: [
                    { stop: 0.0, color: [0, 104, 55] },
                    { stop: 0.2, color: [26, 152, 80] },
                    { stop: 0.4, color: [166, 217, 106] },
                    { stop: 0.6, color: [217, 239, 139] },
                    { stop: 0.7, color: [254, 224, 139] },
                    { stop: 0.8, color: [244, 165, 130] },
                    { stop: 0.9, color: [186, 74, 47] },
                    { stop: 1.0, color: [255, 255, 255] }
                ],
                elevation: [
                    { stop: 0.0, color: [0, 0, 128] },
                    { stop: 0.2, color: [0, 0, 255] },
                    { stop: 0.4, color: [0, 255, 255] },
                    { stop: 0.5, color: [0, 255, 0] },
                    { stop: 0.7, color: [255, 255, 0] },
                    { stop: 0.85, color: [255, 128, 0] },
                    { stop: 0.95, color: [255, 0, 0] },
                    { stop: 1.0, color: [255, 255, 255] }
                ],
                spectral: [
                    { stop: 0.0, color: [158, 1, 66] },
                    { stop: 0.25, color: [252, 141, 89] },
                    { stop: 0.5, color: [255, 255, 191] },
                    { stop: 0.75, color: [153, 213, 148] },
                    { stop: 1.0, color: [94, 79, 162] }
                ],
                plasma: [
                    { stop: 0.0, color: [13, 8, 135] },
                    { stop: 0.25, color: [126, 3, 168] },
                    { stop: 0.5, color: [204, 71, 120] },
                    { stop: 0.75, color: [248, 149, 64] },
                    { stop: 1.0, color: [240, 249, 33] }
                ]
            };

            function getColorFromRamp(elevation, minZ, maxZ, rampName) {
                const normalized = (elevation - minZ) / (maxZ - minZ);
                const ramp = QGIS_COLOR_RAMPS[rampName] || QGIS_COLOR_RAMPS.elevation;

                for (let i = 0; i < ramp.length - 1; i++) {
                    if (normalized >= ramp[i].stop && normalized <= ramp[i + 1].stop) {
                        const localNorm = (normalized - ramp[i].stop) /
                            (ramp[i + 1].stop - ramp[i].stop);
                        const r = Math.round(ramp[i].color[0] +
                            (ramp[i + 1].color[0] - ramp[i].color[0]) * localNorm);
                        const g = Math.round(ramp[i].color[1] +
                            (ramp[i + 1].color[1] - ramp[i].color[1]) * localNorm);
                        const b = Math.round(ramp[i].color[2] +
                            (ramp[i + 1].color[2] - ramp[i].color[2]) * localNorm);
                        return [r, g, b];
                    }
                }
                return [255, 255, 255];
            }

            function applyContrastBrightness(value, contrast, brightness) {
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                value = factor * (value - 128) + 128;
                value += brightness * 2.55;
                return value;
            }

            function renderDTMToCanvas(gridData, hillshade, bounds, colorRamp, options) {
                const canvas = document.createElement('canvas');
                canvas.width = gridData.width;
                canvas.height = gridData.height;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(canvas.width, canvas.height);

                updateLoadingProgress('Rendering pixels...');

                for (let row = 0; row < gridData.height; row++) {
                    for (let col = 0; col < gridData.width; col++) {
                        const elevation = gridData.grid[row][col];
                        if (elevation === null) continue;

                        // Check if cell is outside clip polygon (hard clip)
                        if (gridData.clipPolygon) {
                            const x = bounds.minX + (col * gridData.cellSize) + (gridData.cellSize / 2);
                            const y = bounds.minY + (row * gridData.cellSize) + (gridData.cellSize / 2);

                            if (!gridData.clipPolygon.intersectsCoordinate([x, y])) {
                                // Hard clip: skip this pixel entirely (will be transparent)
                                continue;
                            }
                        }

                        let [r, g, b] = getColorFromRamp(elevation, bounds.minZ, bounds.maxZ, colorRamp);

                        // Apply contrast and brightness
                        r = applyContrastBrightness(r, options.contrast, options.brightness);
                        g = applyContrastBrightness(g, options.contrast, options.brightness);
                        b = applyContrastBrightness(b, options.contrast, options.brightness);

                        // Apply hillshade if enabled - ENHANCED for dramatic 3D effect
                        if (options.hillshadeEnabled && hillshade && hillshade[row]) {
                            const hillshadeValue = hillshade[row][col] / 255;
                            const blend = options.hillshadeOpacity;

                            if (options.hillshadeBlend === 'multiply') {
                                // ENHANCED multiply with much stronger shadow contrast
                                const factor = 0.2 + (hillshadeValue * 0.8); // More aggressive darkening
                                r *= ((1 - blend) + blend * factor);
                                g *= ((1 - blend) + blend * factor);
                                b *= ((1 - blend) + blend * factor);
                            } else if (options.hillshadeBlend === 'overlay') {
                                const overlay = (base, shade) =>
                                    base < 0.5 ? 2 * base * shade : 1 - 2 * (1 - base) * (1 - shade);
                                const blendedR = overlay(r / 255, hillshadeValue);
                                const blendedG = overlay(g / 255, hillshadeValue);
                                const blendedB = overlay(b / 255, hillshadeValue);
                                r = 255 * ((1 - blend) * (r / 255) + blend * blendedR);
                                g = 255 * ((1 - blend) * (g / 255) + blend * blendedG);
                                b = 255 * ((1 - blend) * (b / 255) + blend * blendedB);
                            } else if (options.hillshadeBlend === 'soft-light') {
                                const softLight = (base, shade) => {
                                    base = base / 255;
                                    if (shade < 0.5) {
                                        return 2 * base * shade + base * base * (1 - 2 * shade);
                                    } else {
                                        return 2 * base * (1 - shade) + Math.sqrt(base) * (2 * shade - 1);
                                    }
                                };
                                const blendedR = softLight(r, hillshadeValue);
                                const blendedG = softLight(g, hillshadeValue);
                                const blendedB = softLight(b, hillshadeValue);
                                r = 255 * ((1 - blend) * (r / 255) + blend * blendedR);
                                g = 255 * ((1 - blend) * (g / 255) + blend * blendedG);
                                b = 255 * ((1 - blend) * (b / 255) + blend * blendedB);
                            }
                        }

                        const targetRow = canvas.height - 1 - row;
                        const idx = (targetRow * canvas.width + col) * 4;
                        imageData.data[idx] = Math.max(0, Math.min(255, r));
                        imageData.data[idx + 1] = Math.max(0, Math.min(255, g));
                        imageData.data[idx + 2] = Math.max(0, Math.min(255, b));
                        imageData.data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }


            // ========================================
            // PRODUCTION-GRADE CONTOUR RENDERING SYSTEM
            // ========================================
            // VectorImage-based rendering with smart labeling for QGIS-quality output

            /**
             * Renders contours from edge function GeoJSON using VectorImage for optimal performance
             */
            async function renderContoursOptimized(geojsonData, settings = {}) {
                try {
                    console.log('🎨 Rendering contours with VectorImage...');

                    // Default settings
                    const config = {
                        showLabels: settings.showLabels !== false,
                        minLabelZoom: settings.minLabelZoom || 14,
                        labelSpacing: settings.labelSpacing || 300,  // pixels
                        labelEveryNth: settings.labelEveryNth || 2,  // Label every 2nd major contour
                        majorColor: settings.majorColor || '#8B4513',
                        minorColor: settings.minorColor || '#D2691E',
                        majorWidth: settings.majorWidth || 2,
                        minorWidth: settings.minorWidth || 1,
                        declutter: settings.declutter !== false
                    };

                    // Remove old contour layer
                    if (terrain3DState.contourLayer) {
                        map.removeLayer(terrain3DState.contourLayer);
                    }

                    // Parse GeoJSON - contours are already in map projection (EPSG:3857)
                    const format = new ol.format.GeoJSON();
                    const features = format.readFeatures(geojsonData, {
                        // No dataProjection specified - assume data is already in featureProjection
                        featureProjection: map.getView().getProjection()
                    });

                    console.log(`📊 Loaded ${features.length} contour features`);

                    // Debug: Check coordinate ranges
                    if (features.length > 0) {
                        const firstFeature = features[0];
                        const coords = firstFeature.getGeometry().getCoordinates();
                        console.log('First rendered feature coordinates:', coords.slice(0, 3));
                        console.log('Coordinate range check - should be in EPSG:3857 (millions):', {
                            minX: Math.min(...coords.map(c => c[0])),
                            maxX: Math.max(...coords.map(c => c[0])),
                            minY: Math.min(...coords.map(c => c[1])),
                            maxY: Math.max(...coords.map(c => c[1]))
                        });
                    }

                    // Create VectorImage layer (renders to internal canvas - much faster!)
                    const source = new ol.source.Vector({ features: features });

                    const contourLayer = new ol.layer.VectorImage({
                        source: source,
                        style: createSmartContourStyle(config, geojsonData.metadata),
                        zIndex: 100,
                        declutter: config.declutter,
                        renderBuffer: 250,
                        visible: true
                    });

                    console.log('Adding contour layer to map...');
                    map.addLayer(contourLayer);
                    terrain3DState.contourLayer = contourLayer;
                    console.log('Contour layer added, visible:', contourLayer.getVisible());
                    terrain3DState.contourSettings = config;

                    console.log('✅ Contours rendered successfully with VectorImage');
                    showToast(`Rendered ${features.length} contours successfully`, 'success');

                } catch (error) {
                    console.error('❌ Error rendering contours:', error);
                    showToast('Failed to render contours: ' + error.message, 'error');
                    throw error;
                }
            }

            /**
             * Creates smart style function with zoom-based label filtering
             */
            function createSmartContourStyle(config, metadata) {
                return function (feature, resolution) {
                    const elevation = feature.get('elevation');
                    const isMajor = feature.get('isMajor');
                    const zoom = map.getView().getZoom();

                    const styles = [];

                    // Line style
                    styles.push(new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: isMajor ? config.majorColor : config.minorColor,
                            width: isMajor ? config.majorWidth : config.minorWidth,
                            lineCap: 'round',
                            lineJoin: 'round'
                        })
                    }));

                    // Smart label filtering
                    const majorInterval = metadata?.majorInterval || 25;
                    const shouldLabel =
                        config.showLabels &&
                        isMajor &&
                        zoom >= config.minLabelZoom &&
                        elevation % (majorInterval * config.labelEveryNth) === 0;

                    if (shouldLabel) {
                        styles.push(new ol.style.Style({
                            text: new ol.style.Text({
                                text: elevation.toFixed(0) + 'm',
                                font: 'bold 11px Arial',
                                fill: new ol.style.Fill({ color: '#000' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                                placement: 'line',
                                maxAngle: Math.PI / 4,
                                repeat: config.labelSpacing,
                                overflow: false,
                                textBaseline: 'middle'
                            })
                        }));
                    }

                    return styles;
                };
            }

            /**
             * Complete contour generation workflow - uses single Cloudflare worker pipeline
             */
            // Make functions globally available
            window.renderContoursOptimized = null; // Deprecated
            window.createSmartContourStyle = null; // Deprecated
            window.generateContoursProduction = generateContourLayer; // Redirect legacy calls checking console manually


            async function generateDTMLayer() {
                try {
                    console.log('=== Starting DTM Generation ===');
                    const combinedData = getCombinedData();
                    console.log('Combined data count:', combinedData.length);

                    if (combinedData.length < 3) {
                        throw new Error('Need at least 3 points to generate DTM');
                    }

                    // Always use edge function for best results
                    const useEdgeFunction = true;

                    if (useEdgeFunction) {
                        showLoadingIndicator('Generating DTM on server (large dataset)...');
                        updateLoadingProgress(`Processing ${combinedData.length} points on server...`);

                        try {
                            // Transform coordinates to map projection first
                            const transformedData = transformCoordinates(
                                combinedData,
                                terrain3DState.coordinateSystem,
                                'EPSG:3857'
                            );

                            const bounds = calculateDataBounds(transformedData);
                            terrain3DState.minElevation = bounds.minZ;
                            terrain3DState.maxElevation = bounds.maxZ;

                            // Update UI
                            document.getElementById('minElevation').value = bounds.minZ.toFixed(2);
                            document.getElementById('maxElevation').value = bounds.maxZ.toFixed(2);

                            // Prepare points for edge function
                            const points = transformedData.map(p => ({
                                x: p.x || p.easting,
                                y: p.y || p.northing,
                                z: p.elevation
                            }));

                            updateLoadingProgress('Sending data to server...');

                            // Call edge function
                            const result = await callTerrainProcessor('generate-dtm', {
                                points: points,
                                gridSize: terrain3DState.cellSize || 10,
                                power: terrain3DState.idwPower || 2,
                                extent: {
                                    minX: bounds.minX,
                                    minY: bounds.minY,
                                    maxX: bounds.maxX,
                                    maxY: bounds.maxY
                                },
                                config: {
                                    colorRamp: terrain3DState.colorRamp || 'elevation',
                                    hillshadeEnabled: terrain3DState.hillshadeEnabled || false,
                                    azimuth: terrain3DState.azimuth || 315,
                                    altitude: terrain3DState.altitude || 45,
                                    zFactor: terrain3DState.zFactor || 1,
                                    hillshadeOpacity: terrain3DState.hillshadeOpacity || 0.5,
                                    hillshadeBlend: terrain3DState.hillshadeBlend || 'multiply',
                                    opacity: terrain3DState.dtmOpacity || 0.8,
                                    contrast: terrain3DState.contrast || 0,
                                    brightness: terrain3DState.brightness || 0
                                },
                                // Request contours in the same call (efficiency fix)
                                includeContours: true,
                                interval: terrain3DState.contourInterval || 5,
                                majorInterval: terrain3DState.majorContourInterval || 25
                            });

                            // Check if edge function returned valid data
                            if (result && result.success !== false && (result.bounds || result.gridData)) {
                                // If edge function returned gridData but no image, render it client-side
                                if (result.gridData && !result.imageDataUrl) {
                                    console.log('Edge function returned grid data, rendering client-side...');
                                    // Use the grid data from server
                                    const serverGridData = result.gridData;
                                    const rasterBounds = result.bounds;

                                    // Calculate hillshade if enabled
                                    let hillshade = null;
                                    if (terrain3DState.hillshadeEnabled) {
                                        updateLoadingProgress('Calculating hillshade...');
                                        // Note: calculateHillshade needs to be available or we skip this
                                        // For now, we'll render without hillshade from server
                                    }

                                    updateLoadingProgress('Rendering DTM from server grid data...');

                                    // Render DTM to canvas using server grid data
                                    const canvas = renderDTMToCanvas(
                                        serverGridData,
                                        hillshade,
                                        rasterBounds,
                                        terrain3DState.colorRamp || 'elevation',
                                        {
                                            hillshadeEnabled: terrain3DState.hillshadeEnabled || false,
                                            hillshadeOpacity: terrain3DState.hillshadeOpacity || 0.5,
                                            hillshadeBlend: terrain3DState.hillshadeBlend || 'multiply',
                                            opacity: terrain3DState.dtmOpacity || 0.8,
                                            contrast: terrain3DState.contrast || 0,
                                            brightness: terrain3DState.brightness || 0
                                        }
                                    );

                                    const dtmLayer = new ol.layer.Image({
                                        source: new ol.source.ImageStatic({
                                            url: canvas.toDataURL(),
                                            imageExtent: [rasterBounds.minX, rasterBounds.minY, rasterBounds.maxX, rasterBounds.maxY],
                                            projection: 'EPSG:3857'
                                        }),
                                        opacity: terrain3DState.dtmOpacity || 0.8,
                                        zIndex: 110
                                    });

                                    // Remove old DTM layer if exists
                                    if (terrain3DState.dtmLayer) {
                                        map.removeLayer(terrain3DState.dtmLayer);
                                    }

                                    terrain3DState.dtmLayer = dtmLayer;
                                    terrain3DState.gridData = serverGridData;
                                    map.addLayer(dtmLayer);

                                    const dtmToggleEl = document.getElementById('dtmLayerToggle');
                                    let dtmVisible = terrain3DState.dtmLayerVisible;
                                    if (typeof dtmVisible !== 'boolean') {
                                        dtmVisible = true;
                                    }
                                    terrain3DState.dtmLayerVisible = dtmVisible;
                                    dtmLayer.setVisible(dtmVisible);
                                    if (dtmToggleEl) {
                                        dtmToggleEl.disabled = false;
                                        dtmToggleEl.checked = dtmVisible;
                                    }

                                    if (combinedData.length > 0) {
                                        addPointsLayer(
                                            combinedData,
                                            terrain3DState.showPointNumbers,
                                            terrain3DState.showDescriptions
                                        );
                                    }

                                    hideLoadingIndicator();
                                    showToast(`DTM generated successfully on server (${combinedData.length} points)!`, 'success');
                                    return dtmLayer;
                                } else if (result.imageDataUrl && result.bounds) {
                                    // Edge function returned pre-rendered image
                                    updateLoadingProgress('Rendering DTM from server...');

                                    const rasterBounds = result.bounds;
                                    const dtmLayer = new ol.layer.Image({
                                        source: new ol.source.ImageStatic({
                                            url: result.imageDataUrl,
                                            imageExtent: [rasterBounds.minX, rasterBounds.minY, rasterBounds.maxX, rasterBounds.maxY],
                                            projection: 'EPSG:3857'
                                        }),
                                        opacity: terrain3DState.dtmOpacity || 0.8,
                                        title: 'DTM Raster',
                                        zIndex: 110
                                    });

                                    // Remove old DTM layer if exists
                                    if (terrain3DState.dtmLayer) {
                                        console.log('Removing old DTM layer');
                                        map.removeLayer(terrain3DState.dtmLayer);
                                    }

                                    terrain3DState.dtmLayer = dtmLayer;
                                    // Store grid data if provided, otherwise create placeholder
                                    if (result.gridData) {
                                        terrain3DState.gridData = result.gridData;
                                    } else {
                                        // Create minimal grid data structure for compatibility
                                        terrain3DState.gridData = {
                                            grid: [],
                                            width: 0,
                                            height: 0,
                                            bounds: rasterBounds
                                        };
                                    }
                                    map.addLayer(dtmLayer);

                                    const dtmToggleEl = document.getElementById('dtmLayerToggle');
                                    let dtmVisible = terrain3DState.dtmLayerVisible;
                                    if (typeof dtmVisible !== 'boolean') {
                                        dtmVisible = true;
                                    }
                                    terrain3DState.dtmLayerVisible = dtmVisible;
                                    dtmLayer.setVisible(dtmVisible);
                                    if (dtmToggleEl) {
                                        dtmToggleEl.disabled = false;
                                        dtmToggleEl.checked = dtmVisible;
                                    }

                                    // Add points layer if points should be shown
                                    if (combinedData.length > 0) {
                                        addPointsLayer(
                                            combinedData,
                                            terrain3DState.showPointNumbers,
                                            terrain3DState.showDescriptions
                                        );
                                    }

                                    // Handle Server-Side Contours (New Architecture)
                                    if (result.contours) {
                                        console.log('Received contours from server, rendering directly...');
                                        updateLoadingProgress('Rendering server-generated contours...');

                                        // Create a synthetic result object for renderContoursOptimized
                                        const contourResult = {
                                            features: result.contours,
                                            metadata: result.contourMetadata
                                        };

                                        // Render contours using existing optimized logic
                                        await renderContoursOptimized(contourResult, {
                                            interval: terrain3DState.contourInterval || 5,
                                            majorInterval: terrain3DState.majorContourInterval || 25
                                        });

                                        showToast(`Generated ${result.contours.length} contour features via Edge Function`, 'success');
                                    }

                                    hideLoadingIndicator();
                                    showToast(`DTM generated successfully on server (${combinedData.length} points)!`, 'success');

                                    return dtmLayer;
                                } else {
                                    // Edge function returned bounds but no gridData or imageDataUrl
                                    throw new Error('Server returned invalid DTM data structure');
                                }
                            } else if (result && result.message && result.message.includes('not yet implemented')) {
                                // Edge function not fully implemented yet, fall through to client-side
                                console.log('Edge function DTM generation not fully implemented, using client-side');
                                showToast('Using local processing (server feature in development)...', 'info');
                                // Fall through to client-side processing
                            } else if (result && result.error) {
                                throw new Error('Server error: ' + result.error);
                            } else {
                                throw new Error('Server did not return valid DTM data: ' + (result?.message || 'Unknown error'));
                            }
                        } catch (edgeError) {
                            console.warn('Edge function failed, falling back to client-side:', edgeError);
                            showToast('Server unavailable, using local processing (may be slower)...', 'info');
                            // Fall through to client-side processing
                        }
                    }

                    // Client-side processing (original code or fallback)
                    showLoadingIndicator('Generating DTM raster...');
                    updateLoadingProgress(`Processing ${combinedData.length} points...`);

                    // Transform coordinates to map projection
                    console.log('Transforming coordinates from', terrain3DState.coordinateSystem, 'to EPSG:3857');
                    const transformedData = transformCoordinates(
                        combinedData,
                        terrain3DState.coordinateSystem,
                        'EPSG:3857'
                    );

                    console.log('Transformed data count:', transformedData.length);

                    if (transformedData.length < 3) {
                        throw new Error('Insufficient valid points after coordinate transformation');
                    }

                    const bounds = calculateDataBounds(transformedData);
                    terrain3DState.minElevation = bounds.minZ;
                    terrain3DState.maxElevation = bounds.maxZ;

                    // Update UI
                    document.getElementById('minElevation').value = bounds.minZ.toFixed(2);
                    document.getElementById('maxElevation').value = bounds.maxZ.toFixed(2);

                    updateLoadingProgress('Creating elevation grid...');

                    // Create raster grid using IDW interpolation
                    const gridData = createRasterGrid(
                        transformedData,
                        bounds,
                        terrain3DState.cellSize || 10,
                        {
                            idwPower: terrain3DState.idwPower || 2,
                            idwMaxDistance: terrain3DState.idwMaxDistance || 1000
                        }
                    );
                    const rasterBounds = gridData.bounds;

                    // Calculate hillshade if enabled
                    let hillshade = null;
                    if (terrain3DState.hillshadeEnabled) {
                        updateLoadingProgress('Calculating hillshade...');
                        hillshade = calculateHillshade(
                            gridData,
                            terrain3DState.azimuth || 315,
                            terrain3DState.altitude || 45,
                            terrain3DState.zFactor || 1
                        );
                    }

                    updateLoadingProgress('Rendering DTM to canvas...');

                    // Render DTM to canvas
                    const canvas = renderDTMToCanvas(
                        gridData,
                        hillshade,
                        rasterBounds,
                        terrain3DState.colorRamp || 'elevation',
                        {
                            hillshadeEnabled: terrain3DState.hillshadeEnabled || false,
                            hillshadeOpacity: terrain3DState.hillshadeOpacity || 0.5,
                            hillshadeBlend: terrain3DState.hillshadeBlend || 'multiply',
                            opacity: terrain3DState.dtmOpacity || 0.8,
                            contrast: terrain3DState.contrast || 0,
                            brightness: terrain3DState.brightness || 0
                        }
                    );

                    // Create image layer from canvas
                    const dtmLayer = new ol.layer.Image({
                        source: new ol.source.ImageStatic({
                            url: canvas.toDataURL(),
                            imageExtent: [rasterBounds.minX, rasterBounds.minY, rasterBounds.maxX, rasterBounds.maxY],
                            projection: 'EPSG:3857'
                        }),
                        opacity: terrain3DState.dtmOpacity || 0.8,
                        zIndex: 110
                    });

                    // Remove old DTM layer if exists
                    if (terrain3DState.dtmLayer) {
                        console.log('Removing old DTM layer');
                        map.removeLayer(terrain3DState.dtmLayer);
                    }

                    terrain3DState.dtmLayer = dtmLayer;
                    terrain3DState.gridData = gridData; // Store for contour generation
                    map.addLayer(dtmLayer);

                    const dtmToggleEl = document.getElementById('dtmLayerToggle');
                    let dtmVisible = terrain3DState.dtmLayerVisible;
                    if (typeof dtmVisible !== 'boolean') {
                        dtmVisible = true;
                    }
                    terrain3DState.dtmLayerVisible = dtmVisible;
                    dtmLayer.setVisible(dtmVisible);
                    if (dtmToggleEl) {
                        dtmToggleEl.disabled = false;
                        dtmToggleEl.checked = dtmVisible;
                    }

                    // Add points layer if points should be shown
                    if (combinedData.length > 0) {
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );
                    }

                    hideLoadingIndicator();
                    showToast(`DTM generated successfully (${gridData.width}x${gridData.height} grid)!`, 'success');

                    return dtmLayer;

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('DTM generation error:', error);
                    showToast('Error generating DTM: ' + error.message, 'error');
                    throw error;
                }
            }

            // ========================================
            // TIN-BASED CONTOUR GENERATION (QGIS QUALITY)
            // ========================================

            /**
             * Generate TIN (Triangulated Irregular Network) from point coordinates
             * @param {Array} points - Array of {x, y, z} points
             * @returns {Object} TIN object with triangles and Delaunay structure
             */
            function generateTIN(points) {
                if (!points || points.length < 3) {
                    throw new Error('Need at least 3 points to generate TIN');
                }

                // Extract x, y coordinates for Delaunay triangulation
                const coords = points.map(p => [p.x, p.y]);

                // Create Delaunay triangulation
                const delaunay = d3.Delaunay.from(coords);

                // Build triangle list with elevation data
                const triangles = [];
                const triangleIndices = delaunay.triangles;
                const triangleCount = triangleIndices.length / 3;

                for (let i = 0; i < triangleCount; i++) {
                    const idx0 = triangleIndices[i * 3];
                    const idx1 = triangleIndices[i * 3 + 1];
                    const idx2 = triangleIndices[i * 3 + 2];

                    // Validate indices
                    if (idx0 >= points.length || idx1 >= points.length || idx2 >= points.length) {
                        console.warn(`Invalid triangle indices: ${idx0}, ${idx1}, ${idx2} for ${points.length} points`);
                        continue;
                    }

                    const p0 = points[idx0];
                    const p1 = points[idx1];
                    const p2 = points[idx2];

                    // Skip degenerate triangles (collinear points)
                    const area = Math.abs((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
                    if (area < 1e-10) {
                        continue;
                    }

                    triangles.push({
                        indices: [idx0, idx1, idx2],
                        vertices: [
                            { x: p0.x, y: p0.y, z: p0.z },
                            { x: p1.x, y: p1.y, z: p1.z },
                            { x: p2.x, y: p2.y, z: p2.z }
                        ],
                        // Pre-calculate plane equation: z = ax + by + c
                        // Using plane equation from 3 points
                        plane: calculatePlaneEquation(p0, p1, p2)
                    });
                }

                console.log(`Generated TIN with ${triangles.length} triangles from ${points.length} points`);

                return {
                    delaunay: delaunay,
                    triangles: triangles,
                    points: points
                };
            }

            /**
             * Calculate plane equation z = ax + by + c from three points
             * @param {Object} p0 - Point {x, y, z}
             * @param {Object} p1 - Point {x, y, z}
             * @param {Object} p2 - Point {x, y, z}
             * @returns {Object} Plane coefficients {a, b, c}
             */
            function calculatePlaneEquation(p0, p1, p2) {
                // Vectors in the plane
                const v1 = { x: p1.x - p0.x, y: p1.y - p0.y, z: p1.z - p0.z };
                const v2 = { x: p2.x - p0.x, y: p2.y - p0.y, z: p2.z - p0.z };

                // Normal vector (cross product)
                const nx = v1.y * v2.z - v1.z * v2.y;
                const ny = v1.z * v2.x - v1.x * v2.z;
                const nz = v1.x * v2.y - v1.y * v2.x;

                // If normal is vertical (nz = 0), triangle is degenerate
                if (Math.abs(nz) < 1e-10) {
                    // Use average elevation for flat triangle
                    const avgZ = (p0.z + p1.z + p2.z) / 3;
                    return { a: 0, b: 0, c: avgZ, isVertical: true };
                }

                // Plane equation: nx*x + ny*y + nz*z + d = 0
                // Solve for d using p0
                const d = -(nx * p0.x + ny * p0.y + nz * p0.z);

                // Convert to z = ax + by + c form
                const a = -nx / nz;
                const b = -ny / nz;
                const c = -d / nz;

                return { a, b, c, isVertical: false };
            }

            /**
             * Get elevation at point (x, y) from TIN using triangle interpolation
             * @param {Object} tin - TIN object
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @returns {number|null} Elevation or null if outside TIN
             */
            function getElevationFromTIN(tin, x, y) {
                // Find triangle containing the point using Delaunay's find method
                const triangleIndex = tin.delaunay.find(x, y);

                if (triangleIndex === -1) {
                    // Point is outside convex hull, use nearest neighbor
                    let minDist = Infinity;
                    let nearestZ = null;
                    for (const p of tin.points) {
                        const dist = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestZ = p.z;
                        }
                    }
                    return nearestZ;
                }

                // Get triangle indices from the found triangle
                const triangles = tin.delaunay.triangles;
                const triangleStart = triangleIndex * 3;

                if (triangleStart >= triangles.length) {
                    return null;
                }

                const i0 = triangles[triangleStart];
                const i1 = triangles[triangleStart + 1];
                const i2 = triangles[triangleStart + 2];

                if (i0 >= tin.points.length || i1 >= tin.points.length || i2 >= tin.points.length) {
                    return null;
                }

                const p0 = tin.points[i0];
                const p1 = tin.points[i1];
                const p2 = tin.points[i2];

                // Get the triangle object
                const triangle = tin.triangles[triangleIndex];
                if (!triangle) {
                    return null;
                }

                const plane = triangle.plane;

                if (plane.isVertical) {
                    return plane.c;
                }

                // Calculate elevation using plane equation
                return plane.a * x + plane.b * y + plane.c;
            }

            /**
             * Generate a high-resolution grid from TIN using triangle interpolation
             * This creates a smooth grid that preserves TIN accuracy
             * @param {Object} tin - TIN object
             * @param {Object} extent - Extent {minX, minY, maxX, maxY}
             * @param {number} cellSize - Grid cell size in meters
             * @returns {Object} Grid data object
             */
            function generateGridFromTIN(tin, extent, cellSize) {
                const width = Math.ceil((extent.maxX - extent.minX) / cellSize);
                const height = Math.ceil((extent.maxY - extent.minY) / cellSize);

                // Limit grid size to prevent memory issues
                const maxGridSize = 2000; // Max 2000x2000 = 4M cells
                let finalCellSize = cellSize;
                let finalWidth = width;
                let finalHeight = height;

                if (width > maxGridSize || height > maxGridSize) {
                    const scale = Math.max(width / maxGridSize, height / maxGridSize);
                    finalCellSize = cellSize * scale;
                    finalWidth = Math.ceil((extent.maxX - extent.minX) / finalCellSize);
                    finalHeight = Math.ceil((extent.maxY - extent.minY) / finalCellSize);
                    console.warn(`Grid too large (${width}x${height}), scaling to ${finalWidth}x${finalHeight} with cellSize ${finalCellSize.toFixed(2)}m`);
                }

                console.log(`Generating grid from TIN: ${finalWidth}x${finalHeight} cells, cellSize: ${finalCellSize.toFixed(2)}m`);

                const grid = [];
                let minZ = Infinity;
                let maxZ = -Infinity;
                let validCells = 0;

                // Initialize grid
                for (let row = 0; row < finalHeight; row++) {
                    grid[row] = [];
                    for (let col = 0; col < finalWidth; col++) {
                        // Calculate cell center coordinates
                        const x = extent.minX + (col * finalCellSize) + (finalCellSize / 2);
                        const y = extent.minY + (row * finalCellSize) + (finalCellSize / 2);

                        // Get elevation from TIN
                        const elevation = getElevationFromTIN(tin, x, y);

                        if (elevation !== null && isFinite(elevation)) {
                            grid[row][col] = elevation;
                            validCells++;
                            if (elevation < minZ) minZ = elevation;
                            if (elevation > maxZ) maxZ = elevation;
                        } else {
                            grid[row][col] = null;
                        }
                    }

                    // Update progress for large grids
                    if (row % 50 === 0 && finalHeight > 100) {
                        updateLoadingProgress(`Generating grid: ${Math.round((row / finalHeight) * 100)}%`);
                    }
                }

                console.log(`Grid generated: ${validCells} valid cells. Elevation range: ${minZ.toFixed(2)}m to ${maxZ.toFixed(2)}m`);

                if (validCells === 0) {
                    throw new Error('No valid elevation values in grid. Check TIN generation.');
                }

                if (!isFinite(minZ) || !isFinite(maxZ)) {
                    throw new Error(`Invalid elevation range in grid: ${minZ} to ${maxZ}. Check point elevation values.`);
                }

                const gridBounds = {
                    minX: extent.minX,
                    minY: extent.minY,
                    maxX: extent.maxX,
                    maxY: extent.maxY,
                    minZ: minZ,
                    maxZ: maxZ
                };

                console.log('Grid bounds:', gridBounds);

                return {
                    grid: grid,
                    width: finalWidth,
                    height: finalHeight,
                    cellSize: finalCellSize,
                    bounds: gridBounds
                };
            }

            /**
             * Check if point is inside triangle using barycentric coordinates
             */
            function pointInTriangle(x, y, p0, p1, p2) {
                const v0x = p2.x - p0.x;
                const v0y = p2.y - p0.y;
                const v1x = p1.x - p0.x;
                const v1y = p1.y - p0.y;
                const v2x = x - p0.x;
                const v2y = y - p0.y;

                const dot00 = v0x * v0x + v0y * v0y;
                const dot01 = v0x * v1x + v0y * v1y;
                const dot02 = v0x * v2x + v0y * v2y;
                const dot11 = v1x * v1x + v1y * v1y;
                const dot12 = v1x * v2x + v1y * v2y;

                const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                return (u >= 0) && (v >= 0) && (u + v < 1);
            }

            /**
             * Intersect contour plane with triangle edge
             * @param {Object} p1 - Edge start point {x, y, z}
             * @param {Object} p2 - Edge end point {x, y, z}
             * @param {number} contourLevel - Contour elevation level
             * @returns {Object|null} Intersection point {x, y} or null
             */
            function intersectEdgeWithContour(p1, p2, contourLevel) {
                const z1 = p1.z;
                const z2 = p2.z;

                // Check if contour level is between z1 and z2
                if ((z1 <= contourLevel && z2 >= contourLevel) ||
                    (z1 >= contourLevel && z2 <= contourLevel)) {

                    // Avoid division by zero
                    if (Math.abs(z2 - z1) < 1e-10) {
                        // Edge is horizontal at contour level
                        if (Math.abs(z1 - contourLevel) < 1e-6) {
                            // Return midpoint
                            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                        }
                        return null;
                    }

                    // Linear interpolation
                    const t = (contourLevel - z1) / (z2 - z1);
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }

                return null;
            }

            /**
             * Extract contour line from a single triangle
             * @param {Object} triangle - Triangle object with vertices and plane
             * @param {number} contourLevel - Contour elevation level
             * @returns {Array|null} Array of intersection points or null
             */
            function extractContourFromTriangle(triangle, contourLevel) {
                const [v0, v1, v2] = triangle.vertices;
                const intersections = [];

                // Check each edge
                const i1 = intersectEdgeWithContour(v0, v1, contourLevel);
                const i2 = intersectEdgeWithContour(v1, v2, contourLevel);
                const i3 = intersectEdgeWithContour(v2, v0, contourLevel);

                if (i1) intersections.push(i1);
                if (i2) intersections.push(i2);
                if (i3) intersections.push(i3);

                // A triangle can have 0 or 2 intersections with a contour plane
                if (intersections.length === 2) {
                    return intersections;
                }

                return null;
            }






            // Douglas-Peucker simplification
            function simplifyContour(points, tolerance) {
                if (!points || points.length <= 2) return points;

                let maxDist = 0;
                let index = 0;
                const end = points.length - 1;

                for (let i = 1; i < end; i++) {
                    const d = perpendicularDistance(points[i], points[0], points[end]);
                    if (d > maxDist) {
                        maxDist = d;
                        index = i;
                    }
                }

                if (maxDist > tolerance) {
                    const left = simplifyContour(points.slice(0, index + 1), tolerance);
                    const right = simplifyContour(points.slice(index), tolerance);
                    return left.slice(0, -1).concat(right);
                } else {
                    return [points[0], points[end]];
                }
            }

            function perpendicularDistance(p, a, b) {
                const l2 = (b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2;
                if (l2 === 0) return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
                const t = ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / l2;
                const tClamped = Math.max(0, Math.min(1, t));
                return Math.sqrt(
                    (p[0] - (a[0] + tClamped * (b[0] - a[0]))) ** 2 +
                    (p[1] - (a[1] + tClamped * (b[1] - a[1]))) ** 2
                );
            }

            // Enhanced smoothing using Chaikin's corner cutting algorithm with improved quality
            function smoothContour(line, iterations) {
                if (line.length < 3) return line;

                // Use Chaikin's algorithm with more iterations for better smoothness
                let smoothed = line.slice();

                // Apply Chaikin smoothing multiple times
                for (let iter = 0; iter < iterations; iter++) {
                    const newLine = [];

                    // Always keep the first point
                    newLine.push(smoothed[0]);

                    // Process each segment
                    for (let j = 0; j < smoothed.length - 1; j++) {
                        const p1 = smoothed[j];
                        const p2 = smoothed[j + 1];

                        // Chaikin's corner cutting: create two new points
                        const q = [
                            0.75 * p1[0] + 0.25 * p2[0],
                            0.75 * p1[1] + 0.25 * p2[1]
                        ];
                        const r = [
                            0.25 * p1[0] + 0.75 * p2[0],
                            0.25 * p1[1] + 0.75 * p2[1]
                        ];

                        newLine.push(q, r);
                    }

                    // Always keep the last point
                    newLine.push(smoothed[smoothed.length - 1]);

                    smoothed = newLine;
                }

                // Catmull-Rom removed for performance. Chaikin is sufficient for professional contours.
                return smoothed;
            }

            // Catmull-Rom spline interpolation
            function catmullRomSpline(p0, p1, p2, p3, t, tension) {
                const t2 = t * t;
                const t3 = t2 * t;

                // Catmull-Rom basis matrix
                const m00 = -tension * t3 + 2 * tension * t2 - tension * t;
                const m01 = (2 - tension) * t3 + (tension - 3) * t2 + 1;
                const m02 = (tension - 2) * t3 + (3 - 2 * tension) * t2 + tension * t;
                const m03 = tension * t3 - tension * t2;

                return [
                    m00 * p0[0] + m01 * p1[0] + m02 * p2[0] + m03 * p3[0],
                    m00 * p0[1] + m01 * p1[1] + m02 * p2[1] + m03 * p3[1]
                ];
            }

            function generateContoursFromGrid(gridData, interval, majorInterval) {
                console.log('--- DEBUG: generateContoursFromGrid CALLED ---');
                console.log('Interval:', interval, 'Major:', majorInterval);
                const { grid, width, height, cellSize, bounds } = gridData;

                // Validate bounds
                if (!bounds || !isFinite(bounds.minZ) || !isFinite(bounds.maxZ)) {
                    console.error('Invalid bounds in gridData:', bounds);
                    // Try to calculate from grid
                    let minZ = Infinity;
                    let maxZ = -Infinity;
                    for (let row = 0; row < height; row++) {
                        for (let col = 0; col < width; col++) {
                            const elev = grid[row][col];
                            if (elev !== null && elev !== undefined && isFinite(elev)) {
                                if (elev < minZ) minZ = elev;
                                if (elev > maxZ) maxZ = elev;
                            }
                        }
                    }
                    if (!isFinite(minZ) || !isFinite(maxZ)) {
                        throw new Error('No valid elevation data in grid. Cannot generate contours.');
                    }
                    bounds.minZ = minZ;
                    bounds.maxZ = maxZ;
                    console.log('Calculated elevation range from grid:', minZ, 'to', maxZ);
                }

                console.log('Contour generation parameters:', {
                    elevationRange: `${bounds.minZ.toFixed(2)}m to ${bounds.maxZ.toFixed(2)}m`,
                    interval: interval,
                    majorInterval: majorInterval,
                    gridSize: `${width}x${height}`,
                    cellSize: cellSize
                });

                const minElev = Math.floor(bounds.minZ / interval) * interval;
                const maxElev = Math.ceil(bounds.maxZ / interval) * interval;

                console.log('Contour levels will be generated from', minElev, 'to', maxElev, 'at', interval, 'm intervals');

                if (minElev >= maxElev) {
                    throw new Error(`Invalid elevation range: ${minElev} to ${maxElev}. Elevation range is ${bounds.minZ.toFixed(2)}m to ${bounds.maxZ.toFixed(2)}m. Interval ${interval}m may be too large.`);
                }

                const allContours = [];
                let totalSegments = 0;
                let totalPolylines = 0;

                for (let elevation = minElev; elevation <= maxElev; elevation += interval) {
                    updateLoadingProgress(`Generating contour ${elevation.toFixed(1)}m...`);

                    const segments = marchingSquares(grid, width, height, elevation);
                    totalSegments += segments.length;

                    if (segments.length === 0) {
                        continue; // No segments for this elevation
                    }

                    const polylines = connectSegments(segments, cellSize);
                    totalPolylines += polylines.length;

                    if (polylines.length === 0) {
                        console.warn(`No polylines for elevation ${elevation}m (had ${segments.length} segments)`);
                        continue;
                    }

                    // Convert grid coordinates to geographic coordinates
                    // Note: In grid space, (0,0) is top-left, but in Web Mercator Y increases northward
                    // The grid is organized with row 0 = minY (south), row height-1 = maxY (north)
                    // So we need to flip Y: gridY = 0 means worldY = minY, gridY = height means worldY = maxY
                    const geoLines = polylines.map(line =>
                        line.map(p => {
                            // p.x and p.y are in grid coordinates (0 to width, 0 to height)
                            // Convert to world coordinates
                            const worldX = bounds.minX + p.x * cellSize;
                            // Y axis: grid Y=0 is at minY (south), grid Y=height is at maxY (north)
                            // So: worldY = minY + (height - p.y) * cellSize
                            // But actually, if grid is row-major with row 0 = minY, then:
                            // worldY = minY + p.y * cellSize (this is correct)
                            const worldY = bounds.minY + p.y * cellSize;
                            return [worldX, worldY];
                        })
                    );

                    // Merge any remaining broken segments in geographic coordinates
                    // Use a larger threshold for geographic coordinates (in meters)
                    // FIXED: 150% of cell size ensures proper merging of adjacent segments
                    const geoThreshold = cellSize * 1.5;
                    const mergedGeoLines = mergeContourSegments(geoLines, geoThreshold);

                    // Force smoothing by default for professional results, unless explicitly disabled
                    // Use 3 iterations which is optimal compromise between smoothness and performance
                    // DEBUG: FORCE ENABLE SMOOTHING locally to ensure mesh is fixed
                    const forceSmooth = true;
                    const smoothIterations = (terrain3DState.smoothContours !== false || forceSmooth) ? (terrain3DState.smoothIterations || 3) : 0;
                    if (smoothIterations > 0 && Math.random() < 0.01) console.log('DEBUG: Smoothing enabled with iterations:', smoothIterations);
                    const smoothedLines = smoothIterations > 0
                        ? mergedGeoLines.map(line => {
                            // Simplify first to remove unnecessary points
                            const simplified = simplifyContour(line, cellSize * 0.1);
                            // Apply multiple passes of smoothing for better results
                            let smoothed = simplified;
                            for (let i = 0; i < smoothIterations; i++) {
                                smoothed = smoothContour(smoothed, 1);
                            }
                            return smoothed;
                        })
                        : mergedGeoLines;

                    if (smoothedLines.length > 0) {
                        allContours.push({
                            elevation: elevation,
                            lines: smoothedLines,
                            isMajor: (elevation % majorInterval) === 0
                        });
                    }
                }

                console.log(`Contour generation complete: ${allContours.length} contour levels, ${totalSegments} total segments, ${totalPolylines} total polylines`);

                if (allContours.length === 0) {
                    // Calculate valid cells
                    let validCells = 0;
                    let sampleElevations = [];
                    for (let row = 0; row < Math.min(10, height); row++) {
                        for (let col = 0; col < Math.min(10, width); col++) {
                            const elev = grid[row][col];
                            if (elev !== null && elev !== undefined && isFinite(elev)) {
                                validCells++;
                                if (sampleElevations.length < 5) {
                                    sampleElevations.push(elev);
                                }
                            }
                        }
                    }

                    const debugInfo = {
                        elevationRange: `${bounds.minZ.toFixed(2)}m to ${bounds.maxZ.toFixed(2)}m`,
                        interval: interval,
                        minElev: minElev,
                        maxElev: maxElev,
                        elevationRangeSize: (bounds.maxZ - bounds.minZ).toFixed(2) + 'm',
                        totalSegments: totalSegments,
                        totalPolylines: totalPolylines,
                        gridSize: `${width}x${height}`,
                        cellSize: cellSize,
                        bounds: bounds,
                        sampleElevations: sampleElevations,
                        validCellsSample: validCells
                    };

                    console.error('No contours generated. Debug info:', debugInfo);
                    console.error('Full debug object:', JSON.stringify(debugInfo, null, 2));
                }

                return allContours;
            }

            // E. CONTOUR GENERATION FUNCTIONS - REMOVED - REPLACED WITH SINGLE CLOUDFLARE WORKER PIPELINE

            /**
             * Scale-aware major contour interval calculation
             * @param {number} interval - Base contour interval
             * @param {number} minZ - Minimum elevation
             * @param {number} maxZ - Maximum elevation
             * @returns {number} Major contour interval
             */
            function computeMajorInterval(interval, minZ, maxZ) {
                const range = maxZ - minZ;

                if (range <= 10) return interval * 2;   // small engineering sites
                if (range <= 30) return interval * 5;
                if (range <= 100) return interval * 10;
                return interval * 25;
            }

            /**
             * SINGLE CONTOUR ENTRY POINT - Uses Cloudflare worker as primary, local worker as fallback
             * @param {Array} grid - DTM grid from terrain generation
             * @param {Object} meta - Grid metadata {width, height, bounds, cellSize}
             * @returns {Promise<Object>} GeoJSON FeatureCollection with contours
             */
            async function generateContoursFromDTM(grid, meta) {
                const { width, height, bounds, cellSize } = meta;
                const interval = terrain3DState.contourInterval || 5;

                // Calculate major interval based on elevation range
                const majorInterval = computeMajorInterval(interval, bounds.minZ, bounds.maxZ);

                console.log(`🎯 Single contour pipeline: interval=${interval}m, major=${majorInterval}m, range=${bounds.minZ.toFixed(1)}-${bounds.maxZ.toFixed(1)}m`);
                console.log('DTM bounds for contours:', bounds);
                console.log('Bounds validation - should be in EPSG:3857:', {
                    rangeX: bounds.maxX - bounds.minX,
                    rangeY: bounds.maxY - bounds.minY,
                    expectedRange: (bounds.maxX - bounds.minX) > 1000 ? 'OK' : 'TOO SMALL',
                    coordsInMillions: Math.abs(bounds.minX) > 1000000 ? 'YES' : 'NO',
                    sampleCoords: {
                        minX: bounds.minX,
                        maxX: bounds.maxX,
                        minY: bounds.minY,
                        maxY: bounds.maxY
                    }
                });

                // CRITICAL FIX: Ensure bounds are in EPSG:3857 for contour generation
                let correctedBounds = bounds;
                console.log('Original bounds:', bounds);
                if (Math.abs(bounds.minX) < 180 && Math.abs(bounds.maxX) < 180) {
                    console.warn('⚠️ Bounds appear to be in lat/lng (EPSG:4326), converting to EPSG:3857!');
                    console.log('Converting from EPSG:4326 to EPSG:3857...');
                    // Convert lat/lng bounds to EPSG:3857
                    const min3857 = ol.proj.transform([bounds.minX, bounds.minY], 'EPSG:4326', 'EPSG:3857');
                    const max3857 = ol.proj.transform([bounds.maxX, bounds.maxY], 'EPSG:4326', 'EPSG:3857');
                    console.log('Transform results:', { min3857, max3857 });
                    correctedBounds = {
                        minX: min3857[0],
                        maxX: max3857[0],
                        minY: min3857[1],
                        maxY: max3857[1],
                        minZ: bounds.minZ,
                        maxZ: bounds.maxZ
                    };
                    console.log('Converted bounds to EPSG:3857:', correctedBounds);
                } else {
                    console.log('Bounds already appear to be in EPSG:3857, using as-is');
                }

                try {
                    // PRIMARY: Try Cloudflare worker first
                    console.log('Trying Cloudflare worker...');
                    const cloudflareResult = await generateContoursCloudflare(grid, width, height, correctedBounds, cellSize, interval, majorInterval);
                    console.log(`✅ Cloudflare worker generated ${cloudflareResult.features.length} contours`);
                    return cloudflareResult;

                } catch (cloudflareError) {
                    console.warn('⚠️ Cloudflare worker failed, falling back to local worker:', cloudflareError.message);

                    try {
                        // FALLBACK: Local web worker
                        console.log('Trying local web worker fallback...');
                        const localResult = await generateContoursLocalWorker(grid, width, height, correctedBounds, cellSize, interval, majorInterval);
                        console.log(`✅ Local worker generated ${localResult.features.length} contours`);
                        return localResult;

                    } catch (localError) {
                        console.error('❌ Both contour workers failed:', { cloudflare: cloudflareError.message, local: localError.message });
                        throw new Error(`Contour generation failed: Cloudflare (${cloudflareError.message}), Local (${localError.message})`);
                    }
                }
            }

            /**
             * Generate contours using Cloudflare worker
             */
            async function generateContoursCloudflare(grid, width, height, bounds, cellSize, interval, majorInterval) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                try {
                    const payload = {
                        grid,
                        width,
                        height,
                        bounds,
                        cellSize,
                        interval,
                        majorInterval,
                        blurPasses: 2
                    };

                    console.log('Cloudflare worker payload:', {
                        gridSize: `${width}x${height}`,
                        bounds: bounds,
                        cellSize: cellSize,
                        interval: interval,
                        majorInterval: majorInterval
                    });

                    const response = await fetch('https://contours.geospatialnetworkug.xyz/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const geojson = await response.json();
                    console.log('Cloudflare worker response:', geojson);
                    if (geojson.features && geojson.features.length > 0) {
                        console.log('First few contour coordinates:', geojson.features.slice(0, 3).map(f => f.geometry.coordinates.slice(0, 3)));
                    }

                    // Validate response
                    if (!geojson || !geojson.type || geojson.type !== 'FeatureCollection' || !Array.isArray(geojson.features)) {
                        throw new Error('Invalid GeoJSON response from Cloudflare worker');
                    }

                    return geojson;

                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('Cloudflare worker timeout (30s)');
                    }
                    throw error;
                }
            }

            /**
             * Generate contours using local web worker fallback
             */
            async function generateContoursLocalWorker(grid, width, height, bounds, cellSize, interval, majorInterval) {
                return new Promise((resolve, reject) => {
                    console.log('Creating local contour worker...');
                    const worker = new Worker('contour-worker.js');
                    console.log('Local worker created successfully');

                    const timeoutId = setTimeout(() => {
                        worker.terminate();
                        reject(new Error('Local worker timeout (60s)'));
                    }, 60000);

                    worker.onmessage = function (e) {
                        clearTimeout(timeoutId);
                        const { type, payload } = e.data;

                        if (type === 'contours-complete') {
                            console.log('Local worker completed, result:', payload);
                            if (payload.features && payload.features.length > 0) {
                                console.log('First few local contour coordinates:', payload.features.slice(0, 3).map(f => f.geometry.coordinates.slice(0, 3)));
                            }
                            worker.terminate();
                            resolve(payload);
                        } else if (type === 'error') {
                            worker.terminate();
                            reject(new Error(payload.message));
                        }
                    };

                    worker.onerror = function (error) {
                        clearTimeout(timeoutId);
                        worker.terminate();
                        reject(new Error('Local worker error: ' + error.message));
                    };

                    console.log('Sending payload to local worker:', {
                        gridSize: `${width}x${height}`,
                        bounds: bounds,
                        cellSize: cellSize,
                        interval: interval,
                        majorInterval: majorInterval,
                        gridSample: grid.slice(0, 3).map(row => row.slice(0, 3))  // First 3x3 of grid
                    });

                    worker.postMessage({
                        type: 'generate-contours',
                        payload: {
                            grid,
                            width,
                            height,
                            bounds,
                            cellSize,
                            interval,
                            majorInterval,
                            blurPasses: 2,
                            simplifyTolerance: cellSize * 0.3,
                            smoothIterations: 2
                        }
                    });
                });
            }

            // Make functions globally available
            window.generateContoursFromDTM = generateContoursFromDTM;

            // Helper: Simplify contour by removing points that are too close together
            function simplifyContour(line, tolerance) {
                if (line.length < 3) return line;

                const simplified = [line[0]];

                for (let i = 1; i < line.length - 1; i++) {
                    const prev = line[i - 1];
                    const curr = line[i];
                    const next = line[i + 1];

                    // Calculate distance from current point to line segment between prev and next
                    const dx = next[0] - prev[0];
                    const dy = next[1] - prev[1];
                    const len = Math.sqrt(dx * dx + dy * dy);

                    if (len < 0.001) {
                        // Points are too close, skip current point
                        continue;
                    }

                    // Distance from point to line
                    const dist = Math.abs(
                        (dy * curr[0] - dx * curr[1] + next[0] * prev[1] - next[1] * prev[0]) / len
                    );

                    // Keep point if it's far enough from the line
                    if (dist > tolerance) {
                        simplified.push(curr);
                    }
                }

                // Always keep the last point
                simplified.push(line[line.length - 1]);

                return simplified;
            }

            // Helper: Simplify contour by removing points that are too close together
            function simplifyContour(line, tolerance) {
                if (line.length < 3) return line;

                const simplified = [line[0]];

                for (let i = 1; i < line.length - 1; i++) {
                    const prev = line[i - 1];
                    const curr = line[i];
                    const next = line[i + 1];

                    // Calculate distance from current point to line segment between prev and next
                    const dx = next[0] - prev[0];
                    const dy = next[1] - prev[1];
                    const len = Math.sqrt(dx * dx + dy * dy);

                    if (len < 0.001) {
                        // Points are too close, skip current point
                        continue;
                    }

                    // Distance from point to line
                    const dist = Math.abs(
                        (dy * curr[0] - dx * curr[1] + next[0] * prev[1] - next[1] * prev[0]) / len
                    );

                    // Keep point if it's far enough from the line
                    if (dist > tolerance) {
                        simplified.push(curr);
                    }
                }

                // Always keep the last point
                simplified.push(line[line.length - 1]);

                return simplified;
            }

            // Helper: Merge broken contour segments into continuous lines
            function mergeContourSegments(segments, thresholdOrCellSize) {
                if (!segments || segments.length === 0) return [];

                // FIXED: Use cellSize * 1.5 as threshold for geographic coordinates
                // This ensures segments get properly merged in geographic space (meters)
                const threshold = Math.max(5, (thresholdOrCellSize || 10) * 1.5);

                const mergedLines = [];
                const used = new Set();

                for (let i = 0; i < segments.length; i++) {
                    if (used.has(i)) continue;

                    // Start with this segment
                    let mergedLine = [...segments[i]];
                    used.add(i);

                    let foundConnection = true;
                    while (foundConnection) {
                        foundConnection = false;
                        const lastPoint = mergedLine[mergedLine.length - 1];
                        const firstPoint = mergedLine[0];

                        // Find closest unused segment
                        let bestMatch = null;
                        let bestDist = Infinity;
                        let connectToEnd = true;

                        for (let j = 0; j < segments.length; j++) {
                            if (used.has(j)) continue;

                            const seg = segments[j];
                            const segStart = seg[0];
                            const segEnd = seg[seg.length - 1];

                            // Check if segment connects to end of merged line
                            const distToEnd = Math.sqrt(
                                Math.pow(segStart[0] - lastPoint[0], 2) +
                                Math.pow(segStart[1] - lastPoint[1], 2)
                            );

                            // Check if segment connects to start of merged line (for closed contours)
                            const distToStart = Math.sqrt(
                                Math.pow(segEnd[0] - firstPoint[0], 2) +
                                Math.pow(segEnd[1] - firstPoint[1], 2)
                            );

                            if (distToEnd < threshold && distToEnd < bestDist) {
                                bestMatch = j;
                                bestDist = distToEnd;
                                connectToEnd = true;
                            } else if (distToStart < threshold && distToStart < bestDist) {
                                bestMatch = j;
                                bestDist = distToStart;
                                connectToEnd = false;
                            }
                        }

                        if (bestMatch !== null) {
                            const seg = segments[bestMatch];
                            if (connectToEnd) {
                                // Append segment to end
                                mergedLine.push(...seg.slice(1));
                            } else {
                                // Prepend segment to start (reversed)
                                mergedLine = [...seg.slice(0, -1).reverse(), ...mergedLine];
                            }
                            used.add(bestMatch);
                            foundConnection = true;
                        }
                    }

                    if (mergedLine.length >= 2) {
                        mergedLines.push(mergedLine);
                    }
                }

                return mergedLines;
            }

            /**
             * Unified Contour Generation Entry Point
             */
            async function generateContourLayer() {
                // Determine grid and meta from state
                const gridData = terrain3DState.gridData;
                if (!gridData) {
                    showToast('Please generate DTM first.', 'warning');
                    return;
                }

                // Prepare metadata
                let extent = null;
                // Prefer DTM layer extent
                if (terrain3DState.dtmLayer) {
                    const src = terrain3DState.dtmLayer.getSource();
                    if (src && src.getImageExtent) extent = src.getImageExtent();
                }
                // Fallback to grid bounds
                if ((!extent || !extent.every(isFinite)) && gridData.bounds) {
                    extent = [gridData.bounds.minX, gridData.bounds.minY, gridData.bounds.maxX, gridData.bounds.maxY];
                }

                if (!extent) {
                    throw new Error('Could not determine DTM extent');
                }

                const meta = {
                    width: gridData.width,
                    height: gridData.height,
                    bounds: {
                        minX: extent[0],
                        minY: extent[1],
                        maxX: extent[2],
                        maxY: extent[3]
                    },
                    cellSize: gridData.cellSize || terrain3DState.cellSize || 5,
                    interval: terrain3DState.contourInterval || 5
                };

                return await generateContoursFromDTM(gridData.grid || gridData, meta);
            }

            // CANONICAL CONTOUR GENERATOR
            async function generateContoursFromDTM(grid, meta = {}) {
                // meta: { width, height, bounds, cellSize, interval }
                if (terrain3DState.contourGenerationInProgress) {
                    console.warn('Contour generation already in progress');
                    return;
                }
                terrain3DState.contourGenerationInProgress = true;
                showLoadingIndicator('Generating contours...');

                try {
                    // 1. Basic assertions
                    if (!grid || !meta.width || !meta.height || !meta.bounds) {
                        throw new Error('Missing grid or meta for contour generation');
                    }

                    // 2. Compute elevation range
                    const { minZ, maxZ } = computeGridElevationRange(grid, meta.width, meta.height);
                    const interval = meta.interval || 5;
                    const majorInterval = computeMajorInterval(interval, minZ, maxZ);

                    console.log(`Contour Gen: Range ${minZ.toFixed(1)} to ${maxZ.toFixed(1)}, Interval: ${interval}, Major: ${majorInterval}`);

                    // 3. Prepare payload: use a RESAMPLED COPY
                    // Use a max dimension (e.g. 512 or 768) to keep payload reasonable for server
                    const MAX_DIM = 768; // Matching worker limit
                    const resampleFactor = Math.ceil(Math.max(meta.width / MAX_DIM, meta.height / MAX_DIM, 1));

                    updateLoadingProgress('Preparing data for server...');
                    const payloadGrid = resampleGridCopy(grid, meta.width, meta.height, resampleFactor);

                    const payload = {
                        grid: payloadGrid,
                        width: Math.floor(meta.width / resampleFactor),
                        height: Math.floor(meta.height / resampleFactor),
                        bounds: meta.bounds,
                        cellSize: meta.cellSize * resampleFactor,
                        interval,
                        majorInterval,
                        blurPasses: 2
                    };

                    // 4. Try server with timeout
                    updateLoadingProgress('Requesting contours from server...');
                    let result;
                    const controller = new AbortController();
                    // Long timeout (30s) because cold start or complex terrain might take time
                    const timer = setTimeout(() => controller.abort(), 30000);

                    try {
                        // Use the correct worker URL from config or hardcoded fallback
                        const workerUrl = (window.CONTOUR_CFG && window.CONTOUR_CFG.workerUrl) ?
                            window.CONTOUR_CFG.workerUrl :
                            'https://contours.geospatialnetworkug.xyz';

                        const res = await fetch(workerUrl + '/generate', {
                            method: 'POST',
                            signal: controller.signal,
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        clearTimeout(timer);
                        if (!res.ok) throw new Error('Server responded ' + res.status);

                        result = await res.json();
                        result.__source = 'server';
                        // Log cache status if available
                        const cacheStatus = res.headers.get('X-Cache');
                        console.log('Contour Server Response:', cacheStatus || 'Unknown');

                    } catch (serverErr) {
                        clearTimeout(timer);
                        console.warn('Server contours failed, falling back to local worker', serverErr);
                        showToast('Server busy, using local processing...', 'info');

                        // 5. Fallback to local worker
                        updateLoadingProgress('Server unavailable. Running local fallback...');
                        // Re-use payload or use original full res? 
                        // Using payload (resampled) is faster and safer for browser
                        // But local worker expects slightly different message format usually
                        // We will adapt the payload for the existing local worker interface
                        result = await runClientFallbackWorker({
                            grid: grid, // Use original grid for local quality if browser can handle it? 
                            // Actually, let's use the resampled one to avoid freezing the UI on huge grids
                            // contour-worker.js usually takes {grid, width, height, ...}
                            ...payload,
                            grid: payload.grid // Ensure it uses the resampled grid
                        });
                        result.__source = 'local';
                    }

                    // 6. Validate result
                    validateWorkerResultCoordinates(result, meta.bounds);

                    // 7. Creating output features
                    updateLoadingProgress('Rendering contours...');

                    const format = new ol.format.GeoJSON();
                    let features = format.readFeatures(result, {
                        dataProjection: 'EPSG:3857',
                        featureProjection: map.getView().getProjection()
                    });

                    // Clip contours to custom extent polygon if enabled
                    if (terrain3DState.useCustomExtent && terrain3DState.customExtent && features.length) {
                        try {
                            updateLoadingProgress('Clipping contours...');
                            const clippingPolygon = terrain3DState.customExtent.getGeometry();
                            const clippedFeatures = [];

                            features.forEach(feature => {
                                const geometry = feature.getGeometry();
                                if (!(geometry instanceof ol.geom.LineString)) {
                                    clippedFeatures.push(feature);
                                    return;
                                }

                                const segments = clipLineStringToPolygon(geometry.getCoordinates(), clippingPolygon);
                                if (!segments.length) return;

                                segments.forEach(segmentCoords => {
                                    if (segmentCoords.length < 2) return;
                                    const cloned = feature.clone();
                                    cloned.setGeometry(new ol.geom.LineString(segmentCoords));
                                    clippedFeatures.push(cloned);
                                });
                            });

                            features = clippedFeatures;
                            console.log(`Contours after polygon clipping: ${features.length}`);
                        } catch (clipErr) {
                            console.warn('Clipping failed:', clipErr);
                        }
                    }

                    // 8. Create/replace contour layer
                    attachContourVectorImageLayer(features, {
                        interval,
                        majorInterval,
                        minZ,
                        maxZ
                    });

                    // 9. Safe fit
                    safeFitToExtent(meta.bounds);

                    hideLoadingIndicator();
                    showToast(`Generated ${features.length} contour segments (${result.__source})`, 'success');
                    return result;

                } catch (err) {
                    hideLoadingIndicator();
                    console.error('Contour generation failed:', err);
                    showToast('Contour generation failed: ' + err.message, 'error');
                    terrain3DState.contourGenerationInProgress = false; // Reset lock
                    throw err; // Re-throw
                } finally {
                    terrain3DState.contourGenerationInProgress = false;
                }
            }

            // === HELPER FUNCTIONS ===

            function computeGridElevationRange(grid, w, h) {
                let minZ = Infinity, maxZ = -Infinity;
                // Sampling check to avoid iterating 10M points? No, we need true range.
                // But we can skip nulls.
                for (let y = 0; y < h; y++) {
                    if (!grid[y]) continue;
                    for (let x = 0; x < w; x++) {
                        const v = grid[y][x];
                        if (v !== null && v !== undefined && isFinite(v)) {
                            if (v < minZ) minZ = v;
                            if (v > maxZ) maxZ = v;
                        }
                    }
                }
                if (!isFinite(minZ)) { minZ = 0; maxZ = 100; } // Fallback
                return { minZ, maxZ };
            }

            function computeMajorInterval(interval, minZ, maxZ) {
                const range = maxZ - minZ;
                // If detailed engineering site (small range), ensure major contours appear
                if (range < 20) return interval * 5;
                // Default logic
                return interval * 5;
            }

            function resampleGridCopy(grid, width, height, factor) {
                if (factor <= 1) return grid.map(row => [...row]); // Deep copy required? Row copy is enough.

                const nw = Math.floor(width / factor);
                const nh = Math.floor(height / factor);
                const out = Array.from({ length: nh }, () => Array(nw).fill(null));

                for (let y = 0; y < nh; y++) {
                    for (let x = 0; x < nw; x++) {
                        let sum = 0, count = 0;
                        // Simple average downsampling
                        for (let dy = 0; dy < factor; dy++) {
                            for (let dx = 0; dx < factor; dx++) {
                                // Boundary check
                                if ((y * factor + dy) < height && (x * factor + dx) < width) {
                                    const v = grid[y * factor + dy][x * factor + dx];
                                    if (v != null && isFinite(v)) {
                                        sum += v;
                                        count++;
                                    }
                                }
                            }
                        }
                        out[y][x] = count ? sum / count : null;
                    }
                }
                return out;
            }

            function validateWorkerResultCoordinates(result, bounds) {
                if (!result.features || !result.features.length) return; // Empty is valid (flat terrain)

                const buffer = Math.max(100, (bounds.maxX - bounds.minX) * 0.5); // Generous buffer
                const minX = bounds.minX - buffer;
                const maxX = bounds.maxX + buffer;
                const minY = bounds.minY - buffer;
                const maxY = bounds.maxY + buffer;

                // Check first few features
                const sample = result.features.slice(0, 5);
                for (const f of sample) {
                    const geom = f.geometry;
                    if (!geom || !geom.coordinates || !geom.coordinates.length) continue;

                    // Handle LineString vs MultiLineString structure if needed, 
                    // but standard GeoJSON LineString is [[x,y], [x,y]]
                    const firstCoord = geom.coordinates[0];
                    // If nested (MultiLineString), it might be [[[x,y]...]]
                    const pt = Array.isArray(firstCoord[0]) ? firstCoord[0] : firstCoord;

                    const [x, y] = pt;
                    if (!isFinite(x) || !isFinite(y)) throw new Error('Invalid coordinates NaN');

                    if (x < minX || x > maxX || y < minY || y > maxY) {
                        console.error('Coordinate Mismatch:', { x, y, bounds });
                        throw new Error('Worker returned coordinates far outside DTM bounds. CRS Mismatch?');
                    }
                }
            }

            function safeFitToExtent(bounds) {
                // Determine safe extent
                const extent = [bounds.minX, bounds.minY, bounds.maxX, bounds.maxY];
                // Sanity check: is it in web mercator world?
                const MAX_WORLD = 20037508.34;
                if (Math.abs(extent[0]) > MAX_WORLD || Math.abs(extent[1]) > MAX_WORLD) {
                    console.warn('Extent outside Web Mercator bounds, not fitting.');
                    return;
                }

                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000,
                    maxZoom: 22
                });
            }

            function attachContourVectorImageLayer(features, { interval, majorInterval, minZ, maxZ }) {
                // VERSION 4.0 - SOLID BROWN CONTOURS WITH MINOR LABELS
                console.log('[CONTOUR v4.0] SOLID brown contours - Major+Minor labels');

                // Create source
                const source = new ol.source.Vector({ features });

                // Compute site diagonal for dynamic label spacing (15m × 30m support)
                const bounds = terrain3DState.gridData?.bounds || { minX: 0, minY: 0, maxX: 100, maxY: 100 };
                const siteWidth = bounds.maxX - bounds.minX;
                const siteHeight = bounds.maxY - bounds.minY;
                const siteDiagonal = Math.sqrt(siteWidth * siteWidth + siteHeight * siteHeight);

                // Dynamic spacing: clamp(diagonal / 8, 5, 40) per prompt
                const metersPerLabel = Math.max(5, Math.min(40, siteDiagonal / 8));

                console.log(`[CONTOUR] Site: ${siteWidth.toFixed(1)}m × ${siteHeight.toFixed(1)}m, Label spacing: ${metersPerLabel.toFixed(1)}m`);

                // ============================================================
                // SINGLE CONTOUR STYLE FUNCTION (ONLY ONE ALLOWED)
                // ============================================================
                const styleFunction = (feature, resolution) => {
                    const elev = feature.get('elevation');
                    const isMajor = feature.get('isMajor');
                    const currentZoom = map.getView().getZoom();

                    // Hide minor contours when zoomed out
                    const showMinor = resolution < 10;
                    if (!isMajor && !showMinor) return null;

                    // --------------------------------------------------------
                    // STROKE STYLE (SOLID ONLY - NO DASHES ALLOWED)
                    // --------------------------------------------------------
                    const strokeColor = isMajor ? '#5A3E1B' : '#C8A46A';  // Brown tones: dark/light
                    const strokeWidth = isMajor ? 2 : 1;

                    const stroke = new ol.style.Stroke({
                        color: strokeColor,
                        width: strokeWidth,
                        lineCap: 'round',
                        lineJoin: 'round',
                        lineDash: undefined  // EXPLICITLY undefined = SOLID (forces cache refresh)
                    });

                    // --------------------------------------------------------
                    // LABEL FILTERING (MAJOR AND MINOR CONTOURS)
                    // --------------------------------------------------------
                    const minLabelZoom = 16;
                    const minLabelZoomMinor = 17;  // Minor contours labeled at higher zoom
                    const maxLabelResolution = 30;  // Don't label if too zoomed out

                    // Label major contours
                    const shouldLabelMajor =
                        isMajor &&
                        currentZoom >= minLabelZoom &&
                        resolution < maxLabelResolution;

                    // Label minor contours at higher zoom
                    const shouldLabelMinor =
                        !isMajor &&
                        currentZoom >= minLabelZoomMinor &&
                        resolution < maxLabelResolution;

                    const shouldLabel = shouldLabelMajor || shouldLabelMinor;

                    let text = null;
                    if (shouldLabel) {
                        // *** RESOLUTION-AWARE REPETITION (NO FIXED PIXELS) ***
                        // repeatPx = metersPerLabel / resolution
                        // Clamp between 100 and 2000 per prompt
                        const repeatPx = Math.max(100, Math.min(2000, metersPerLabel / resolution));

                        text = new ol.style.Text({
                            text: Math.round(elev) + 'm',
                            font: isMajor ? 'bold 11px Arial' : 'italic 10px Arial',  // Different fonts
                            placement: 'line',
                            fill: new ol.style.Fill({ color: '#000000' }),
                            stroke: new ol.style.Stroke({ color: '#ffffff', width: isMajor ? 2.5 : 2 }),
                            overflow: true,
                            repeat: repeatPx,  // WORLD-UNIT-BASED
                            maxAngle: 0.5,
                            padding: [3, 3, 3, 3]
                        });
                    }

                    // *** RETURN SINGLE STYLE OBJECT (NOT ARRAY) ***
                    return new ol.style.Style({
                        stroke: stroke,
                        text: text  // null if not labeling
                    });
                };

                // Remove existing contour layer
                if (terrain3DState.contourLayer) {
                    map.removeLayer(terrain3DState.contourLayer);
                }

                // Create VectorImage layer with decluttering
                terrain3DState.contourLayer = new ol.layer.VectorImage({
                    source: source,
                    style: styleFunction,
                    declutter: true,  // Set ONCE on layer
                    zIndex: 150
                });

                map.addLayer(terrain3DState.contourLayer);
                console.log('[CONTOUR] Layer attached with SOLID lines and resolution-aware labels');
            }

            // ========================================
            // INLINED CONTOUR WORKER CODE
            // (Used to fix SecurityError on local file:// protocol)
            // ========================================
            const CONTOUR_WORKER_CODE = `
// Implements: Gaussian blur pre-processing, contour line tracing,
// topology cleanup, simplification, and smoothing
'use strict';

self.onmessage = function (e) {
    const { type, payload } = e.data;
    try {
        switch (type) {
            case 'generate-contours':
                const result = generateContours(payload);
                self.postMessage({ type: 'contours-complete', payload: result });
                break;
            case 'ping':
                self.postMessage({ type: 'pong' });
                break;
            default:
                throw new Error(\`Unknown message type: \${type}\`);
        }
    } catch (error) {
        self.postMessage({
            type: 'error',
            payload: { message: error.message, stack: error.stack }
        });
    }
};

function generateContours(params) {
    const {
        grid, width, height, bounds, cellSize,
        interval = 5, majorInterval = 25, blurPasses = 1,
        simplifyTolerance = null, smoothIterations = 2
    } = params;

    let processedGrid = grid;
    for (let i = 0; i < blurPasses; i++) {
        processedGrid = blurGrid(processedGrid, width, height);
    }

    let minZ = Infinity, maxZ = -Infinity;
    for (let r = 0; r < height; r++) {
        for (let c = 0; c < width; c++) {
            const val = processedGrid[r][c];
            if (val !== null && isFinite(val)) {
                if (val < minZ) minZ = val;
                if (val > maxZ) maxZ = val;
            }
        }
    }

    if (!isFinite(minZ) || !isFinite(maxZ)) throw new Error('No valid elevation data in grid');

    const minLevel = Math.floor(minZ / interval) * interval;
    const maxLevel = Math.ceil(maxZ / interval) * interval;
    const levels = [];
    for (let elev = minLevel; elev <= maxLevel; elev += interval) levels.push(elev);

    const features = [];
    for (const elevation of levels) {
        const lines = traceContoursAtLevel(processedGrid, width, height, elevation);
        if (lines.length === 0) continue;

        const worldLines = lines.map(line =>
            line.map(p => [
                bounds.minX + p[0] * cellSize,
                bounds.minY + p[1] * cellSize
            ])
        ).filter(line => {
            // Filter out tiny segments that are just noise
            if (line.length < 2) return false;
            const dx = line[line.length-1][0] - line[0][0];
            const dy = line[line.length-1][1] - line[0][1];
            return (dx*dx + dy*dy) > (cellSize * cellSize * 0.25);
        });

        // Use a more aggressive merge threshold
        const mergedLines = mergeLineEndpoints(worldLines, cellSize * 2.5);
        const tolerance = simplifyTolerance || (cellSize * 0.3);
        
        // Filter out short merged lines to reduce clutter (noise/tiny loops)
        const simplifiedLines = mergedLines
            .map(line => simplifyDouglasPeucker(line, tolerance))
            .filter(line => {
                if (line.length < 2) return false;
                // Simple length approximation for filtering
                let len = 0;
                for(let i=1; i<line.length; i++) {
                    const dx = line[i][0]-line[i-1][0], dy = line[i][1]-line[i-1][1];
                    len += Math.sqrt(dx*dx + dy*dy);
                }
                return len > (cellSize * 2); // Relaxed: must be at least 2 cells long
            });

        const smoothedLines = smoothIterations > 0
            ? simplifiedLines.map(line => {
                let result = line;
                for (let i = 0; i < smoothIterations; i++) result = smoothChaikin(result);
                return result;
            })
            : simplifiedLines;

        const isMajor = (elevation % majorInterval) === 0;
        for (const line of smoothedLines) {
            if (line.length < 2) continue;
            features.push({
                type: 'Feature',
                properties: { elevation: elevation, isMajor: isMajor },
                geometry: { type: 'LineString', coordinates: line }
            });
        }
    }

    return { type: 'FeatureCollection', features: features };
}

function blurGrid(grid, width, height) {
    const kernel = [[1/16, 2/16, 1/16], [2/16, 4/16, 2/16], [1/16, 2/16, 1/16]];
    const blurred = new Array(height);
    for (let r = 0; r < height; r++) {
        blurred[r] = new Array(width);
        for (let c = 0; c < width; c++) {
            const centerVal = grid[r][c];
            if (centerVal === null || !isFinite(centerVal)) {
                blurred[r][c] = centerVal;
                continue;
            }
            let sum = 0, weightSum = 0;
            for (let kr = -1; kr <= 1; kr++) {
                for (let kc = -1; kc <= 1; kc++) {
                    const nr = r + kr, nc = c + kc;
                    if (nr >= 0 && nr < height && nc >= 0 && nc < width) {
                        const val = grid[nr][nc];
                        if (val !== null && isFinite(val)) {
                            const weight = kernel[kr + 1][kc + 1];
                            sum += val * weight;
                            weightSum += weight;
                        }
                    }
                }
            }
            blurred[r][c] = weightSum > 0 ? sum / weightSum : centerVal;
        }
    }
    return blurred;
}

function traceContoursAtLevel(grid, width, height, isoValue) {
    const lines = [];
    const visited = new Set();
    for (let row = 0; row < height - 1; row++) {
        for (let col = 0; col < width - 1; col++) {
            const a = grid[row][col], b = grid[row][col + 1], c = grid[row + 1][col + 1], d = grid[row + 1][col];
            if (a === null || b === null || c === null || d === null) continue;
            let cellCase = 0;
            if (a >= isoValue) cellCase |= 1;
            if (b >= isoValue) cellCase |= 2;
            if (c >= isoValue) cellCase |= 4;
            if (d >= isoValue) cellCase |= 8;
            if (cellCase === 0 || cellCase === 15) continue;
            const edgeKeys = getEdgeKeys(row, col, cellCase);
            for (const edgeKey of edgeKeys) {
                if (visited.has(edgeKey)) continue;
                const line = traceContourFromEdge(grid, width, height, isoValue, row, col, edgeKey, visited);
                if (line && line.length >= 2) lines.push(line);
            }
        }
    }
    return lines;
}

function getEdgeKeys(row, col, cellCase) {
    const keys = [];
    const hasTop = ((cellCase & 1) !== 0) !== ((cellCase & 2) !== 0);
    const hasRight = ((cellCase & 2) !== 0) !== ((cellCase & 4) !== 0);
    const hasBottom = ((cellCase & 4) !== 0) !== ((cellCase & 8) !== 0);
    const hasLeft = ((cellCase & 1) !== 0) !== ((cellCase & 8) !== 0);
    if (hasTop) keys.push(\`T:\${row}:\${col}\`);
    if (hasRight) keys.push(\`R:\${row}:\${col}\`);
    if (hasBottom) keys.push(\`B:\${row}:\${col}\`);
    if (hasLeft) keys.push(\`L:\${row}:\${col}\`);
    return keys;
}

function traceContourFromEdge(grid, width, height, isoValue, startRow, startCol, startEdgeKey, visited) {
    const line = [];
    let row = startRow, col = startCol, entryEdge = startEdgeKey.split(':')[0];
    const maxIterations = width * height * 2;
    let iterations = 0;
    while (iterations++ < maxIterations) {
        const a = grid[row][col], b = grid[row][col + 1], c = grid[row + 1][col + 1], d = grid[row + 1][col];
        if (a === null || b === null || c === null || d === null) break;
        const crossings = {};
        if ((a >= isoValue) !== (b >= isoValue)) crossings.T = [col + (isoValue - a) / (b - a), row];
        if ((b >= isoValue) !== (c >= isoValue)) crossings.R = [col + 1, row + (isoValue - b) / (c - b)];
        if ((d >= isoValue) !== (c >= isoValue)) crossings.B = [col + (isoValue - d) / (c - d), row + 1];
        if ((a >= isoValue) !== (d >= isoValue)) crossings.L = [col, row + (isoValue - a) / (d - a)];
        const crossingEdges = Object.keys(crossings).filter(e => e !== entryEdge);
        if (crossingEdges.length === 0) break;
        let exitEdge = crossingEdges[0];
        if (crossingEdges.length > 1) {
            const center = (a + b + c + d) / 4;
            exitEdge = center >= isoValue ? crossingEdges[0] : crossingEdges[crossingEdges.length - 1];
        }
        const point = crossings[exitEdge];
        if (point) line.push(point);
        const edgeKey = \`\${exitEdge}:\${row}:\${col}\`;
        if (visited.has(edgeKey)) break;
        visited.add(edgeKey);
        let nextRow = row, nextCol = col, nextEntryEdge = '';
        switch (exitEdge) {
            case 'T': nextRow = row - 1; nextEntryEdge = 'B'; break;
            case 'R': nextCol = col + 1; nextEntryEdge = 'L'; break;
            case 'B': nextRow = row + 1; nextEntryEdge = 'T'; break;
            case 'L': nextCol = col - 1; nextEntryEdge = 'R'; break;
        }
        if (nextRow < 0 || nextRow >= height - 1 || nextCol < 0 || nextCol >= width - 1) break;
        visited.add(\`\${nextEntryEdge}:\${nextRow}:\${nextCol}\`);
        row = nextRow; col = nextCol; entryEdge = nextEntryEdge;
    }
    return line;
}

function mergeLineEndpoints(lines, threshold) {
    if (lines.length <= 1) return lines;
    const merged = [], used = new Set();
    for (let i = 0; i < lines.length; i++) {
        if (used.has(i)) continue;
        let current = [...lines[i]];
        used.add(i);
        let foundMerge = true;
        while (foundMerge) {
            foundMerge = false;
            for (let j = 0; j < lines.length; j++) {
                if (used.has(j)) continue;
                const other = lines[j];
                const d1 = distance(current[current.length - 1], other[0]);
                const d2 = distance(current[current.length - 1], other[other.length - 1]);
                const d3 = distance(current[0], other[0]);
                const d4 = distance(current[0], other[other.length - 1]);
                const minDist = Math.min(d1, d2, d3, d4);
                if (minDist <= threshold) {
                    used.add(j); foundMerge = true;
                    if (minDist === d1) current = current.concat(other.slice(1));
                    else if (minDist === d2) current = current.concat(other.slice(0, -1).reverse());
                    else if (minDist === d3) current = other.slice(1).reverse().concat(current);
                    else current = other.slice(0, -1).concat(current);
                    break;
                }
            }
        }
        merged.push(current);
    }
    return merged;
}

function distance(p1, p2) {
    const dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return Math.sqrt(dx * dx + dy * dy);
}

function simplifyDouglasPeucker(points, tolerance) {
    if (!points || points.length <= 2) return points;
    let maxDist = 0, maxIndex = 0;
    const end = points.length - 1;
    for (let i = 1; i < end; i++) {
        const d = perpendicularDistance(points[i], points[0], points[end]);
        if (d > maxDist) { maxDist = d; maxIndex = i; }
    }
    if (maxDist > tolerance) {
        const left = simplifyDouglasPeucker(points.slice(0, maxIndex + 1), tolerance);
        const right = simplifyDouglasPeucker(points.slice(maxIndex), tolerance);
        return left.slice(0, -1).concat(right);
    }
    return [points[0], points[end]];
}

function perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd[0] - lineStart[0], dy = lineEnd[1] - lineStart[1], lenSq = dx * dx + dy * dy;
    if (lenSq === 0) return distance(point, lineStart);
    const t = Math.max(0, Math.min(1, ((point[0] - lineStart[0]) * dx + (point[1] - lineStart[1]) * dy) / lenSq));
    return distance(point, [lineStart[0] + t * dx, lineStart[1] + t * dy]);
}

function smoothChaikin(points) {
    if (!points || points.length < 3) return points;
    const smoothed = [points[0]];
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i], p1 = points[i + 1];
        smoothed.push([p0[0] * 0.75 + p1[0] * 0.25, p0[1] * 0.75 + p1[1] * 0.25]);
        smoothed.push([p0[0] * 0.25 + p1[0] * 0.75, p0[1] * 0.25 + p1[1] * 0.75]);
    }
    smoothed.push(points[points.length - 1]);
    return smoothed;
}
`;

            async function runClientFallbackWorker(payload) {
                // Wrapper to use inlined worker code
                return new Promise((resolve, reject) => {
                    let worker;
                    let workerUrl;
                    try {
                        const blob = new Blob([CONTOUR_WORKER_CODE], { type: 'application/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                        worker = new Worker(workerUrl);
                    } catch (err) {
                        return reject(new Error('Failed to initialize local worker: ' + err.message));
                    }

                    worker.onmessage = (e) => {
                        const { type, payload: result } = e.data;

                        if (type === 'contours-complete') {
                            resolve(result);
                            worker.terminate();
                            if (workerUrl) URL.revokeObjectURL(workerUrl);
                        } else if (type === 'error') {
                            reject(new Error(result.message || 'Worker error'));
                            worker.terminate();
                            if (workerUrl) URL.revokeObjectURL(workerUrl);
                        }
                    };

                    worker.onerror = (err) => {
                        reject(err);
                        worker.terminate();
                        if (workerUrl) URL.revokeObjectURL(workerUrl);
                    };

                    // Post message with correct protocol
                    const workerPayload = {
                        grid: payload.grid,
                        width: payload.width,
                        height: payload.height,
                        bounds: payload.bounds,
                        cellSize: payload.cellSize,
                        interval: payload.interval,
                        majorInterval: payload.majorInterval,
                        blurPasses: payload.blurPasses || 1
                    };

                    worker.postMessage({
                        type: 'generate-contours',
                        payload: workerPayload
                    });
                });
            }




            // F. LAYER MANAGEMENT FUNCTIONS

            function clipLineStringToPolygon(coords, polygon) {
                if (!coords || coords.length < 2 || !polygon) return [];

                const clippedSegments = [];
                let currentSegment = [];

                for (let i = 0; i < coords.length - 1; i++) {
                    const start = coords[i];
                    const end = coords[i + 1];
                    const splitPoints = getSegmentSplitPoints(start, end, polygon);

                    for (let j = 0; j < splitPoints.length - 1; j++) {
                        const segStart = splitPoints[j];
                        const segEnd = splitPoints[j + 1];
                        if (pointsEqual(segStart, segEnd)) continue;

                        const mid = [
                            (segStart[0] + segEnd[0]) / 2,
                            (segStart[1] + segEnd[1]) / 2
                        ];

                        if (polygon.intersectsCoordinate(mid)) {
                            if (currentSegment.length === 0) {
                                currentSegment.push(segStart);
                            } else if (!pointsEqual(currentSegment[currentSegment.length - 1], segStart)) {
                                currentSegment.push(segStart);
                            }
                            currentSegment.push(segEnd);
                        } else if (currentSegment.length > 1) {
                            clippedSegments.push(currentSegment);
                            currentSegment = [];
                        } else {
                            currentSegment = [];
                        }
                    }
                }

                if (currentSegment.length > 1) {
                    clippedSegments.push(currentSegment);
                }

                return clippedSegments;
            }

            function getSegmentSplitPoints(start, end, polygon) {
                const points = [start];
                const intersections = findSegmentIntersections(start, end, polygon)
                    .sort((a, b) => a.t - b.t);

                intersections.forEach(intersection => {
                    const lastPoint = points[points.length - 1];
                    if (!pointsEqual(lastPoint, intersection.point)) {
                        points.push(intersection.point);
                    }
                });

                const last = points[points.length - 1];
                if (!pointsEqual(last, end)) {
                    points.push(end);
                }

                return points;
            }

            function findSegmentIntersections(start, end, polygon) {
                const intersections = [];
                if (!polygon || typeof polygon.getCoordinates !== 'function') return intersections;

                const rings = polygon.getCoordinates();
                rings.forEach(ring => {
                    for (let i = 0; i < ring.length - 1; i++) {
                        const intersection = segmentIntersection(start, end, ring[i], ring[i + 1]);
                        if (intersection) {
                            intersections.push(intersection);
                        }
                    }
                });

                return intersections;
            }

            function segmentIntersection(p1, p2, p3, p4) {
                const denom = (p2[0] - p1[0]) * (p4[1] - p3[1]) - (p2[1] - p1[1]) * (p4[0] - p3[0]);
                if (Math.abs(denom) < 1e-12) return null;

                const ua = ((p4[0] - p3[0]) * (p1[1] - p3[1]) - (p4[1] - p3[1]) * (p1[0] - p3[0])) / denom;
                const ub = ((p2[0] - p1[0]) * (p1[1] - p3[1]) - (p2[1] - p1[1]) * (p1[0] - p3[0])) / denom;

                if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null;

                const intersectionPoint = [
                    p1[0] + ua * (p2[0] - p1[0]),
                    p1[1] + ua * (p2[1] - p1[1])
                ];

                const segVec = [p2[0] - p1[0], p2[1] - p1[1]];
                const segLenSq = segVec[0] * segVec[0] + segVec[1] * segVec[1];
                const t = segLenSq > 0
                    ? ((intersectionPoint[0] - p1[0]) * segVec[0] + (intersectionPoint[1] - p1[1]) * segVec[1]) / segLenSq
                    : 0;

                return { point: intersectionPoint, t };
            }

            function pointsEqual(a, b) {
                return Math.abs(a[0] - b[0]) < 1e-7 && Math.abs(a[1] - b[1]) < 1e-7;
            }

            function addPointsLayer(data, showNumbers, showDescriptions) {
                try {
                    // Transform data if needed
                    const transformedData = data[0] && data[0].x ? data : transformCoordinates(
                        data,
                        terrain3DState.coordinateSystem,
                        'EPSG:3857'
                    );

                    const features = transformedData.map(point => {
                        const feature = new ol.Feature({
                            geometry: new ol.geom.Point([point.x, point.y]),
                            point: point.point,
                            description: point.description,
                            elevation: point.elevation
                        });
                        return feature;
                    });

                    const styleFunction = function (feature) {
                        let label = '';
                        if (showNumbers) {
                            label = feature.get('point') || '';
                        }
                        if (showDescriptions && feature.get('description')) {
                            label += (label ? '\n' : '') + feature.get('description');
                        }

                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: terrain3DState.pointSize,
                                fill: new ol.style.Fill({ color: terrain3DState.pointColor }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            }),
                            text: label ? new ol.style.Text({
                                text: label,
                                font: '12px Arial',
                                fill: new ol.style.Fill({ color: '#000' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                                offsetY: -15,
                                textAlign: 'center'
                            }) : undefined
                        });
                    };

                    const pointsSource = new ol.source.Vector({ features: features });
                    const pointsLayer = new ol.layer.Vector({
                        source: pointsSource,
                        style: styleFunction,
                        title: 'Survey Points',
                        zIndex: 70,
                        visible: terrain3DState.showPoints
                    });

                    // Remove old points layer if exists
                    if (terrain3DState.pointsLayer) {
                        map.removeLayer(terrain3DState.pointsLayer);
                    }

                    terrain3DState.pointsLayer = pointsLayer;
                    map.addLayer(pointsLayer);

                    return pointsLayer;

                } catch (error) {
                    console.error('Error adding points layer:', error);
                    showToast('Error adding points layer: ' + error.message, 'error');
                }
            }

            function updateBasemapOpacity(opacity) {
                const basemap = terrain3DState.activeBasemap;
                const opacityValue = opacity / 100;

                if (basemap === 'google' && googleHybrid) {
                    googleHybrid.setOpacity(opacityValue);
                } else if (basemap === 'esri' && esriSatellite) {
                    esriSatellite.setOpacity(opacityValue);
                } else if (basemap === 'osm' && osmLayer) {
                    osmLayer.setOpacity(opacityValue);
                }
            }

            function clearTerrainLayers() {
                if (terrain3DState.dtmLayer) {
                    map.removeLayer(terrain3DState.dtmLayer);
                    terrain3DState.dtmLayer = null;
                }
                if (terrain3DState.contourLayer) {
                    map.removeLayer(terrain3DState.contourLayer);
                    terrain3DState.contourLayer = null;
                }
                if (terrain3DState.pointsLayer) {
                    map.removeLayer(terrain3DState.pointsLayer);
                    terrain3DState.pointsLayer = null;
                }
                if (terrain3DState.classificationLayer) {
                    map.removeLayer(terrain3DState.classificationLayer);
                    terrain3DState.classificationLayer = null;
                }
                if (terrain3DState.analysisLayer) {
                    map.removeLayer(terrain3DState.analysisLayer);
                    terrain3DState.analysisLayer = null;
                    terrain3DState.analysisLayerVisible = true;
                    const analysisToggle = document.getElementById('analysisLayerToggle');
                    if (analysisToggle) {
                        analysisToggle.checked = false;
                        analysisToggle.disabled = true;
                    }
                }

                const disableToggle = (id) => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.checked = false;
                        el.disabled = true;
                    }
                };

                disableToggle('dtmLayerToggle');
                disableToggle('contourLayerToggle');
                disableToggle('classificationLayerToggle');

                terrain3DState.dtmLayerVisible = true;
                terrain3DState.contourLayerVisible = true;
                terrain3DState.classificationLayerVisible = true;

                showToast('All terrain layers cleared', 'info');
            }

            // 3D EXPORT FUNCTIONS

            // Export DTM as STL for 3D printing
            function exportSTL() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Generating STL file...');

                    const gridData = terrain3DState.gridData;
                    const vertExag = parseFloat(document.getElementById('exportVerticalExaggeration')?.value) || 1.0;

                    let stl = 'solid terrain\n';

                    // Generate triangular mesh from grid
                    for (let row = 0; row < gridData.height - 1; row++) {
                        for (let col = 0; col < gridData.width - 1; col++) {
                            const x0 = col * gridData.cellSize;
                            const y0 = row * gridData.cellSize;
                            const x1 = (col + 1) * gridData.cellSize;
                            const y1 = (row + 1) * gridData.cellSize;

                            const z00 = gridData.grid[row][col] * vertExag;
                            const z10 = gridData.grid[row][col + 1] * vertExag;
                            const z01 = gridData.grid[row + 1][col] * vertExag;
                            const z11 = gridData.grid[row + 1][col + 1] * vertExag;

                            // Triangle 1
                            stl += writeSTLTriangle(
                                [x0, y0, z00],
                                [x1, y0, z10],
                                [x0, y1, z01]
                            );

                            // Triangle 2
                            stl += writeSTLTriangle(
                                [x1, y0, z10],
                                [x1, y1, z11],
                                [x0, y1, z01]
                            );
                        }
                    }

                    stl += 'endsolid terrain\n';

                    // Download file
                    const blob = new Blob([stl], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terrain_${new Date().getTime()}.stl`;
                    a.click();
                    URL.revokeObjectURL(url);

                    hideLoadingIndicator();
                    showToast('STL file exported successfully!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('STL export error:', error);
                    showToast('Error exporting STL: ' + error.message, 'error');
                }
            }

            function writeSTLTriangle(v1, v2, v3) {
                // Calculate normal vector
                const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                const n = [
                    u[1] * v[2] - u[2] * v[1],
                    u[2] * v[0] - u[0] * v[2],
                    u[0] * v[1] - u[1] * v[0]
                ];
                const len = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
                n[0] /= len; n[1] /= len; n[2] /= len;

                return `  facet normal ${n[0].toFixed(6)} ${n[1].toFixed(6)} ${n[2].toFixed(6)}\n` +
                    `    outer loop\n` +
                    `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n` +
                    `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n` +
                    `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n` +
                    `    endloop\n` +
                    `  endfacet\n`;
            }

            // Export DTM as OBJ for 3D modeling
            function exportOBJ() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Generating OBJ file...');

                    const gridData = terrain3DState.gridData;
                    const vertExag = parseFloat(document.getElementById('exportVerticalExaggeration')?.value) || 1.0;

                    let obj = '# Terrain Model\n';
                    obj += '# Vertices\n';

                    // Write vertices
                    for (let row = 0; row < gridData.height; row++) {
                        for (let col = 0; col < gridData.width; col++) {
                            const x = col * gridData.cellSize;
                            const y = row * gridData.cellSize;
                            const z = gridData.grid[row][col] * vertExag;
                            obj += `v ${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}\n`;
                        }
                    }

                    obj += '\n# Faces\n';

                    // Write faces (triangles)
                    for (let row = 0; row < gridData.height - 1; row++) {
                        for (let col = 0; col < gridData.width - 1; col++) {
                            const v1 = row * gridData.width + col + 1;
                            const v2 = row * gridData.width + col + 2;
                            const v3 = (row + 1) * gridData.width + col + 1;
                            const v4 = (row + 1) * gridData.width + col + 2;

                            obj += `f ${v1} ${v2} ${v3}\n`;
                            obj += `f ${v2} ${v4} ${v3}\n`;
                        }
                    }

                    // Download file
                    const blob = new Blob([obj], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terrain_${new Date().getTime()}.obj`;
                    a.click();
                    URL.revokeObjectURL(url);

                    hideLoadingIndicator();
                    showToast('OBJ file exported successfully!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('OBJ export error:', error);
                    showToast('Error exporting OBJ: ' + error.message, 'error');
                }
            }

            // Export DTM as GeoTIFF raster
            async function exportGeoTIFF() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Generating GeoTIFF file...');

                    showToast('GeoTIFF export requires server-side processing. Exporting as raw data...', 'info');

                    // For now, export as simple text grid until geotiff.js is properly integrated
                    const gridData = terrain3DState.gridData;
                    let output = `# GeoTIFF Data Export\n`;
                    output += `# Width: ${gridData.width}\n`;
                    output += `# Height: ${gridData.height}\n`;
                    output += `# Cell Size: ${gridData.cellSize}\n`;
                    output += `# Bounds: ${JSON.stringify(gridData.bounds)}\n`;
                    output += `# Data (row-major order):\n`;

                    for (let row = 0; row < gridData.height; row++) {
                        output += gridData.grid[row].join(',') + '\n';
                    }

                    const blob = new Blob([output], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terrain_${new Date().getTime()}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);

                    hideLoadingIndicator();
                    showToast('Grid data exported successfully!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('GeoTIFF export error:', error);
                    showToast('Error exporting GeoTIFF: ' + error.message, 'error');
                }
            }

            // Export DTM as LAS point cloud
            function exportLAS() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Generating LAS point cloud...');

                    const gridData = terrain3DState.gridData;
                    const vertExag = parseFloat(document.getElementById('exportVerticalExaggeration')?.value) || 1.0;

                    // Export as simple XYZ text format (LAS binary requires complex encoding)
                    let xyz = '# LAS Point Cloud Export (XYZ format)\n';
                    xyz += '# X Y Z\n';

                    for (let row = 0; row < gridData.height; row++) {
                        for (let col = 0; col < gridData.width; col++) {
                            const x = gridData.bounds.minX + col * gridData.cellSize;
                            const y = gridData.bounds.minY + row * gridData.cellSize;
                            const z = gridData.grid[row][col] * vertExag;
                            xyz += `${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}\n`;
                        }
                    }

                    const blob = new Blob([xyz], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terrain_pointcloud_${new Date().getTime()}.xyz`;
                    a.click();
                    URL.revokeObjectURL(url);

                    hideLoadingIndicator();
                    showToast('Point cloud exported as XYZ format!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('LAS export error:', error);
                    showToast('Error exporting point cloud: ' + error.message, 'error');
                }
            }

            // BREAKLINE FUNCTIONS

            // Initialize breakline layer with dynamic styling
            function initializeBreaklineLayer() {
                if (!terrain3DState.breaklineLayer) {
                    const breaklineSource = new ol.source.Vector();

                    // Dynamic style function based on breakline type
                    const breaklineStyleFunction = function (feature) {
                        const breaklineType = feature.get('breaklineType') || 'other';
                        const customColor = feature.get('breaklineColor');
                        const typeInfo = terrain3DState.breaklineTypes[breaklineType] || terrain3DState.breaklineTypes.other;
                        const color = customColor || typeInfo.color;

                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: color,
                                width: 3
                            }),
                            image: new ol.style.Circle({
                                radius: 5,
                                fill: new ol.style.Fill({ color: color }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            })
                        });
                    };

                    terrain3DState.breaklineLayer = new ol.layer.Vector({
                        source: breaklineSource,
                        style: breaklineStyleFunction,
                        title: 'Breaklines',
                        zIndex: 80
                    });
                    map.addLayer(terrain3DState.breaklineLayer);
                }
            }

            // Start breakline drawing
            function startBreaklineDrawing() {
                initializeBreaklineLayer();

                // Get selected breakline type from UI or use default
                const typeSelect = document.getElementById('breaklineTypeSelect');
                const selectedType = typeSelect ? typeSelect.value : terrain3DState.currentBreaklineType;

                // Remove existing draw interaction
                if (window.breaklineDrawInteraction) {
                    map.removeInteraction(window.breaklineDrawInteraction);
                }

                window.breaklineDrawInteraction = new ol.interaction.Draw({
                    source: terrain3DState.breaklineLayer.getSource(),
                    type: 'LineString'
                });

                window.breaklineDrawInteraction.on('drawend', function (event) {
                    const feature = event.feature;
                    feature.set('id', 'breakline_' + Date.now());
                    feature.set('type', 'breakline');
                    feature.set('breaklineType', selectedType);

                    // Apply color based on type
                    const typeInfo = terrain3DState.breaklineTypes[selectedType] || terrain3DState.breaklineTypes.other;
                    feature.set('breaklineColor', typeInfo.color);

                    terrain3DState.breaklines.push(feature);
                    updateBreaklineList();

                    // Refresh layer to apply new style
                    terrain3DState.breaklineLayer.getSource().changed();

                    showToast(`${typeInfo.name} added. Remember to regenerate DTM to apply it.`, 'info');

                    // Stop drawing after one line
                    map.removeInteraction(window.breaklineDrawInteraction);
                    window.breaklineDrawInteraction = null;
                });

                map.addInteraction(window.breaklineDrawInteraction);
                const typeInfo = terrain3DState.breaklineTypes[selectedType] || terrain3DState.breaklineTypes.other;
                showToast(`Drawing ${typeInfo.name}. Click on map to draw breakline. Double-click to finish.`, 'info');
            }

            // Import breaklines from file
            async function importBreaklines() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.geojson,.json,.kml';

                input.onchange = async function (event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        showLoadingIndicator('Importing breaklines...');

                        const text = await file.text();
                        let geojson;

                        if (file.name.endsWith('.geojson') || file.name.endsWith('.json')) {
                            geojson = JSON.parse(text);
                        } else {
                            throw new Error('Unsupported file format. Please use GeoJSON.');
                        }

                        initializeBreaklineLayer();

                        const format = new ol.format.GeoJSON();
                        const features = format.readFeatures(geojson, {
                            dataProjection: 'EPSG:4326',
                            featureProjection: 'EPSG:3857'
                        });

                        features.forEach(feature => {
                            feature.set('id', 'breakline_import_' + Date.now() + '_' + Math.random());
                            feature.set('type', 'breakline');

                            // Preserve type/color from GeoJSON properties if present
                            const props = feature.getProperties();
                            const importedType = props.breaklineType || props.type || 'other';
                            const importedColor = props.breaklineColor || props.color;

                            // Validate type
                            const validType = terrain3DState.breaklineTypes[importedType] ? importedType : 'other';
                            feature.set('breaklineType', validType);

                            // Set color
                            if (importedColor) {
                                feature.set('breaklineColor', importedColor);
                            } else {
                                const typeInfo = terrain3DState.breaklineTypes[validType];
                                feature.set('breaklineColor', typeInfo.color);
                            }

                            terrain3DState.breaklines.push(feature);
                            terrain3DState.breaklineLayer.getSource().addFeature(feature);
                        });

                        // Refresh layer to apply styles
                        terrain3DState.breaklineLayer.getSource().changed();

                        updateBreaklineList();
                        hideLoadingIndicator();
                        showToast(`Imported ${features.length} breaklines`, 'success');

                    } catch (error) {
                        hideLoadingIndicator();
                        console.error('Breakline import error:', error);
                        showToast('Error importing breaklines: ' + error.message, 'error');
                    }
                };

                input.click();
            }

            // Update breakline list UI
            function updateBreaklineList() {
                const listEl = document.getElementById('breaklineList');

                if (terrain3DState.breaklines.length === 0) {
                    listEl.innerHTML = '<p style="font-size: 0.85rem; color: #95a5a6; text-align: center; padding: 20px 0;">No breaklines added</p>';
                    return;
                }

                listEl.innerHTML = terrain3DState.breaklines.map((feature, idx) => {
                    const id = feature.get('id');
                    const breaklineType = feature.get('breaklineType') || 'other';
                    const typeInfo = terrain3DState.breaklineTypes[breaklineType] || terrain3DState.breaklineTypes.other;
                    const color = feature.get('breaklineColor') || typeInfo.color;

                    return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f8f9fa; margin-bottom: 5px; border-radius: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            <div style="width: 16px; height: 16px; background: ${color}; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2);" title="${typeInfo.name}"></div>
                            <span style="font-size: 0.85rem; font-weight: 500;">${typeInfo.name}</span>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="editBreakline('${id}')" style="background: #3498db; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.75rem;" title="Edit type/color">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button onclick="removeBreakline('${id}')" style="background: #e74c3c; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.75rem;" title="Remove">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                }).join('');
            }

            // Edit breakline type and color
            window.editBreakline = function (id) {
                const feature = terrain3DState.breaklines.find(f => f.get('id') === id);
                if (!feature) return;

                const currentType = feature.get('breaklineType') || 'other';
                const currentColor = feature.get('breaklineColor') || terrain3DState.breaklineTypes[currentType].color;

                // Create modal for editing
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';

                modal.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 8px; max-width: 400px; width: 90%;">
                    <h3 style="margin: 0 0 15px 0;">Edit Breakline</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Type:</label>
                        <select id="editBreaklineType" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            ${Object.keys(terrain3DState.breaklineTypes).map(type =>
                    `<option value="${type}" ${type === currentType ? 'selected' : ''}>${terrain3DState.breaklineTypes[type].name}</option>`
                ).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Color:</label>
                        <input type="color" id="editBreaklineColor" value="${currentColor}" style="width: 100%; height: 40px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    </div>
                    <div style="display: flex; gap: 8px; justify-content: flex-end;">
                        <button id="cancelEditBreakline" style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                        <button id="saveEditBreakline" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">Save</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                document.getElementById('cancelEditBreakline').onclick = () => {
                    document.body.removeChild(modal);
                };

                document.getElementById('saveEditBreakline').onclick = () => {
                    const newType = document.getElementById('editBreaklineType').value;
                    const newColor = document.getElementById('editBreaklineColor').value;

                    feature.set('breaklineType', newType);
                    feature.set('breaklineColor', newColor);

                    // Refresh layer to apply new style
                    terrain3DState.breaklineLayer.getSource().changed();
                    updateBreaklineList();

                    document.body.removeChild(modal);
                    showToast('Breakline updated', 'success');
                };
            };

            // Remove breakline
            window.removeBreakline = function (id) {
                const index = terrain3DState.breaklines.findIndex(f => f.get('id') === id);
                if (index > -1) {
                    const feature = terrain3DState.breaklines[index];
                    terrain3DState.breaklineLayer.getSource().removeFeature(feature);
                    terrain3DState.breaklines.splice(index, 1);
                    updateBreaklineList();
                    showToast('Breakline removed', 'info');
                }
            };

            // Apply breaklines to grid interpolation
            function applyBreaklinesToGrid(gridData, breaklines) {
                if (!breaklines || breaklines.length === 0) return gridData;

                // For each breakline, enforce exact elevations along its path
                breaklines.forEach(feature => {
                    const geometry = feature.getGeometry();
                    const coordinates = geometry.getCoordinates();

                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const start = coordinates[i];
                        const end = coordinates[i + 1];

                        // Sample along the line segment
                        const segmentLength = Math.sqrt(
                            (end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2
                        );
                        const steps = Math.ceil(segmentLength / gridData.cellSize);

                        for (let step = 0; step <= steps; step++) {
                            const t = step / steps;
                            const x = start[0] + t * (end[0] - start[0]);
                            const y = start[1] + t * (end[1] - start[1]);

                            // Find closest grid cell
                            const col = Math.round((x - gridData.bounds.minX) / gridData.cellSize);
                            const row = Math.round((y - gridData.bounds.minY) / gridData.cellSize);

                            if (row >= 0 && row < gridData.height && col >= 0 && col < gridData.width) {
                                // Mark this cell as a breakline (could store elevation if available)
                                if (!gridData.breaklineMarks) gridData.breaklineMarks = [];
                                if (!gridData.breaklineMarks[row]) gridData.breaklineMarks[row] = [];
                                gridData.breaklineMarks[row][col] = true;
                            }
                        }
                    }
                });

                return gridData;
            }

            // VOLUME CALCULATION FUNCTIONS

            // Calculate volume to reference plane
            function calculateVolumeToPlane() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Calculating volumes...');

                    const gridData = terrain3DState.gridData;
                    const referencePlane = parseFloat(document.getElementById('referencePlaneElevation')?.value) || 0;
                    const cellArea = gridData.cellSize * gridData.cellSize;

                    let cutVolume = 0;
                    let fillVolume = 0;
                    let cellCount = 0;

                    for (let row = 0; row < gridData.height; row++) {
                        for (let col = 0; col < gridData.width; col++) {
                            const elevation = gridData.grid[row][col];
                            if (elevation !== null && elevation !== undefined) {
                                const diff = elevation - referencePlane;
                                if (diff > 0) {
                                    cutVolume += diff * cellArea;
                                } else {
                                    fillVolume += Math.abs(diff) * cellArea;
                                }
                                cellCount++;
                            }
                        }
                    }

                    const netVolume = cutVolume - fillVolume;
                    const avgElevation = (cutVolume - fillVolume + referencePlane * cellCount * cellArea) / (cellCount * cellArea);

                    displayVolumeResults({
                        type: 'Reference Plane',
                        referencePlane: referencePlane.toFixed(2),
                        cutVolume: cutVolume.toFixed(2),
                        fillVolume: fillVolume.toFixed(2),
                        netVolume: netVolume.toFixed(2),
                        avgElevation: avgElevation.toFixed(2),
                        cellCount: cellCount
                    });

                    hideLoadingIndicator();
                    showToast('Volume calculated successfully!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('Volume calculation error:', error);
                    showToast('Error calculating volume: ' + error.message, 'error');
                }
            }

            // Calculate volume within polygon
            function calculateVolumeInPolygon() {
                showToast('Draw a polygon on the map...', 'info');

                // Remove existing draw interaction
                if (window.volumePolygonDrawInteraction) {
                    map.removeInteraction(window.volumePolygonDrawInteraction);
                }

                const volumeSource = new ol.source.Vector();
                const volumeLayer = new ol.layer.Vector({
                    source: volumeSource,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#3498db',
                            width: 2
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(52, 152, 219, 0.2)'
                        })
                    }),
                    zIndex: 85
                });
                map.addLayer(volumeLayer);

                window.volumePolygonDrawInteraction = new ol.interaction.Draw({
                    source: volumeSource,
                    type: 'Polygon'
                });

                window.volumePolygonDrawInteraction.on('drawend', function (event) {
                    const polygon = event.feature.getGeometry();
                    const coords = polygon.getCoordinates()[0];

                    if (!terrain3DState.gridData) {
                        showToast('Please generate DTM first', 'error');
                        return;
                    }

                    showLoadingIndicator('Calculating volumes...');

                    try {
                        const gridData = terrain3DState.gridData;
                        const cellArea = gridData.cellSize * gridData.cellSize;
                        const referencePlane = parseFloat(document.getElementById('referencePlaneElevation')?.value) || 0;

                        let cutVolume = 0;
                        let fillVolume = 0;
                        let cellCount = 0;

                        for (let row = 0; row < gridData.height; row++) {
                            for (let col = 0; col < gridData.width; col++) {
                                const x = gridData.bounds.minX + col * gridData.cellSize;
                                const y = gridData.bounds.minY + row * gridData.cellSize;

                                // Check if point is inside polygon
                                if (isPointInPolygon([x, y], coords)) {
                                    const elevation = gridData.grid[row][col];
                                    if (elevation !== null && elevation !== undefined) {
                                        const diff = elevation - referencePlane;
                                        if (diff > 0) {
                                            cutVolume += diff * cellArea;
                                        } else {
                                            fillVolume += Math.abs(diff) * cellArea;
                                        }
                                        cellCount++;
                                    }
                                }
                            }
                        }

                        const netVolume = cutVolume - fillVolume;
                        const area = cellCount * cellArea;

                        displayVolumeResults({
                            type: 'Polygon Area',
                            area: area.toFixed(2),
                            referencePlane: referencePlane.toFixed(2),
                            cutVolume: cutVolume.toFixed(2),
                            fillVolume: fillVolume.toFixed(2),
                            netVolume: netVolume.toFixed(2),
                            cellCount: cellCount
                        });

                        hideLoadingIndicator();
                        showToast('Polygon volume calculated!', 'success');

                    } catch (error) {
                        hideLoadingIndicator();
                        console.error('Polygon volume error:', error);
                        showToast('Error: ' + error.message, 'error');
                    }

                    map.removeInteraction(window.volumePolygonDrawInteraction);
                    setTimeout(() => map.removeLayer(volumeLayer), 5000); // Remove after 5s
                });

                map.addInteraction(window.volumePolygonDrawInteraction);
            }

            // Helper: Point in polygon test
            function isPointInPolygon(point, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];

                    const intersect = ((yi > point[1]) !== (yj > point[1]))
                        && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            // Compare two surfaces (placeholder - requires two DTMs)
            function compareSurfaces() {
                showToast('Surface comparison requires two DTM datasets. Coming soon!', 'info');
                displayVolumeResults({
                    type: 'Surface Comparison',
                    message: 'This feature requires loading two separate DTM datasets.',
                    note: 'Generate a DTM, save it, then load new data and generate another DTM to compare.'
                });
            }

            // Calculate stockpile volume
            function calculateStockpileVolume() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                try {
                    showLoadingIndicator('Analyzing stockpile...');

                    const gridData = terrain3DState.gridData;
                    const cellArea = gridData.cellSize * gridData.cellSize;

                    // Auto-detect base elevation (use minimum or average of edge cells)
                    const edgeElevations = [];
                    for (let col = 0; col < gridData.width; col++) {
                        if (gridData.grid[0][col]) edgeElevations.push(gridData.grid[0][col]);
                        if (gridData.grid[gridData.height - 1][col]) edgeElevations.push(gridData.grid[gridData.height - 1][col]);
                    }
                    for (let row = 0; row < gridData.height; row++) {
                        if (gridData.grid[row][0]) edgeElevations.push(gridData.grid[row][0]);
                        if (gridData.grid[row][gridData.width - 1]) edgeElevations.push(gridData.grid[row][gridData.width - 1]);
                    }

                    const baseElevation = edgeElevations.reduce((a, b) => a + b, 0) / edgeElevations.length;

                    let volume = 0;
                    let maxHeight = 0;
                    let cellCount = 0;

                    for (let row = 0; row < gridData.height; row++) {
                        for (let col = 0; col < gridData.width; col++) {
                            const elevation = gridData.grid[row][col];
                            if (elevation !== null && elevation !== undefined) {
                                const height = elevation - baseElevation;
                                if (height > 0) {
                                    volume += height * cellArea;
                                    maxHeight = Math.max(maxHeight, height);
                                    cellCount++;
                                }
                            }
                        }
                    }

                    // Estimate tonnage (assume density of 1.8 tons/m³ for typical soil)
                    const tonnage = volume * 1.8;

                    displayVolumeResults({
                        type: 'Stockpile Analysis',
                        baseElevation: baseElevation.toFixed(2),
                        volume: volume.toFixed(2),
                        maxHeight: maxHeight.toFixed(2),
                        tonnage: tonnage.toFixed(2),
                        cellCount: cellCount
                    });

                    hideLoadingIndicator();
                    showToast('Stockpile volume calculated!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('Stockpile calculation error:', error);
                    showToast('Error: ' + error.message, 'error');
                }
            }

            // Display volume results
            function displayVolumeResults(results) {
                // Store results for PDF export
                terrain3DState.lastVolumeResults = results;

                const panel = document.getElementById('volumeResultsPanel');

                let html = `<div style="background: #fff; border: 2px solid #3498db; border-radius: 8px; padding: 15px; margin-top: 15px;">`;
                html += `<h4 style="margin: 0 0 12px 0; color: #3498db; font-size: 1rem;">${results.type}</h4>`;

                if (results.message) {
                    html += `<p style="font-size: 0.9rem; color: #7f8c8d; margin: 8px 0;">${results.message}</p>`;
                    if (results.note) {
                        html += `<p style="font-size: 0.85rem; color: #95a5a6; font-style: italic; margin: 8px 0;">${results.note}</p>`;
                    }
                } else {
                    html += `<table style="width: 100%; font-size: 0.9rem; border-collapse: collapse;">`;

                    for (const [key, value] of Object.entries(results)) {
                        if (key === 'type') continue;
                        const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        html += `<tr style="border-bottom: 1px solid #ecf0f1;">
                        <td style="padding: 8px 0; font-weight: 500;">${label}:</td>
                        <td style="padding: 8px 0; text-align: right;">${value}${key.includes('Volume') || key.includes('volume') ? ' m³' : key.includes('Elevation') || key.includes('elevation') || key.includes('Height') || key.includes('height') ? ' m' : key.includes('tonnage') ? ' tons' : key.includes('area') || key.includes('Area') ? ' m²' : ''}</td>
                    </tr>`;
                    }

                    html += `</table>`;
                }

                html += `</div>`;
                panel.innerHTML = html;
                panel.style.display = 'block';
            }

            // ========================================
            // EXTENT POLYGON FUNCTIONS
            // ========================================

            // Initialize extent layer
            function initializeExtentLayer() {
                if (!terrain3DState.extentLayer) {
                    const extentSource = new ol.source.Vector();
                    terrain3DState.extentLayer = new ol.layer.Vector({
                        source: extentSource,
                        style: createExtentStyle,
                        title: 'Processing Extent',
                        zIndex: 85
                    });
                    map.addLayer(terrain3DState.extentLayer);
                }
            }

            // Create extent polygon style
            function createExtentStyle(feature) {
                const geometry = feature.getGeometry();
                const coordinates = geometry.getCoordinates()[0];
                const styles = [];

                // Main polygon style (no fill, dashed orange stroke)
                styles.push(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#FF6B00',
                        width: 3,
                        lineDash: [10, 5]
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255, 107, 0, 0)' // Transparent
                    })
                }));

                // Add corner labels (A, B, C, D...) - Simple black text with white stroke
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                coordinates.slice(0, -1).forEach((coord, idx) => {
                    styles.push(new ol.style.Style({
                        geometry: new ol.geom.Point(coord),
                        text: new ol.style.Text({
                            text: letters[idx],
                            font: 'bold 14px Arial',
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#FFF', width: 3 }),
                            textAlign: 'center',
                            textBaseline: 'middle',
                            offsetY: -10
                        })
                    }));
                });

                // Add distance labels if enabled - Aligned to polygon edge
                if (terrain3DState.showExtentMeasurements) {
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const start = coordinates[i];
                        const end = coordinates[(i + 1) % (coordinates.length - 1)];
                        const midpoint = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2];
                        const distance = Math.sqrt(
                            Math.pow(end[0] - start[0], 2) + Math.pow(end[1] - start[1], 2)
                        );

                        // Calculate angle to align text along edge
                        const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);

                        // Normalize angle to keep text readable
                        let textAngle = angle;
                        if (textAngle > Math.PI / 2) textAngle -= Math.PI;
                        if (textAngle < -Math.PI / 2) textAngle += Math.PI;

                        styles.push(new ol.style.Style({
                            geometry: new ol.geom.Point(midpoint),
                            text: new ol.style.Text({
                                text: distance.toFixed(1) + 'm',
                                font: 'bold 11px Arial',
                                fill: new ol.style.Fill({ color: '#000' }),
                                stroke: new ol.style.Stroke({ color: '#FFF', width: 2.5 }),
                                textAlign: 'center',
                                textBaseline: 'bottom',
                                rotation: textAngle,
                                offsetY: -5
                            })
                        }));
                    }
                }

                return styles;
            }

            // Start extent polygon drawing
            function startExtentDrawing() {
                initializeExtentLayer();

                // Clear existing extent
                if (terrain3DState.customExtent) {
                    terrain3DState.extentLayer.getSource().clear();
                    terrain3DState.customExtent = null;
                }

                // Remove existing draw interaction
                if (window.extentDrawInteraction) {
                    map.removeInteraction(window.extentDrawInteraction);
                }

                // Create snap interaction if enabled
                let snapInteraction = null;
                if (terrain3DState.snapToPoints && terrain3DState.pointsLayer) {
                    snapInteraction = new ol.interaction.Snap({
                        source: terrain3DState.pointsLayer.getSource(),
                        pixelTolerance: 20
                    });
                    map.addInteraction(snapInteraction);
                }

                window.extentDrawInteraction = new ol.interaction.Draw({
                    source: terrain3DState.extentLayer.getSource(),
                    type: 'Polygon',
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#FF6B00',
                            width: 2,
                            lineDash: [10, 5]
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 107, 0, 0.1)'
                        }),
                        image: new ol.style.Circle({
                            radius: 5,
                            fill: new ol.style.Fill({ color: '#FF6B00' })
                        })
                    })
                });

                window.extentDrawInteraction.on('drawend', function (event) {
                    const feature = event.feature;
                    feature.set('id', 'extent_polygon');
                    feature.set('type', 'extent');

                    terrain3DState.customExtent = feature;

                    // Clean up
                    map.removeInteraction(window.extentDrawInteraction);
                    if (snapInteraction) map.removeInteraction(snapInteraction);
                    window.extentDrawInteraction = null;

                    // Update UI
                    updateExtentInfo();
                    document.getElementById('clearExtentBtn').disabled = false;
                    document.getElementById('clearExtentBtn').style.opacity = '1';
                    document.getElementById('useCustomExtent').disabled = false;
                    document.getElementById('useCustomExtent').checked = true;
                    terrain3DState.useCustomExtent = true;

                    // Save to localStorage
                    saveExtentToLocalStorage();

                    showToast('Extent defined successfully!', 'success');
                });

                map.addInteraction(window.extentDrawInteraction);
                showToast('Click on map to draw extent polygon. Double-click to finish.', 'info');
            }

            // Clear extent polygon
            function clearExtent() {
                if (terrain3DState.extentLayer) {
                    terrain3DState.extentLayer.getSource().clear();
                }
                terrain3DState.customExtent = null;
                terrain3DState.useCustomExtent = false;

                // Update UI
                document.getElementById('extentInfoPanel').style.display = 'none';
                document.getElementById('clearExtentBtn').disabled = true;
                document.getElementById('clearExtentBtn').style.opacity = '0.6';
                document.getElementById('useCustomExtent').checked = false;
                document.getElementById('useCustomExtent').disabled = true;

                // Clear from localStorage
                localStorage.removeItem('terrain_extent_polygon');

                showToast('Extent cleared', 'info');
            }

            // Update extent info panel
            function updateExtentInfo() {
                if (!terrain3DState.customExtent) return;

                const polygon = terrain3DState.customExtent.getGeometry();
                const area = polygon.getArea(); // square meters
                const coordinates = polygon.getCoordinates()[0];

                // Calculate perimeter
                let perimeter = 0;
                for (let i = 0; i < coordinates.length - 1; i++) {
                    const start = coordinates[i];
                    const end = coordinates[(i + 1) % (coordinates.length - 1)];
                    perimeter += Math.sqrt(
                        Math.pow(end[0] - start[0], 2) + Math.pow(end[1] - start[1], 2)
                    );
                }

                // Count points inside
                if (terrain3DState.useCustomExtent) {
                    const allData = getAllPointsBeforeFiltering();
                    let inside = 0;
                    let outside = 0;

                    allData.forEach(point => {
                        if (polygon.intersectsCoordinate([point.x, point.y])) {
                            inside++;
                        } else {
                            outside++;
                        }
                    });

                    document.getElementById('extentPointsInside').textContent = inside.toLocaleString();
                    document.getElementById('extentPointsExcluded').textContent = outside.toLocaleString();
                }

                // Update UI
                document.getElementById('extentArea').textContent = area.toLocaleString(undefined, { maximumFractionDigits: 0 });
                document.getElementById('extentPerimeter').textContent = perimeter.toFixed(1);
                document.getElementById('extentInfoPanel').style.display = 'block';
            }

            // Get all points before extent filtering
            function getAllPointsBeforeFiltering() {
                let combined = [];
                const dataSource = terrain3DState.dataSource;

                if (dataSource === 'import' || dataSource === 'both') {
                    if (terrain3DState.importedData && terrain3DState.importedData.length > 0) {
                        combined = combined.concat(terrain3DState.importedData);
                    }
                }

                if (dataSource === 'existing' || dataSource === 'both') {
                    const selected = terrain3DState.selectedDatasets || [];
                    if (selected.length > 0) {
                        selected.forEach(dataset => {
                            if (dataset.data && dataset.data.length) {
                                combined = combined.concat(dataset.data);
                            }
                        });
                    } else if (terrain3DState.existingDatasets && terrain3DState.existingDatasets.length > 0) {
                        terrain3DState.existingDatasets.forEach(dataset => {
                            if (dataset.data && dataset.data.length) {
                                combined = combined.concat(dataset.data);
                            }
                        });
                    }
                }

                // Transform to map projection
                return transformCoordinates(combined, terrain3DState.coordinateSystem, 'EPSG:3857');
            }

            // Save extent to localStorage
            function saveExtentToLocalStorage() {
                if (!terrain3DState.customExtent) return;

                const format = new ol.format.GeoJSON();
                const geojson = format.writeFeature(terrain3DState.customExtent, {
                    dataProjection: 'EPSG:4326',
                    featureProjection: 'EPSG:3857'
                });

                localStorage.setItem('terrain_extent_polygon', geojson);
            }

            // Load extent from localStorage
            function loadExtentFromLocalStorage() {
                const stored = localStorage.getItem('terrain_extent_polygon');
                if (!stored) return;

                try {
                    initializeExtentLayer();
                    const format = new ol.format.GeoJSON();
                    const feature = format.readFeature(stored, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: 'EPSG:3857'
                    });

                    terrain3DState.customExtent = feature;
                    terrain3DState.extentLayer.getSource().addFeature(feature);

                    updateExtentInfo();
                    document.getElementById('clearExtentBtn').disabled = false;
                    document.getElementById('clearExtentBtn').style.opacity = '1';
                    document.getElementById('useCustomExtent').disabled = false;

                    showToast('Extent loaded from previous session', 'info');
                } catch (error) {
                    console.error('Error loading extent:', error);
                    localStorage.removeItem('terrain_extent_polygon');
                }
            }

            // Export extent as GeoJSON
            function exportExtentGeoJSON() {
                if (!terrain3DState.customExtent) {
                    showToast('No extent to export', 'error');
                    return;
                }

                const format = new ol.format.GeoJSON();
                const geojson = format.writeFeature(terrain3DState.customExtent, {
                    dataProjection: 'EPSG:4326',
                    featureProjection: 'EPSG:3857'
                });

                const blob = new Blob([geojson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `extent_polygon_${new Date().toISOString().slice(0, 10)}.geojson`;
                link.click();
                URL.revokeObjectURL(url);

                showToast('Extent exported as GeoJSON', 'success');
            }

            // Import extent from GeoJSON
            function importExtentGeoJSON() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.geojson,.json';

                input.onchange = function (event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function (e) {
                        try {
                            initializeExtentLayer();
                            const format = new ol.format.GeoJSON();
                            const feature = format.readFeature(e.target.result, {
                                dataProjection: 'EPSG:4326',
                                featureProjection: 'EPSG:3857'
                            });

                            // Clear existing
                            if (terrain3DState.customExtent) {
                                terrain3DState.extentLayer.getSource().clear();
                            }

                            terrain3DState.customExtent = feature;
                            terrain3DState.extentLayer.getSource().addFeature(feature);

                            updateExtentInfo();
                            document.getElementById('clearExtentBtn').disabled = false;
                            document.getElementById('clearExtentBtn').style.opacity = '1';
                            document.getElementById('useCustomExtent').disabled = false;
                            document.getElementById('useCustomExtent').checked = true;
                            terrain3DState.useCustomExtent = true;

                            saveExtentToLocalStorage();
                            showToast('Extent imported successfully!', 'success');

                        } catch (error) {
                            console.error('Import error:', error);
                            showToast('Error importing extent: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                };

                input.click();
            }

            // TERRAIN CLASSIFICATION FUNCTIONS

            // Classify terrain features
            async function classifyTerrain() {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'error');
                    return;
                }

                const classifyType = document.getElementById('classifyType')?.value || 'basic';

                try {
                    showLoadingIndicator(`Classifying terrain (${classifyType})...`);

                    const gridData = terrain3DState.gridData;
                    let features;

                    if (classifyType === 'basic') {
                        features = classifyBasicFeatures(gridData);
                    } else if (classifyType === 'advanced') {
                        features = classifyAdvancedFeatures(gridData);
                    } else if (classifyType === 'landform') {
                        features = classifyLandforms(gridData);
                    }

                    // Store results for PDF export
                    terrain3DState.lastClassificationResults = features;

                    displayClassificationResults(features, classifyType);
                    visualizeClassification(features, gridData);

                    hideLoadingIndicator();
                    showToast('Terrain classified successfully!', 'success');

                } catch (error) {
                    hideLoadingIndicator();
                    console.error('Classification error:', error);
                    showToast('Error classifying terrain: ' + error.message, 'error');
                }
            }

            // Basic feature classification (peaks, pits, ridges, valleys)
            function classifyBasicFeatures(gridData) {
                const { grid, width, height, cellSize } = gridData;
                const features = {
                    peaks: [],
                    pits: [],
                    ridges: [],
                    valleys: [],
                    passes: []
                };

                for (let row = 2; row < height - 2; row++) {
                    for (let col = 2; col < width - 2; col++) {
                        const z = grid[row][col];
                        if (z === null || z === undefined) continue;

                        // Get 8 neighbors
                        const neighbors = [
                            grid[row - 1][col - 1], grid[row - 1][col], grid[row - 1][col + 1],
                            grid[row][col - 1], grid[row][col + 1],
                            grid[row + 1][col - 1], grid[row + 1][col], grid[row + 1][col + 1]
                        ];

                        const validNeighbors = neighbors.filter(n => n !== null && n !== undefined);
                        if (validNeighbors.length < 6) continue;

                        const maxNeighbor = Math.max(...validNeighbors);
                        const minNeighbor = Math.min(...validNeighbors);
                        const avgNeighbor = validNeighbors.reduce((a, b) => a + b, 0) / validNeighbors.length;

                        // Peak: Higher than all neighbors
                        if (z > maxNeighbor && z - avgNeighbor > 2) {
                            features.peaks.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z,
                                prominence: z - avgNeighbor
                            });
                        }

                        // Pit: Lower than all neighbors
                        if (z < minNeighbor && avgNeighbor - z > 2) {
                            features.pits.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z,
                                depth: avgNeighbor - z
                            });
                        }

                        // Calculate profile curvature for ridge/valley detection
                        const zxx = (grid[row][col + 1] + grid[row][col - 1] - 2 * z) / (cellSize * cellSize);
                        const zyy = (grid[row + 1][col] + grid[row - 1][col] - 2 * z) / (cellSize * cellSize);

                        // Ridge: Negative curvature in profile direction
                        if (zxx < -0.01 && zyy < -0.01) {
                            features.ridges.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z,
                                curvature: (zxx + zyy) / 2
                            });
                        }

                        // Valley: Positive curvature
                        if (zxx > 0.01 && zyy > 0.01) {
                            features.valleys.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z,
                                curvature: (zxx + zyy) / 2
                            });
                        }
                    }
                }

                return features;
            }

            // Advanced feature classification
            function classifyAdvancedFeatures(gridData) {
                const basic = classifyBasicFeatures(gridData);
                const { grid, width, height, cellSize } = gridData;

                // Add more sophisticated features
                const features = {
                    ...basic,
                    saddles: [],
                    planes: [],
                    channels: []
                };

                for (let row = 2; row < height - 2; row++) {
                    for (let col = 2; col < width - 2; col++) {
                        const z = grid[row][col];
                        if (z === null || z === undefined) continue;

                        // Calculate slope
                        const dzdx = (grid[row][col + 1] - grid[row][col - 1]) / (2 * cellSize);
                        const dzdy = (grid[row + 1][col] - grid[row - 1][col]) / (2 * cellSize);
                        const slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy)) * 180 / Math.PI;

                        // Calculate curvature
                        const zxx = (grid[row][col + 1] + grid[row][col - 1] - 2 * z) / (cellSize * cellSize);
                        const zyy = (grid[row + 1][col] + grid[row - 1][col] - 2 * z) / (cellSize * cellSize);

                        // Plane: Low slope and low curvature
                        if (slope < 2 && Math.abs(zxx) < 0.005 && Math.abs(zyy) < 0.005) {
                            features.planes.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z,
                                slope: slope
                            });
                        }

                        // Saddle: Mixed curvature (one positive, one negative)
                        if (zxx * zyy < 0 && Math.abs(zxx) > 0.01 && Math.abs(zyy) > 0.01) {
                            features.saddles.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z
                            });
                        }

                        // Channel: Valley with high curvature
                        if (zyy > 0.02 && slope > 5) {
                            features.channels.push({
                                x: gridData.bounds.minX + col * cellSize,
                                y: gridData.bounds.minY + row * cellSize,
                                z: z
                            });
                        }
                    }
                }

                return features;
            }

            // Landform classification using TPI (Topographic Position Index)
            function classifyLandforms(gridData) {
                const { grid, width, height, cellSize } = gridData;
                const features = {
                    mountains: [],
                    hills: [],
                    plains: [],
                    depressions: [],
                    valleys: []
                };

                const tpiRadius = Math.floor(100 / cellSize); // 100m radius

                for (let row = tpiRadius; row < height - tpiRadius; row++) {
                    for (let col = tpiRadius; col < width - tpiRadius; col++) {
                        const z = grid[row][col];
                        if (z === null || z === undefined) continue;

                        // Calculate TPI (elevation difference from neighborhood mean)
                        let sum = 0;
                        let count = 0;
                        for (let dr = -tpiRadius; dr <= tpiRadius; dr++) {
                            for (let dc = -tpiRadius; dc <= tpiRadius; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nz = grid[row + dr][col + dc];
                                if (nz !== null && nz !== undefined) {
                                    sum += nz;
                                    count++;
                                }
                            }
                        }

                        const meanElev = sum / count;
                        const tpi = z - meanElev;

                        // Calculate slope for additional classification
                        const dzdx = (grid[row][col + 1] - grid[row][col - 1]) / (2 * cellSize);
                        const dzdy = (grid[row + 1][col] - grid[row - 1][col]) / (2 * cellSize);
                        const slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy)) * 180 / Math.PI;

                        const x = gridData.bounds.minX + col * cellSize;
                        const y = gridData.bounds.minY + row * cellSize;

                        // Classification based on TPI and slope
                        if (tpi > 10 && slope > 15) {
                            features.mountains.push({ x, y, z, tpi, slope });
                        } else if (tpi > 5 && slope > 5) {
                            features.hills.push({ x, y, z, tpi, slope });
                        } else if (Math.abs(tpi) < 3 && slope < 5) {
                            features.plains.push({ x, y, z, tpi, slope });
                        } else if (tpi < -10) {
                            features.depressions.push({ x, y, z, tpi, slope });
                        } else if (tpi < -5 && slope < 10) {
                            features.valleys.push({ x, y, z, tpi, slope });
                        }
                    }
                }

                return features;
            }

            // Display classification results
            function displayClassificationResults(features, type) {
                const panel = document.getElementById('classificationResultsPanel');

                let html = `<div style="background: #fff; border: 2px solid #27ae60; border-radius: 8px; padding: 15px; margin-top: 15px;">`;
                html += `<h4 style="margin: 0 0 12px 0; color: #27ae60; font-size: 1rem;">${type.charAt(0).toUpperCase() + type.slice(1)} Classification Results</h4>`;

                html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 0.9rem;">`;

                for (const [featureType, items] of Object.entries(features)) {
                    const count = Array.isArray(items) ? items.length : 0;
                    const label = featureType.charAt(0).toUpperCase() + featureType.slice(1);

                    html += `<div style="background: #ecf0f1; padding: 10px; border-radius: 4px; text-align: center;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 4px;">${label}</div>
                    <div style="font-size: 1.5rem; color: #27ae60; font-weight: bold;">${count}</div>
                </div>`;
                }

                html += `</div></div>`;

                panel.innerHTML = html;
                panel.style.display = 'block';
            }

            // Visualize classification on map
            function visualizeClassification(features, gridData) {
                // Create a vector layer with classified features
                const featureArray = [];

                const colors = {
                    peaks: '#e74c3c',
                    pits: '#3498db',
                    ridges: '#f39c12',
                    valleys: '#27ae60',
                    passes: '#9b59b6',
                    saddles: '#e67e22',
                    planes: '#95a5a6',
                    channels: '#16a085',
                    mountains: '#c0392b',
                    hills: '#d35400',
                    plains: '#f1c40f',
                    depressions: '#2980b9'
                };

                for (const [featureType, items] of Object.entries(features)) {
                    if (!Array.isArray(items) || items.length === 0) continue;

                    items.forEach(item => {
                        const feature = new ol.Feature({
                            geometry: new ol.geom.Point([item.x, item.y]),
                            featureType: featureType,
                            elevation: item.z
                        });

                        feature.setStyle(new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 4,
                                fill: new ol.style.Fill({ color: colors[featureType] || '#333' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
                            })
                        }));

                        featureArray.push(feature);
                    });
                }

                // Remove old classification layer
                if (terrain3DState.classificationLayer) {
                    map.removeLayer(terrain3DState.classificationLayer);
                }

                const classificationSource = new ol.source.Vector({ features: featureArray });
                terrain3DState.classificationLayer = new ol.layer.Vector({
                    source: classificationSource,
                    title: 'Terrain Classification',
                    zIndex: 120
                });

                map.addLayer(terrain3DState.classificationLayer);

                const classToggleEl = document.getElementById('classificationLayerToggle');
                let classVisible = terrain3DState.classificationLayerVisible;
                if (typeof classVisible !== 'boolean') {
                    classVisible = true;
                }
                terrain3DState.classificationLayerVisible = classVisible;
                terrain3DState.classificationLayer.setVisible(classVisible);
                if (classToggleEl) {
                    classToggleEl.disabled = false;
                    classToggleEl.checked = classVisible;
                }
            }

            function saveDTMConfiguration() {
                const config = {
                    dataSource: terrain3DState.dataSource,
                    coordinateSystem: terrain3DState.coordinateSystem,
                    interpolationMethod: terrain3DState.interpolationMethod,
                    colorScheme: terrain3DState.colorScheme,
                    contourInterval: terrain3DState.contourInterval,
                    majorInterval: terrain3DState.majorInterval,
                    activeBasemap: terrain3DState.activeBasemap,
                    basemapOpacity: terrain3DState.basemapOpacity
                };

                localStorage.setItem('terrain3DConfig', JSON.stringify(config));
                showToast('Configuration saved successfully', 'success');
            }

            // Helper functions for loading indicators
            function showLoadingIndicator(message) {
                const overlay = document.getElementById('terrainLoadingOverlay');
                const messageEl = document.getElementById('terrainLoadingMessage');
                if (overlay && messageEl) {
                    messageEl.textContent = message;
                    overlay.classList.add('visible');
                    terrain3DState.isProcessing = true;
                }
            }

            function updateLoadingProgress(progress) {
                const progressEl = document.getElementById('terrainLoadingProgress');
                if (progressEl) {
                    progressEl.textContent = progress;
                }
            }

            function hideLoadingIndicator() {
                const overlay = document.getElementById('terrainLoadingOverlay');
                if (overlay) {
                    overlay.classList.remove('visible');
                    terrain3DState.isProcessing = false;
                }
            }

            // Initialize districts dropdown
            function initializeTerrainDistricts() {
                const select = document.getElementById('terrainSearchDistrict');
                if (select && select.options.length <= 1 && typeof UGANDA_DISTRICTS !== 'undefined') {
                    UGANDA_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        select.appendChild(option);
                    });
                }
            }

            // ========================================
            // 3D TERRAIN UI EVENT HANDLERS
            // ========================================

            // Section collapsible headers
            document.querySelectorAll('.terrain-3d-section-header').forEach(header => {
                header.addEventListener('click', function () {
                    const section = header.dataset.section;
                    const content = document.getElementById(`${section}-content`);
                    const icon = header.querySelector('.toggle-icon');

                    if (content) {
                        if (content.classList.contains('expanded')) {
                            content.classList.remove('expanded');
                            icon.classList.remove('expanded');
                        } else {
                            content.classList.add('expanded');
                            icon.classList.add('expanded');
                        }
                    }
                });
            });

            // Data source radio buttons
            document.querySelectorAll('input[name="dataSource"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    terrain3DState.dataSource = this.value;

                    // Show/hide relevant sections
                    const csvSection = document.getElementById('csv-upload-section');
                    const searchSection = document.getElementById('search-existing-section');
                    const datasetsSection = document.getElementById('datasets-section');

                    if (this.value === 'import') {
                        csvSection.style.display = 'block';
                        searchSection.style.display = 'none';
                        datasetsSection.style.display = 'none';
                    } else if (this.value === 'existing') {
                        csvSection.style.display = 'none';
                        searchSection.style.display = 'block';
                        datasetsSection.style.display = 'block';
                    } else if (this.value === 'both') {
                        csvSection.style.display = 'block';
                        searchSection.style.display = 'block';
                        datasetsSection.style.display = 'block';
                    }

                    // Update radio button styling
                    document.querySelectorAll('.terrain-radio-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.closest('.terrain-radio-option').classList.add('selected');
                });
            });

            // CSV file upload handlers for terrain
            const terrainCsvFileInput = document.getElementById('terrainCsvFileInput');
            const terrainCsvBrowseBtn = document.getElementById('terrainCsvBrowseBtn');
            const terrainCsvUploadArea = document.getElementById('terrainCsvUploadArea');
            const terrainCsvFileInfo = document.getElementById('terrainCsvFileInfo');
            const terrainCsvFileName = document.getElementById('terrainCsvFileName');
            const terrainCsvFileDetails = document.getElementById('terrainCsvFileDetails');

            if (terrainCsvBrowseBtn && terrainCsvFileInput) {
                terrainCsvBrowseBtn.addEventListener('click', () => terrainCsvFileInput.click());

                terrainCsvFileInput.addEventListener('change', async function () {
                    if (this.files.length > 0) {
                        const file = this.files[0];

                        // Check if project exists
                        if (!currentTerrainProject) {
                            showToast('Please create a project first by clicking the 3D Terrain button', 'error');
                            this.value = ''; // Clear file input
                            return;
                        }

                        try {
                            const coordinateSystem = document.getElementById('csvCoordinateSystem').value;

                            // Validate coordinate system matches project
                            if (coordinateSystem !== currentTerrainProject.coordinate_system) {
                                showToast(`Coordinate system mismatch! Project uses ${currentTerrainProject.coordinate_system}, but CSV is ${coordinateSystem}. Please use the correct coordinate system.`, 'error');
                                this.value = ''; // Clear file input
                                return;
                            }

                            const parsedData = await parseCSVFile(file, coordinateSystem);

                            terrain3DState.importedCSV = file;
                            terrain3DState.importedData = parsedData.data;
                            terrain3DState.coordinateSystem = coordinateSystem;

                            terrainCsvUploadArea.classList.add('has-file');
                            terrainCsvFileInfo.classList.add('visible');
                            terrainCsvFileName.textContent = file.name;
                            terrainCsvFileDetails.textContent = `${parsedData.count} points loaded | ${coordinateSystem}`;

                            // Save CSV to Supabase with metadata
                            showLoadingIndicator('Saving CSV to database...');
                            try {
                                const user = await supabase.auth.getUser();
                                if (!user?.data?.user) {
                                    throw new Error('User not authenticated');
                                }

                                // Calculate center point for location
                                const bounds = calculateDataBounds(parsedData.data);
                                const centerLon = (bounds.minX + bounds.maxX) / 2;
                                const centerLat = (bounds.minY + bounds.maxY) / 2;

                                // Transform to WGS84 for storage
                                const wgs84Center = ol.proj.transform(
                                    [centerLon, centerLat],
                                    coordinateSystem,
                                    'EPSG:4326'
                                );

                                // Save CSV file to storage
                                const csvPath = `terrain-csvs/${currentTerrainProject.id}/${file.name}`;
                                const { data: uploadData, error: uploadError } = await supabase.storage
                                    .from('uploads')
                                    .upload(csvPath, file, {
                                        cacheControl: '3600',
                                        upsert: true
                                    });

                                if (uploadError) throw uploadError;

                                // Save metadata to project_files
                                // First check if user has permission, if not, use RPC or service role
                                const { data: fileData, error: fileError } = await supabase
                                    .from('project_files')
                                    .insert([{
                                        file_name: file.name,
                                        file_path: csvPath,
                                        file_type: 'csv',
                                        nature: 'other',
                                        client: currentTerrainProject.client,
                                        project_name: currentTerrainProject.project_name,
                                        coordinate_system: currentTerrainProject.coordinate_system,
                                        district: currentTerrainProject.district,
                                        surveyor: currentTerrainProject.surveyor,
                                        supervisor: currentTerrainProject.supervisor,
                                        latitude: wgs84Center[1],
                                        longitude: wgs84Center[0],
                                        number_of_points: parsedData.count,
                                        uploaded_by: user.data.user.id
                                    }])
                                    .select()
                                    .single();

                                if (fileError) {
                                    console.error('Error saving to project_files:', fileError);
                                    // If RLS error, try using RPC function or just continue without saving metadata
                                    if (fileError.message && fileError.message.includes('row-level security')) {
                                        console.warn('RLS policy error - CSV uploaded but metadata not saved. Please check RLS policies.');
                                        showToast('CSV uploaded but metadata save failed. Please check database permissions.', 'warning');
                                    } else {
                                        throw fileError;
                                    }
                                }

                                // Trigger real-time merge
                                await triggerCSVMerge(fileData.id, currentTerrainProject);

                                hideLoadingIndicator();
                                showToast(`CSV uploaded and saved: ${parsedData.count} points`, 'success');
                            } catch (saveError) {
                                console.error('Error saving CSV:', saveError);
                                hideLoadingIndicator();
                                showToast('CSV loaded but failed to save: ' + saveError.message, 'warning');
                            }

                            // Automatically display points on map if data source is "import" or "both"
                            if (terrain3DState.dataSource === 'import' || terrain3DState.dataSource === 'both') {
                                const combinedData = getCombinedData();
                                if (combinedData.length > 0) {
                                    addPointsLayer(
                                        combinedData,
                                        terrain3DState.showPointNumbers,
                                        terrain3DState.showDescriptions
                                    );

                                    // Zoom to the imported data extent
                                    if (terrain3DState.pointsLayer) {
                                        const extent = terrain3DState.pointsLayer.getSource().getExtent();
                                        if (extent && isFinite(extent[0])) {
                                            map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 1000 });
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            showToast('Error loading CSV: ' + error.message, 'error');
                            terrainCsvUploadArea.classList.remove('has-file');
                            terrainCsvFileInfo.classList.remove('visible');
                            this.value = ''; // Clear file input
                        }
                    }
                });

                // Drag and drop support
                terrainCsvUploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    terrainCsvUploadArea.style.borderColor = '#2980b9';
                    terrainCsvUploadArea.style.background = '#e3f2fd';
                });

                terrainCsvUploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    terrainCsvUploadArea.style.borderColor = '#3498db';
                    terrainCsvUploadArea.style.background = '#f8f9fa';
                });

                terrainCsvUploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    terrainCsvUploadArea.style.borderColor = '#3498db';
                    terrainCsvUploadArea.style.background = '#f8f9fa';

                    if (e.dataTransfer.files.length > 0) {
                        terrainCsvFileInput.files = e.dataTransfer.files;
                        terrainCsvFileInput.dispatchEvent(new Event('change'));
                    }
                });
            }

            // Search existing data button
            const terrainSearchBtn = document.getElementById('terrainSearchBtn');
            if (terrainSearchBtn) {
                terrainSearchBtn.addEventListener('click', async function () {
                    const filters = {
                        district: document.getElementById('terrainSearchDistrict').value,
                        nature: document.getElementById('terrainSearchNature').value,
                        projectName: document.getElementById('terrainSearchProject').value,
                        surveyor: document.getElementById('terrainSearchSurveyor').value,
                        dateFrom: document.getElementById('terrainSearchDateFrom').value,
                        dateTo: document.getElementById('terrainSearchDateTo').value
                    };

                    try {
                        showLoadingIndicator('Searching datasets...');
                        const results = await searchExistingTerrainData(filters);
                        terrain3DState.existingDatasets = results;
                        displayAvailableDatasets(results);
                        plotDatasetPinsOnMap(results);
                        hideLoadingIndicator();

                        if (results.length === 0) {
                            showToast('No datasets found matching criteria', 'info');
                        } else {
                            showToast(`Found ${results.length} datasets`, 'success');
                        }
                    } catch (error) {
                        hideLoadingIndicator();
                        showToast('Search failed: ' + error.message, 'error');
                    }
                });
            }

            // Reset search filters
            const terrainSearchResetBtn = document.getElementById('terrainSearchResetBtn');
            if (terrainSearchResetBtn) {
                terrainSearchResetBtn.addEventListener('click', function () {
                    document.getElementById('terrainSearchDistrict').value = '';
                    document.getElementById('terrainSearchNature').value = '';
                    document.getElementById('terrainSearchProject').value = '';
                    document.getElementById('terrainSearchSurveyor').value = '';
                    document.getElementById('terrainSearchDateFrom').value = '';
                    document.getElementById('terrainSearchDateTo').value = '';

                    document.getElementById('datasetsList').innerHTML = '<p class="no-results">Search for existing data to display datasets</p>';
                    document.getElementById('datasetsCount').textContent = '(0)';
                });
            }

            // Display options handlers
            document.getElementById('showPoints')?.addEventListener('change', function () {
                terrain3DState.showPoints = this.checked;

                // Toggle points layer visibility
                if (terrain3DState.pointsLayer) {
                    terrain3DState.pointsLayer.setVisible(this.checked);
                }
            });

            document.getElementById('showPointNumbers')?.addEventListener('change', function () {
                terrain3DState.showPointNumbers = this.checked;

                // Refresh points layer to update labels
                if (terrain3DState.pointsLayer) {
                    const combinedData = getCombinedData();
                    if (combinedData.length > 0) {
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );
                    }
                }
            });

            document.getElementById('showDescriptions')?.addEventListener('change', function () {
                terrain3DState.showDescriptions = this.checked;

                // Refresh points layer to update labels
                if (terrain3DState.pointsLayer) {
                    const combinedData = getCombinedData();
                    if (combinedData.length > 0) {
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );
                    }
                }
            });

            document.getElementById('pointColor')?.addEventListener('change', function () {
                terrain3DState.pointColor = this.value;

                // Refresh points layer to update color
                if (terrain3DState.pointsLayer) {
                    const combinedData = getCombinedData();
                    if (combinedData.length > 0) {
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );
                    }
                }
            });

            document.getElementById('pointSize')?.addEventListener('input', function () {
                terrain3DState.pointSize = parseInt(this.value);
                document.getElementById('pointSizeValue').textContent = this.value + 'px';

                // Refresh points layer to update size
                if (terrain3DState.pointsLayer) {
                    const combinedData = getCombinedData();
                    if (combinedData.length > 0) {
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );
                    }
                }
            });

            // DTM Configuration handlers

            // Interpolation method
            document.getElementById('interpolationMethod')?.addEventListener('change', function () {
                terrain3DState.interpolationMethod = this.value;
                terrain3DState.gridData = null; // Invalidate grid when method changes
                showToast(`Switched to ${this.value.toUpperCase()} interpolation`, 'info');
            });

            // Grid and IDW parameters
            document.getElementById('cellSize')?.addEventListener('input', function () {
                const value = parseFloat(this.value);
                terrain3DState.cellSize = value;
                document.getElementById('cellSizeValue').textContent = value + 'm';
                terrain3DState.gridData = null; // Invalidate grid when cell size changes
            });

            document.getElementById('idwPower')?.addEventListener('change', function () {
                terrain3DState.idwPower = parseFloat(this.value);
                terrain3DState.gridData = null; // Invalidate grid when IDW parameter changes
            });

            document.getElementById('idwMaxDistance')?.addEventListener('change', function () {
                terrain3DState.idwMaxDistance = parseFloat(this.value);
                terrain3DState.gridData = null; // Invalidate grid when IDW parameter changes
            });

            // Color ramp selection
            document.getElementById('colorRamp')?.addEventListener('change', function () {
                terrain3DState.colorRamp = this.value;
                terrain3DState.colorScheme = this.value; // Keep legacy property in sync
                updateColorSchemePreview(this.value);
            });

            function updateColorSchemePreview(rampName) {
                const preview = document.getElementById('colorSchemePreview');
                if (preview) {
                    const ramps = {
                        viridis: 'linear-gradient(to right, #440154, #3b528b, #21918c, #5ec962, #fde725)',
                        grayscale: 'linear-gradient(to right, #1e1e1e, #505050, #8c8c8c, #c8c8c8, #ffffff)',
                        terrain: 'linear-gradient(to right, #006837, #1a9850, #a6d96a, #d9ef8b, #fee08b, #f46d43, #a50026, #ffffff)',
                        elevation: 'linear-gradient(to right, #000080, #0000ff, #00ffff, #00ff00, #ffff00, #ff8000, #ff0000, #ffffff)',
                        spectral: 'linear-gradient(to right, #9e0142, #fc8d59, #ffffbf, #99d594, #5e4fa2)',
                        plasma: 'linear-gradient(to right, #0d0887, #7e03a8, #cc4778, #f89540, #f0f921)'
                    };
                    preview.style.background = ramps[rampName] || ramps.elevation;
                }
            }

            // Initialize color scheme preview
            updateColorSchemePreview(terrain3DState.colorRamp || 'elevation');

            // Rendering adjustments
            document.getElementById('contrastSlider')?.addEventListener('input', function () {
                terrain3DState.contrast = parseFloat(this.value);
                document.getElementById('contrastValue').textContent = this.value;
            });

            document.getElementById('brightnessSlider')?.addEventListener('input', function () {
                terrain3DState.brightness = parseFloat(this.value);
                document.getElementById('brightnessValue').textContent = this.value;
            });

            // Hillshade toggle and settings
            document.getElementById('hillshadeEnabled')?.addEventListener('change', function () {
                terrain3DState.hillshadeEnabled = this.checked;
                const settings = document.getElementById('hillshadeSettings');
                if (settings) {
                    settings.style.display = this.checked ? 'block' : 'none';
                }
            });

            document.getElementById('multidirectionalHillshade')?.addEventListener('change', function () {
                terrain3DState.multidirectionalHillshade = this.checked;
            });

            document.getElementById('azimuthSlider')?.addEventListener('input', function () {
                terrain3DState.azimuth = parseFloat(this.value);
                document.getElementById('azimuthValue').textContent = this.value + '°';
            });

            document.getElementById('altitudeSlider')?.addEventListener('input', function () {
                terrain3DState.altitude = parseFloat(this.value);
                document.getElementById('altitudeValue').textContent = this.value + '°';
            });

            document.getElementById('zFactorSlider')?.addEventListener('input', function () {
                terrain3DState.zFactor = parseFloat(this.value);
                document.getElementById('zFactorValue').textContent = parseFloat(this.value).toFixed(1);
            });

            document.getElementById('hillshadeBlend')?.addEventListener('change', function () {
                terrain3DState.hillshadeBlend = this.value;
            });

            document.getElementById('hillshadeOpacity')?.addEventListener('input', function () {
                terrain3DState.hillshadeOpacity = parseFloat(this.value) / 100;
                document.getElementById('hillshadeOpacityValue').textContent = this.value + '%';
            });

            // DTM Layer opacity
            document.getElementById('dtmOpacity')?.addEventListener('input', function () {
                terrain3DState.dtmOpacity = parseFloat(this.value) / 100;
                document.getElementById('dtmOpacityValue').textContent = this.value + '%';

                // Update existing layer if present
                if (terrain3DState.dtmLayer) {
                    terrain3DState.dtmLayer.setOpacity(terrain3DState.dtmOpacity);
                }
            });

            // Contour Configuration handlers
            document.getElementById('contourInterval')?.addEventListener('change', function () {
                terrain3DState.contourInterval = parseFloat(this.value);
            });

            document.getElementById('majorInterval')?.addEventListener('change', function () {
                terrain3DState.majorInterval = parseFloat(this.value);
            });

            document.getElementById('minorContourColor')?.addEventListener('change', function () {
                terrain3DState.minorContourColor = this.value;
            });

            document.getElementById('minorContourWidth')?.addEventListener('change', function () {
                terrain3DState.minorContourWidth = parseFloat(this.value);
            });

            document.getElementById('minorContourStyle')?.addEventListener('change', function () {
                terrain3DState.minorContourStyle = this.value;
            });

            document.getElementById('majorContourColor')?.addEventListener('change', function () {
                terrain3DState.majorContourColor = this.value;
            });

            document.getElementById('majorContourWidth')?.addEventListener('change', function () {
                terrain3DState.majorContourWidth = parseFloat(this.value);
            });

            document.getElementById('majorContourStyle')?.addEventListener('change', function () {
                terrain3DState.majorContourStyle = this.value;
            });

            document.getElementById('showContourLabels')?.addEventListener('change', function () {
                terrain3DState.showContourLabels = this.checked;
                const wrapper1 = document.getElementById('labelFrequencyWrapper');
                const wrapper2 = document.getElementById('labelFontSizeWrapper');
                if (wrapper1) wrapper1.style.opacity = this.checked ? '1' : '0.5';
                if (wrapper2) wrapper2.style.opacity = this.checked ? '1' : '0.5';
            });

            document.getElementById('labelFrequency')?.addEventListener('change', function () {
                terrain3DState.labelFrequency = parseInt(this.value);
            });

            document.getElementById('labelFontSize')?.addEventListener('input', function () {
                terrain3DState.labelFontSize = parseInt(this.value);
                document.getElementById('labelFontSizeValue').textContent = this.value + 'px';
            });

            // Enhanced Contour Label Controls
            document.getElementById('maxLabelsPerContour')?.addEventListener('change', function () {
                terrain3DState.maxLabelsPerContour = parseInt(this.value);
                showToast(`Max labels per contour: ${this.value}`, 'info');
            });

            document.getElementById('rotateLabels')?.addEventListener('change', function () {
                terrain3DState.rotateLabels = this.checked;
            });

            // NEW: Minor Contour Label Event Handlers
            document.getElementById('labelMinorContours')?.addEventListener('change', function () {
                terrain3DState.labelMinorContours = this.checked;
                const wrapper = document.getElementById('minorLabelOptions');
                if (wrapper) {
                    wrapper.style.opacity = this.checked ? '1' : '0.5';
                }
                showToast(this.checked ? 'Minor contour labels enabled' : 'Minor contour labels disabled', 'info');
            });

            document.getElementById('minorLabelFrequency')?.addEventListener('change', function () {
                terrain3DState.minorLabelFrequency = parseInt(this.value);
                showToast(`Minor label frequency: Every ${this.value === '1' ? '' : this.value + ' '}contour(s)`, 'info');
            });

            document.getElementById('minorLabelFontSize')?.addEventListener('input', function () {
                terrain3DState.minorLabelFontSize = parseInt(this.value);
                document.getElementById('minorLabelFontSizeValue').textContent = this.value + 'px';
            });

            document.getElementById('minorLabelColor')?.addEventListener('change', function () {
                terrain3DState.minorLabelColor = this.value;
                showToast('Minor label color updated', 'info');
            });

            // Extent Control Event Handlers
            document.getElementById('drawExtentBtn')?.addEventListener('click', startExtentDrawing);
            document.getElementById('clearExtentBtn')?.addEventListener('click', clearExtent);

            document.getElementById('useCustomExtent')?.addEventListener('change', function () {
                terrain3DState.useCustomExtent = this.checked;
                if (this.checked) {
                    updateExtentInfo(); // Recalculate point counts
                }
                showToast(this.checked ? 'Extent filtering enabled' : 'Extent filtering disabled', 'info');
            });

            document.getElementById('snapToPoints')?.addEventListener('change', function () {
                terrain3DState.snapToPoints = this.checked;
            });

            document.getElementById('showExtentOnMap')?.addEventListener('change', function () {
                if (terrain3DState.extentLayer) {
                    terrain3DState.extentLayer.setVisible(this.checked);
                }
            });

            document.getElementById('showExtentMeasurements')?.addEventListener('change', function () {
                terrain3DState.showExtentMeasurements = this.checked;
                // Refresh extent layer
                if (terrain3DState.customExtent && terrain3DState.extentLayer) {
                    terrain3DState.extentLayer.changed();
                }
            });

            document.getElementById('exportExtentBtn')?.addEventListener('click', exportExtentGeoJSON);
            document.getElementById('importExtentBtn')?.addEventListener('click', importExtentGeoJSON);

            // Custom label spacing handler
            document.getElementById('labelSpacingMeters')?.addEventListener('change', function () {
                const customWrapper = document.getElementById('customLabelSpacingWrapper');
                if (this.value === 'custom') {
                    customWrapper.style.display = 'block';
                    const customValue = parseInt(document.getElementById('customLabelSpacing').value);
                    terrain3DState.labelSpacingMeters = customValue;
                    showToast(`Custom label spacing: ${customValue}m`, 'info');
                } else {
                    customWrapper.style.display = 'none';
                    terrain3DState.labelSpacingMeters = parseInt(this.value);
                    showToast(`Label spacing: ${this.value}m`, 'info');
                }
            });

            document.getElementById('customLabelSpacing')?.addEventListener('change', function () {
                const value = parseInt(this.value);
                terrain3DState.labelSpacingMeters = value;
                showToast(`Custom label spacing: ${value}m`, 'info');
            });

            // Load saved extent on page load
            loadExtentFromLocalStorage();

            // Contour smoothing handlers
            // TIN-based contour generation toggle
            const useTINContoursEl = document.getElementById('useTINContours');
            if (useTINContoursEl) {
                // Initialize checkbox state
                useTINContoursEl.checked = terrain3DState.useTINContours !== false; // Default to true

                useTINContoursEl.addEventListener('change', function () {
                    terrain3DState.useTINContours = this.checked;
                    if (this.checked) {
                        showToast('TIN-based contours enabled (QGIS quality). Regenerate contours to apply.', 'info');
                    } else {
                        showToast('DTM grid-based contours enabled. Regenerate contours to apply.', 'info');
                    }
                });
            }

            document.getElementById('smoothContours')?.addEventListener('change', function () {
                terrain3DState.smoothContours = this.checked;
                const wrapper = document.getElementById('smoothIterationsWrapper');
                if (wrapper) {
                    wrapper.style.opacity = this.checked ? '1' : '0.5';
                }
            });

            document.getElementById('smoothIterations')?.addEventListener('input', function () {
                terrain3DState.smoothIterations = parseInt(this.value);
                document.getElementById('smoothIterationsValue').textContent = this.value;
            });

            document.getElementById('simplifyContours')?.addEventListener('change', function () {
                terrain3DState.simplifyContours = this.checked;
                const wrapper = document.getElementById('simplifyToleranceWrapper');
                if (wrapper) {
                    wrapper.style.display = this.checked ? 'block' : 'none';
                }
            });

            document.getElementById('simplifyTolerance')?.addEventListener('input', function () {
                terrain3DState.simplifyTolerance = parseFloat(this.value);
                document.getElementById('simplifyToleranceValue').textContent = parseFloat(this.value).toFixed(1) + 'm';
            });

            // Basemap handlers
            document.querySelectorAll('input[name="basemap"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    terrain3DState.activeBasemap = this.value;

                    // Update basemap styling
                    document.querySelectorAll('.basemap-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.closest('.basemap-option').classList.add('selected');

                    // Apply basemap visibility
                    if (googleHybrid) googleHybrid.setVisible(this.value === 'google');
                    if (esriSatellite) esriSatellite.setVisible(this.value === 'esri');
                    if (osmLayer) osmLayer.setVisible(this.value === 'osm');

                    // Enable/disable opacity slider
                    const opacityWrapper = document.getElementById('basemapOpacityWrapper');
                    if (opacityWrapper) {
                        opacityWrapper.style.opacity = this.value === 'none' ? '0.5' : '1';
                    }
                });
            });

            document.getElementById('basemapOpacity')?.addEventListener('input', function () {
                terrain3DState.basemapOpacity = parseFloat(this.value) / 100;
                document.getElementById('basemapOpacityValue').textContent = this.value + '%';
                updateBasemapOpacity(parseInt(this.value));
            });

            // Action buttons

            // Generate DTM Only
            const generateDTMOnlyBtn = document.getElementById('generateDTMOnlyBtn');
            if (generateDTMOnlyBtn) {
                generateDTMOnlyBtn.addEventListener('click', async function () {
                    try {
                        const combinedData = getCombinedData();

                        console.log('Combined data points:', combinedData.length);
                        console.log('Data source:', terrain3DState.dataSource);
                        console.log('Imported data:', terrain3DState.importedData?.length || 0);
                        console.log('Existing datasets:', terrain3DState.existingDatasets?.length || 0);

                        if (combinedData.length < 3) {
                            showToast(`Not enough data points. Found ${combinedData.length}, need at least 3. Please import a CSV file first.`, 'warning');
                            return;
                        }

                        await generateDTMLayer();

                        // Zoom to extent
                        if (terrain3DState.dtmLayer) {
                            const source = terrain3DState.dtmLayer.getSource();
                            const extent = source.getImageExtent ? source.getImageExtent() : null;
                            if (extent && extent.some(val => isFinite(val))) {
                                map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 1000 });
                            }
                        }

                    } catch (error) {
                        console.error('Error generating DTM:', error);
                        console.error('Error stack:', error.stack);
                        showToast('Error generating DTM: ' + error.message, 'error');
                    }
                });
            }

            // Generate Contours Only
            const generateContoursOnlyBtn = document.getElementById('generateContoursOnlyBtn');
            if (generateContoursOnlyBtn) {
                generateContoursOnlyBtn.addEventListener('click', async function () {
                    try {
                        const combinedData = getCombinedData();

                        console.log('Combined data points:', combinedData.length);
                        console.log('Data source:', terrain3DState.dataSource);

                        if (combinedData.length < 3) {
                            showToast(`Not enough data points. Found ${combinedData.length}, need at least 3. Please import a CSV file first.`, 'warning');
                            return;
                        }

                        // Use the new single contour pipeline
                        await generateContourLayer();

                        // Zoom to extent
                        if (terrain3DState.contourLayer) {
                            const source = terrain3DState.contourLayer.getSource();
                            const extent = source.getExtent ? source.getExtent() : null;
                            console.log('Contour layer source extent:', extent);

                            // For VectorImage layers, we need to calculate extent from features
                            if (!extent || !extent.some(val => isFinite(val))) {
                                console.log('Source extent invalid, calculating from features...');
                                const features = source.getFeatures();
                                console.log(`Found ${features.length} features for extent calculation`);
                                if (features.length > 0) {
                                    const featureExtent = new ol.extent.createEmpty();
                                    features.forEach((feature, i) => {
                                        const geom = feature.getGeometry();
                                        if (geom) {
                                            const geomExtent = geom.getExtent();
                                            ol.extent.extend(featureExtent, geomExtent);
                                            if (i < 3) { // Log first few feature extents
                                                console.log(`Feature ${i} extent:`, geomExtent);
                                            }
                                        }
                                    });
                                    extent = featureExtent;
                                    console.log('Calculated extent from features:', extent);
                                }
                            }

                            if (extent && extent.some(val => isFinite(val))) {
                                console.log('Zooming to contour extent:', extent);
                                // Check if extent looks reasonable (not ocean coordinates)
                                const centerX = (extent[0] + extent[2]) / 2;
                                const centerY = (extent[1] + extent[3]) / 2;
                                console.log('Extent center coordinates:', [centerX, centerY]);
                                if (Math.abs(centerX) > 10000000 || Math.abs(centerY) > 10000000) {
                                    console.warn('⚠️ Extent center appears to be in wrong coordinate system (too large for EPSG:3857)');
                                }
                                map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 1000 });
                            } else {
                                console.warn('No valid extent found for contour zoom');
                            }
                        } else {
                            console.warn('No contour layer found for zoom');
                        }

                    } catch (error) {
                        console.error('Error generating contours:', error);
                        showToast('Error generating contours: ' + error.message, 'error');
                    }
                });
            }

            // Generate Both DTM and Contours
            const generateBothBtn = document.getElementById('generateBothBtn');
            if (generateBothBtn) {
                generateBothBtn.addEventListener('click', async function () {
                    try {
                        const combinedData = getCombinedData();

                        if (combinedData.length < 3) {
                            showToast('Please load at least 3 data points to generate terrain', 'error');
                            return;
                        }

                        // Generate DTM and Contours
                        await generateDTMLayer();
                        await generateContoursProduction();

                        // Add points layer
                        addPointsLayer(
                            combinedData,
                            terrain3DState.showPointNumbers,
                            terrain3DState.showDescriptions
                        );

                        // Zoom to extent
                        if (terrain3DState.dtmLayer) {
                            // For Image layers, get the imageExtent from the ImageStatic source
                            const source = terrain3DState.dtmLayer.getSource();
                            const extent = source.getImageExtent ? source.getImageExtent() : null;
                            if (extent) {
                                map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 1000 });
                            }
                        }

                    } catch (error) {
                        console.error('Terrain generation error:', error);
                        showToast('Failed to generate terrain: ' + error.message, 'error');
                    }
                });
            }

            const saveConfigBtn = document.getElementById('saveConfigBtn');
            if (saveConfigBtn) {
                saveConfigBtn.addEventListener('click', function () {
                    saveDTMConfiguration();
                });
            }

            // Analysis Generation Button
            const generateAnalysisBtn = document.getElementById('generateAnalysisBtn');
            if (generateAnalysisBtn) {
                generateAnalysisBtn.addEventListener('click', async function () {
                    const analysisType = document.getElementById('analysisType')?.value;
                    const analysisUnit = document.getElementById('analysisUnit')?.value || 'degrees';

                    if (!analysisType) {
                        showToast('Please select an analysis type', 'warning');
                        return;
                    }

                    await generateAnalysisLayer(analysisType, analysisUnit);
                });
            }

            const analysisLayerToggle = document.getElementById('analysisLayerToggle');
            if (analysisLayerToggle) {
                analysisLayerToggle.addEventListener('change', function () {
                    terrain3DState.analysisLayerVisible = this.checked;
                    if (terrain3DState.analysisLayer) {
                        terrain3DState.analysisLayer.setVisible(this.checked);
                    }
                });
            }

            const dtmLayerToggle = document.getElementById('dtmLayerToggle');
            if (dtmLayerToggle) {
                dtmLayerToggle.addEventListener('change', function () {
                    terrain3DState.dtmLayerVisible = this.checked;
                    if (terrain3DState.dtmLayer) {
                        terrain3DState.dtmLayer.setVisible(this.checked);
                    }
                });
            }

            const contourLayerToggle = document.getElementById('contourLayerToggle');
            if (contourLayerToggle) {
                contourLayerToggle.addEventListener('change', function () {
                    terrain3DState.contourLayerVisible = this.checked;
                    if (terrain3DState.contourLayer) {
                        terrain3DState.contourLayer.setVisible(this.checked);
                    }
                });
            }

            const classificationLayerToggle = document.getElementById('classificationLayerToggle');
            if (classificationLayerToggle) {
                classificationLayerToggle.addEventListener('change', function () {
                    terrain3DState.classificationLayerVisible = this.checked;
                    if (terrain3DState.classificationLayer) {
                        terrain3DState.classificationLayer.setVisible(this.checked);
                    }
                });
            }

            // 3D Export Buttons
            document.getElementById('exportSTLBtn')?.addEventListener('click', exportSTL);
            document.getElementById('exportOBJBtn')?.addEventListener('click', exportOBJ);

            // Terrain Classification (from export buttons)
            document.getElementById('classifyTerrainBtn')?.addEventListener('click', async function () {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'warning');
                    return;
                }

                try {
                    showLoadingIndicator('Classifying terrain...');

                    // Get extent from DTM layer or gridData
                    let extent = terrain3DState.extent;
                    if (!extent && terrain3DState.dtmLayer) {
                        const source = terrain3DState.dtmLayer.getSource();
                        if (source && source.getImageExtent) {
                            const imageExtent = source.getImageExtent();
                            extent = {
                                minX: imageExtent[0],
                                minY: imageExtent[1],
                                maxX: imageExtent[2],
                                maxY: imageExtent[3]
                            };
                        }
                    }

                    if (!extent && terrain3DState.gridData && terrain3DState.gridData.bounds) {
                        extent = terrain3DState.gridData.bounds;
                    }

                    if (!extent) {
                        throw new Error('Unable to determine terrain extent');
                    }

                    // Ensure gridData is in correct format for edge function
                    const gridDataForEdge = {
                        grid: terrain3DState.gridData.grid || terrain3DState.gridData,
                        width: terrain3DState.gridData.width,
                        height: terrain3DState.gridData.height,
                        cellSize: terrain3DState.gridData.cellSize || terrain3DState.cellSize || 10
                    };

                    const result = await callTerrainProcessor('classify-terrain', {
                        gridData: gridDataForEdge,
                        extent: extent,
                        cellSize: terrain3DState.cellSize || 10
                    });

                    console.log('Classification result:', result);

                    if (result && (result.success || result.classification || result.features)) {
                        // Store classification results for PDF export
                        if (result.classification) {
                            terrain3DState.lastClassificationResults = {
                                classification: result.classification,
                                stats: result.classification.stats
                            };

                            // Render classification overlay (polygon-based)
                            renderTerrainClassification(result.classification);
                        } else if (result.features) {
                            // Store point-based features
                            terrain3DState.lastClassificationResults = result.features;

                            // Visualize point-based classification
                            visualizeClassification(result.features, terrain3DState.gridData);

                            // Display results panel
                            displayClassificationResults(result.features, 'terrain');
                        }

                        showToast('Terrain classified successfully', 'success');
                    } else {
                        showToast('Terrain classification failed: ' + (result?.message || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Error classifying terrain:', error);
                    showToast('Error classifying terrain: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    hideLoadingIndicator();
                }
            });

            // Hydrology Analysis
            document.getElementById('hydrologyAnalysisBtn')?.addEventListener('click', async function () {
                if (!terrain3DState.gridData) {
                    showToast('Please generate DTM first', 'warning');
                    return;
                }

                try {
                    showLoadingIndicator('Analyzing hydrology...');

                    // Get extent from DTM layer or gridData
                    let extent = terrain3DState.extent;
                    if (!extent && terrain3DState.dtmLayer) {
                        const source = terrain3DState.dtmLayer.getSource();
                        if (source && source.getImageExtent) {
                            const imageExtent = source.getImageExtent();
                            extent = {
                                minX: imageExtent[0],
                                minY: imageExtent[1],
                                maxX: imageExtent[2],
                                maxY: imageExtent[3]
                            };
                        }
                    }

                    if (!extent && terrain3DState.gridData && terrain3DState.gridData.bounds) {
                        extent = terrain3DState.gridData.bounds;
                    }

                    if (!extent) {
                        throw new Error('Unable to determine terrain extent');
                    }

                    // Ensure gridData is in correct format for edge function
                    const gridDataForEdge = {
                        grid: terrain3DState.gridData.grid || terrain3DState.gridData,
                        width: terrain3DState.gridData.width,
                        height: terrain3DState.gridData.height,
                        cellSize: terrain3DState.gridData.cellSize || terrain3DState.cellSize || 10
                    };

                    const result = await callTerrainProcessor('hydrology-analysis', {
                        gridData: gridDataForEdge,
                        extent: extent,
                        cellSize: terrain3DState.cellSize || 10
                    });

                    console.log('Hydrology analysis result:', result);

                    if (result && (result.success || result.watersheds || result.flowDirection)) {
                        // Store hydrology results for PDF export
                        terrain3DState.lastHydrologyResults = result;

                        // Render hydrology layers
                        renderHydrologyAnalysis(result);
                        const watershedCount = result.watersheds?.length || 0;
                        showToast(`Hydrology analysis completed: ${watershedCount} watersheds identified`, 'success');
                    } else {
                        showToast('Hydrology analysis failed: ' + (result?.message || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Error in hydrology analysis:', error);
                    showToast('Error in hydrology analysis: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    hideLoadingIndicator();
                }
            });

            // Helper function to render terrain classification
            function renderTerrainClassification(classification) {
                if (!classification || (!classification.polygons && !classification.grid)) {
                    console.warn('Invalid classification data:', classification);
                    return;
                }

                try {
                    // Remove existing classification layer if any
                    if (terrain3DState.classificationLayer) {
                        map.removeLayer(terrain3DState.classificationLayer);
                    }

                    // Create classification overlay
                    const classificationSource = new ol.source.Vector();
                    const classificationLayer = new ol.layer.Vector({
                        source: classificationSource,
                        style: function (feature) {
                            const type = feature.get('type');
                            const colors = {
                                'flat': '#90EE90',
                                'gentle': '#FFD700',
                                'moderate': '#FF8C00',
                                'steep': '#FF4500',
                                'very_steep': '#8B0000'
                            };
                            return new ol.style.Style({
                                fill: new ol.style.Fill({
                                    color: colors[type] || '#CCCCCC'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#FFFFFF',
                                    width: 1
                                })
                            });
                        },
                        opacity: 0.6,
                        zIndex: 120
                    });

                    // Add classification polygons if provided
                    if (classification.polygons && Array.isArray(classification.polygons) && classification.polygons.length > 0) {
                        console.log('Adding', classification.polygons.length, 'classification polygons');
                        let addedCount = 0;
                        classification.polygons.forEach((poly, idx) => {
                            try {
                                if (poly.coordinates && Array.isArray(poly.coordinates) && poly.coordinates.length > 0) {
                                    const feature = new ol.Feature({
                                        geometry: new ol.geom.Polygon([poly.coordinates]),
                                        type: poly.type || 'unknown',
                                        slope: poly.slope,
                                        elevation: poly.elevation
                                    });
                                    classificationSource.addFeature(feature);
                                    addedCount++;
                                }
                            } catch (e) {
                                console.warn('Error adding classification polygon at index', idx, ':', e);
                            }
                        });
                        console.log('Successfully added', addedCount, 'classification polygons');
                    } else if (classification.grid) {
                        // Handle grid-based classification
                        console.log('Classification has grid data, converting to polygons...');
                        // Grid-based classification would need to be converted to polygons
                        // For now, show a message
                        showToast('Grid-based classification received. Visualization may be limited.', 'info');
                    } else {
                        console.warn('No polygons or grid in classification data. Classification object:', classification);
                        showToast('Classification completed but no displayable data. Check console for details.', 'warning');
                    }

                    // Only add layer if it has features
                    if (classificationSource.getFeatures().length > 0) {
                        terrain3DState.classificationLayer = classificationLayer;
                        map.addLayer(classificationLayer);

                        // Ensure layer is visible
                        classificationLayer.setVisible(true);
                        classificationLayer.setZIndex(120);

                        // Enable toggle
                        const toggle = document.getElementById('classificationLayerToggle');
                        if (toggle) {
                            toggle.disabled = false;
                            toggle.checked = true;
                        }
                        console.log('Classification layer added to map with', classificationSource.getFeatures().length, 'features');
                    } else {
                        console.warn('No features to add to classification layer');
                    }

                    // Show classification results panel
                    const panel = document.getElementById('classificationResultsPanel');
                    if (panel) {
                        panel.style.display = 'block';
                        const stats = classification.stats || {};
                        if (document.getElementById('classificationStats')) {
                            document.getElementById('classificationStats').innerHTML = `
                            <p><strong>Flat:</strong> ${stats.flat || 0}%</p>
                            <p><strong>Gentle:</strong> ${stats.gentle || 0}%</p>
                            <p><strong>Moderate:</strong> ${stats.moderate || 0}%</p>
                            <p><strong>Steep:</strong> ${stats.steep || 0}%</p>
                            <p><strong>Very Steep:</strong> ${stats.very_steep || 0}%</p>
                        `;
                        }
                    }

                    console.log('Terrain classification rendered successfully');
                } catch (error) {
                    console.error('Error rendering classification:', error);
                    showToast('Error rendering classification: ' + error.message, 'error');
                }
            }

            // Helper function to render hydrology analysis
            function renderHydrologyAnalysis(result) {
                if (!result) {
                    console.warn('Invalid hydrology analysis data');
                    return;
                }

                try {
                    // Remove existing hydrology layers if any
                    if (terrain3DState.hydrologyLayers) {
                        terrain3DState.hydrologyLayers.forEach(layer => map.removeLayer(layer));
                    }
                    terrain3DState.hydrologyLayers = [];

                    // Create flow direction layer
                    if (result.flowDirection) {
                        const flowSource = new ol.source.Vector();
                        const flowLayer = new ol.layer.Vector({
                            source: flowSource,
                            style: new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#0066FF',
                                    width: 1
                                })
                            }),
                            opacity: 0.7,
                            zIndex: 102
                        });

                        // Add flow direction arrows if provided
                        if (result.flowArrows && Array.isArray(result.flowArrows) && result.flowArrows.length > 0) {
                            console.log('Adding', result.flowArrows.length, 'flow direction arrows');
                            let addedCount = 0;
                            result.flowArrows.forEach((arrow, idx) => {
                                try {
                                    if (arrow.coordinates && Array.isArray(arrow.coordinates) && arrow.coordinates.length >= 2) {
                                        const feature = new ol.Feature({
                                            geometry: new ol.geom.LineString(arrow.coordinates),
                                            direction: arrow.direction
                                        });
                                        flowSource.addFeature(feature);
                                        addedCount++;
                                    }
                                } catch (e) {
                                    console.warn('Error adding flow arrow at index', idx, ':', e);
                                }
                            });
                            console.log('Successfully added', addedCount, 'flow arrows');
                        }

                        if (flowSource.getFeatures().length > 0) {
                            map.addLayer(flowLayer);
                            terrain3DState.hydrologyLayers.push(flowLayer);
                            console.log('Flow direction layer added with', flowSource.getFeatures().length, 'features');
                        } else {
                            console.warn('No flow arrows to display');
                        }
                    }

                    // Create watershed boundaries layer
                    if (result.watersheds && Array.isArray(result.watersheds)) {
                        const watershedSource = new ol.source.Vector();
                        const watershedLayer = new ol.layer.Vector({
                            source: watershedSource,
                            style: new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#FF0000',
                                    width: 2
                                }),
                                fill: new ol.style.Fill({
                                    color: 'rgba(255, 0, 0, 0.1)'
                                })
                            }),
                            opacity: 0.8,
                            zIndex: 103
                        });

                        let watershedCount = 0;
                        result.watersheds.forEach((watershed, idx) => {
                            try {
                                if (watershed.boundary && Array.isArray(watershed.boundary) && watershed.boundary.length > 0) {
                                    const feature = new ol.Feature({
                                        geometry: new ol.geom.Polygon([watershed.boundary]),
                                        area: watershed.area,
                                        outlet: watershed.outlet
                                    });
                                    watershedSource.addFeature(feature);
                                    watershedCount++;
                                }
                            } catch (e) {
                                console.warn('Error adding watershed at index', idx, ':', e);
                            }
                        });

                        if (watershedSource.getFeatures().length > 0) {
                            map.addLayer(watershedLayer);
                            terrain3DState.hydrologyLayers.push(watershedLayer);
                            console.log('Watershed layer added with', watershedCount, 'features');
                        } else {
                            console.warn('No watersheds to display');
                        }
                    }

                    // Show hydrology results panel
                    const hydrologyPanel = document.getElementById('hydrologyResultsPanel');
                    const hydrologyContent = document.getElementById('hydrologyResultsContent');

                    if (hydrologyPanel && hydrologyContent) {
                        let html = '';

                        const watershedCount = result.watersheds?.length || result.stats?.watershedCount || 0;

                        html += '<div style="margin-bottom: 10px;">';
                        html += '<strong>Summary Statistics:</strong><br>';
                        html += `• Watersheds Identified: <strong>${watershedCount}</strong><br>`;

                        if (result.stats) {
                            if (result.stats.watershedCount && result.stats.watershedCount !== watershedCount) {
                                html += `• Total Watersheds: <strong>${result.stats.watershedCount}</strong><br>`;
                            }
                            if (result.stats.totalArea) {
                                html += `• Total Area: <strong>${result.stats.totalArea.toFixed(2)} m²</strong><br>`;
                            }
                        }
                        html += '</div>';

                        if (result.watersheds && Array.isArray(result.watersheds) && result.watersheds.length > 0) {
                            html += '<div style="margin-top: 10px;">';
                            html += '<strong>Watershed Details:</strong><br>';
                            html += '<div style="max-height: 200px; overflow-y: auto; margin-top: 5px;">';
                            result.watersheds.slice(0, 10).forEach((ws, idx) => {
                                html += `<div style="padding: 5px; margin: 2px 0; background: white; border-radius: 3px;">`;
                                html += `<strong>Watershed ${idx + 1}:</strong> `;
                                html += `Area: ${(ws.area || 0).toFixed(2)} m²`;
                                if (ws.outlet && Array.isArray(ws.outlet) && ws.outlet.length >= 2) {
                                    html += ` | Outlet: (${ws.outlet[0].toFixed(2)}, ${ws.outlet[1].toFixed(2)})`;
                                }
                                html += `</div>`;
                            });
                            if (result.watersheds.length > 10) {
                                html += `<div style="padding: 5px; color: #666; font-style: italic;">... and ${result.watersheds.length - 10} more</div>`;
                            }
                            html += '</div></div>';
                        } else if (watershedCount === 0) {
                            html += '<div style="margin-top: 10px; color: #666; font-style: italic;">No watersheds identified in this area</div>';
                        }

                        hydrologyContent.innerHTML = html;
                        hydrologyPanel.style.display = 'block';
                    }

                    const finalWatershedCount = result.watersheds?.length || result.stats?.watershedCount || 0;
                    showToast(`Hydrology analysis completed: ${finalWatershedCount} watersheds identified`, 'success');

                    console.log('Hydrology analysis rendered successfully');
                } catch (error) {
                    console.error('Error rendering hydrology:', error);
                    showToast('Error rendering hydrology: ' + error.message, 'error');
                }
            }
            document.getElementById('exportGeoTIFFBtn')?.addEventListener('click', exportGeoTIFF);
            document.getElementById('exportLASBtn')?.addEventListener('click', exportLAS);

            // Breakline Buttons
            // Terrain Classification (from panel button - duplicate ID fix)
            document.getElementById('classifyTerrainPanelBtn')?.addEventListener('click', async function () {
                // Trigger the same handler as the export button
                const exportBtn = document.getElementById('classifyTerrainBtn');
                if (exportBtn) {
                    exportBtn.click();
                }
            });

            // Breakline Buttons
            document.getElementById('drawBreaklineBtn')?.addEventListener('click', function () {
                try {
                    startBreaklineDrawing();
                } catch (error) {
                    console.error('Error starting breakline drawing:', error);
                    showToast('Error starting breakline drawing: ' + error.message, 'error');
                }
            });
            document.getElementById('importBreaklineBtn')?.addEventListener('click', function () {
                try {
                    importBreaklines();
                } catch (error) {
                    console.error('Error importing breaklines:', error);
                    showToast('Error importing breaklines: ' + error.message, 'error');
                }
            });

            // Volume Calculation Button
            document.getElementById('calculateVolumeBtn')?.addEventListener('click', function () {
                const volumeType = document.getElementById('volumeCalcType')?.value || 'plane';

                if (volumeType === 'plane') {
                    calculateVolumeToPlane();
                } else if (volumeType === 'polygon') {
                    calculateVolumeInPolygon();
                } else if (volumeType === 'surface') {
                    compareSurfaces();
                } else if (volumeType === 'stockpile') {
                    calculateStockpileVolume();
                }
            });

            // Terrain Classification Button - Already handled above (line 24918)

            const clearTerrainBtn = document.getElementById('clearTerrainBtn');
            if (clearTerrainBtn) {
                clearTerrainBtn.addEventListener('click', function () {
                    if (confirm('Are you sure you want to clear all terrain layers?')) {
                        clearTerrainLayers();
                    }
                });
            }

            // Close terrain popup (old code - to be removed)
            const terrainPopup = document.getElementById('terrainPopup');
            const terrainPopupClose = document.getElementById('terrainPopupClose');

            if (terrainPopup && terrainPopupClose) {
                terrainPopupClose.addEventListener('click', function () {
                    terrainPopup.classList.remove('show');
                });
            }

            /* ========================================
               OLD TERRAIN SETTINGS CODE - COMMENTED OUT
               These functions referenced the old terrain popup modal
               which has been replaced with the new 3D Terrain DTM dock
               ======================================== */

            // OLD CODE REMOVED - terrainPopup event listener
            // OLD CODE REMOVED - terrainSettings object
            // OLD CODE REMOVED - loadTerrainSettings function
            // OLD CODE REMOVED - saveTerrainSettings function
            // OLD CODE REMOVED - updateOpacityDisplays function
            // OLD CODE REMOVED - applyTerrainSettings function
            // OLD CODE REMOVED - terrain3DToggle event listener
            // OLD CODE REMOVED - contoursToggle event listener
            // OLD CODE REMOVED - updateTerrainToggleState function
            // OLD CODE REMOVED - applyTerrainBtn event listener
            // OLD CODE REMOVED - resetViewBtn event listener

            // Layer warning functionality
            const layerWarning = document.getElementById('layerWarning');
            setTimeout(function () {
                layerWarning.style.display = 'block';
                setTimeout(function () {
                    layerWarning.style.display = 'none';
                }, 5000);
            }, 10000);

            // Make modals draggable
            function makeDraggable(modalId) {
                const modal = document.getElementById(modalId);
                const header = modal.querySelector('.modal-header');

                let isDragging = false;
                let startX, startY, initialLeft, initialTop;

                if (!header) return; // Skip if no header

                header.addEventListener('mousedown', function (e) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialLeft = parseInt(window.getComputedStyle(modal).left, 10) || 0;
                    initialTop = parseInt(window.getComputedStyle(modal).top, 10) || 0;

                    modal.style.position = 'absolute';
                    modal.style.cursor = 'grabbing';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', function (e) {
                    if (isDragging) {
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;

                        modal.style.left = (initialLeft + dx) + 'px';
                        modal.style.top = (initialTop + dy) + 'px';
                    }
                });

                document.addEventListener('mouseup', function () {
                    isDragging = false;
                    modal.style.cursor = 'grab';
                });
            }

            // Initialize modals as draggable

            // Initialize layer counter
            updateLayerCounter();

            // Show initial welcome message
            setTimeout(() => {
                showToast('Welcome to Geospatial Network Uganda! Map initialized successfully.', 'success', 4000);
            }, 2000);

            // Add keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // Add keyboard shortcuts for common actions
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'f':
                            e.preventDefault();
                            document.getElementById('fullScreenBtn').click();
                            break;
                        case 'p':
                            e.preventDefault();
                            document.getElementById('printBtn').click();
                            break;
                        case 'l':
                            e.preventDefault();
                            document.getElementById('locateBtn').click();
                            break;
                    }
                }

                // Escape key to close modals
                if (e.key === 'Escape') {
                    // Close any open modals or panels
                    if (coordExtractorModal.style.display === 'block') {
                        coordExtractorClose.click();
                    }
                    if (gspnetPanel && gspnetPanel.style.display === 'block') {
                        const gspnetCloseBtn = document.getElementById('gspnet-panel-close');
                        if (gspnetCloseBtn) gspnetCloseBtn.click();
                    }
                    if (featureInfo.style.display === 'block') {
                        closeFeatureInfo.click();
                    }
                }
            });

            // Add enter key support for search inputs
            document.getElementById('placeSearch').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    document.getElementById('placeSearchBtn').click();
                }
            });

            // PATCH: Add null checks for missing elements to prevent console errors
            const eastingElement = document.getElementById('easting');
            if (eastingElement) {
                eastingElement.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        document.getElementById('coordSearchBtn').click();
                    }
                });
            }

            const northingElement = document.getElementById('northing');
            if (northingElement) {
                northingElement.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        document.getElementById('coordSearchBtn').click();
                    }
                });
            }

            // OLD NLIS CODE - REMOVED (replaced with parcel search)



            // PATCH: Drawing tools functionality
            let currentDrawInteraction = null;
            let drawingModifyInteraction = null;

            function updateDrawingStats() {
                const features = drawingSource.getFeatures();
                let points = 0, lines = 0, polygons = 0;

                features.forEach(feature => {
                    const type = feature.getGeometry().getType();
                    if (type === 'Point') points++;
                    else if (type === 'LineString') lines++;
                    else if (type === 'Polygon' || type === 'Circle') polygons++;
                });

                document.getElementById('point-count').textContent = points;
                document.getElementById('line-count').textContent = lines;
                document.getElementById('polygon-count').textContent = polygons;
            }

            function clearDrawingInteractions() {
                if (currentDrawInteraction) {
                    map.removeInteraction(currentDrawInteraction);
                    currentDrawInteraction = null;
                }
                if (drawingModifyInteraction) {
                    map.removeInteraction(drawingModifyInteraction);
                    drawingModifyInteraction = null;
                }
                if (selectInteraction) {
                    map.removeInteraction(selectInteraction);
                    selectInteraction = null;
                }

                // Remove active class from all drawing buttons
                document.querySelectorAll('.drawing-btn').forEach(btn => btn.classList.remove('active'));

                // Hide stop button
                document.getElementById('stopDrawing').style.display = 'none';

                // Disable crosshair cursor
                disableCrosshair();
            }

            function setupDrawingInteractions() {
                // Drawing tools
                document.getElementById('drawPoint').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    currentDrawInteraction = new ol.interaction.Draw({
                        source: drawingSource,
                        type: 'Point'
                    });
                    map.addInteraction(currentDrawInteraction);
                    document.getElementById('stopDrawing').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click to draw points', 'info');
                });

                document.getElementById('drawLine').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    currentDrawInteraction = new ol.interaction.Draw({
                        source: drawingSource,
                        type: 'LineString'
                    });
                    map.addInteraction(currentDrawInteraction);

                    // Enable crosshair cursor
                    enableCrosshair();
                    document.getElementById('stopDrawing').style.display = 'inline-block';
                    showToast('Click to draw lines (double-click to finish)', 'info');
                });

                document.getElementById('drawPolygon').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    currentDrawInteraction = new ol.interaction.Draw({
                        source: drawingSource,
                        type: 'Polygon'
                    });
                    map.addInteraction(currentDrawInteraction);
                    document.getElementById('stopDrawing').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click to draw polygons (double-click to finish)', 'info');
                });

                document.getElementById('drawCircle').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    currentDrawInteraction = new ol.interaction.Draw({
                        source: drawingSource,
                        type: 'Circle'
                    });
                    map.addInteraction(currentDrawInteraction);
                    document.getElementById('stopDrawing').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click and drag to draw circles', 'info');
                });

                // Modify features
                document.getElementById('modifyFeatures').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    selectInteraction = new ol.interaction.Select({
                        layers: [drawingLayer]
                    });
                    drawingModifyInteraction = new ol.interaction.Modify({
                        features: selectInteraction.getFeatures()
                    });
                    map.addInteraction(selectInteraction);
                    map.addInteraction(drawingModifyInteraction);
                    document.getElementById('stopDrawing').style.display = 'inline-block';
                    showToast('Click features to modify them', 'info');
                });

                // Delete features
                document.getElementById('deleteFeatures').addEventListener('click', function () {
                    clearDrawingInteractions();
                    this.classList.add('active');
                    selectInteraction = new ol.interaction.Select({
                        layers: [drawingLayer]
                    });
                    map.addInteraction(selectInteraction);
                    document.getElementById('stopDrawing').style.display = 'inline-block';
                    showToast('Click features to delete them', 'info');

                    selectInteraction.on('select', function (e) {
                        if (e.selected.length > 0) {
                            e.selected.forEach(feature => drawingSource.removeFeature(feature));
                            updateDrawingStats();
                            showToast('Feature deleted', 'success');
                        }
                    });
                });

                // Clear all
                document.getElementById('clearAll').addEventListener('click', function () {
                    if (confirm('Clear all drawings?')) {
                        drawingSource.clear();
                        updateDrawingStats();
                        showToast('All drawings cleared', 'info');
                    }
                });

                // Export GeoJSON
                document.getElementById('exportGeoJSON').addEventListener('click', function () {
                    const features = drawingSource.getFeatures();
                    if (features.length === 0) {
                        showToast('No features to export', 'warning');
                        return;
                    }

                    const geoJSON = new ol.format.GeoJSON().writeFeatures(features);
                    const blob = new Blob([geoJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'drawing_' + new Date().toISOString().slice(0, 10) + '.geojson';
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('GeoJSON exported', 'success');
                });

                // Import GeoJSON
                document.getElementById('importGeoJSON').addEventListener('click', function () {
                    document.getElementById('geojson-file-input').click();
                });

                document.getElementById('geojson-file-input').addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function (e) {
                        try {
                            const geoJSON = JSON.parse(e.target.result);
                            const features = new ol.format.GeoJSON().readFeatures(geoJSON);
                            drawingSource.addFeatures(features);
                            updateDrawingStats();
                            showToast('GeoJSON imported successfully', 'success');
                        } catch (error) {
                            showToast('Invalid GeoJSON file', 'error');
                            console.error('GeoJSON import error:', error);
                        }
                    };
                    reader.readAsText(file);
                });

                // Stop drawing button
                document.getElementById('stopDrawing').addEventListener('click', function () {
                    clearDrawingInteractions();
                    showToast('Drawing stopped', 'info');
                });

                // Update stats when features change
                drawingSource.on('addfeature', updateDrawingStats);
                drawingSource.on('removefeature', updateDrawingStats);
                drawingSource.on('clear', updateDrawingStats);
            }

            // Initialize drawing tools
            setupDrawingInteractions();
            updateDrawingStats();

            // PATCH: Measurement tools functionality
            let currentMeasureInteraction = null;
            let measureType = null;

            function clearMeasurementInteractions() {
                if (currentMeasureInteraction) {
                    map.removeInteraction(currentMeasureInteraction);
                    currentMeasureInteraction = null;
                }

                // Remove active class from all measurement buttons
                document.querySelectorAll('.measurement-btn').forEach(btn => btn.classList.remove('active'));

                // Hide stop button
                document.getElementById('stopMeasurement').style.display = 'none';

                // Disable crosshair cursor
                disableCrosshair();
            }

            function setupMeasurementInteractions() {
                // Distance measurement
                document.getElementById('measureDistance').addEventListener('click', function () {
                    clearMeasurementInteractions();
                    this.classList.add('active');
                    measureType = 'distance';

                    currentMeasureInteraction = new ol.interaction.Draw({
                        source: measurementSource,
                        type: 'LineString',
                        style: new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 3
                            })
                        })
                    });

                    map.addInteraction(currentMeasureInteraction);
                    document.getElementById('stopMeasurement').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click to start measuring distance. Double-click to finish.', 'info');

                    currentMeasureInteraction.on('drawend', function (evt) {
                        const feature = evt.feature;
                        const geometry = feature.getGeometry();
                        const coordinates = geometry.getCoordinates();

                        // Calculate distance
                        let totalDistance = 0;
                        for (let i = 0; i < coordinates.length - 1; i++) {
                            const from = ol.proj.transform(coordinates[i], 'EPSG:3857', 'EPSG:4326');
                            const to = ol.proj.transform(coordinates[i + 1], 'EPSG:3857', 'EPSG:4326');
                            const distance = ol.sphere.getDistance(from, to);
                            totalDistance += distance;
                        }

                        const distanceText = totalDistance > 1000 ?
                            `${(totalDistance / 1000).toFixed(2)} km` :
                            `${totalDistance.toFixed(2)} m`;

                        feature.set('measurement', distanceText);
                        document.getElementById('distance-value').textContent = distanceText;
                        document.getElementById('distance-result').style.display = 'block';
                        showToast(`Distance measured: ${distanceText}`, 'success');
                    });
                });

                // Area measurement
                document.getElementById('measureArea').addEventListener('click', function () {
                    clearMeasurementInteractions();
                    this.classList.add('active');
                    measureType = 'area';

                    currentMeasureInteraction = new ol.interaction.Draw({
                        source: measurementSource,
                        type: 'Polygon',
                        style: new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 107, 107, 0.2)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 2
                            })
                        })
                    });

                    map.addInteraction(currentMeasureInteraction);
                    document.getElementById('stopMeasurement').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click to start measuring area. Double-click to finish.', 'info');

                    currentMeasureInteraction.on('drawend', function (evt) {
                        const feature = evt.feature;
                        const geometry = feature.getGeometry();
                        const coordinates = geometry.getCoordinates()[0];

                        // Calculate area
                        const area = ol.sphere.getArea(geometry);
                        const areaText = area > 10000 ?
                            `${(area / 10000).toFixed(2)} ha` :
                            `${area.toFixed(2)} m²`;

                        feature.set('measurement', areaText);
                        document.getElementById('area-value').textContent = areaText;
                        document.getElementById('area-result').style.display = 'block';
                        showToast(`Area measured: ${areaText}`, 'success');
                    });
                });

                // Azimuth measurement
                document.getElementById('measureAzimuth').addEventListener('click', function () {
                    clearMeasurementInteractions();
                    this.classList.add('active');
                    measureType = 'azimuth';

                    currentMeasureInteraction = new ol.interaction.Draw({
                        source: measurementSource,
                        type: 'LineString',
                        style: new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 3
                            })
                        })
                    });

                    map.addInteraction(currentMeasureInteraction);
                    document.getElementById('stopMeasurement').style.display = 'inline-block';

                    // Enable crosshair cursor
                    enableCrosshair();

                    showToast('Click two points to measure azimuth. Double-click to finish.', 'info');

                    currentMeasureInteraction.on('drawend', function (evt) {
                        const feature = evt.feature;
                        const geometry = feature.getGeometry();
                        const coordinates = geometry.getCoordinates();

                        if (coordinates.length >= 2) {
                            const from = ol.proj.transform(coordinates[0], 'EPSG:3857', 'EPSG:4326');
                            const to = ol.proj.transform(coordinates[coordinates.length - 1], 'EPSG:3857', 'EPSG:4326');

                            // Calculate azimuth (bearing) manually
                            const lat1 = from[1] * Math.PI / 180;
                            const lat2 = to[1] * Math.PI / 180;
                            const dLon = (to[0] - from[0]) * Math.PI / 180;

                            const y = Math.sin(dLon) * Math.cos(lat2);
                            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                            const bearing = Math.atan2(y, x) * 180 / Math.PI;
                            const azimuth = (bearing + 360) % 360; // Normalize to 0-360

                            const azimuthText = `${azimuth.toFixed(1)}°`;
                            feature.set('measurement', azimuthText);
                            document.getElementById('azimuth-value').textContent = azimuthText;
                            document.getElementById('azimuth-result').style.display = 'block';
                            showToast(`Azimuth measured: ${azimuthText}`, 'success');
                        }
                    });
                });

                // Clear measurements
                document.getElementById('clearMeasurements').addEventListener('click', function () {
                    if (confirm('Clear all measurements?')) {
                        measurementSource.clear();
                        document.getElementById('distance-result').style.display = 'none';
                        document.getElementById('area-result').style.display = 'none';
                        document.getElementById('azimuth-result').style.display = 'none';
                        showToast('All measurements cleared', 'info');
                    }
                });

                // Toggle measurements visibility
                document.getElementById('toggleMeasurements').addEventListener('click', function () {
                    const visible = measurementLayer.getVisible();
                    measurementLayer.setVisible(!visible);
                    this.classList.toggle('active', !visible);
                    showToast(`Measurements ${!visible ? 'hidden' : 'shown'}`, 'info');
                });

                // Stop measurement button
                document.getElementById('stopMeasurement').addEventListener('click', function () {
                    clearMeasurementInteractions();
                    showToast('Measurement stopped', 'info');
                });
            }

            // Initialize measurement tools
            setupMeasurementInteractions();

            // Get feature info for FlatGeobuf layers (GSPNET LAYERS)
            function getFlatGeobufFeatureInfo(pixel) {
                // Check all visible FlatGeobuf layers (gspnetLayers)
                const features = [];
                gspnetLayers.forEach(layer => {
                    if (layer.getVisible()) {
                        const layerFeatures = map.getFeaturesAtPixel(pixel, {
                            layerFilter: function (layerFilter) {
                                return layerFilter === layer;
                            }
                        });
                        if (layerFeatures && layerFeatures.length > 0) {
                            layerFeatures.forEach(feature => {
                                // Add layer name to feature properties for identification
                                const props = feature.getProperties();
                                props['_layer'] = layer.get('title');
                                features.push(feature);
                            });
                        }
                    }
                });
                return features;
            }

            // PATCH: Legacy WMS GetFeatureInfo (kept for compatibility but not used in current setup)
            function getWMSFeatureInfo(evt) {
                const view = map.getView();
                const viewResolution = view.getResolution();
                const viewProjection = view.getProjection();

                // Get visible WMS layers
                const visibleLayers = wmsLayers.filter(layer => layer.getVisible());
                if (visibleLayers.length === 0) {
                    return Promise.resolve([]);
                }

                console.log('Trying WMS GetFeatureInfo for', visibleLayers.length, 'visible layers');

                // Try each visible layer's source getFeatureInfoUrl method
                const promises = visibleLayers.map(layer => {
                    const source = layer.getSource();
                    if (source && typeof source.getFeatureInfoUrl === 'function') {
                        try {
                            // Use the same approach as the working example
                            const url = source.getFeatureInfoUrl(
                                evt.coordinate,
                                viewResolution,
                                viewProjection.getCode(),
                                {
                                    INFO_FORMAT: "application/json",
                                    FEATURE_COUNT: 50
                                }
                            );

                            if (url) {
                                console.log('WMS GetFeatureInfo URL for', layer.get('title'), ':', url);
                                return fetch(url, {
                                    method: 'GET',
                                    mode: 'cors',
                                    cache: 'no-cache',
                                    headers: {
                                        'Accept': 'application/json',
                                    }
                                })
                                    .then((response) => {
                                        console.log('WMS response status for', layer.get('title'), ':', response.status);
                                        if (!response.ok) {
                                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                        }
                                        return response.json();
                                    })
                                    .then((data) => {
                                        console.log('WMS response data for', layer.get('title'), ':', data);
                                        if (data.features && data.features.length > 0) {
                                            console.log(`Found ${data.features.length} features in layer:`, layer.get('title'));
                                            console.log('Feature properties:', data.features[0].properties);
                                            return data.features.map(feature => {
                                                const props = feature.properties || {};
                                                // Add layer name to properties
                                                props['Layer'] = layer.get('title');
                                                console.log('Processed feature properties:', props);
                                                return new ol.Feature({
                                                    properties: props,
                                                    geometry: null
                                                });
                                            });
                                        } else {
                                            console.log('No features found in layer:', layer.get('title'));
                                            return [];
                                        }
                                    })
                                    .catch((err) => {
                                        console.error(`WMS GetFeatureInfo error for layer ${layer.get('title')}:`, err);
                                        // Check if it's a CORS error
                                        if (err.message.includes('Failed to fetch') || err.message.includes('CORS')) {
                                            console.warn('CORS error detected. This may be due to running the file locally (file:// protocol).');
                                            console.warn('Try serving the file from a web server or use a browser with disabled security for local files.');
                                            console.warn('Alternative: Try opening the URL directly in a new tab to test the server response.');
                                        }
                                        return [];
                                    });
                            } else {
                                console.log('No URL generated for layer:', layer.get('title'));
                                return Promise.resolve([]);
                            }
                        } catch (error) {
                            console.error(`Error getting URL for layer ${layer.get('title')}:`, error);
                            return Promise.resolve([]);
                        }
                    } else {
                        console.log('Layer source does not support getFeatureInfoUrl:', layer.get('title'));
                        return Promise.resolve([]);
                    }
                });

                // Wait for all layer requests to complete
                return Promise.all(promises).then(results => {
                    // Flatten all results into a single array
                    const allFeatures = results.flat();
                    console.log(`Total features found: ${allFeatures.length}`);
                    return allFeatures;
                });
            }

            // Feature info panel functionality for the info button only
            map.on('click', function (evt) {
                if (featureInfo.style.display === 'block') {
                    const pixel = evt.pixel;

                    // Show loading message
                    featureInfoContent.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Loading feature information...</p>';

                    // First check for polygon features (Survey Polygons)
                    const polygonFeature = map.forEachFeatureAtPixel(pixel, function (feature) {
                        if (feature.get('unique_id')) {
                            return feature;
                        }
                    });

                    if (polygonFeature) {
                        displayPolygonInfo(polygonFeature);
                        return;
                    }

                    // Then try FlatGeobuf layers (GSPNET LAYERS)
                    const flatGeobufFeatures = getFlatGeobufFeatureInfo(pixel);
                    if (flatGeobufFeatures && flatGeobufFeatures.length > 0) {
                        let content = '<h3>Feature Information</h3>';
                        flatGeobufFeatures.forEach(feature => {
                            const props = feature.getProperties();
                            const layerName = props._layer || 'Unknown Layer';

                            content += `<h4 style="margin-top:15px; margin-bottom:5px; color:#2c3e50;">${layerName}</h4>`;
                            content += '<table border="1" style="border-collapse:collapse; font-size:12px; width:100%; margin-bottom:10px;">';

                            for (let key in props) {
                                if (key !== 'geometry' && key !== '_layer') {
                                    const value = props[key];
                                    let displayValue = value;

                                    // Format different data types nicely
                                    if (value === null || value === undefined) {
                                        displayValue = '<em>null</em>';
                                    } else if (typeof value === 'boolean') {
                                        displayValue = value ? 'Yes' : 'No';
                                    } else if (typeof value === 'number') {
                                        // Format numbers nicely
                                        displayValue = Number.isInteger(value) ?
                                            value.toLocaleString() :
                                            value.toFixed(3).toLocaleString();
                                    } else if (typeof value === 'object') {
                                        displayValue = JSON.stringify(value, null, 2);
                                    }

                                    content += `<tr><td style="padding:4px; background-color:#f5f5f5; font-weight:bold;">${key}</td><td style="padding:4px;">${displayValue}</td></tr>`;
                                }
                            }
                            content += '</table>';
                        });
                        featureInfoContent.innerHTML = content;
                        return;
                    }

                    // Fallback to vector features
                    const feature = map.forEachFeatureAtPixel(pixel, function (feature) {
                        return feature;
                    });

                    if (feature) {
                        const props = feature.getProperties();
                        let content = '<h3>Feature Information</h3>';
                        content += '<table border="1" style="border-collapse:collapse; font-size:12px; width:100%; margin-top:10px;">';

                        for (let key in props) {
                            if (key !== 'geometry') {
                                content += `<tr><td style="padding:4px; background-color:#f5f5f5; font-weight:bold;">${key}</td><td style="padding:4px;">${props[key]}</td></tr>`;
                            }
                        }

                        content += '</table>';
                        featureInfoContent.innerHTML = content;
                    } else {
                        // Check if there are visible FlatGeobuf layers
                        const visibleFlatGeobufLayers = gspnetLayers.filter(layer => layer.getVisible());
                        if (visibleFlatGeobufLayers.length > 0) {
                            featureInfoContent.innerHTML = `
                                <h3>Feature Information</h3>
                                <p>No features found at this location.</p>
                                <p><small><strong>Note:</strong> FlatGeobuf layers are loaded on-demand. If you don't see features, try zooming in or wait for the layer to finish loading.</small></p>
                            `;
                        } else {
                            featureInfoContent.innerHTML = `
                                <h3>Feature Information</h3>
                                <p>No feature information available at this location.</p>
                                <p><small>Make sure you have enabled some layers in the layer switcher.</small></p>
                            `;
                        }
                    }
                }
            });

            // PATCH: pg_featureserv Layer Loading and Tool Functionality
            // Global variables for pg_featureserv layers and interactions
            let pgLayers = [];
            let currentPreviewLayer = null;
            let currentEditingMode = null;
            let pendingEdits = [];

            // Load available layers from pg_featureserv
            async function loadPgLayers() {
                try {
                    // Loading layers from pg_featureserv

                    // Try to fetch from the API first
                    let data;
                    try {
                        const response = await fetch("https://pgf.geospatialnetworkug.xyz/collections");
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        data = await response.json();
                        // Collections loaded from API
                    } catch (apiError) {
                        console.warn('API fetch failed, using fallback data:', apiError);
                        // Fallback to the provided layers data
                        data = {
                            "collections": [
                                { "id": "public.Transmission_Lines_UETCL", "title": "Transmission Lines UETCL" },
                                { "id": "public.arua_linea", "title": "Arua Lines" },
                                { "id": "public.arua_poly", "title": "Arua Polygons" },
                                { "id": "public.control_points", "title": "Control Points" },
                                { "id": "public.gulu_blocks", "title": "Gulu Blocks" },
                                { "id": "public.gulu_lines", "title": "Gulu Lines" },
                                { "id": "public.gulu_poly", "title": "Gulu Polygons" },
                                { "id": "public.jinja_blocks", "title": "Jinja Blocks" },
                                { "id": "public.jinja_lines1", "title": "Jinja Lines 1" },
                                { "id": "public.jinja_poly11", "title": "Jinja Polygons 11" },
                                { "id": "public.kabale_blocks", "title": "Kabale Blocks" },
                                { "id": "public.kabale_lines1", "title": "Kabale Lines 1" },
                                { "id": "public.kabale_lines11", "title": "Kabale Lines 11" },
                                { "id": "public.kabale_poly1", "title": "Kabale Polygons 1" },
                                { "id": "public.kabalore_blocks", "title": "Kabarole Blocks" },
                                { "id": "public.kabalore_lines", "title": "Kabarole Lines" },
                                { "id": "public.kabalore_poly", "title": "Kabarole Polygons" },
                                { "id": "public.kampala_blocks", "title": "Kampala Blocks" },
                                { "id": "public.kampala_lines1", "title": "Kampala Lines 1" },
                                { "id": "public.kampala_poly1", "title": "Kampala Polygons 1" },
                                { "id": "public.kampala_poly2", "title": "Kampala Polygons 2" },
                                { "id": "public.kibaale_blocks", "title": "Kibaale Blocks" },
                                { "id": "public.kibaale_lines1", "title": "Kibaale Lines 1" },
                                { "id": "public.kibaale_poly1", "title": "Kibaale Polygons 1" },
                                { "id": "public.lira_blocks", "title": "Lira Blocks" },
                                { "id": "public.lira_lines", "title": "Lira Lines" },
                                { "id": "public.lira_poly", "title": "Lira Polygons" },
                                { "id": "public.luwero_blocks", "title": "Luwero Blocks" },
                                { "id": "public.luwero_lines1", "title": "Luwero Lines 1" },
                                { "id": "public.luwero_lines2", "title": "Luwero Lines 2" },
                                { "id": "public.luwero_lines3", "title": "Luwero Lines 3" },
                                { "id": "public.luwero_poly1", "title": "Luwero Polygons 1" },
                                { "id": "public.luwero_poly2", "title": "Luwero Polygons 2" },
                                { "id": "public.luwero_poly3", "title": "Luwero Polygons 3" },
                                { "id": "public.masaka_blocks", "title": "Masaka Blocks" },
                                { "id": "public.masaka_line1", "title": "Masaka Lines 1" },
                                { "id": "public.masaka_ranches", "title": "Masaka Ranches" },
                                { "id": "public.masindi_blocks", "title": "Masindi Blocks" },
                                { "id": "public.masindi_lines1", "title": "Masindi Lines 1" },
                                { "id": "public.masindi_poly1", "title": "Masindi Polygons 1" },
                                { "id": "public.mbale_blocks", "title": "Mbale Blocks" },
                                { "id": "public.mbale_lines", "title": "Mbale Lines" },
                                { "id": "public.mbale_poly", "title": "Mbale Polygons" },
                                { "id": "public.mbarara_blocks", "title": "Mbarara Blocks" },
                                { "id": "public.mbarara_lines1", "title": "Mbarara Lines 1" },
                                { "id": "public.mbarara_lines2", "title": "Mbarara Lines 2" },
                                { "id": "public.mbarara_lines3", "title": "Mbarara Lines 3" },
                                { "id": "public.mbarara_poly1", "title": "Mbarara Polygons 1" },
                                { "id": "public.mbarara_poly2", "title": "Mbarara Polygons 2" },
                                { "id": "public.mbarara_poly3", "title": "Mbarara Polygons 3" },
                                { "id": "public.mityana_blocks", "title": "Mityana Blocks" },
                                { "id": "public.mityana_lines1", "title": "Mityana Lines 1" },
                                { "id": "public.mityana_poly1", "title": "Mityana Polygons 1" },
                                { "id": "public.moroto_blocks", "title": "Moroto Blocks" },
                                { "id": "public.moroto_lines1", "title": "Moroto Lines 1" },
                                { "id": "public.moroto_poly1", "title": "Moroto Polygons 1" },
                                { "id": "public.mpigi_blocks", "title": "Mpigi Blocks" },
                                { "id": "public.mpigi_lines1", "title": "Mpigi Lines 1" },
                                { "id": "public.mpigi_poly1", "title": "Mpigi Polygons 1" },
                                { "id": "public.mukono_blocks", "title": "Mukono Blocks" },
                                { "id": "public.mukono_lines11", "title": "Mukono Lines 11" },
                                { "id": "public.mukono_lines2", "title": "Mukono Lines 2" },
                                { "id": "public.mukono_poly1", "title": "Mukono Polygons 1" },
                                { "id": "public.mukono_poly2", "title": "Mukono Polygons 2" },
                                { "id": "public.my_geometry_table", "title": "My Geometry Table" },
                                { "id": "public.protected_areas", "title": "Protected Areas" },
                                { "id": "public.rukungiri_blocks", "title": "Rukungiri Blocks" },
                                { "id": "public.rukungiri_lines1", "title": "Rukungiri Lines 1" },
                                { "id": "public.rukungiri_poly1", "title": "Rukungiri Polygons 1" },
                                { "id": "public.rukungiri_poly2", "title": "Rukungiri Polygons 2" },
                                { "id": "public.soroti_blocks", "title": "Soroti Blocks" },
                                { "id": "public.soroti_lines1", "title": "Soroti Lines 1" },
                                { "id": "public.soroti_poly1", "title": "Soroti Polygons 1" },
                                { "id": "public.title_tracts_36n_lines", "title": "Title Tracts 36N Lines" },
                                { "id": "public.title_tracts_36n_poly", "title": "Title Tracts 36N Polygons" },
                                { "id": "public.title_tracts_36s_lines", "title": "Title Tracts 36S Lines" },
                                { "id": "public.title_tracts_36s_poly", "title": "Title Tracts 36S Polygons" },
                                { "id": "public.tororo_blocks", "title": "Tororo Blocks" },
                                { "id": "public.tororo_lines", "title": "Tororo Lines" },
                                { "id": "public.tororo_poly", "title": "Tororo Polygons" },
                                { "id": "public.untitled_lines", "title": "Untitled Lines" },
                                { "id": "public.untitled_polygons", "title": "Untitled Polygons" },
                                { "id": "public.wakiso_blocks", "title": "Wakiso Blocks" },
                                { "id": "public.wakiso_lines1", "title": "Wakiso Lines 1" },
                                { "id": "public.wakiso_lines2", "title": "Wakiso Lines 2" },
                                { "id": "public.wakiso_poly1", "title": "Wakiso Polygons 1" },
                                { "id": "public.wakiso_poly2", "title": "Wakiso Polygons 2" }
                            ]
                        };
                    }

                    const layers = data.collections.map(collection => collection.id);
                    console.log('Available layers:', layers);

                    const updatesDropdown = document.getElementById("gspnetUpdatesLayerSelect");
                    const extractorDropdown = document.getElementById("coordExtractorLayerSelect");

                    [updatesDropdown, extractorDropdown].forEach(dropdown => {
                        if (!dropdown) return;
                        dropdown.innerHTML = '<option value="">-- Select Layer --</option>';
                        layers.forEach(layer => {
                            const option = document.createElement("option");
                            option.value = layer;
                            // Use a more readable title
                            const collection = data.collections.find(c => c.id === layer);
                            option.textContent = collection ? collection.title || layer : layer;
                            dropdown.appendChild(option);
                        });
                    });

                    showToast(`Loaded ${layers.length} layers from pg_featureserv`, 'success');
                    return layers;
                } catch (error) {
                    console.error("Error loading pg_featureserv layers:", error);
                    showToast(`Error loading layers: ${error.message}`, 'error');
                    return [];
                }
            }

            // Create a preview layer from pg_featureserv
            function createPreviewLayer(layerId) {
                const source = new ol.source.Vector({
                    url: `https://pgf.geospatialnetworkug.xyz/collections/${layerId}/items?f=geojson&limit=10000`,
                    format: new ol.format.GeoJSON()
                });

                const layer = new ol.layer.Vector({
                    title: `${layerId} (Preview)`,
                    source: source,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#ff6b6b',
                            width: 2,
                            lineDash: [5, 5]
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 107, 107, 0.1)'
                        }),
                        image: new ol.style.Circle({
                            radius: 6,
                            stroke: new ol.style.Stroke({
                                color: '#ff6b6b',
                                width: 2
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 107, 107, 0.3)'
                            })
                        })
                    })
                });

                return layer;
            }

            // Create an editable layer for new features
            function createEditableLayer(layerId) {
                const source = new ol.source.Vector();

                const layer = new ol.layer.Vector({
                    title: `${layerId} (Editable)`,
                    source: source,
                    style: new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#2ecc71',
                            width: 3
                        }),
                        fill: new ol.style.Fill({
                            color: 'rgba(46, 204, 113, 0.2)'
                        }),
                        image: new ol.style.Circle({
                            radius: 8,
                            stroke: new ol.style.Stroke({
                                color: '#2ecc71',
                                width: 3
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(46, 204, 113, 0.5)'
                            })
                        })
                    })
                });

                return layer;
            }

            // Initialize pg_featureserv functionality on DOM ready
            document.addEventListener('DOMContentLoaded', function () {
                // Load layers when the page loads
                loadPgLayers();

                // GSP.NET UPDATES functionality
                const gspnetLayerSelect = document.getElementById('gspnetUpdatesLayerSelect');
                const startEditingBtn = document.getElementById('start-editing-btn');
                const plotCsvBtn = document.getElementById('plot-csv-btn');
                const stopEditingBtn = document.getElementById('stop-editing-btn');
                const saveUpdatesBtn = document.getElementById('save-updates-btn');
                const csvUploadInput = document.getElementById('csv-upload-updates');

                // Layer selection is handled by the async event listener at line 8814
                // This duplicate has been removed to prevent conflicts
                // The handler at line 8814 properly sets editingSession state

                // Start editing mode - now optional, mode buttons start drawing directly
                if (startEditingBtn) {
                    startEditingBtn.addEventListener('click', function () {
                        const selectedLayer = document.getElementById('gspnetUpdatesLayerSelect').value;
                        if (!selectedLayer) {
                            showToast('Please select a layer first', 'warning');
                            return;
                        }

                        const editMode = document.querySelector('.edit-mode-btn.active');
                        if (!editMode) {
                            // If no mode selected, just enable editing tools without starting draw
                            showToast('Select a drawing mode (Point/Line/Polygon) to start', 'info');
                            return;
                        }

                        // Start drawing using the mode
                        const mode = editMode.dataset.mode;
                        startDrawing(mode);
                    });
                }

                // CSV upload and plotting
                if (csvUploadInput) {
                    csvUploadInput.addEventListener('change', function () {
                        const file = this.files[0];
                        if (file && currentEditable) {
                            plotCsvBtn.disabled = false;
                            showToast('CSV file selected. Click "Plot Coordinates" to import.', 'info');
                        }
                    });
                }

                // CSV plotting is now handled by the event listener at line 8104
                // This duplicate listener has been removed to prevent conflicts

                // Stop editing
                if (stopEditingBtn) {
                    stopEditingBtn.addEventListener('click', function () {
                        // Remove draw interaction
                        if (drawInteraction) {
                            map.removeInteraction(drawInteraction);
                            drawInteraction = null;
                        }

                        // Clear editing interactions
                        clearEditingInteractions();

                        // Update UI
                        document.getElementById('start-editing-btn').disabled = false;
                        document.getElementById('stop-editing-btn').disabled = true;

                        showToast('Editing stopped', 'info');
                    });
                }

                // Save updates
                if (saveUpdatesBtn) {
                    saveUpdatesBtn.addEventListener('click', function () {
                        saveUpdates();
                    });
                }

                // Coordinate Extractor functionality
                const coordExtractorLayerSelect = document.getElementById('coordExtractorLayerSelect');
                const startExtractionBtn = document.getElementById('start-extraction-btn');
                const snappingToggleBtn = document.getElementById('snapping-toggle-btn');

                if (coordExtractorLayerSelect) {
                    coordExtractorLayerSelect.addEventListener('change', function () {
                        const selectedLayer = this.value;
                        if (selectedLayer) {
                            // Find the layer configuration
                            const layerConfig = EDITABLE_LAYERS.find(l => l.id === selectedLayer);
                            if (layerConfig) {
                                showPreviewForLayer(layerConfig);
                            } else {
                                // For non-editable layers (FlatGeobuf), snapping is handled by our FlatGeobuf implementation
                                console.log(`Selected layer: ${selectedLayer} (FlatGeobuf layer)`);
                            }

                            startExtractionBtn.disabled = false;
                            showToast(`Layer ${selectedLayer} loaded for coordinate extraction`, 'success');
                        } else {
                            if (previewLayer) {
                                map.removeLayer(previewLayer);
                                previewLayer = null;
                                previewSource = null;
                            }
                            startExtractionBtn.disabled = true;
                        }
                    });
                }

                // Start coordinate extraction
                if (startExtractionBtn) {
                    startExtractionBtn.addEventListener('click', function () {
                        if (!previewLayer) return;

                        // Enable snapping to the preview layer
                        const snapSources = [previewSource];
                        if (controlPointsSource) snapSources.push(controlPointsSource);
                        if (csvPointsSource) snapSources.push(csvPointsSource);
                        safeAttachSnappingToCurrent(snapSources);

                        // Add click interaction for coordinate extraction
                        map.on('click', handleCoordinateExtraction);

                        this.disabled = true;
                        snappingToggleBtn.textContent = 'Snapping: ON';
                        showToast('Coordinate extraction started. Click on the map to extract coordinates.', 'success');
                    });
                }

                // Snapping toggle
                if (snappingToggleBtn) {
                    snappingToggleBtn.addEventListener('click', function () {
                        if (snapInteractions.length > 0) {
                            snapInteractions.forEach(si => map.removeInteraction(si));
                            snapInteractions = [];
                            this.textContent = 'Snapping: OFF';
                            showToast('Snapping disabled', 'info');
                        } else if (previewLayer) {
                            const snapSources = [previewSource];
                            if (controlPointsSource) snapSources.push(controlPointsSource);
                            if (csvPointsSource) snapSources.push(csvPointsSource);
                            safeAttachSnappingToCurrent(snapSources);
                            this.textContent = 'Snapping: ON';
                            showToast('Snapping enabled', 'success');
                        }
                    });
                }

                // Edit mode selection
                const editModeBtns = document.querySelectorAll('.edit-mode-btn');
                editModeBtns.forEach(btn => {
                    btn.addEventListener('click', function () {
                        const mode = this.getAttribute('data-mode');

                        // Check if layer is selected
                        if (!editingSession.layerId || !currentEditable) {
                            showToast('Please select a layer first', 'warning');
                            return;
                        }

                        // Check if geometry type matches layer type
                        const layerGeomType = editingSession.layerConfig?.geomType;
                        const requestedType = mode === 'point' ? 'Point' : mode === 'line' ? 'LineString' : 'Polygon';

                        if (layerGeomType && layerGeomType !== requestedType) {
                            showToast(`Cannot draw ${requestedType} on ${layerGeomType} layer`, 'warning');
                            return;
                        }

                        // Update active button
                        editModeBtns.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');

                        // Start drawing
                        startDrawing(mode);
                    });
                });
            });

            // Enhanced drawing functionality for GSP.NET UPDATES with QGIS-like behavior
            function startDrawing(mode) {
                if (!currentEditable) {
                    showToast('Please select a layer first', 'warning');
                    return;
                }

                stopDrawing(); // Clear any existing interactions

                const source = currentEditable.source;
                const geometryType = mode === 'point' ? 'Point' : mode === 'line' ? 'LineString' : 'Polygon';

                // Store current draw mode
                editingSession.currentDrawMode = geometryType;

                // Create draw interaction
                drawInteraction = new ol.interaction.Draw({
                    source: source,
                    type: geometryType
                });

                // Store in editing session
                editingSession.interactions.draw = drawInteraction;

                // Handle draw end - add to buffer and open attribute form
                drawInteraction.on('drawend', (evt) => {
                    const feature = evt.feature;

                    // Mark as new feature
                    feature.set('_pgfs_state', 'new');

                    // Add to edit buffer
                    if (!editingSession.editBuffer.adds.includes(feature)) {
                        editingSession.editBuffer.adds.push(feature);
                    }
                    if (!editBuffers.adds.includes(feature)) {
                        editBuffers.adds.push(feature);
                    }

                    // Update pending count
                    updatePendingCount();

                    // Open attribute form for new feature
                    setTimeout(() => {
                        editingSession.selectedFeatures = [feature];
                        if (editingSession.schema) {
                            generateAttributeForm(feature, editingSession.schema);
                        }
                    }, 100);

                    showToast(`${geometryType} created. Fill in attributes.`, 'success');
                });

                map.addInteraction(drawInteraction);

                // Enable crosshair cursor
                enableCrosshair();

                // Enable modify interaction for existing features
                modifyInteraction = new ol.interaction.Modify({
                    source: source
                });

                modifyInteraction.on('modifyend', (evt) => {
                    evt.features.forEach(feature => {
                        if (feature.get('_pgfs_state') !== 'new') {
                            feature.set('_pgfs_state', 'modified');
                            if (!editingSession.editBuffer.updates.includes(feature)) {
                                editingSession.editBuffer.updates.push(feature);
                            }
                            if (!editBuffers.updates.includes(feature)) {
                                editBuffers.updates.push(feature);
                            }
                        }
                    });
                    updatePendingCount();
                });

                map.addInteraction(modifyInteraction);

                // Setup right-click to finish
                setupRightClickFinish();

                // Update snapping
                updateSnapping();

                // Add selection interaction for existing features
                if (!selectInteraction) {
                    selectInteraction = new ol.interaction.Select({
                        layers: [currentEditable.layer],
                        style: new ol.style.Style({
                            stroke: new ol.style.Stroke({ color: '#FFA500', width: 3 }),
                            fill: new ol.style.Fill({ color: 'rgba(255, 165, 0, 0.3)' }),
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({ color: '#FFA500' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            })
                        })
                    });

                    selectInteraction.on('select', (evt) => {
                        if (evt.selected.length > 0) {
                            editingSession.selectedFeatures = evt.selected;
                            showToast(`${evt.selected.length} feature(s) selected. Press Delete to remove or double-click to edit attributes.`, 'info');
                        } else {
                            editingSession.selectedFeatures = [];
                        }
                    });

                    map.addInteraction(selectInteraction);
                    editingSession.interactions.select = selectInteraction;
                }

                // Add double-click to edit attributes
                map.on('dblclick', (evt) => {
                    if (editingSession.selectedFeatures.length > 0) {
                        const feature = editingSession.selectedFeatures[0];
                        if (editingSession.schema) {
                            generateAttributeForm(feature, editingSession.schema);
                        }
                    }
                });

                // Update UI
                document.getElementById('start-editing-btn').disabled = true;
                document.getElementById('stop-editing-btn').disabled = false;
                document.getElementById('save-updates-btn').disabled = false;

                showToast(`Started drawing ${mode}s. Left-click to add vertices, right-click to finish.`, 'success');
            }

            function stopDrawing() {
                if (drawInteraction) {
                    map.removeInteraction(drawInteraction);
                    drawInteraction = null;
                }
                if (modifyInteraction) {
                    map.removeInteraction(modifyInteraction);
                    modifyInteraction = null;
                }

                // Disable crosshair cursor
                disableCrosshair();

                // Update UI
                document.getElementById('start-editing-btn').disabled = false;
                document.getElementById('stop-editing-btn').disabled = true;

                showToast('Drawing stopped', 'info');
            }

            // Coordinate extraction handler
            function handleCoordinateExtraction(evt) {
                const coordinate = evt.coordinate;
                const crs = document.getElementById('crs-selector').value;

                // Transform to selected CRS
                const transformedCoord = ol.proj.transform(coordinate, 'EPSG:3857', crs);

                // Add to results table
                const tbody = document.getElementById('coord-results-body');
                const row = document.createElement('tr');
                const pointId = tbody.children.length + 1;

                row.innerHTML = `
                <td>${pointId}</td>
                <td>${transformedCoord[0].toFixed(6)}</td>
                <td>${transformedCoord[1].toFixed(6)}</td>
                <td>${coordinate[1].toFixed(6)}</td>
                <td>${coordinate[0].toFixed(6)}</td>
            `;

                tbody.appendChild(row);

                // Enable export button
                document.getElementById('export-csv-btn').disabled = false;

                showToast(`Coordinate extracted: ${transformedCoord[0].toFixed(6)}, ${transformedCoord[1].toFixed(6)}`, 'success');
            }

            // Save updates to pg_featureserv
            async function saveUpdates() {
                if (!currentEditable || !document.getElementById('gspnetUpdatesLayerSelect').value) return;

                const features = editBuffers.adds.concat(editBuffers.updates);

                if (features.length === 0) {
                    showToast('No features to save', 'warning');
                    return;
                }

                const layerId = document.getElementById('gspnetUpdatesLayerSelect').value;
                const confirmSave = confirm(`Save ${features.length} features to ${layerId}?`);

                if (!confirmSave) return;

                try {
                    let successCount = 0;
                    let errorCount = 0;

                    for (const feature of features) {
                        try {
                            const geometry = feature.getGeometry();
                            const properties = feature.getProperties();
                            delete properties.geometry; // Remove geometry from properties

                            const geojsonFeature = {
                                type: 'Feature',
                                geometry: new ol.format.GeoJSON().writeGeometryObject(geometry),
                                properties: properties
                            };

                            const response = await fetch(`https://pgf.geospatialnetworkug.xyz/collections/${layerId}/items`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/geo+json'
                                },
                                body: JSON.stringify(geojsonFeature)
                            });

                            if (response.ok) {
                                successCount++;
                            } else {
                                console.error('Failed to save feature:', response.statusText);
                                errorCount++;
                            }
                        } catch (error) {
                            console.error('Error saving feature:', error);
                            errorCount++;
                        }
                    }

                    if (successCount > 0) {
                        showToast(`Successfully saved ${successCount} features to ${layerId}`, 'success');
                        source.clear(); // Clear the editable layer
                        updatePendingCount();
                    }

                    if (errorCount > 0) {
                        showToast(`Failed to save ${errorCount} features`, 'error');
                    }

                } catch (error) {
                    console.error('Error saving updates:', error);
                    showToast('Error saving updates: ' + error.message, 'error');
                }
            }

            // Update pending count display
            function updatePendingCount() {
                const countElement = document.getElementById('gspnet-pending-count');
                if (countElement) {
                    const pendingCount = editBuffers.adds.length + editBuffers.updates.length + editBuffers.deletes.length;
                    countElement.textContent = pendingCount;
                }
            }

            // Export coordinates to CSV
            function exportCoordinatesToCSV() {
                const tbody = document.getElementById('coord-results-body');
                if (tbody.children.length === 0) {
                    showToast('No coordinates to export', 'warning');
                    return;
                }

                let csv = 'Point ID,Easting,Northing,Latitude,Longitude\n';

                for (const row of tbody.children) {
                    const cells = row.children;
                    csv += `${cells[0].textContent},${cells[1].textContent},${cells[2].textContent},${cells[3].textContent},${cells[4].textContent}\n`;
                }

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'extracted_coordinates.csv';
                a.click();
                window.URL.revokeObjectURL(url);

                showToast('Coordinates exported to CSV', 'success');
            }

            // Wire up export button
            document.addEventListener('DOMContentLoaded', function () {
                const exportBtn = document.getElementById('export-csv-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', exportCoordinatesToCSV);
                }
            });

            // PATCH: Fix other button functionalities - Copy from working webmap.html
            // Locate button functionality
            const locateBtn = document.getElementById('locateBtn');
            if (locateBtn && !locateBtn.hasAttribute('data-listener-added')) {
                locateBtn.setAttribute('data-listener-added', 'true');
                locateBtn.addEventListener('click', function () {
                    if (!navigator.geolocation) {
                        alert('Geolocation is not supported by your browser');
                        if (typeof showToast === 'function') {
                            showToast('Geolocation is not supported by your browser', 'error');
                        }
                        return;
                    }

                    // Check if we have permission
                    if (navigator.permissions) {
                        navigator.permissions.query({ name: 'geolocation' }).then(function (result) {
                            if (result.state === 'denied') {
                                if (typeof showToast === 'function') {
                                    showToast('Geolocation access denied. Please enable location access in your browser settings.', 'error', 8000);
                                }
                                return;
                            }
                            attemptGeolocation();
                        }).catch(function (error) {
                            console.warn('Permissions API not fully supported, attempting geolocation anyway');
                            attemptGeolocation();
                        });
                    } else {
                        attemptGeolocation();
                    }
                });
            }

            function attemptGeolocation() {
                const mainMap = window.map || (typeof map !== 'undefined' ? map : null);
                if (!mainMap) {
                    console.error('Map not available for geolocation');
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 60000
                };

                if (typeof showToast === 'function') {
                    showToast('Getting your location...', 'info');
                }

                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        const lon = position.coords.longitude;
                        const lat = position.coords.latitude;
                        const accuracy = position.coords.accuracy;

                        console.log('Location obtained:', { lon, lat, accuracy });

                        // Check if accuracy is reasonable
                        let accuracyMessage = '';
                        if (accuracy <= 10) {
                            accuracyMessage = ' (Very High Accuracy)';
                        } else if (accuracy <= 50) {
                            accuracyMessage = ' (High Accuracy)';
                        } else if (accuracy <= 100) {
                            accuracyMessage = ' (Good Accuracy)';
                        } else {
                            accuracyMessage = ` (Accuracy: ${Math.round(accuracy)}m - May not be precise)`;
                        }

                        const coord = ol.proj.transform([lon, lat], 'EPSG:4326', 'EPSG:3857');

                        // Clear previous markers (check if markerSource exists)
                        if (typeof markerSource !== 'undefined' && markerSource) {
                            markerSource.clear();

                            // Add user location marker
                            const marker = new ol.Feature({
                                geometry: new ol.geom.Point(coord),
                                type: 'user'
                            });
                            markerSource.addFeature(marker);
                        }

                        // Zoom to location
                        let zoomLevel = 16;
                        if (accuracy > 100) zoomLevel = 14;
                        else if (accuracy > 50) zoomLevel = 15;

                        const view = mainMap.getView();
                        if (view) {
                            view.animate({
                                center: coord,
                                zoom: zoomLevel,
                                duration: 1500
                            });
                        }

                        if (typeof showToast === 'function') {
                            showToast(`Your location has been marked on the map${accuracyMessage}`, 'success');
                        }
                    },
                    function (error) {
                        console.error('Geolocation error:', error);
                        let errorMessage = 'Unable to get your location: ';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Location access denied.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out.';
                                break;
                            default:
                                errorMessage += 'Unknown error occurred.';
                                break;
                        }
                        if (typeof showToast === 'function') {
                            showToast(errorMessage, 'error', 8000);
                        }
                    },
                    options
                );
            }

            // Full screen functionality
            document.getElementById('fullScreenBtn').addEventListener('click', function () {
                const mapElement = document.getElementById('map');

                if (!document.fullscreenElement) {
                    if (mapElement.requestFullscreen) {
                        mapElement.requestFullscreen();
                    } else if (mapElement.mozRequestFullScreen) {
                        mapElement.mozRequestFullScreen();
                    } else if (mapElement.webkitRequestFullscreen) {
                        mapElement.webkitRequestFullscreen();
                    } else if (mapElement.msRequestFullscreen) {
                        mapElement.msRequestFullscreen();
                    }
                    showToast('Full screen mode enabled', 'info');
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                    showToast('Full screen mode disabled', 'info');
                }
            });

            // Enhanced Print button functionality
            const printBtn = document.getElementById('printBtn');
            if (printBtn) {
                printBtn.addEventListener('click', function () {
                    // Open the print dialog modal
                    const printModal = document.getElementById('printDialogModal');
                    if (!printModal) {
                        console.error('Print dialog modal not found');
                        return;
                    }
                    printModal.classList.add('active');

                    // ALWAYS destroy and recreate preview map to ensure fresh layer state
                    // This fixes the caching issue where layer changes weren't reflected
                    if (window.printPreviewMap) {
                        console.log('[PRINT] Destroying old preview map to refresh layers');
                        window.printPreviewMap.setTarget(null); // Detach from DOM
                        window.printPreviewMap = null; // Clear reference
                    }

                    // Always initialize with current layer state (basemaps, visibility, contours, etc.)
                    setTimeout(() => {
                        console.log('[PRINT] Creating fresh preview map with current layer state');
                        initializePrintPreviewMap();
                    }, 200);
                });
            }

            // Initialize print preview map
            function initializePrintPreviewMap() {
                // Get map reference (use window.map if available, otherwise try local map)
                const mainMap = window.map || (typeof map !== 'undefined' ? map : null);
                if (!mainMap) {
                    console.error('Main map not initialized');
                    return;
                }

                // Check if preview container exists
                const previewContainer = document.getElementById('printMapPreview');
                if (!previewContainer) {
                    console.error('Print map preview container not found');
                    return;
                }

                // Get current map view
                const currentView = mainMap.getView();
                if (!currentView) {
                    console.error('Map view not available');
                    return;
                }

                const currentCenter = currentView.getCenter();
                const currentZoom = currentView.getZoom();
                const currentProjection = currentView.getProjection();

                // Get all layers from main map (including layer groups)
                const layers = [];

                function cloneLayer(layer) {
                    if (layer instanceof ol.layer.Tile) {
                        return new ol.layer.Tile({
                            source: layer.getSource(),
                            opacity: layer.getOpacity(),
                            visible: layer.getVisible()
                        });
                    } else if (layer instanceof ol.layer.VectorImage) {
                        // *** CRITICAL FIX: Support VectorImage layers (used for contours) ***
                        return new ol.layer.VectorImage({
                            source: layer.getSource(),
                            style: layer.getStyle(),
                            opacity: layer.getOpacity(),
                            visible: layer.getVisible(),
                            declutter: true // Maintain decluttering in print
                        });
                    } else if (layer instanceof ol.layer.Vector) {
                        return new ol.layer.Vector({
                            source: layer.getSource(),
                            style: layer.getStyle(),
                            opacity: layer.getOpacity(),
                            visible: layer.getVisible()
                        });
                    } else if (layer instanceof ol.layer.Image) {
                        return new ol.layer.Image({
                            source: layer.getSource(),
                            opacity: layer.getOpacity(),
                            visible: layer.getVisible()
                        });
                    } else if (layer instanceof ol.layer.Group) {
                        // Handle layer groups - clone all sublayers
                        const sublayers = [];
                        layer.getLayers().forEach(function (sublayer) {
                            const cloned = cloneLayer(sublayer);
                            if (cloned) sublayers.push(cloned);
                        });
                        return new ol.layer.Group({
                            layers: sublayers,
                            opacity: layer.getOpacity(),
                            visible: layer.getVisible()
                        });
                    }
                    return null;
                }

                mainMap.getLayers().forEach(function (layer) {
                    const cloned = cloneLayer(layer);
                    if (cloned) {
                        if (cloned instanceof ol.layer.Group) {
                            // Add all sublayers from group
                            cloned.getLayers().forEach(function (sublayer) {
                                layers.push(sublayer);
                            });
                        } else {
                            layers.push(cloned);
                        }
                    }
                });

                // Create controls array (OpenLayers 7 doesn't have ol.control.defaults)
                const previewControls = [
                    new ol.control.Zoom(),
                    new ol.control.Rotate()
                ];

                // Create a new map instance for preview
                window.printPreviewMap = new ol.Map({
                    target: 'printMapPreview',
                    layers: layers,
                    view: new ol.View({
                        center: currentCenter,
                        zoom: currentZoom,
                        projection: currentProjection
                    }),
                    controls: previewControls
                });

                // Set map size after a short delay to ensure container is rendered
                setTimeout(() => {
                    if (window.printPreviewMap) {
                        const previewContainer = document.getElementById('printMapPreview');
                        if (previewContainer && previewContainer.offsetWidth > 0) {
                            window.printPreviewMap.updateSize();
                        }
                    }
                }, 200);
            }

            // Sync preview map with main map
            function syncPreviewMap() {
                if (window.printPreviewMap) {
                    const mainMap = window.map || (typeof map !== 'undefined' ? map : null);
                    if (mainMap) {
                        const currentView = mainMap.getView();
                        if (currentView) {
                            window.printPreviewMap.getView().setCenter(currentView.getCenter());
                            window.printPreviewMap.getView().setZoom(currentView.getZoom());
                        }
                    }
                }
            }

            // Close print dialog
            const closePrintDialogBtn = document.getElementById('closePrintDialog');
            const cancelPrintBtn = document.getElementById('cancelPrint');
            const resetPreviewBtn = document.getElementById('resetPreviewView');
            const previewPrintBtn = document.getElementById('previewPrint');
            const executePrintBtn = document.getElementById('executePrint');

            function closePrintDialog() {
                const printModal = document.getElementById('printDialogModal');
                if (printModal) {
                    printModal.classList.remove('active');
                }
            }

            if (closePrintDialogBtn) {
                closePrintDialogBtn.addEventListener('click', closePrintDialog);
            }
            if (cancelPrintBtn) {
                cancelPrintBtn.addEventListener('click', closePrintDialog);
            }

            // Reset preview view
            if (resetPreviewBtn) {
                resetPreviewBtn.addEventListener('click', function () {
                    if (window.printPreviewMap) {
                        syncPreviewMap();
                    }
                });
            }

            // Preview print
            if (previewPrintBtn) {
                previewPrintBtn.addEventListener('click', function () {
                    generatePrintPreview(true);
                });
            }

            // Execute print
            if (executePrintBtn) {
                executePrintBtn.addEventListener('click', function () {
                    // Validate form
                    if (!validatePrintForm()) {
                        alert('Please fill in all required fields (marked with *)');
                        return;
                    }

                    // Generate preview or export based on format
                    generatePrintPreview(false);
                });
            }

            function validatePrintForm() {
                const required = ['printHeading', 'printDistrict', 'printCounty',
                    'printClientName', 'printClientContact',
                    'printSurveyorName', 'printSurveyorContact'];
                return required.every(id => {
                    const field = document.getElementById(id);
                    return field && field.value.trim() !== '';
                });
            }

            // Generate QR code using API
            function generateQRCode(text, size = 100) {
                const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(text)}`;
                return qrUrl;
            }

            // Compass SVG - Enhanced Design with Graphics
            function getCompassSVG() {
                return `<svg width="120" height="120" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- Gradient for North arrow -->
    <linearGradient id="northGrad" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#1a1a1a;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#000000;stop-opacity:1" />
    </linearGradient>
    <!-- Shadow filter -->
    <filter id="compassShadow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
      <feOffset dx="1" dy="1" result="offsetblur"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.3"/>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    <!-- Inner circle gradient -->
    <radialGradient id="innerGrad" cx="50%" cy="50%">
      <stop offset="0%" style="stop-color:#f5f5f5;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
    </radialGradient>
  </defs>
  
  <!-- Background circle with gradient -->
  <circle cx="100" cy="100" r="95" fill="url(#innerGrad)" stroke="black" stroke-width="3" filter="url(#compassShadow)"/>
  <circle cx="100" cy="100" r="85" fill="none" stroke="black" stroke-width="1.5"/>
  
  <!-- Decorative inner ring -->
  <circle cx="100" cy="100" r="75" fill="none" stroke="#666" stroke-width="0.5" opacity="0.5"/>
  
  <!-- North (bold with gradient) -->
  <polygon points="100,10 115,100 100,90 85,100" fill="url(#northGrad)" stroke="black" stroke-width="1.5"/>

  <!-- South (with subtle gradient) -->
  <polygon points="100,190 115,100 100,110 85,100" fill="white" stroke="black" stroke-width="1.5">
    <animate attributeName="fill" values="white;#f0f0f0;white" dur="0s"/>
  </polygon>

  <!-- East -->
  <polygon points="190,100 100,115 110,100 100,85" fill="white" stroke="black" stroke-width="1.5"/>

  <!-- West -->
  <polygon points="10,100 100,115 90,100 100,85" fill="white" stroke="black" stroke-width="1.5"/>

  <!-- Center point -->
  <circle cx="100" cy="100" r="3" fill="black" stroke="white" stroke-width="1"/>

  <!-- Cardinal letters with shadow effect -->
  <text x="100" y="40" text-anchor="middle" font-size="20" font-weight="bold" font-family="Arial, sans-serif" fill="black" stroke="white" stroke-width="0.5">N</text>
  <text x="160" y="108" text-anchor="middle" font-size="17" font-weight="bold" font-family="Arial, sans-serif" fill="black" stroke="white" stroke-width="0.5">E</text>
  <text x="100" y="175" text-anchor="middle" font-size="17" font-weight="bold" font-family="Arial, sans-serif" fill="black" stroke="white" stroke-width="0.5">S</text>
  <text x="40" y="108" text-anchor="middle" font-size="17" font-weight="bold" font-family="Arial, sans-serif" fill="black" stroke="white" stroke-width="0.5">W</text>
</svg>`;
            }

            // Modern North Arrow SVG - Improved Design (kept for backward compatibility)
            function getNorthArrowSVG() {
                return `
                <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="display: block; margin: 0 auto;">
                    <defs>
                        <linearGradient id="arrowGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#1a2a6c;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#3498db;stop-opacity:1" />
                        </linearGradient>
                        <filter id="shadow">
                            <feDropShadow dx="0" dy="1" stdDeviation="1" flood-opacity="0.3"/>
                        </filter>
                    </defs>
                    <!-- Compass background circle -->
                    <circle cx="50" cy="50" r="48" fill="white" stroke="#1a2a6c" stroke-width="2"/>
                    <circle cx="50" cy="50" r="42" fill="none" stroke="#3498db" stroke-width="1.5"/>
                    
                    <!-- Cardinal direction markers -->
                    <line x1="50" y1="2" x2="50" y2="8" stroke="#1a2a6c" stroke-width="2.5" stroke-linecap="round"/>
                    <line x1="50" y1="92" x2="50" y2="98" stroke="#666" stroke-width="1.5" stroke-linecap="round"/>
                    <line x1="2" y1="50" x2="8" y2="50" stroke="#666" stroke-width="1.5" stroke-linecap="round"/>
                    <line x1="92" y1="50" x2="98" y2="50" stroke="#666" stroke-width="1.5" stroke-linecap="round"/>
                    
                    <!-- North arrow - more refined -->
                    <path d="M 50 5 L 38 28 L 44 28 L 44 60 L 56 60 L 56 28 L 62 28 Z" 
                          fill="url(#arrowGrad)" stroke="#1a2a6c" stroke-width="1.5" filter="url(#shadow)"/>
                    
                    <!-- N letter with better positioning -->
                    <text x="50" y="82" font-family="Arial, sans-serif" font-size="20" font-weight="bold" 
                          text-anchor="middle" fill="#1a2a6c" letter-spacing="1">N</text>
                </svg>
            `;
            }

            // Generate scale bar SVG
            function generateScaleBar(scale, mapWidth, mapHeight, resolution) {
                if (scale === 'auto' || !resolution) {
                    return '';
                }

                // Extract numeric scale (e.g., "1:1000" -> 1000)
                const scaleValue = parseInt(scale.replace(/[^0-9]/g, ''));
                if (!scaleValue || isNaN(scaleValue)) {
                    return '';
                }

                // Calculate scale bar length in meters
                // For a good visual scale bar, use about 1/4 to 1/3 of map width
                const targetLengthPixels = mapWidth * 0.25;
                const targetLengthMeters = targetLengthPixels * resolution;

                // Round to nice values (100, 200, 500, 1000, 2000, 5000, etc.)
                let niceLength = 100;
                if (targetLengthMeters >= 5000) {
                    niceLength = Math.round(targetLengthMeters / 5000) * 5000;
                } else if (targetLengthMeters >= 2000) {
                    niceLength = Math.round(targetLengthMeters / 2000) * 2000;
                } else if (targetLengthMeters >= 1000) {
                    niceLength = Math.round(targetLengthMeters / 1000) * 1000;
                } else if (targetLengthMeters >= 500) {
                    niceLength = Math.round(targetLengthMeters / 500) * 500;
                } else if (targetLengthMeters >= 200) {
                    niceLength = Math.round(targetLengthMeters / 200) * 200;
                } else if (targetLengthMeters >= 100) {
                    niceLength = Math.round(targetLengthMeters / 100) * 100;
                } else {
                    niceLength = Math.round(targetLengthMeters / 50) * 50;
                }

                // Convert back to pixels
                const scaleBarLengthPixels = niceLength / resolution;

                // Format label
                let label = '';
                if (niceLength >= 1000) {
                    label = (niceLength / 1000).toFixed(niceLength % 1000 === 0 ? 0 : 1) + ' km';
                } else {
                    label = niceLength + ' m';
                }

                // Position at bottom right
                const x = mapWidth - scaleBarLengthPixels - 20;
                const y = mapHeight - 35;
                const barHeight = 10;
                const tickHeight = 14;

                return `
                <g id="scalebar" transform="translate(${x}, ${y})">
                    <!-- Scale bar background with shadow effect -->
                    <rect x="0" y="0" width="${scaleBarLengthPixels}" height="${barHeight}" 
                          fill="rgba(255, 255, 255, 0.95)" stroke="#000" stroke-width="1.5" rx="2"/>
                    <!-- Scale bar segments -->
                    <rect x="0" y="0" width="${scaleBarLengthPixels / 2}" height="${barHeight}" fill="#1a2a6c"/>
                    <!-- Ticks -->
                    <line x1="0" y1="0" x2="0" y2="${tickHeight}" stroke="#000" stroke-width="2" stroke-linecap="round"/>
                    <line x1="${scaleBarLengthPixels / 2}" y1="0" x2="${scaleBarLengthPixels / 2}" y2="${tickHeight}" stroke="#000" stroke-width="2" stroke-linecap="round"/>
                    <line x1="${scaleBarLengthPixels}" y1="0" x2="${scaleBarLengthPixels}" y2="${tickHeight}" stroke="#000" stroke-width="2" stroke-linecap="round"/>
                    <!-- Labels -->
                    <text x="0" y="${tickHeight + 13}" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#000" text-anchor="start">0</text>
                    <text x="${scaleBarLengthPixels / 2}" y="${tickHeight + 13}" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#000" text-anchor="middle">${label.split(' ')[0]}</text>
                    <text x="${scaleBarLengthPixels}" y="${tickHeight + 13}" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#000" text-anchor="end">${label}</text>
                </g>
            `;
            }

            // Capture map image at high resolution
            function captureMapImage(scale = 2) {
                if (!window.printPreviewMap) {
                    console.error('Print preview map not initialized');
                    return Promise.resolve(null);
                }

                return new Promise((resolve) => {
                    const mapSize = window.printPreviewMap.getSize();
                    if (!mapSize || mapSize[0] === 0 || mapSize[1] === 0) {
                        resolve(null);
                        return;
                    }

                    // Calculate high-resolution size
                    const width = Math.floor(mapSize[0] * scale);
                    const height = Math.floor(mapSize[1] * scale);

                    // Get current view
                    const view = window.printPreviewMap.getView();
                    const extent = view.calculateExtent(mapSize);
                    const resolution = view.getResolution();

                    // Create a temporary map for high-res rendering
                    const tempLayers = [];
                    window.printPreviewMap.getLayers().forEach(function (layer) {
                        if (layer instanceof ol.layer.Tile) {
                            tempLayers.push(new ol.layer.Tile({
                                source: layer.getSource(),
                                opacity: layer.getOpacity(),
                                visible: layer.getVisible()
                            }));
                        } else if (layer instanceof ol.layer.VectorImage) {
                            // *** CRITICAL: Support VectorImage layers (contours) in export ***
                            tempLayers.push(new ol.layer.VectorImage({
                                source: layer.getSource(),
                                style: layer.getStyle(),
                                opacity: layer.getOpacity(),
                                visible: layer.getVisible(),
                                declutter: true
                            }));
                        } else if (layer instanceof ol.layer.Vector) {
                            tempLayers.push(new ol.layer.Vector({
                                source: layer.getSource(),
                                style: layer.getStyle(),
                                opacity: layer.getOpacity(),
                                visible: layer.getVisible()
                            }));
                        } else if (layer instanceof ol.layer.Image) {
                            tempLayers.push(new ol.layer.Image({
                                source: layer.getSource(),
                                opacity: layer.getOpacity(),
                                visible: layer.getVisible()
                            }));
                        }
                    });

                    // Create temporary container
                    const tempContainer = document.createElement('div');
                    tempContainer.style.width = width + 'px';
                    tempContainer.style.height = height + 'px';
                    tempContainer.style.position = 'absolute';
                    tempContainer.style.left = '-9999px';
                    tempContainer.style.top = '0px';
                    document.body.appendChild(tempContainer);

                    const tempMap = new ol.Map({
                        layers: tempLayers,
                        view: new ol.View({
                            center: view.getCenter(),
                            zoom: view.getZoom(),
                            projection: view.getProjection()
                        }),
                        controls: []
                    });

                    tempMap.setTarget(tempContainer);
                    tempMap.updateSize();

                    // Wait for render
                    tempMap.once('rendercomplete', function () {
                        try {
                            const mapCanvas = document.createElement('canvas');
                            mapCanvas.width = width;
                            mapCanvas.height = height;
                            const mapContext = mapCanvas.getContext('2d');

                            // Fill with white background
                            mapContext.fillStyle = '#ffffff';
                            mapContext.fillRect(0, 0, width, height);

                            const canvasElements = tempContainer.querySelectorAll('.ol-layer canvas');

                            Array.prototype.forEach.call(canvasElements, function (canvas) {
                                if (canvas.width > 0 && canvas.height > 0) {
                                    const opacity = canvas.parentElement.style.opacity;
                                    mapContext.globalAlpha = opacity === '' || opacity === null ? 1 : Number(opacity);

                                    const transform = canvas.style.transform;
                                    if (transform) {
                                        const matrix = transform.match(/^matrix\(([^\(]*)\)$/);
                                        if (matrix) {
                                            const matrixValues = matrix[1].split(',').map(Number);
                                            mapContext.setTransform.apply(mapContext, matrixValues);
                                            mapContext.drawImage(canvas, 0, 0);
                                            mapContext.setTransform(1, 0, 0, 1, 0, 0);
                                        } else {
                                            mapContext.drawImage(canvas, 0, 0);
                                        }
                                    } else {
                                        mapContext.drawImage(canvas, 0, 0);
                                    }
                                }
                            });

                            // Cleanup
                            document.body.removeChild(tempContainer);
                            tempMap.setTarget(null);

                            resolve(mapCanvas.toDataURL('image/png'));
                        } catch (error) {
                            console.error('Error capturing map image:', error);
                            if (tempContainer.parentNode) {
                                document.body.removeChild(tempContainer);
                            }
                            tempMap.setTarget(null);
                            resolve(null);
                        }
                    });

                    // Trigger render
                    setTimeout(() => {
                        tempMap.renderSync();
                    }, 100);
                });
            }

            // Generate gridlines based on coordinate system and scale
            function generateGridlinesSVG(crs, scale, extent, mapWidth, mapHeight) {
                if (crs === 'none' || !extent || !mapWidth || !mapHeight) return '';

                // Calculate grid interval based on scale
                let interval = 1000; // default 1km
                if (scale && typeof scale === 'string') {
                    if (scale.includes('1:500')) interval = 50;
                    else if (scale.includes('1:1000')) interval = 100;
                    else if (scale.includes('1:2000')) interval = 200;
                    else if (scale.includes('1:5000')) interval = 500;
                    else if (scale.includes('1:10000')) interval = 1000;
                    else if (scale.includes('1:25000')) interval = 2500;
                    else if (scale.includes('1:50000')) interval = 5000;
                }

                try {
                    // Transform extent to selected CRS if needed
                    let gridExtent = extent;
                    const sourceProj = ol.proj.get('EPSG:3857');
                    const targetProj = crs !== 'EPSG:3857' ? ol.proj.get(crs) : null;

                    if (targetProj && sourceProj && crs !== 'EPSG:3857') {
                        // Transform from map projection (EPSG:3857) to selected CRS
                        gridExtent = ol.proj.transformExtent(extent, sourceProj, targetProj);
                    }

                    // Calculate grid lines in target CRS coordinates
                    const minX = Math.floor(gridExtent[0] / interval) * interval;
                    const maxX = Math.ceil(gridExtent[2] / interval) * interval;
                    const minY = Math.floor(gridExtent[1] / interval) * interval;
                    const maxY = Math.ceil(gridExtent[3] / interval) * interval;

                    // Generate SVG gridlines with blue color
                    let gridSVG = '<g id="gridlines" stroke="#0066cc" stroke-width="0.8" opacity="0.8" fill="none">';

                    // Vertical lines (eastings)
                    for (let x = minX; x <= maxX; x += interval) {
                        // Create points in target CRS
                        let point1 = [x, minY];
                        let point2 = [x, maxY];

                        // Transform back to map coordinates (EPSG:3857) for pixel calculation
                        if (targetProj && sourceProj) {
                            point1 = ol.proj.transform(point1, targetProj, sourceProj);
                            point2 = ol.proj.transform(point2, targetProj, sourceProj);
                        }

                        // Convert to pixel coordinates relative to the map extent
                        const x1 = ((point1[0] - extent[0]) / (extent[2] - extent[0])) * mapWidth;
                        const y1 = ((extent[3] - point1[1]) / (extent[3] - extent[1])) * mapHeight;
                        const x2 = ((point2[0] - extent[0]) / (extent[2] - extent[0])) * mapWidth;
                        const y2 = ((extent[3] - point2[1]) / (extent[3] - extent[1])) * mapHeight;

                        // Only draw if line is within map bounds
                        if ((x1 >= 0 && x1 <= mapWidth) || (x2 >= 0 && x2 <= mapWidth)) {
                            const clampedX = Math.max(0, Math.min(x1, mapWidth));
                            const clampedY1 = Math.max(0, Math.min(y1, mapHeight));
                            const clampedY2 = Math.max(0, Math.min(y2, mapHeight));

                            gridSVG += `<line x1="${clampedX}" y1="${clampedY1}" x2="${clampedX}" y2="${clampedY2}"/>`;

                            // Add label at top of line with white buffer
                            if (clampedX >= 0 && clampedX <= mapWidth && clampedY1 >= 0 && clampedY1 <= mapHeight) {
                                const labelText = Math.round(x).toLocaleString();
                                const labelX = clampedX + 4;
                                const labelY = Math.max(15, Math.min(clampedY1 + 15, mapHeight - 5));

                                // Calculate text width (approximate: 6px per character)
                                const textWidth = labelText.length * 6.5;
                                const textHeight = 12;

                                // White background rectangle for text - minimal padding
                                gridSVG += `<rect x="${labelX - 2}" y="${labelY - textHeight - 1}" width="${textWidth + 4}" height="${textHeight + 2}" fill="white" fill-opacity="0.9" stroke="none"/>`;
                                // Text label
                                gridSVG += `<text x="${labelX}" y="${labelY - 2}" font-size="10" fill="#000000" font-weight="600" text-anchor="start" dominant-baseline="middle">${labelText}</text>`;
                            }
                        }
                    }

                    // Horizontal lines (northings)
                    for (let y = minY; y <= maxY; y += interval) {
                        // Create points in target CRS
                        let point1 = [minX, y];
                        let point2 = [maxX, y];

                        // Transform back to map coordinates (EPSG:3857) for pixel calculation
                        if (targetProj && sourceProj) {
                            point1 = ol.proj.transform(point1, targetProj, sourceProj);
                            point2 = ol.proj.transform(point2, targetProj, sourceProj);
                        }

                        // Convert to pixel coordinates relative to the map extent
                        const x1 = ((point1[0] - extent[0]) / (extent[2] - extent[0])) * mapWidth;
                        const y1 = ((extent[3] - point1[1]) / (extent[3] - extent[1])) * mapHeight;
                        const x2 = ((point2[0] - extent[0]) / (extent[2] - extent[0])) * mapWidth;
                        const y2 = ((extent[3] - point2[1]) / (extent[3] - extent[1])) * mapHeight;

                        // Only draw if line is within map bounds
                        if ((y1 >= 0 && y1 <= mapHeight) || (y2 >= 0 && y2 <= mapHeight)) {
                            const clampedX1 = Math.max(0, Math.min(x1, mapWidth));
                            const clampedX2 = Math.max(0, Math.min(x2, mapWidth));
                            const clampedY = Math.max(0, Math.min(y1, mapHeight));

                            gridSVG += `<line x1="${clampedX1}" y1="${clampedY}" x2="${clampedX2}" y2="${clampedY}"/>`;

                            // Add label at left of line with white buffer
                            if (clampedY >= 0 && clampedY <= mapHeight && clampedX1 >= 0 && clampedX1 <= mapWidth) {
                                const labelText = Math.round(y).toLocaleString();
                                const labelX = Math.max(4, Math.min(clampedX1 + 4, mapWidth - 60));
                                const labelY = clampedY - 2;

                                // Calculate text width (approximate: 6px per character)
                                const textWidth = labelText.length * 6.5;
                                const textHeight = 12;

                                // White background rectangle for text - minimal padding
                                gridSVG += `<rect x="${labelX - 2}" y="${labelY - textHeight - 1}" width="${textWidth + 4}" height="${textHeight + 2}" fill="white" fill-opacity="0.9" stroke="none"/>`;
                                // Text label
                                gridSVG += `<text x="${labelX}" y="${labelY - 2}" font-size="10" fill="#000000" font-weight="600" text-anchor="start" dominant-baseline="middle">${labelText}</text>`;
                            }
                        }
                    }

                    gridSVG += '</g>';
                    return gridSVG;
                } catch (error) {
                    console.error('Error generating gridlines:', error);
                    return '';
                }
            }

            // Generate print preview
            async function generatePrintPreview(previewOnly = false) {
                // Collect form data
                const printData = {
                    heading: document.getElementById('printHeading').value,
                    district: document.getElementById('printDistrict').value,
                    county: document.getElementById('printCounty').value,
                    block: document.getElementById('printBlock').value,
                    plot: document.getElementById('printPlot').value,
                    clientName: document.getElementById('printClientName').value,
                    clientContact: document.getElementById('printClientContact').value,
                    surveyorName: document.getElementById('printSurveyorName').value,
                    surveyorContact: document.getElementById('printSurveyorContact').value,
                    supervisorName: document.getElementById('printSupervisorName').value,
                    company: document.getElementById('printCompany').value,
                    orientation: document.getElementById('printOrientation').value,
                    scale: document.getElementById('printScale').value,
                    crs: document.getElementById('printCRS').value,
                    date: new Date().toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    })
                };

                // Get map image from preview at high resolution
                const mapCanvas = await captureMapImage(2);

                // Get map info for scale bar
                let mapWidth = 0;
                let mapHeight = 0;
                let resolution = null;
                if (window.printPreviewMap) {
                    const mapSize = window.printPreviewMap.getSize();
                    if (mapSize) {
                        mapWidth = mapSize[0] * 2; // High res width
                        mapHeight = mapSize[1] * 2; // High res height
                        const view = window.printPreviewMap.getView();
                        if (view) {
                            resolution = view.getResolution();
                        }
                    }
                }

                // Generate scale bar
                const scaleBarSVG = generateScaleBar(printData.scale, mapWidth, mapHeight, resolution);

                // Generate gridlines based on coordinate system and scale
                let gridlinesSVG = '';
                if (window.printPreviewMap && printData.crs && printData.crs !== 'none') {
                    const view = window.printPreviewMap.getView();
                    if (view) {
                        const extent = view.calculateExtent(window.printPreviewMap.getSize());
                        gridlinesSVG = generateGridlinesSVG(printData.crs, printData.scale, extent, mapWidth, mapHeight);
                    }
                }

                // Generate QR code
                const qrCodeUrl = generateQRCode('https://webmap.geospatialnetworkug.xyz', 120);

                // Define page size (needed for both PDF and print preview)
                const pageSize = printData.orientation === 'landscape' ? 'A3 landscape' : 'A3';

                // Check if PDF export is requested
                const format = document.getElementById('printFormat').value;
                if (format === 'pdf' && !previewOnly) {
                    // Use html2canvas to capture preview window for exact match
                    generatePDFFromPreviewWindow(printData, mapCanvas, qrCodeUrl, scaleBarSVG, gridlinesSVG, mapWidth, mapHeight, pageSize);
                    return;
                }

                // Create print window for preview or print dialog
                const printWindow = window.open('', '_blank');

                printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Map Print - ${printData.heading}</title>
                    <style>
                        @page {
                            size: ${pageSize};
                            margin: 12mm;
                        }
                        * {
                            box-sizing: border-box;
                        }
                        body {
                            margin: 0;
                            padding: 0;
                            font-family: 'Arial', 'Helvetica', sans-serif;
                            font-size: 11px;
                            color: #000;
                            background: #fff;
                        }
                        .print-layout {
                            width: 100%;
                            height: 100%;
                        }
                        
                        /* Header Section - Restructured */
                        .print-header-section {
                            border: 3px solid #000;
                            padding: 10px 12px;
                            margin-bottom: 10px;
                            background: #fff;
                            position: relative;
                        }
                        .print-heading-row {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 8px;
                            border-bottom: 1px solid #ccc;
                            padding-bottom: 5px;
                        }
                        .print-heading {
                            text-align: center;
                            font-size: 22px;
                            font-weight: bold;
                            flex: 1;
                            color: #000;
                        }
                        .company-header {
                            font-weight: bold;
                            font-size: 14px;
                            color: #1a2a6c;
                            white-space: nowrap;
                        }
                        .print-info-container {
                            display: flex;
                            justify-content: space-between;
                            align-items: flex-start;
                            margin-top: 5px;
                        }
                        .print-left-info {
                            text-align: left;
                        }
                        .print-right-info {
                            text-align: right;
                            display: flex;
                            flex-direction: column;
                            align-items: flex-end;
                        }
                        .print-info-line {
                            margin: 3px 0;
                            font-size: 10px;
                            line-height: 1.3;
                        }
                        .print-info-label {
                            font-weight: 600;
                            display: inline-block;
                            min-width: 55px;
                        }
                        .print-info-value {
                            display: inline-block;
                        }
                        .qr-container {
                            margin-top: 5px;
                            text-align: center;
                        }
                        .qr-container img {
                            width: 70px;
                            height: 70px;
                            border: 1px solid #000;
                            padding: 2px;
                            background: #fff;
                        }
                        
                        /* Map Section - Fixed stretching */
                        .print-map-section {
                            border: 3px solid #000;
                            padding: 5px;
                            margin: 10px 0;
                            background: #fff;
                            min-height: 450px;
                            position: relative;
                        }
                        .print-map-container {
                            width: 100%;
                            height: 100%;
                            min-height: 450px;
                            border: 2px solid #333;
                            background: #f5f5f5;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            position: relative;
                            overflow: hidden;
                        }
                        .print-map-container img {
                            width: 100%;
                            height: 100%;
                            object-fit: contain;
                            object-position: center;
                            display: block;
                        }
                        .map-scale-info {
                            position: absolute;
                            bottom: 8px;
                            left: 8px;
                            background: rgba(255, 255, 255, 0.95);
                            padding: 4px 8px;
                            border: 1px solid #000;
                            font-size: 9px;
                            font-weight: 600;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                        }
                        .map-scale-bar {
                            position: absolute;
                            bottom: 8px;
                            right: 8px;
                        }
                        
                        /* Bottom Section with Signatures */
                        .print-bottom-section {
                            border: 3px solid #000;
                            padding: 12px;
                            margin-top: 10px;
                            display: flex;
                            justify-content: space-between;
                            gap: 15px;
                            background: #fff;
                            align-items: stretch;
                        }
                        .print-signature-section {
                            flex: 1;
                            border: 2px solid #000;
                            padding: 10px;
                            background: #fafafa;
                        }
                        .print-signature-section h4 {
                            margin: 0 0 10px 0;
                            font-size: 11px;
                            font-weight: bold;
                            color: #1a2a6c;
                            border-bottom: 1px solid #000;
                            padding-bottom: 5px;
                        }
                        .print-signature-line {
                            margin: 12px 0;
                            font-size: 10px;
                        }
                        .print-signature-label {
                            font-weight: 600;
                            display: block;
                            margin-bottom: 3px;
                        }
                        .print-signature-value {
                            margin-bottom: 5px;
                            min-height: 15px;
                        }
                        .print-signature-space {
                            height: 50px;
                            border-bottom: 2px solid #000;
                            margin-top: 8px;
                            position: relative;
                        }
                        .print-signature-space::after {
                            content: '';
                            position: absolute;
                            bottom: -1px;
                            left: 0;
                            right: 0;
                            border-bottom: 1px solid #ccc;
                        }
                        
                        /* Compass Container with Rectangle */
                        .print-compass-container {
                            flex: 0 0 140px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border: 2px solid #000;
                            background: #fafafa;
                            padding: 10px;
                            margin: 0 5px;
                            min-height: 140px;
                        }
                        .print-compass {
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            width: 120px;
                            height: 120px;
                        }
                        .print-compass svg {
                            display: block;
                        }
                        
                        @media print {
                            .print-compass-container {
                                position: fixed;
                                top: 15mm;
                                right: 15mm;
                            }
                        }
                        
                        /* Disclaimer Section */
                        .print-disclaimer-section {
                            border: 3px solid #000;
                            padding: 10px;
                            margin-top: 10px;
                            background: #fff;
                        }
                        .print-disclaimer-final {
                            font-size: 9px;
                            color: #333;
                            text-align: center;
                            line-height: 1.4;
                            margin: 0;
                        }
                        .print-disclaimer-final strong {
                            font-weight: bold;
                            color: #000;
                        }
                        
                        @media print {
                            body {
                                -webkit-print-color-adjust: exact;
                                print-color-adjust: exact;
                            }
                            .print-header-section,
                            .print-map-section,
                            .print-bottom-section,
                            .print-disclaimer-section {
                                page-break-inside: avoid;
                            }
                        }
                    </style>
                </head>
                <body class="print-mode">
                    <div class="print-layout">
                        <!-- Header Section - Restructured -->
                        <div class="print-header-section">
                            <div class="print-heading-row">
                                <div class="print-heading">${printData.heading}</div>
                                <div class="company-header">GSP.NET UGANDA</div>
                            </div>
                            <div class="print-info-container">
                                <div class="print-left-info">
                                    <div class="print-info-line">
                                        <span class="print-info-label">District:</span>
                                        <span class="print-info-value">${printData.district}</span>
                                        <span style="margin-left: 20px;" class="print-info-label">County:</span>
                                        <span class="print-info-value">${printData.county}</span>
                                    </div>
                                    <div class="print-info-line">
                                        <span class="print-info-label">Block:</span>
                                        <span class="print-info-value">${printData.block || 'N/A'}</span>
                                        <span style="margin-left: 20px;" class="print-info-label">Plot/Unique ID:</span>
                                        <span class="print-info-value">${printData.plot || 'N/A'}</span>
                                    </div>
                                    <div class="print-info-line">
                                        <span class="print-info-label">Client:</span>
                                        <span class="print-info-value">${printData.clientName}</span>
                                    </div>
                                    <div class="print-info-line">
                                        <span class="print-info-label">Contact:</span>
                                        <span class="print-info-value">${printData.clientContact}</span>
                                    </div>
                                </div>
                                <div class="print-right-info">
                                    <div class="qr-container">
                                        <img src="${qrCodeUrl}" alt="QR Code" title="Scan to visit webmap.geospatialnetworkug.xyz">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Map Section -->
                        <div class="print-map-section">
                            <div class="print-map-container">
                                ${mapCanvas ? `<img src="${mapCanvas}" alt="Map Preview" style="width: 100%; height: 100%; object-fit: contain; object-position: center;">` : '<div style="text-align: center; color: #666; padding: 50px;">Map preview will appear here</div>'}
                                ${gridlinesSVG ? `<svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;" viewBox="0 0 ${mapWidth} ${mapHeight}" preserveAspectRatio="xMidYMid meet">${gridlinesSVG}</svg>` : ''}
                                <div class="map-scale-info">Scale: ${printData.scale === 'auto' ? 'Auto' : printData.scale}</div>
                                ${printData.crs && printData.crs !== 'none' ? `<div style="position: absolute; bottom: 8px; left: 120px; background: rgba(255, 255, 255, 0.95); padding: 4px 8px; border: 1px solid #000; font-size: 9px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2); z-index: 10;">CRS: ${printData.crs}</div>` : ''}
                                ${scaleBarSVG && mapWidth > 0 && mapHeight > 0 ? `<svg style="position: absolute; bottom: 15px; right: 15px; pointer-events: none; z-index: 10;" width="${Math.min(mapWidth * 0.3, 300)}" height="${Math.min(mapHeight * 0.15, 80)}" viewBox="0 0 ${mapWidth} ${mapHeight}" preserveAspectRatio="xMinYMin meet">${scaleBarSVG}</svg>` : ''}
                            </div>
                        </div>
                        
                        <!-- Bottom Section with Signatures -->
                        <div class="print-bottom-section">
                            <!-- Surveyor Section -->
                            <div class="print-signature-section">
                                <h4>SURVEYOR INFORMATION</h4>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Name:</span>
                                    <div class="print-signature-value">${printData.surveyorName}</div>
                                </div>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Contact:</span>
                                    <div class="print-signature-value">${printData.surveyorContact}</div>
                                </div>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Signature:</span>
                                    <div class="print-signature-space"></div>
                                </div>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Date:</span>
                                    <div class="print-signature-value">${printData.date}</div>
                                </div>
                            </div>
                            
                            <!-- Compass Container -->
                            <div class="print-compass-container">
                                <div class="print-compass">
                                    ${getCompassSVG()}
                                </div>
                            </div>
                            
                            <!-- Supervisor Section -->
                            <div class="print-signature-section">
                                <h4>SUPERVISOR INFORMATION</h4>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Name:</span>
                                    <div class="print-signature-value">${printData.supervisorName || 'N/A'}</div>
                                </div>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Company:</span>
                                    <div class="print-signature-value">${printData.company || 'N/A'}</div>
                                </div>
                                <div class="print-signature-line">
                                    <span class="print-signature-label">Signature:</span>
                                    <div class="print-signature-space"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Disclaimer Section -->
                        <div class="print-disclaimer-section">
                            <p class="print-disclaimer-final">
                                <strong>DISCLAIMER:</strong> This map is provided "as is" without warranty. GSP.NET UGANDA does not verify all data and assumes no liability for errors, omissions, or damages. Users must independently verify all information.
                            </p>
                        </div>
                    </div>
                </body>
                </html>
            `);

                printWindow.document.close();

                if (!previewOnly) {
                    setTimeout(() => {
                        printWindow.print();
                    }, 500);
                }
            }

            // PDF generation from preview window (captures exactly what user sees)
            async function generatePDFFromPreviewWindow(printData, mapCanvas, qrCodeUrl, scaleBarSVG, gridlinesSVG, mapWidth, mapHeight, pageSize) {
                // Create a temporary div with the preview content, capture it, then convert to PDF
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.width = '297mm'; // A3 width
                tempDiv.style.height = '420mm'; // A3 height
                tempDiv.style.background = '#fff';
                document.body.appendChild(tempDiv);

                // Generate HTML content
                tempDiv.innerHTML = generatePreviewHTMLForPDF(printData, mapCanvas, qrCodeUrl, scaleBarSVG, gridlinesSVG, mapWidth, mapHeight, pageSize);

                // Wait for images to load
                await new Promise(resolve => {
                    const images = tempDiv.querySelectorAll('img');
                    let loaded = 0;
                    if (images.length === 0) {
                        resolve();
                        return;
                    }
                    images.forEach(img => {
                        if (img.complete) {
                            loaded++;
                            if (loaded === images.length) resolve();
                        } else {
                            img.onload = () => {
                                loaded++;
                                if (loaded === images.length) resolve();
                            };
                            img.onerror = () => {
                                loaded++;
                                if (loaded === images.length) resolve();
                            };
                        }
                    });
                    setTimeout(resolve, 2000); // Timeout after 2 seconds
                });

                if (typeof html2canvas === 'undefined') {
                    alert('html2canvas library not loaded. Please use Print option instead.');
                    document.body.removeChild(tempDiv);
                    return;
                }

                try {
                    // Capture the content at high resolution for quality PDF export
                    const canvas = await html2canvas(tempDiv, {
                        scale: 4, // Increased from 2 to 4 for very high resolution
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff',
                        width: tempDiv.scrollWidth,
                        height: tempDiv.scrollHeight,
                        windowWidth: tempDiv.scrollWidth,
                        windowHeight: tempDiv.scrollHeight
                    });

                    // Convert to PDF
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({
                        orientation: printData.orientation === 'landscape' ? 'landscape' : 'portrait',
                        unit: 'mm',
                        format: 'a3'
                    });

                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();

                    // Add image to PDF (fit to page)
                    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, pageWidth, pageHeight);

                    // Save PDF
                    const fileName = `Map_Print_${printData.heading.replace(/[^a-z0-9]/gi, '_')}_${new Date().getTime()}.pdf`;
                    pdf.save(fileName);

                    // Cleanup
                    document.body.removeChild(tempDiv);
                } catch (e) {
                    console.error('Error generating PDF from preview:', e);
                    alert('Error generating PDF. Please try the Print option instead.');
                    document.body.removeChild(tempDiv);
                }
            }

            // Generate preview HTML for PDF (extracted function)
            function generatePreviewHTMLForPDF(printData, mapCanvas, qrCodeUrl, scaleBarSVG, gridlinesSVG, mapWidth, mapHeight, pageSize) {
                // This will return the inner HTML content (without html/body tags)
                return `
                <div class="print-layout" style="width: 100%; height: 100%; font-family: 'Arial', 'Helvetica', sans-serif; font-size: 11px; color: #000; background: #fff;">
                    <!-- Header Section -->
                    <div style="border: 3px solid #000; padding: 10px 12px; margin-bottom: 10px; background: #fff;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; border-bottom: 1px solid #ccc; padding-bottom: 5px;">
                            <div style="text-align: center; font-size: 22px; font-weight: bold; flex: 1; color: #000;">${printData.heading}</div>
                            <div style="font-weight: bold; font-size: 14px; color: #1a2a6c; white-space: nowrap;">GSP.NET UGANDA</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 5px;">
                            <div style="text-align: left;">
                                <div style="margin: 3px 0; font-size: 10px;">
                                    <span style="font-weight: 600; min-width: 55px; display: inline-block;">District:</span>
                                    <span>${printData.district}</span>
                                    <span style="margin-left: 20px; font-weight: 600; min-width: 55px; display: inline-block;">County:</span>
                                    <span>${printData.county}</span>
                                </div>
                                <div style="margin: 3px 0; font-size: 10px;">
                                    <span style="font-weight: 600; min-width: 55px; display: inline-block;">Block:</span>
                                    <span>${printData.block || 'N/A'}</span>
                                    <span style="margin-left: 20px; font-weight: 600; min-width: 55px; display: inline-block;">Plot/Unique ID:</span>
                                    <span>${printData.plot || 'N/A'}</span>
                                </div>
                                <div style="margin: 3px 0; font-size: 10px;">
                                    <span style="font-weight: 600; min-width: 55px; display: inline-block;">Client:</span>
                                    <span>${printData.clientName}</span>
                                </div>
                                <div style="margin: 3px 0; font-size: 10px;">
                                    <span style="font-weight: 600; min-width: 55px; display: inline-block;">Contact:</span>
                                    <span>${printData.clientContact}</span>
                                </div>
                            </div>
                            <div style="text-align: right; display: flex; flex-direction: column; align-items: flex-end;">
                                <div style="margin-top: 5px; text-align: center;">
                                    <img src="${qrCodeUrl}" alt="QR Code" style="width: 70px; height: 70px; border: 1px solid #000; padding: 2px; background: #fff;">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Map Section -->
                    <div style="border: 3px solid #000; padding: 5px; margin: 10px 0; background: #fff; min-height: 450px; position: relative;">
                        <div style="width: 100%; height: 100%; min-height: 450px; border: 2px solid #333; background: #f5f5f5; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                            ${mapCanvas ? `<img src="${mapCanvas}" alt="Map Preview" style="width: 100%; height: 100%; object-fit: contain; object-position: center; display: block;">` : '<div style="text-align: center; color: #666; padding: 50px;">Map preview will appear here</div>'}
                            ${gridlinesSVG ? `<svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;" viewBox="0 0 ${mapWidth} ${mapHeight}" preserveAspectRatio="xMidYMid meet">${gridlinesSVG}</svg>` : ''}
                            <div style="position: absolute; bottom: 8px; left: 8px; background: rgba(255, 255, 255, 0.95); padding: 4px 8px; border: 1px solid #000; font-size: 9px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2); z-index: 10;">Scale: ${printData.scale === 'auto' ? 'Auto' : printData.scale}</div>
                            ${printData.crs && printData.crs !== 'none' ? `<div style="position: absolute; bottom: 8px; left: 120px; background: rgba(255, 255, 255, 0.95); padding: 4px 8px; border: 1px solid #000; font-size: 9px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2); z-index: 10;">CRS: ${printData.crs}</div>` : ''}
                            ${scaleBarSVG && mapWidth > 0 && mapHeight > 0 ? `<svg style="position: absolute; bottom: 15px; right: 15px; pointer-events: none; z-index: 10;" width="${Math.min(mapWidth * 0.3, 300)}" height="${Math.min(mapHeight * 0.15, 80)}" viewBox="0 0 ${mapWidth} ${mapHeight}" preserveAspectRatio="xMinYMin meet">${scaleBarSVG}</svg>` : ''}
                        </div>
                    </div>
                    
                    <!-- Bottom Section -->
                    <div style="border: 3px solid #000; padding: 12px; margin-top: 10px; display: flex; justify-content: space-between; gap: 15px; background: #fff; align-items: stretch;">
                        <!-- Surveyor Section -->
                        <div style="flex: 1; border: 2px solid #000; padding: 10px; background: #fafafa;">
                            <h4 style="margin: 0 0 10px 0; font-size: 11px; font-weight: bold; color: #1a2a6c; border-bottom: 1px solid #000; padding-bottom: 5px;">SURVEYOR INFORMATION</h4>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Name:</span>
                                <div style="margin-bottom: 5px; min-height: 15px;">${printData.surveyorName}</div>
                            </div>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Contact:</span>
                                <div style="margin-bottom: 5px; min-height: 15px;">${printData.surveyorContact}</div>
                            </div>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Signature:</span>
                                <div style="height: 50px; border-bottom: 2px solid #000; margin-top: 8px;"></div>
                            </div>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Date:</span>
                                <div style="margin-bottom: 5px; min-height: 15px;">${printData.date}</div>
                            </div>
                        </div>
                        
                        <!-- Compass Container -->
                        <div style="flex: 0 0 140px; display: flex; align-items: center; justify-content: center; border: 2px solid #000; background: #fafafa; padding: 10px; margin: 0 5px; min-height: 140px;">
                            <div style="display: flex; align-items: center; justify-content: center; width: 120px; height: 120px;">
                                ${getCompassSVG()}
                            </div>
                        </div>
                        
                        <!-- Supervisor Section -->
                        <div style="flex: 1; border: 2px solid #000; padding: 10px; background: #fafafa;">
                            <h4 style="margin: 0 0 10px 0; font-size: 11px; font-weight: bold; color: #1a2a6c; border-bottom: 1px solid #000; padding-bottom: 5px;">SUPERVISOR INFORMATION</h4>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Name:</span>
                                <div style="margin-bottom: 5px; min-height: 15px;">${printData.supervisorName || 'N/A'}</div>
                            </div>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Company:</span>
                                <div style="margin-bottom: 5px; min-height: 15px;">${printData.company || 'N/A'}</div>
                            </div>
                            <div style="margin: 10px 0; font-size: 10px;">
                                <span style="font-weight: 600; display: block; margin-bottom: 3px;">Signature:</span>
                                <div style="height: 50px; border-bottom: 2px solid #000; margin-top: 8px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Disclaimer Section -->
                    <div style="border: 3px solid #000; padding: 10px; margin-top: 10px; background: #fff;">
                        <p style="font-size: 9px; color: #333; text-align: center; line-height: 1.4; margin: 0;">
                            <strong>DISCLAIMER:</strong> This map is provided "as is" without warranty. GSP.NET UGANDA does not verify all data and assumes no liability for errors, omissions, or damages. Users must independently verify all information.
                        </p>
                    </div>
                </div>
            `;
            }

            // PDF generation function using jsPDF (legacy - kept for fallback)
            function generatePDF(printData, mapCanvas, qrCodeUrl, scaleBarSVG, mapWidth, mapHeight) {
                if (typeof window.jspdf === 'undefined') {
                    alert('PDF library not loaded. Please use Print option instead.');
                    return;
                }

                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: printData.orientation === 'landscape' ? 'landscape' : 'portrait',
                    unit: 'mm',
                    format: 'a3'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 12;
                const contentWidth = pageWidth - (margin * 2);

                let yPos = margin;

                // Header section with border
                pdf.setDrawColor(0, 0, 0);
                pdf.setLineWidth(0.8);
                pdf.rect(margin, yPos, contentWidth, 28);

                // Heading row - heading centered, company on right
                pdf.setFontSize(22);
                pdf.setFont('helvetica', 'bold');
                const headingWidth = pdf.getTextWidth(printData.heading);
                pdf.text(printData.heading, (pageWidth - headingWidth) / 2, yPos + 10);

                // Company name on same line, right aligned
                pdf.setFontSize(14);
                pdf.setTextColor(26, 42, 108); // #1a2a6c
                pdf.text('GSP.NET UGANDA', pageWidth - margin - 2, yPos + 10, { align: 'right' });
                pdf.setTextColor(0, 0, 0);

                yPos += 12;

                // Left info - starting from header line
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                pdf.text(`District: ${printData.district}  County: ${printData.county}`, margin + 2, yPos);
                yPos += 4;
                pdf.text(`Block: ${printData.block || 'N/A'}  Plot/ID: ${printData.plot || 'N/A'}`, margin + 2, yPos);
                yPos += 4;
                pdf.text(`Client: ${printData.clientName}`, margin + 2, yPos);
                yPos += 4;
                pdf.text(`Contact: ${printData.clientContact}`, margin + 2, yPos);

                // Right info with QR code
                if (qrCodeUrl) {
                    try {
                        // QR code positioned below company name
                        pdf.addImage(qrCodeUrl, 'PNG', pageWidth - margin - 30, yPos - 10, 25, 25);
                    } catch (e) {
                        console.error('Error loading QR code:', e);
                    }
                }

                // Map section (taking most space)
                yPos = margin + 35;
                const pdfMapHeight = pageHeight - yPos - 70; // Leave space for bottom section
                const pdfMapWidth = contentWidth;

                // Draw map border
                pdf.setLineWidth(1);
                pdf.rect(margin, yPos, pdfMapWidth, pdfMapHeight);
                pdf.setLineWidth(0.3);
                pdf.rect(margin + 3, yPos + 3, pdfMapWidth - 6, pdfMapHeight - 6);

                if (mapCanvas) {
                    try {
                        // Fill the map container exactly like the preview does (object-fit: contain)
                        // The map should fill the available space while maintaining aspect ratio
                        const mapX = margin + 3;
                        const mapY = yPos + 3;
                        const containerWidth = pdfMapWidth - 6;
                        const containerHeight = pdfMapHeight - 6;

                        // Calculate aspect ratios
                        const mapAspectRatio = mapWidth > 0 && mapHeight > 0 ? mapWidth / mapHeight : 1;
                        const containerAspectRatio = containerWidth / containerHeight;

                        let finalMapWidth = containerWidth;
                        let finalMapHeight = containerHeight;
                        let finalMapX = mapX;
                        let finalMapY = mapY;

                        // Fit map to container maintaining aspect ratio (like CSS object-fit: contain)
                        if (mapAspectRatio > containerAspectRatio) {
                            // Map is wider - fit to width, center vertically
                            finalMapHeight = containerWidth / mapAspectRatio;
                            finalMapY = mapY + (containerHeight - finalMapHeight) / 2;
                        } else {
                            // Map is taller - fit to height, center horizontally
                            finalMapWidth = containerHeight * mapAspectRatio;
                            finalMapX = mapX + (containerWidth - finalMapWidth) / 2;
                        }

                        // Add map image - this will match the preview exactly
                        pdf.addImage(mapCanvas, 'PNG', finalMapX, finalMapY, finalMapWidth, finalMapHeight);

                        // Add scale info box (matching preview position)
                        pdf.setFontSize(8);
                        pdf.setFont('helvetica', 'bold');
                        pdf.setFillColor(255, 255, 255, 0.95);
                        pdf.rect(margin + 5, yPos + pdfMapHeight - 12, 35, 8, 'F');
                        pdf.setTextColor(0, 0, 0);
                        pdf.text(`Scale: ${printData.scale === 'auto' ? 'Auto' : printData.scale}`, margin + 7, yPos + pdfMapHeight - 5);

                    } catch (e) {
                        console.error('Error adding map image:', e);
                        pdf.setFontSize(12);
                        pdf.text('Map preview unavailable', pageWidth / 2, yPos + pdfMapHeight / 2, { align: 'center' });
                    }
                } else {
                    pdf.setFontSize(12);
                    pdf.text('Map preview unavailable', pageWidth / 2, yPos + pdfMapHeight / 2, { align: 'center' });
                }

                // Bottom section with signatures
                yPos = pageHeight - 60;
                const bottomSectionHeight = 50;
                const sectionWidth = (contentWidth - 20) / 3; // Three sections with gaps

                // Surveyor section
                pdf.setLineWidth(0.5);
                pdf.rect(margin, yPos, sectionWidth, bottomSectionHeight);
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'bold');
                pdf.text('SURVEYOR INFORMATION', margin + 2, yPos + 5);
                pdf.setFont('helvetica', 'normal');
                pdf.setFontSize(9);
                pdf.text(`Name: ${printData.surveyorName}`, margin + 2, yPos + 10);
                pdf.text(`Contact: ${printData.surveyorContact}`, margin + 2, yPos + 15);
                pdf.text('Signature: _______________', margin + 2, yPos + 25);
                pdf.text(`Date: ${printData.date}`, margin + 2, yPos + 30);

                // North Arrow (center) - Convert SVG to data URL and add to PDF
                const northArrowX = margin + sectionWidth + 10;
                const northArrowY = yPos + bottomSectionHeight / 2;
                const northArrowSize = 20; // mm

                try {
                    // Convert compass SVG to data URL (synchronous)
                    const compassSVG = getCompassSVG();
                    // Create data URL from SVG string
                    const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(compassSVG)));

                    // Add compass image to PDF (adjust size to match 120px)
                    const compassSize = 30; // mm - adjusted to match 120px at print resolution
                    pdf.addImage(svgDataUrl, 'SVG', northArrowX - compassSize / 2, northArrowY - compassSize / 2, compassSize, compassSize);
                } catch (e) {
                    console.error('Error adding north arrow SVG:', e);
                    // Fallback: Draw north arrow using PDF commands
                    pdf.setDrawColor(26, 42, 108); // #1a2a6c
                    pdf.setLineWidth(0.5);
                    pdf.circle(northArrowX, northArrowY, 18, 'S');
                    pdf.setDrawColor(52, 152, 219); // #3498db
                    pdf.setLineWidth(0.3);
                    pdf.circle(northArrowX, northArrowY, 15, 'S');
                    // Draw arrow shape
                    pdf.setFillColor(26, 42, 108);
                    pdf.rect(northArrowX - 2, northArrowY - 8, 4, 16, 'F');
                    // Draw "N"
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(26, 42, 108);
                    pdf.text('N', northArrowX, northArrowY + 6, { align: 'center' });
                    pdf.setTextColor(0, 0, 0);
                }

                // Supervisor section
                const supervisorX = margin + (sectionWidth * 2) + 20;
                pdf.rect(supervisorX, yPos, sectionWidth, bottomSectionHeight);
                pdf.setFont('helvetica', 'bold');
                pdf.text('SUPERVISOR INFORMATION', supervisorX + 2, yPos + 5);
                pdf.setFont('helvetica', 'normal');
                pdf.text(`Name: ${printData.supervisorName || 'N/A'}`, supervisorX + 2, yPos + 10);
                pdf.text(`Company: ${printData.company || 'N/A'}`, supervisorX + 2, yPos + 15);
                pdf.text('Signature: _______________', supervisorX + 2, yPos + 25);

                // Disclaimer
                const disclaimerY = pageHeight - 8;
                pdf.setFontSize(7);
                pdf.setFont('helvetica', 'normal');
                const disclaimerText = 'DISCLAIMER: This map is provided "as is" without warranty. GSP.NET UGANDA does not verify all data and assumes no liability for errors, omissions, or damages. Users must independently verify all information.';
                const splitDisclaimer = pdf.splitTextToSize(disclaimerText, contentWidth);
                pdf.text(splitDisclaimer, pageWidth / 2, disclaimerY, { align: 'center' });

                // Save PDF
                const fileName = `Map_Print_${printData.heading.replace(/[^a-z0-9]/gi, '_')}_${new Date().getTime()}.pdf`;
                pdf.save(fileName);
            }

            // OLD NLIS CODE - REMOVED (replaced with parcel search)

            // Chat state management
            let chatState = {
                isOpen: false,
                unreadCount: 0,
                onlineUsers: new Map(),
                typingUsers: new Set(),
                currentUser: { id: 'demo-user', email: 'demo@example.com', username: 'Demo User' },
                lastReadTime: new Date().toISOString(),
                messages: []
            };

            // Initialize chat system with Supabase
            async function initializeChat() {
                try {
                    // Function to get cookie value (reused from auth check)
                    function getCookie(name) {
                        const value = `; ${document.cookie}`;
                        const parts = value.split(`; ${name}=`);
                        if (parts.length === 2) return parts.pop().split(';').shift();
                    }

                    // Get current user from Supabase auth using the stored token
                    const authToken = getCookie('supabase_auth_token');
                    let user = null;

                    if (authToken) {
                        const { data: { user: authUser }, error: authError } = await supabase.auth.getUser(authToken);
                        if (!authError && authUser) {
                            user = authUser;
                        }
                    }

                    if (!user) {
                        // Fallback: try to get user from current session
                        const { data: { user: sessionUser }, error: sessionError } = await supabase.auth.getUser();
                        if (!sessionError && sessionUser) {
                            user = sessionUser;
                        }
                    }

                    if (!user) {
                        console.log('No authenticated user, using anonymous mode');
                        chatState.currentUser = {
                            id: 'anonymous_' + Date.now(),
                            email: 'Anonymous User',
                            username: 'Anonymous'
                        };
                    } else {
                        chatState.currentUser = {
                            id: user.id,
                            email: user.email,
                            username: user.email.split('@')[0] || 'User'
                        };
                    }

                    // Setup event listeners
                    setupChatEventListeners();

                    // Load recent messages from Supabase
                    await loadRecentMessages();

                    // Setup real-time subscriptions
                    setupRealtimeSubscriptions();

                    // Add welcome message
                    addMessage({
                        id: 'welcome',
                        content: `Welcome ${chatState.currentUser.username}`,
                        user_id: 'system',
                        username: 'System',
                        timestamp: new Date().toISOString(),
                        type: 'system'
                    });

                    // Update online users
                    await updateOnlineUsers();

                } catch (error) {
                    console.error('Error initializing chat:', error);
                    // Fallback to demo mode
                    chatState.currentUser = {
                        id: 'demo-user',
                        email: 'demo@example.com',
                        username: 'Demo User'
                    };
                    setupChatEventListeners();
                }
            }

            // Toggle chat panel
            function toggleChatPanel() {
                const panel = document.getElementById('chatPanel');
                chatState.isOpen = !chatState.isOpen;
                panel.classList.toggle('open', chatState.isOpen);

                if (chatState.isOpen) {
                    markMessagesAsRead();
                    // Focus on appropriate input based on current tab
                    const messageInput = document.getElementById('message-input');
                    const postInput = document.getElementById('post-input');
                    if (messageInput) messageInput.focus();
                    else if (postInput) postInput.focus();
                }
            }

            // Update unread badge
            function updateUnreadBadge() {
                const badge = document.getElementById('unreadBadge');
                badge.textContent = chatState.unreadCount > 9 ? '9+' : chatState.unreadCount.toString();
                badge.classList.toggle('active', chatState.unreadCount > 0);
            }

            // Mark messages as read
            function markMessagesAsRead() {
                chatState.unreadCount = 0;
                chatState.lastReadTime = new Date().toISOString();
                updateUnreadBadge();
            }

            // Update online users display
            function renderOnlineUsers() {
                const container = document.getElementById('onlineUsersList');
                container.innerHTML = '';

                chatState.onlineUsers.forEach(user => {
                    const userElement = document.createElement('div');
                    userElement.className = 'online-user';
                    userElement.innerHTML = `
                    <div class="user-status ${user.status}"></div>
                    <span>${user.username}</span>
                `;
                    container.appendChild(userElement);
                });
            }

            // Update online count
            function updateOnlineCount() {
                const countElement = document.getElementById('onlineCount');
                countElement.textContent = `${chatState.onlineUsers.size} online`;
            }

            // Add message to chat
            function addMessage(message) {
                chatState.messages.push(message);
                renderMessage(message);

                if (!chatState.isOpen) {
                    chatState.unreadCount++;
                    updateUnreadBadge();
                }

                // Auto-scroll to bottom
                const messagesList = document.getElementById('messagesList');
                messagesList.scrollTop = messagesList.scrollHeight;
            }

            // Render message in UI (WhatsApp-style)
            function renderMessage(message) {
                const messagesList = document.getElementById('messagesList');
                const messageElement = document.createElement('div');

                const isOwn = message.user_id === chatState.currentUser.id;
                const isSystem = message.type === 'system';
                const isLocation = message.type === 'location';

                // WhatsApp-style message container
                messageElement.className = `message-item ${isOwn ? 'message-sent' : 'message-received'}`;
                messageElement.setAttribute('data-message-id', message.id);

                if (isSystem) {
                    messageElement.innerHTML = `
                    <div class="system-message">
                        <div class="system-content">${formatMessage(message.content)}</div>
                    </div>
                `;
                } else if (isLocation && message.metadata) {
                    const metadataStr = JSON.stringify(message.metadata).replace(/"/g, '&quot;');
                    messageElement.innerHTML = `
                    <div class="message-bubble location-bubble">
                        ${!isOwn ? `<div class="sender-name">${message.username}</div>` : ''}
                        <div class="location-message">
                            <div class="location-icon">📍</div>
                            <div class="location-text">${formatMessage(message.content)}</div>
                        </div>
                        <div class="message-time">${formatTime(message.timestamp)}</div>
                    </div>
                    <div class="message-actions-below">
                        <button class="action-message-btn location-btn" onclick='flyToLocation(${metadataStr})' title="View on map">
                            <i class="fas fa-map-marked-alt"></i>
                        </button>
                        ${isOwn ? `
                            <button class="action-message-btn delete-btn" onclick="deleteMessage('${message.id}')" title="Delete message">
                                <i class="fas fa-trash"></i>
                            </button>
                        ` : ''}
                        <button class="action-message-btn pin-btn" onclick="togglePinMessage('${message.id}')" title="Pin message">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                        <button class="action-message-btn reply-btn" onclick="replyToMessage('${message.id}', '${message.username}', '${message.content.replace(/'/g, "\\'")}')" title="Reply to message">
                            <i class="fas fa-reply"></i>
                        </button>
                        <button class="action-message-btn reaction-btn" onclick="showReactionMenu('${message.id}')" title="Add reaction">
                            <i class="fas fa-smile"></i>
                        </button>
                    </div>
                    <div class="message-reactions" id="reactions-${message.id}">
                        <!-- Reactions will be added here dynamically -->
                    </div>
                `;
                } else {
                    messageElement.innerHTML = `
                    <div class="message-bubble">
                        ${!isOwn ? `<div class="sender-name">${message.username}</div>` : ''}
                        <div class="message-content">${formatMessage(message.content)}</div>
                        <div class="message-time">${formatTime(message.timestamp)}</div>
                        <div class="message-actions">
                            ${isOwn ? `
                                <button class="action-message-btn delete-btn" onclick="deleteMessage('${message.id}')" title="Delete message">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                            <button class="action-message-btn pin-btn" onclick="togglePinMessage('${message.id}')" title="Pin message">
                                <i class="fas fa-thumbtack"></i>
                            </button>
                            <button class="action-message-btn reply-btn" onclick="replyToMessage('${message.id}', '${message.username}', '${message.content.replace(/'/g, "\\'")}')" title="Reply to message">
                                <i class="fas fa-reply"></i>
                            </button>
                            <button class="action-message-btn reaction-btn" onclick="showReactionMenu('${message.id}')" title="Add reaction">
                                <i class="fas fa-smile"></i>
                            </button>
                        </div>
                    </div>
                    <div class="message-reactions" id="reactions-${message.id}">
                        <!-- Reactions will be added here dynamically -->
                    </div>
                `;
                }

                messagesList.appendChild(messageElement);
            }

            // Format message content (bold, italics, mentions)
            function formatMessage(content) {
                // Parse @mentions
                content = content.replace(/@(\w+)/g, '<span class="message-mention">@$1</span>');

                // Parse **bold**
                content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

                // Parse *italic*
                content = content.replace(/\*(.*?)\*/g, '<em>$1</em>');

                return content;
            }

            // Format timestamp
            function formatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            // Load recent messages from Supabase
            async function loadRecentMessages() {
                try {
                    const { data: messages, error } = await supabase
                        .from('chat_messages')
                        .select('*')
                        .order('created_at', { ascending: true }) // Oldest first for proper chat order
                        .limit(50);

                    if (error) {
                        console.error('Error loading messages:', error);
                        return;
                    }

                    // Clear existing messages first
                    const messagesList = document.getElementById('messagesList');
                    if (messagesList) {
                        messagesList.innerHTML = '';
                    }

                    // Add each message to the chat
                    messages.forEach(message => {
                        console.log('Adding message to chat:', message);
                        addMessage({
                            id: message.id,
                            content: message.message || message.text || message.message_text || message.message_content || message.content,
                            type: message.message_type || message.type || 'text',
                            metadata: message.metadata || null,
                            user_id: message.user_id,
                            username: message.username,
                            timestamp: message.created_at || new Date().toISOString()
                        });
                    });

                    // Scroll to bottom after loading
                    setTimeout(() => {
                        const messagesContainer = document.getElementById('messagesContainer');
                        if (messagesContainer) {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                    }, 100);

                } catch (error) {
                    console.error('Error loading messages:', error);
                }
            }

            // Setup real-time subscriptions
            function setupRealtimeSubscriptions() {
                // Subscribe to new messages
                supabase
                    .channel('chat_messages')
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'chat_messages'
                    }, (payload) => {
                        const message = payload.new;
                        addMessage({
                            id: message.id,
                            content: message.message || message.text || message.message_text || message.message_content || message.content,
                            type: message.message_type || message.type || 'text',
                            metadata: message.metadata || null,
                            user_id: message.user_id,
                            username: message.username,
                            timestamp: message.created_at || new Date().toISOString()
                        });

                        // Scroll to bottom when new message arrives
                        setTimeout(() => {
                            const messagesContainer = document.getElementById('messagesContainer');
                            if (messagesContainer) {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        }, 100);
                    })
                    .subscribe();

                // Subscribe to online users
                supabase
                    .channel('online_users')
                    .on('presence', { event: 'sync' }, () => {
                        updateOnlineUsers();
                    })
                    .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                        updateOnlineUsers();
                    })
                    .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                        updateOnlineUsers();
                    })
                    .subscribe(async (status) => {
                        if (status === 'SUBSCRIBED') {
                            await supabase.channel('online_users').track({
                                user_id: chatState.currentUser.id,
                                username: chatState.currentUser.username,
                                last_seen: new Date().toISOString(),
                                online_at: new Date().toISOString()
                            });
                        }
                    });
            }

            // Update online users from Supabase
            async function updateOnlineUsers() {
                try {

                    const { data: users, error } = await supabase
                        .from('online_users')
                        .select('*')
                        .gte('last_seen', new Date(Date.now() - 30000).toISOString()); // Last 30 seconds

                    if (error) {
                        console.error('Error loading online users:', error);
                        return;
                    }

                    chatState.onlineUsers.clear();
                    users.forEach(user => {
                        chatState.onlineUsers.set(user.user_id, {
                            id: user.user_id,
                            username: user.username,
                            status: 'online'
                        });
                    });

                    renderOnlineUsers();
                    updateOnlineCount();

                } catch (error) {
                    console.error('Error updating online users:', error);
                }
            }

            // Send message to Supabase
            async function sendMessage(content, type = 'text', metadata = null) {
                if (!content.trim()) return;

                try {
                    // Check if user is authenticated
                    if (!supabase || !chatState.currentUser) {
                        console.log('User not authenticated - message not sent:', content);
                        showToast('Please log in to send messages', 'warning');

                        // Clear input
                        const messageInput = document.getElementById('messageInput');
                        if (messageInput) messageInput.value = '';
                        return;
                    }

                    // Use only the most basic columns that definitely exist
                    let insertData = {
                        user_id: chatState.currentUser.id,
                        username: chatState.currentUser.username,
                        message: content.trim()
                    };

                    // Add message type if not default
                    if (type && type !== 'text') {
                        insertData.message_type = type;
                        insertData.type = type;
                    }

                    // Add metadata if provided (for locations, screenshots, etc.)
                    if (metadata) {
                        insertData.metadata = metadata;
                    }

                    // Add reply context if replying to a message
                    if (chatState.replyingTo) {
                        insertData.message = `Replying to ${chatState.replyingTo.username}: ${content.trim()}`;
                        insertData.reply_to = chatState.replyingTo.id;
                    }

                    const { data, error } = await supabase
                        .from('chat_messages')
                        .insert([insertData])
                        .select();

                    if (error) {
                        console.error('Error sending message:', error);
                        const errorMessage = error.message || error.details || JSON.stringify(error);
                        console.error('Error details:', errorMessage);
                        // Always show message locally if database fails
                        console.log('Database error, showing message locally');
                        addMessage({
                            id: 'local_' + Date.now(),
                            content: content.trim(),
                            type: type,
                            metadata: metadata || null,
                            user_id: chatState.currentUser.id,
                            username: chatState.currentUser.username,
                            timestamp: new Date().toISOString()
                        });
                        showToast('Message shown locally (database issue)', 'warning');
                        return;
                    }

                    // Clear input and reply context
                    const messageInputElement2 = document.getElementById('messageInput');
                    if (messageInputElement2) messageInputElement2.value = '';

                    // Clear reply context
                    if (chatState.replyingTo) {
                        cancelReply();
                    }

                    // Update online status
                    await supabase
                        .from('online_users')
                        .upsert([{
                            user_id: chatState.currentUser.id,
                            username: chatState.currentUser.username,
                            last_seen: new Date().toISOString()
                        }]);

                    // Add the message to the chat immediately for better UX
                    console.log('Message sent successfully, adding to chat...');
                    const newMessage = {
                        id: data[0].id,
                        content: content.trim(),
                        type: type,
                        metadata: metadata,
                        user_id: chatState.currentUser.id,
                        username: chatState.currentUser.username,
                        timestamp: new Date().toISOString()
                    };
                    addMessage(newMessage);

                } catch (error) {
                    console.error('Error sending message:', error);
                    const errorMessage = error.message || error.details || JSON.stringify(error);
                    console.error('Error details:', errorMessage);
                    showToast(`Error: ${errorMessage}`, 'error');

                    // Clear input even on error
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) messageInput.value = '';
                }
            }

            // Share current location
            function shareCurrentLocation() {
                if (!window.map || !window.map.getView) {
                    showToast('Map not available', 'error');
                    return;
                }

                const view = window.map.getView();
                const center = view.getCenter();
                const zoom = view.getZoom();

                // Convert coordinates for better display
                const lat = center[1].toFixed(6);
                const lon = center[0].toFixed(6);

                const locationData = {
                    center: center,
                    zoom: zoom,
                    lat: parseFloat(lat),
                    lon: parseFloat(lon),
                    timestamp: new Date().toISOString(),
                    username: chatState.currentUser.username
                };

                const locationText = `📍 **Shared Location**\n\n**Coordinates:** ${lat}, ${lon}\n**Zoom Level:** ${Math.round(zoom)}\n\n*Click to fly to this location*`;

                // Check if authentication is disabled (for testing)
                const authDisabled = document.querySelector('script').textContent.includes('Authentication temporarily disabled');

                if (authDisabled || !supabase || !chatState.currentUser) {
                    // Show location message locally during testing
                    const localLocationMessage = {
                        id: 'local_location_' + Date.now(),
                        content: locationText,
                        type: 'location',
                        metadata: locationData || null,
                        user_id: chatState.currentUser.id,
                        username: chatState.currentUser.username,
                        timestamp: new Date().toISOString()
                    };

                    addMessage(localLocationMessage);
                    showToast('Location shared locally (not saved to server)', 'info');
                } else {
                    sendMessage(locationText, 'location', locationData);
                    showToast('Location shared!', 'success');
                }
            }

            // Fly to shared location
            function flyToLocation(locationData) {
                if (!map || !map.getView) return;

                const view = map.getView();

                // IMPORTANT: Use the exact center coordinate that was saved
                // This is already in map projection (EPSG:3857)
                let center = locationData.center;

                if (!center) {
                    // Fallback: convert from lat/lon if center not available
                    if (locationData.lat && locationData.lon) {
                        center = ol.proj.fromLonLat([locationData.lon, locationData.lat]);
                    } else {
                        showToast('Invalid location data', 'error');
                        return;
                    }
                }

                // Zoom level 18 = approximately 50m view
                const targetZoom = 18;

                // Animate to location with 50m zoom level
                view.animate({
                    center: center,
                    zoom: targetZoom,
                    duration: 1500
                });

                // Add a persistent marker at THE EXACT SAME coordinate
                addPersistentMarker(center, locationData.description);

                // Close chat to show map
                const chatPanel = document.getElementById('chatPanel');
                if (chatPanel && chatPanel.classList.contains('open')) {
                    toggleChatPanel();
                }

                showToast(`Flying to: ${locationData.description || 'Location'}`, 'info');
            }

            // Persistent marker layer (stays until refresh)
            let persistentMarkerLayer = null;

            function addPersistentMarker(coordinate, description) {
                // Remove existing persistent marker if any
                if (persistentMarkerLayer) {
                    map.removeLayer(persistentMarkerLayer);
                }

                const markerFeature = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate)
                });

                const markerStyle = new ol.style.Style({
                    image: new ol.style.Icon({
                        anchor: [0.5, 1],
                        src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 32 32"><path fill="%23e74c3c" stroke="%23ffffff" stroke-width="2" d="M16 0C10.5 0 6 4.5 6 10c0 8 10 22 10 22s10-14 10-22c0-5.5-4.5-10-10-10zm0 14c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>',
                        scale: 1.5
                    }),
                    text: description ? new ol.style.Text({
                        text: description,
                        offsetY: -45,
                        font: 'bold 14px Arial',
                        fill: new ol.style.Fill({ color: '#fff' }),
                        stroke: new ol.style.Stroke({ color: '#e74c3c', width: 3 }),
                        backgroundFill: new ol.style.Fill({ color: 'rgba(231, 76, 60, 0.9)' }),
                        padding: [5, 8, 5, 8]
                    }) : null
                });

                markerFeature.setStyle(markerStyle);

                const vectorSource = new ol.source.Vector({
                    features: [markerFeature]
                });

                persistentMarkerLayer = new ol.layer.Vector({
                    source: vectorSource,
                    zIndex: 1001
                });

                map.addLayer(persistentMarkerLayer);
            }

            // Function to clear persistent marker (can be called manually)
            function clearPersistentMarker() {
                if (persistentMarkerLayer) {
                    map.removeLayer(persistentMarkerLayer);
                    persistentMarkerLayer = null;
                    showToast('Location marker cleared', 'info');
                }
            }

            // Format bold text
            function applyBoldFormatting() {
                const input = document.getElementById('messageInput');
                if (!input) return;

                const start = input.selectionStart;
                const end = input.selectionEnd;
                const selectedText = input.value.substring(start, end);

                if (selectedText) {
                    input.value = input.value.substring(0, start) +
                        '**' + selectedText + '**' +
                        input.value.substring(end);

                    // Set cursor position after the formatting
                    input.setSelectionRange(start + 2, end + 2);
                    input.focus();
                    showToast('Bold formatting applied!', 'success');
                } else {
                    // If no text selected, insert bold markers at cursor
                    input.value = input.value.substring(0, start) +
                        '**bold text**' +
                        input.value.substring(end);
                    input.setSelectionRange(start + 2, start + 10);
                    input.focus();
                    showToast('Bold formatting ready - replace "bold text"', 'info');
                }
            }

            // Format italic text
            function applyItalicFormatting() {
                const input = document.getElementById('messageInput');
                if (!input) return;

                const start = input.selectionStart;
                const end = input.selectionEnd;
                const selectedText = input.value.substring(start, end);

                if (selectedText) {
                    input.value = input.value.substring(0, start) +
                        '*' + selectedText + '*' +
                        input.value.substring(end);

                    // Set cursor position after the formatting
                    input.setSelectionRange(start + 1, end + 1);
                    input.focus();
                    showToast('Italic formatting applied!', 'success');
                } else {
                    // If no text selected, insert italic markers at cursor
                    input.value = input.value.substring(0, start) +
                        '*italic text*' +
                        input.value.substring(end);
                    input.setSelectionRange(start + 1, start + 11);
                    input.focus();
                    showToast('Italic formatting ready - replace "italic text"', 'info');
                }
            }

            // Handle input keypress
            function handleInputKeypress(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const content = document.getElementById('messageInput').value;
                    sendMessage(content);
                }
            }

            // Add reaction to message (local only for now)
            async function addReaction(messageId, emoji) {
                try {
                    console.log('Adding reaction:', emoji, 'to message:', messageId);

                    // For now, just update the UI locally
                    // TODO: Add message_reactions table to Supabase later
                    updateReactionUI(messageId, emoji);
                    showToast(`Added ${emoji} reaction!`, 'success');

                } catch (error) {
                    console.error('Error adding reaction:', error);
                    // Still update UI for local testing
                    updateReactionUI(messageId, emoji);
                }
            }

            // Reply to message function
            function replyToMessage(messageId, username, content) {
                const messageInput = document.getElementById('messageInput');
                if (!messageInput) return;

                // Set reply context
                chatState.replyingTo = {
                    id: messageId,
                    username: username,
                    content: content.substring(0, 50) + (content.length > 50 ? '...' : '')
                };

                // Update input placeholder
                messageInput.placeholder = `Replying to ${username}: ${chatState.replyingTo.content}`;

                // Focus on input
                messageInput.focus();

                // Show reply indicator
                showReplyIndicator();

                showToast(`Replying to ${username}`, 'info');
            }

            // Show reply indicator
            function showReplyIndicator() {
                const messageInput = document.getElementById('messageInput');
                if (!messageInput || !chatState.replyingTo) return;

                // Create or update reply indicator
                let indicator = document.getElementById('replyIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'replyIndicator';
                    indicator.className = 'reply-indicator';
                    messageInput.parentNode.insertBefore(indicator, messageInput);
                }

                indicator.innerHTML = `
                <div class="reply-content">
                    <span class="reply-label">Replying to ${chatState.replyingTo.username}:</span>
                    <span class="reply-text">${chatState.replyingTo.content}</span>
                    <button class="reply-cancel" onclick="cancelReply()" title="Cancel reply">×</button>
                </div>
            `;
            }

            // Cancel reply
            function cancelReply() {
                chatState.replyingTo = null;
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.placeholder = 'Type your message... (Use @ to mention users)';
                }

                const indicator = document.getElementById('replyIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            // Show reaction menu
            function showReactionMenu(messageId) {
                // Create reaction menu if it doesn't exist
                let menu = document.getElementById('reactionMenu');
                if (menu) {
                    menu.remove();
                }

                menu = document.createElement('div');
                menu.id = 'reactionMenu';
                menu.className = 'reaction-menu';
                menu.innerHTML = `
                <div class="reaction-options">
                    <button class="reaction-option" onclick="addReaction('${messageId}', '👍')" title="Like">👍</button>
                    <button class="reaction-option" onclick="addReaction('${messageId}', '❤️')" title="Love">❤️</button>
                    <button class="reaction-option" onclick="addReaction('${messageId}', '😂')" title="Laugh">😂</button>
                    <button class="reaction-option" onclick="addReaction('${messageId}', '😮')" title="Wow">😮</button>
                    <button class="reaction-option" onclick="addReaction('${messageId}', '😢')" title="Sad">😢</button>
                    <button class="reaction-option" onclick="addReaction('${messageId}', '😡')" title="Angry">😡</button>
                </div>
            `;

                // Position menu near the message
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    const rect = messageElement.getBoundingClientRect();
                    menu.style.position = 'fixed';
                    menu.style.left = (rect.right - 200) + 'px';
                    menu.style.top = (rect.top - 50) + 'px';
                    menu.style.zIndex = '10000';
                }

                document.body.appendChild(menu);

                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    });
                }, 100);
            }

            // Delete message function
            async function deleteMessage(messageId) {
                try {
                    // Show confirmation dialog
                    const confirmed = confirm('Are you sure you want to delete this message? This action cannot be undone.');
                    if (!confirmed) return;

                    console.log('Deleting message:', messageId);

                    // Check if user is authenticated
                    if (!supabase || !chatState.currentUser) {
                        console.log('User not authenticated - cannot delete message');
                        showToast('Please log in to delete messages', 'warning');
                        return;
                    }

                    // Try to delete from database
                    console.log('Attempting to delete message with ID:', messageId, 'for user:', chatState.currentUser.id);

                    // First, let's check if the message exists and belongs to the user
                    const { data: checkData, error: checkError } = await supabase
                        .from('chat_messages')
                        .select('id, user_id, message')
                        .eq('id', messageId)
                        .eq('user_id', chatState.currentUser.id);

                    if (checkError) {
                        console.error('Error checking message:', checkError);
                        showToast('Error checking message ownership', 'error');
                        return;
                    }

                    if (!checkData || checkData.length === 0) {
                        console.log('Message not found or not owned by user');
                        showToast('Message not found or you cannot delete this message', 'error');
                        return;
                    }

                    console.log('Message found, proceeding with deletion:', checkData[0]);

                    // Now delete the message
                    const { data, error } = await supabase
                        .from('chat_messages')
                        .delete()
                        .eq('id', messageId)
                        .eq('user_id', chatState.currentUser.id)
                        .select();

                    if (error) {
                        console.error('Error deleting message from database:', error);
                        showToast('Failed to delete message from server', 'error');
                        return;
                    }

                    console.log('Message deleted from database:', data);

                    // Remove from UI immediately
                    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        messageElement.style.opacity = '0';
                        messageElement.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            messageElement.remove();
                        }, 300);
                    }

                    // Remove from chat state
                    chatState.messages = chatState.messages.filter(msg => msg.id !== messageId);

                    showToast('Message deleted successfully', 'success');

                } catch (error) {
                    console.error('Error deleting message:', error);
                    showToast('Failed to delete message', 'error');
                }
            }

            // Update reaction UI (WhatsApp-style)
            function updateReactionUI(messageId, emoji) {
                const reactionsContainer = document.getElementById(`reactions-${messageId}`);
                if (!reactionsContainer) {
                    console.log('Reactions container not found for message:', messageId);
                    return;
                }

                console.log('Updating reaction UI for message:', messageId, 'emoji:', emoji);

                // Find existing reaction or create new one
                let reactionElement = reactionsContainer.querySelector(`[data-emoji="${emoji}"]`);

                if (!reactionElement) {
                    // Create new reaction
                    reactionElement = document.createElement('div');
                    reactionElement.className = 'reaction-bubble';
                    reactionElement.setAttribute('data-emoji', emoji);
                    reactionElement.innerHTML = `
                    <span class="reaction-emoji">${emoji}</span>
                    <span class="reaction-count">1</span>
                `;
                    reactionsContainer.appendChild(reactionElement);

                    // Show the reactions container
                    reactionsContainer.style.display = 'flex';
                    reactionsContainer.style.marginTop = '4px';
                    reactionsContainer.style.gap = '4px';
                } else {
                    // Increment existing reaction count
                    const countElement = reactionElement.querySelector('.reaction-count');
                    const currentCount = parseInt(countElement.textContent) || 0;
                    countElement.textContent = currentCount + 1;
                }

                // Add animation
                reactionElement.style.animation = 'reactionPop 0.3s ease-out';
                setTimeout(() => {
                    reactionElement.style.animation = '';
                }, 300);
            }

            // Initialize chat on page load
            document.addEventListener('DOMContentLoaded', function () {
                // Setup event listeners for chat button and other controls
                setupChatEventListeners();
                // Optionally initialize full chat system
                // initializeChat(); // Uncomment if full Supabase chat is needed
            });

            // Event listeners for chat - ensure elements exist
            function setupChatEventListeners() {
                const chatBtn = document.getElementById('chatBtn');
                const chatClose = document.getElementById('chatClose');
                const sendBtn = document.getElementById('sendMessageBtn');
                const messageInput = document.getElementById('messageInput');
                const shareLocationBtn = document.getElementById('shareLocationBtn');
                const formatBold = document.getElementById('formatBold');
                const formatItalic = document.getElementById('formatItalic');

                // New feature buttons
                const themeToggleBtn = document.getElementById('themeToggleBtn');
                const searchToggleBtn = document.getElementById('searchToggleBtn');
                const shareCoordinatesBtn = document.getElementById('shareCoordinatesBtn');
                const mapScreenshotBtn = document.getElementById('mapScreenshotBtn');

                if (chatBtn) chatBtn.addEventListener('click', toggleChatPanel);
                if (chatClose) chatClose.addEventListener('click', toggleChatPanel);
                if (sendBtn) sendBtn.addEventListener('click', function () {
                    const content = document.getElementById('messageInput').value;
                    sendMessage(content);
                });
                if (messageInput) messageInput.addEventListener('keypress', handleInputKeypress);
                if (formatBold) formatBold.addEventListener('click', applyBoldFormatting);
                if (formatItalic) formatItalic.addEventListener('click', applyItalicFormatting);

                // New feature listeners
                if (themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
                if (searchToggleBtn) searchToggleBtn.addEventListener('click', toggleSearchBar);
                if (shareCoordinatesBtn) shareCoordinatesBtn.addEventListener('click', showCoordModal);
                if (mapScreenshotBtn) mapScreenshotBtn.addEventListener('click', captureMapScreenshot);

                // Setup other event listeners
                setupSearchListeners();
                setupCoordModalListeners();

                window.__initializeValuationUI = function () {
                    if (window.__valuationFeaturesEnabled === true) {
                        const valuationBtn = document.getElementById('valuationBtn');
                        if (valuationBtn) {
                            valuationBtn.style.display = '';
                        }
                        setupValuationPanel();
                    } else {
                        disableValuationUI();
                    }
                };
                window.__initializeValuationUI();
            }

            // ========================================
            //  PROPERTY VALUATION SYSTEM
            // ========================================

            // Valuation panel state (following property listing pattern)
            let valuationMarkersSource = null;
            let valuationMarkersLayer = null;
            let valuationClickListener = null;
            let currentValuationPin = null;
            let selectedValuationCoordinate = null;
            let loadedPropertiesForExport = null; // Store loaded properties for CSV export
            const valuationState = {
                isOpen: false,
                activeTool: null,
                autoValueData: null,
                reportData: null,
                charts: null, // Store chart instances for export
                isInitialized: false,
                reportTemplate: 'detailed',
                filteredComparables: [],
                selectedComparables: new Map(),
                enableComparableMapSelect: false,
                lastComparableFilters: null
            };
            const VALUER_SCHEMA = 'valuer_data';
            const VALUER_TABLE = `${VALUER_SCHEMA}.property_valuations`;
            const VALUER_RPC_INSERT = 'insert_property_valuation'; // Use public schema function
            const VALUER_RPC_GET_RADIUS = 'valuer_get_properties_in_radius';
            const FIELD_CAPTURE_STORAGE_KEY = 'valuationFieldDrafts';
            const comparableFeatureIndex = new Map();
            let comparableSelectionListener = null;
            const fieldCaptureState = {
                initialized: false,
                isSelecting: false
            };
            let fieldCaptureListener = null;
            let fieldCapturePin = null;

            const valuationUserCache = {
                id: (typeof window !== 'undefined' && window.__currentValuationUserId) ? window.__currentValuationUserId : null,
                promise: null
            };

            async function ensureValuationUserId() {
                if (valuationUserCache.id) {
                    return valuationUserCache.id;
                }
                if (!valuationUserCache.promise) {
                    valuationUserCache.promise = (async () => {
                        try {
                            const { data, error } = await supabase.auth.getUser();
                            if (error || !data?.user) {
                                console.warn('Unable to resolve current valuer ID:', error);
                                return null;
                            }
                            valuationUserCache.id = data.user.id;
                            if (typeof window !== 'undefined') {
                                window.__currentValuationUserId = data.user.id;
                            }
                            return valuationUserCache.id;
                        } catch (err) {
                            console.error('Unexpected error resolving valuer ID:', err);
                            return null;
                        } finally {
                            valuationUserCache.promise = null;
                        }
                    })();
                }
                return await valuationUserCache.promise;
            }

            // Complete list of Uganda Districts (135 districts)
            // Make it globally accessible
            const UGANDA_DISTRICTS = window.UGANDA_DISTRICTS = [
                'Kampala', 'Wakiso', 'Mukono', 'Jinja', 'Mbarara', 'Gulu', 'Lira', 'Mbale', 'Masaka',
                'Fort Portal', 'Arua', 'Entebbe', 'Kasese', 'Kabale', 'Hoima', 'Soroti', 'Tororo',
                'Iganga', 'Kamuli', 'Pallisa', 'Kumi', 'Nakasongola', 'Apac', 'Kitgum', 'Nebbi',
                'Moyo', 'Yumbe', 'Koboko', 'Maracha', 'Arua', 'Adjumani', 'Buliisa', 'Bundibugyo',
                'Bushenyi', 'Busia', 'Butaleja', 'Dokolo', 'Gomba', 'Ibanda', 'Isingiro', 'Kaabong',
                'Kabarole', 'Kaberamaido', 'Kalangala', 'Kaliro', 'Kalungu', 'Kampala', 'Kamwenge',
                'Kanungu', 'Kapchorwa', 'Kasese', 'Katakwi', 'Kayunga', 'Kibaale', 'Kiboga', 'Kibuku',
                'Kiruhura', 'Kiryandongo', 'Kisoro', 'Kitgum', 'Koboko', 'Kole', 'Kotido', 'Kumi',
                'Kween', 'Kyankwanzi', 'Kyegegwa', 'Kyenjojo', 'Lamwo', 'Lira', 'Luuka', 'Luwero',
                'Lwengo', 'Lyantonde', 'Manafwa', 'Maracha', 'Masaka', 'Masindi', 'Mayuge', 'Mbale',
                'Mbarara', 'Mitooma', 'Mityana', 'Moroto', 'Moyo', 'Mpigi', 'Mubende', 'Mukono',
                'Nakapiripirit', 'Nakaseke', 'Nakasongola', 'Namayingo', 'Namutumba', 'Napak', 'Nebbi',
                'Ngora', 'Ntungamo', 'Nwoya', 'Oyam', 'Pader', 'Pallisa', 'Rakai', 'Rubirizi',
                'Rukungiri', 'Sembabule', 'Serere', 'Sheema', 'Sironko', 'Soroti', 'Tororo', 'Wakiso',
                'Yumbe', 'Zombo', 'Abim', 'Amolatar', 'Amuru', 'Budaka', 'Bududa', 'Bugiri',
                'Bukedea', 'Bukomansimbi', 'Bukwa', 'Bulambuli', 'Buliisa', 'Bundibugyo', 'Bushenyi',
                'Butaleja', 'Buyende', 'Dokolo', 'Gomba', 'Ibanda', 'Isingiro', 'Jinja', 'Kaabong',
                'Kabarole', 'Kaberamaido', 'Kalangala', 'Kaliro', 'Kalungu', 'Kamuli', 'Kamwenge',
                'Kanungu', 'Kapchorwa', 'Katakwi', 'Kayunga', 'Kibaale', 'Kiboga', 'Kibuku',
                'Kiruhura', 'Kiryandongo', 'Kisoro', 'Kitgum', 'Koboko', 'Kole', 'Kotido', 'Kumi',
                'Kween', 'Kyankwanzi', 'Kyegegwa', 'Kyenjojo', 'Lamwo', 'Luuka', 'Luwero', 'Lwengo',
                'Lyantonde', 'Manafwa', 'Masindi', 'Mayuge', 'Mitooma', 'Mityana', 'Moroto', 'Mpigi',
                'Mubende', 'Nakapiripirit', 'Nakaseke', 'Namayingo', 'Namutumba', 'Napak', 'Ngora',
                'Ntungamo', 'Nwoya', 'Oyam', 'Pader', 'Rakai', 'Rubirizi', 'Sembabule', 'Serere',
                'Sheema', 'Sironko', 'Zombo'
            ].filter((value, index, self) => self.indexOf(value) === index).sort(); // Remove duplicates and sort

            // Uganda Coordinate Systems
            // Make it globally accessible
            const UGANDA_COORDINATE_SYSTEMS = window.UGANDA_COORDINATE_SYSTEMS = [
                { value: 'EPSG:32636', label: 'WGS84 UTM Zone 36N (EPSG:32636)' },
                { value: 'EPSG:21096', label: 'Arc1960 UTM Zone 36N (EPSG:21096)' },
                { value: 'EPSG:21036', label: 'Arc1960 UTM Zone 36S (EPSG:21036)' },
                { value: 'EPSG:32736', label: 'WGS84 UTM Zone 36S (EPSG:32736)' },
                { value: 'EPSG:4326', label: 'WGS84 Geographic Lat/Lon (EPSG:4326)' }
            ];

            // Project Library State Variables
            let projectLibraryState = {
                locationSelectionActive: false,
                currentProjectPin: null,
                selectedProjectCoordinate: null,
                projectLocationSelected: false,
                currentUploadType: null, // 'fileCsv' or 'dwgDxf'
                projectLocationListener: null
            };

            // Initialize valuation markers layer (following property listing pattern)
            function initializeValuationLayer() {
                if (valuationMarkersSource) return;

                valuationMarkersSource = new ol.source.Vector();
                valuationMarkersLayer = new ol.layer.Vector({
                    source: valuationMarkersSource,
                    zIndex: 998,
                    style: function (feature) {
                        return new ol.style.Style({
                            image: new ol.style.Icon({
                                anchor: [0.5, 1],
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="%23e74c3c" stroke="%23ffffff" stroke-width="2" d="M16 0C10.5 0 6 4.5 6 10c0 8 10 22 10 22s10-14 10-22c0-5.5-4.5-10-10-10zm0 14c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>',
                                scale: 1.3
                            })
                        });
                    }
                });

                map.addLayer(valuationMarkersLayer);
            }

            // Setup valuation panel event listeners
            function disableValuationUI() {
                const valuationBtn = document.getElementById('valuationBtn');
                if (valuationBtn) {
                    valuationBtn.style.display = 'none';
                }
                const valuationPanel = document.getElementById('valuationPanel');
                if (valuationPanel) {
                    valuationPanel.classList.remove('open');
                    valuationPanel.setAttribute('aria-hidden', 'true');
                }
            }

            function setupValuationPanel() {
                if (window.__valuationFeaturesEnabled !== true) {
                    disableValuationUI();
                    return;
                }
                if (valuationState.isInitialized) {
                    return;
                }
                valuationState.isInitialized = true;
                // Initialize valuation layer when setting up panel
                initializeValuationLayer();
                // Initialize village autocomplete
                initializeVillageAutocomplete();
                const valuationBtn = document.getElementById('valuationBtn');
                const valuationClose = document.getElementById('valuationClose');
                const valuationTabs = document.querySelectorAll('.valuation-tab');

                if (valuationBtn) {
                    valuationBtn.addEventListener('click', toggleValuationPanel);
                }
                if (valuationClose) {
                    valuationClose.addEventListener('click', toggleValuationPanel);
                }

                // Tab switching
                valuationTabs.forEach(tab => {
                    tab.addEventListener('click', function () {
                        const targetTab = this.getAttribute('data-tab');
                        switchValuationTab(targetTab);
                    });
                });

                // Tool 1: Add Property
                const startAddPropertyBtn = document.getElementById('startAddPropertyBtn');
                const cancelPropertyBtn = document.getElementById('cancelPropertyBtn');
                const propertyForm = document.getElementById('propertyForm');
                const propertySizeSQM = document.getElementById('propertySizeSQM');
                const propertySizeAcres = document.getElementById('propertySizeAcres');

                if (startAddPropertyBtn) {
                    startAddPropertyBtn.addEventListener('click', startAddProperty);
                }
                if (cancelPropertyBtn) {
                    cancelPropertyBtn.addEventListener('click', cancelAddProperty);
                }
                if (propertyForm) {
                    propertyForm.addEventListener('submit', savePropertyToSupabase);
                }

                // Auto-calculate total value from land + improvements
                function updatePropertyTotalValue() {
                    const landValue = parseFloat(document.getElementById('propertyLandValue')?.value) || 0;
                    const improvementsValue = parseFloat(document.getElementById('propertyImprovementsValue')?.value) || 0;
                    const totalValue = landValue + improvementsValue;
                    const totalValueInput = document.getElementById('propertyTotalValue');
                    const priceInput = document.getElementById('propertyPriceUGX');
                    if (totalValueInput) {
                        totalValueInput.value = totalValue.toFixed(2);
                    }
                    if (priceInput) {
                        priceInput.value = totalValue.toFixed(2);
                    }
                }

                // Valuation scope change handler
                document.querySelectorAll('input[name="propertyValuationScope"]').forEach(radio => {
                    radio.addEventListener('change', function () {
                        const improvementsGroup = document.getElementById('propertyImprovementsValueGroup');
                        if (this.value === 'Land + Improvements') {
                            if (improvementsGroup) improvementsGroup.style.display = 'block';
                        } else {
                            if (improvementsGroup) improvementsGroup.style.display = 'none';
                            const improvementsInput = document.getElementById('propertyImprovementsValue');
                            if (improvementsInput) improvementsInput.value = '';
                            updatePropertyTotalValue();
                        }
                    });
                });

                // Land value and improvements value change handlers
                const propertyLandValue = document.getElementById('propertyLandValue');
                const propertyImprovementsValue = document.getElementById('propertyImprovementsValue');
                if (propertyLandValue) {
                    propertyLandValue.addEventListener('input', updatePropertyTotalValue);
                }
                if (propertyImprovementsValue) {
                    propertyImprovementsValue.addEventListener('input', updatePropertyTotalValue);
                }

                // Auto-calculate acres from square meters
                if (propertySizeSQM && propertySizeAcres) {
                    propertySizeSQM.addEventListener('input', function () {
                        const sqm = parseFloat(this.value) || 0;
                        propertySizeAcres.value = (sqm / 4046.86).toFixed(4);
                    });
                }

                // Populate Uganda districts dropdowns
                const autoValueDistrict = document.getElementById('autoValueDistrict');
                if (autoValueDistrict) {
                    UGANDA_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        autoValueDistrict.appendChild(option);
                    });
                }

                // Also populate other district dropdowns (Value a Property form)
                const propertyDistrict = document.getElementById('propertyDistrict');
                if (propertyDistrict) {
                    // Clear existing options except the first one (Select District)
                    const firstOption = propertyDistrict.querySelector('option[value=""]');
                    propertyDistrict.innerHTML = '';
                    if (firstOption) {
                        propertyDistrict.appendChild(firstOption);
                    } else {
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = 'Select District';
                        propertyDistrict.appendChild(defaultOption);
                    }
                    // Populate with all districts
                    UGANDA_DISTRICTS.forEach(district => {
                        const option = document.createElement('option');
                        option.value = district;
                        option.textContent = district;
                        propertyDistrict.appendChild(option);
                    });
                }

                // Populate View Properties district dropdown
                const viewDistrict = document.getElementById('viewDistrict');
                if (viewDistrict) {
                    const existingOptions = viewDistrict.querySelectorAll('option');
                    if (existingOptions.length <= 13) { // Only if not already populated
                        UGANDA_DISTRICTS.forEach(district => {
                            // Skip if already exists
                            if (!Array.from(existingOptions).some(opt => opt.value === district)) {
                                const option = document.createElement('option');
                                option.value = district;
                                option.textContent = district;
                                viewDistrict.appendChild(option);
                            }
                        });
                    }
                }

                // Populate Field Capture district dropdown
                const fieldCaptureDistrict = document.getElementById('fieldCaptureDistrict');
                if (fieldCaptureDistrict) {
                    const existingOptions = fieldCaptureDistrict.querySelectorAll('option');
                    if (existingOptions.length <= 1) {
                        UGANDA_DISTRICTS.forEach(district => {
                            const option = document.createElement('option');
                            option.value = district;
                            option.textContent = district;
                            fieldCaptureDistrict.appendChild(option);
                        });
                    }
                }

                // Tool 2: Auto-Value - New workflow
                const startAutoValueBtn = document.getElementById('startAutoValueBtn');
                const cancelAutoValueBtn = document.getElementById('cancelAutoValueBtn');
                const generateReportBtn = document.getElementById('generateReportBtn');
                const exportReportCSVBtn = document.getElementById('exportReportCSVBtn');
                const exportReportPDFBtn = document.getElementById('exportReportPDFBtn');
                const closeReportBtn = document.getElementById('closeReportBtn');
                const autoValuePropertySizeSQM = document.getElementById('autoValuePropertySizeSQM');
                const autoValuePropertySizeAcres = document.getElementById('autoValuePropertySizeAcres');
                const loadComparablesBtn = document.getElementById('loadComparablesBtn');
                const useSelectedComparablesBtn = document.getElementById('useSelectedComparablesBtn');
                const clearSelectedComparablesBtn = document.getElementById('clearSelectedComparablesBtn');
                const toggleComparableMapSelectBtn = document.getElementById('toggleComparableMapSelectBtn');

                if (startAutoValueBtn) {
                    startAutoValueBtn.addEventListener('click', startAutoValuation);
                }
                if (cancelAutoValueBtn) {
                    cancelAutoValueBtn.addEventListener('click', cancelAutoValuation);
                }
                if (generateReportBtn) {
                    generateReportBtn.addEventListener('click', generateAutoValuationReport);
                }
                if (exportReportCSVBtn) {
                    exportReportCSVBtn.addEventListener('click', exportValuationReportToCSV);
                }
                if (exportReportPDFBtn) {
                    exportReportPDFBtn.addEventListener('click', exportValuationReportToPDF);
                }
                if (closeReportBtn) {
                    closeReportBtn.addEventListener('click', closeValuationReport);
                }
                if (loadComparablesBtn) {
                    loadComparablesBtn.addEventListener('click', loadComparablesForAutoValue);
                }
                if (useSelectedComparablesBtn) {
                    useSelectedComparablesBtn.addEventListener('click', useSelectedComparables);
                }
                if (clearSelectedComparablesBtn) {
                    clearSelectedComparablesBtn.addEventListener('click', clearSelectedComparables);
                }
                if (toggleComparableMapSelectBtn) {
                    toggleComparableMapSelectBtn.addEventListener('click', toggleComparableMapSelectionMode);
                }

                // Auto-calculate acres from square meters for auto-value form
                if (autoValuePropertySizeSQM && autoValuePropertySizeAcres) {
                    autoValuePropertySizeSQM.addEventListener('input', function () {
                        const sqm = parseFloat(this.value) || 0;
                        autoValuePropertySizeAcres.value = (sqm / 4046.86).toFixed(4);
                    });
                }

                // Set default valuation date to today for auto-value form
                const autoValueValuationDate = document.getElementById('autoValueValuationDate');
                if (autoValueValuationDate) {
                    autoValueValuationDate.valueAsDate = new Date();
                }

                // Setup auto-value district listener to load properties when district is selected
                setupAutoValueDistrictListener();

                // Tool 3: View Properties
                const viewPropertiesBtn = document.getElementById('viewPropertiesBtn');
                const exportPropertiesBtn = document.getElementById('exportPropertiesBtn');

                if (viewPropertiesBtn) {
                    viewPropertiesBtn.addEventListener('click', loadDistrictProperties);
                }
                if (exportPropertiesBtn) {
                    exportPropertiesBtn.addEventListener('click', exportPropertiesToCSV);
                }

                // Map click handler for valuation markers - show comparable details
                map.on('singleclick', function (evt) {
                    // Check if we clicked on a valuation marker
                    map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
                        const featureType = feature.get('type');
                        if (featureType === 'property-view' || featureType === 'property-valuation') {
                            const propertyData = feature.get('propertyData');
                            if (propertyData) {
                                showComparableDetails(propertyData);
                                return true; // Stop iteration
                            }
                        }
                    });
                });

                // Set default valuation date to today
                const valuationDate = document.getElementById('propertyValuationDate');
                if (valuationDate) {
                    valuationDate.valueAsDate = new Date();
                }

                const fieldVisitDate = document.getElementById('fieldVisitDate');
                if (fieldVisitDate) {
                    fieldVisitDate.valueAsDate = new Date();
                }

                // Field capture setup
                initializeFieldCaptureTab();
            }

            // Toggle valuation panel (following property listing pattern)
            function toggleValuationPanel() {
                if (window.__valuationFeaturesEnabled !== true) {
                    if (typeof showToast === 'function') {
                        showToast('Valuation tools are available for valuer accounts only.', 'warning');
                    }
                    return;
                }
                const panel = document.getElementById('valuationPanel');
                valuationState.isOpen = !valuationState.isOpen;
                panel.classList.toggle('open', valuationState.isOpen);

                if (valuationState.isOpen) {
                    // Initialize valuation layer when panel opens
                    initializeValuationLayer();
                } else {
                    // Cancel any active tool
                    cancelValuationTool();
                }
            }

            // Cancel valuation tool (cleanup function)
            function cancelValuationTool() {
                // Remove map click listener
                if (valuationClickListener) {
                    ol.Observable.unByKey(valuationClickListener);
                    valuationClickListener = null;
                }

                // Remove temporary pin if exists
                if (currentValuationPin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(currentValuationPin);
                    currentValuationPin = null;
                }

                // Reset coordinate
                selectedValuationCoordinate = null;

                // Hide forms if showing (with null checks)
                const propertyFormContainer = document.getElementById('propertyFormContainer');
                if (propertyFormContainer) {
                    propertyFormContainer.style.display = 'none';
                }

                // Old auto-value results container (might not exist in new workflow)
                const autoValueResultsContainer = document.getElementById('autoValueResultsContainer');
                if (autoValueResultsContainer) {
                    autoValueResultsContainer.style.display = 'none';
                }

                // New auto-value form and report containers
                const autoValueFormContainer = document.getElementById('autoValueFormContainer');
                if (autoValueFormContainer) {
                    autoValueFormContainer.style.display = 'none';
                }

                const autoValueReportContainer = document.getElementById('autoValueReportContainer');
                if (autoValueReportContainer) {
                    autoValueReportContainer.style.display = 'none';
                }
                const comparablesContainer = document.getElementById('autoValueComparablesListContainer');
                if (comparablesContainer) {
                    comparablesContainer.style.display = 'none';
                    const list = document.getElementById('autoValueComparablesList');
                    if (list) list.innerHTML = '';
                    const summary = document.getElementById('autoValueSelectedSummary');
                    if (summary) summary.textContent = '';
                }

                // Reset button states
                const startBtn = document.getElementById('startAddPropertyBtn');
                if (startBtn) {
                    startBtn.innerHTML = '<i class="fas fa-plus-circle"></i> Start';
                    startBtn.disabled = false;
                }

                const autoBtn = document.getElementById('startAutoValueBtn');
                if (autoBtn) {
                    autoBtn.innerHTML = '<i class="fas fa-calculator"></i> Start Auto-Valuation';
                    autoBtn.disabled = false;
                }

                if (fieldCaptureListener) {
                    ol.Observable.unByKey(fieldCaptureListener);
                    fieldCaptureListener = null;
                }
                if (fieldCapturePin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(fieldCapturePin);
                    fieldCapturePin = null;
                }
            }

            function initializeFieldCaptureTab() {
                if (fieldCaptureState.initialized) return;
                const fieldForm = document.getElementById('fieldCaptureForm');
                const pendingList = document.getElementById('fieldCapturePendingList');
                if (!fieldForm || !pendingList) return;
                fieldCaptureState.initialized = true;

                fieldForm.addEventListener('submit', handleFieldCaptureSubmit);
                const useLocationBtn = document.getElementById('fieldUseLocationBtn');
                if (useLocationBtn) {
                    useLocationBtn.addEventListener('click', fillFieldCaptureDeviceLocation);
                }
                const mapSelectBtn = document.getElementById('fieldMapSelectBtn');
                if (mapSelectBtn) {
                    mapSelectBtn.addEventListener('click', startFieldCaptureMapSelection);
                }
                const syncAllBtn = document.getElementById('fieldSyncAllBtn');
                if (syncAllBtn) {
                    syncAllBtn.addEventListener('click', syncPendingFieldEntries);
                }
                pendingList.addEventListener('click', handleFieldCapturePendingAction);

                // Initialize village autocomplete for field capture form
                initializeVillageAutocompleteForFieldCapture();

                renderFieldCaptureEntries();
            }

            // Initialize village autocomplete for field capture form
            function initializeVillageAutocompleteForFieldCapture() {
                const villageInput = document.getElementById('fieldCaptureVillage');
                const countyInput = document.getElementById('fieldCaptureCounty');
                const districtSelect = document.getElementById('fieldCaptureDistrict');

                if (!villageInput) return;

                let autocompleteContainer = null;
                let currentSuggestions = [];
                let selectedIndex = -1;

                // Create autocomplete container
                const createAutocompleteContainer = () => {
                    if (autocompleteContainer) return;
                    autocompleteContainer = document.createElement('div');
                    autocompleteContainer.className = 'village-autocomplete';
                    autocompleteContainer.id = 'fieldCaptureVillageAutocomplete';
                    villageInput.parentNode.appendChild(autocompleteContainer);
                };

                // Hide autocomplete
                const hideAutocomplete = () => {
                    if (autocompleteContainer) {
                        autocompleteContainer.style.display = 'none';
                    }
                    selectedIndex = -1;
                };

                // Show autocomplete with suggestions
                const showAutocomplete = (suggestions) => {
                    if (!suggestions || suggestions.length === 0) {
                        hideAutocomplete();
                        return;
                    }
                    createAutocompleteContainer();
                    currentSuggestions = suggestions;
                    autocompleteContainer.innerHTML = suggestions.map((village, index) => `
                    <div class="autocomplete-item ${index === selectedIndex ? 'selected' : ''}" 
                         data-index="${index}"
                         data-village="${village.village_name}"
                         data-county="${village.county}">
                        <strong>${village.village_name}</strong>
                        <span class="autocomplete-meta">${village.county}, ${village.district}</span>
                    </div>
                `).join('');
                    autocompleteContainer.style.display = 'block';
                };

                // Search villages
                const searchVillages = async (searchTerm) => {
                    if (!searchTerm || searchTerm.length < 2) {
                        hideAutocomplete();
                        return;
                    }

                    const district = districtSelect?.value || '';
                    const county = countyInput?.value || '';

                    try {
                        const { data, error } = await supabase.rpc('search_villages', {
                            p_district: district || null,
                            p_county: county || null,
                            p_search_term: searchTerm,
                            p_limit: 10
                        });

                        if (error) throw error;
                        showAutocomplete(data || []);
                    } catch (error) {
                        console.error('Error searching villages:', error);
                        hideAutocomplete();
                    }
                };

                // Handle input
                villageInput.addEventListener('input', (e) => {
                    const value = e.target.value.trim();
                    searchVillages(value);
                });

                // Handle selection
                document.addEventListener('click', (e) => {
                    const item = e.target.closest('.autocomplete-item');
                    if (item && autocompleteContainer && autocompleteContainer.contains(item)) {
                        const index = parseInt(item.dataset.index);
                        const suggestion = currentSuggestions[index];
                        if (suggestion) {
                            villageInput.value = suggestion.village_name;
                            if (countyInput && !countyInput.value) {
                                countyInput.value = suggestion.county;
                            }
                            hideAutocomplete();
                        }
                    } else if (!villageInput.contains(e.target) && !autocompleteContainer?.contains(e.target)) {
                        hideAutocomplete();
                    }
                });

                // Handle keyboard navigation
                villageInput.addEventListener('keydown', (e) => {
                    if (!autocompleteContainer || autocompleteContainer.style.display === 'none') return;

                    const items = autocompleteContainer.querySelectorAll('.autocomplete-item');
                    if (items.length === 0) return;

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                        items.forEach((item, idx) => {
                            item.classList.toggle('selected', idx === selectedIndex);
                        });
                        items[selectedIndex]?.scrollIntoView({ block: 'nearest' });
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        selectedIndex = Math.max(selectedIndex - 1, -1);
                        items.forEach((item, idx) => {
                            item.classList.toggle('selected', idx === selectedIndex);
                        });
                        if (selectedIndex >= 0) {
                            items[selectedIndex]?.scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'Enter' && selectedIndex >= 0) {
                        e.preventDefault();
                        const suggestion = currentSuggestions[selectedIndex];
                        if (suggestion) {
                            villageInput.value = suggestion.village_name;
                            if (countyInput && !countyInput.value) {
                                countyInput.value = suggestion.county;
                            }
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                });
            }

            function getStoredFieldEntries() {
                try {
                    const raw = localStorage.getItem(FIELD_CAPTURE_STORAGE_KEY);
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.warn('Failed to read field entries from storage:', error);
                    return [];
                }
            }

            function persistFieldEntries(entries) {
                try {
                    localStorage.setItem(FIELD_CAPTURE_STORAGE_KEY, JSON.stringify(entries));
                } catch (error) {
                    console.warn('Failed to persist field entries:', error);
                }
            }

            function renderFieldCaptureEntries() {
                const listContainer = document.getElementById('fieldCapturePendingList');
                if (!listContainer) return;
                const entries = getStoredFieldEntries();
                if (!entries.length) {
                    listContainer.innerHTML = '<p style="margin: 0;">No pending field entries.</p>';
                    return;
                }

                listContainer.innerHTML = entries.map(entry => {
                    const status = entry.synced ? 'Synced' : 'Pending';
                    return `
                    <div class="valuation-pending-card ${entry.synced ? 'synced' : ''}" data-entry-id="${entry.id}">
                        <div>
                            <h5>${entry.siteName || 'Untitled Site'}</h5>
                            <p><strong>District:</strong> ${entry.district || 'N/A'}</p>
                            ${entry.county ? `<p><strong>County:</strong> ${entry.county}</p>` : ''}
                            ${entry.village_name ? `<p><strong>Village/Parish:</strong> ${entry.village_name}</p>` : ''}
                            <p><strong>Coordinates:</strong> ${entry.latitude}, ${entry.longitude}</p>
                            <p><strong>Visit:</strong> ${entry.visitDate || 'N/A'} | <strong>Status:</strong> ${status}</p>
                        </div>
                        <div class="valuation-pending-actions">
                            <button class="sync" data-action="sync" data-entry-id="${entry.id}" ${entry.synced ? 'disabled' : ''}>
                                <i class="fas fa-cloud-upload-alt"></i> Sync
                            </button>
                            <button class="delete" data-action="delete" data-entry-id="${entry.id}">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                `;
                }).join('');
            }

            function buildFieldCaptureEntryFromForm() {
                const siteName = document.getElementById('fieldSiteName').value.trim();
                const district = document.getElementById('fieldCaptureDistrict').value;
                const county = document.getElementById('fieldCaptureCounty')?.value.trim() || '';
                const village = document.getElementById('fieldCaptureVillage')?.value.trim() || '';
                const tenure = document.getElementById('fieldCaptureTenure').value;
                const propertyType = document.getElementById('fieldCapturePropertyType').value;
                const latitude = document.getElementById('fieldLatitude').value.trim();
                const longitude = document.getElementById('fieldLongitude').value.trim();
                const visitDate = document.getElementById('fieldVisitDate').value;
                const notes = document.getElementById('fieldNotes').value.trim();

                if (!siteName || !district || !county || !village || !latitude || !longitude || !visitDate) {
                    showToast('Please complete all required field capture inputs (including County and Village/Parish).', 'error');
                    return null;
                }

                return {
                    id: crypto.randomUUID ? crypto.randomUUID() : `field-${Date.now()}`,
                    siteName,
                    district,
                    county,
                    village_name: village,
                    tenure,
                    propertyType,
                    latitude,
                    longitude,
                    visitDate,
                    notes,
                    synced: false,
                    createdAt: new Date().toISOString()
                };
            }

            function handleFieldCapturePendingAction(event) {
                const actionButton = event.target.closest('button[data-entry-id]');
                if (!actionButton) return;
                const entryId = actionButton.dataset.entryId;
                const action = actionButton.dataset.action;
                if (!entryId || !action) return;

                if (action === 'delete') {
                    const entries = getStoredFieldEntries().filter(entry => entry.id !== entryId);
                    persistFieldEntries(entries);
                    renderFieldCaptureEntries();
                    showToast('Field entry removed from local storage.', 'info');
                } else if (action === 'sync') {
                    syncFieldEntry(entryId);
                }
            }

            async function handleFieldCaptureSubmit(event) {
                event.preventDefault();
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Field capture is available for valuer accounts only.', 'warning');
                    return;
                }
                const entry = buildFieldCaptureEntryFromForm();
                if (!entry) return;

                const entries = getStoredFieldEntries();
                entries.push(entry);
                persistFieldEntries(entries);
                renderFieldCaptureEntries();

                event.currentTarget.reset();
                const fieldVisitDate = document.getElementById('fieldVisitDate');
                if (fieldVisitDate) {
                    fieldVisitDate.valueAsDate = new Date();
                }
                showToast('Field entry saved offline.', 'success');
            }

            function fillFieldCaptureDeviceLocation() {
                if (!navigator.geolocation) {
                    showToast('Geolocation not supported on this device.', 'error');
                    return;
                }
                navigator.geolocation.getCurrentPosition(position => {
                    const { latitude, longitude } = position.coords;
                    document.getElementById('fieldLatitude').value = latitude.toFixed(6);
                    document.getElementById('fieldLongitude').value = longitude.toFixed(6);
                    showToast('Device location captured.', 'success');
                }, error => {
                    console.warn('Geolocation error:', error);
                    showToast('Unable to access device location.', 'error');
                }, { enableHighAccuracy: true, timeout: 10000 });
            }

            function startFieldCaptureMapSelection() {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Field capture is available for valuer accounts only.', 'warning');
                    return;
                }
                initializeValuationLayer();
                cancelValuationTool();
                fieldCaptureState.isSelecting = true;
                showToast('Click on the map to record field coordinates.', 'info');

                if (fieldCaptureListener) {
                    ol.Observable.unByKey(fieldCaptureListener);
                    fieldCaptureListener = null;
                }

                fieldCaptureListener = map.on('singleclick', function (evt) {
                    fieldCaptureState.isSelecting = false;
                    const lonLat = ol.proj.toLonLat(evt.coordinate);
                    document.getElementById('fieldLatitude').value = lonLat[1].toFixed(6);
                    document.getElementById('fieldLongitude').value = lonLat[0].toFixed(6);

                    if (fieldCapturePin && valuationMarkersSource) {
                        valuationMarkersSource.removeFeature(fieldCapturePin);
                    }
                    fieldCapturePin = new ol.Feature({
                        geometry: new ol.geom.Point(evt.coordinate),
                        type: 'field-capture',
                        isTemporary: true
                    });
                    fieldCapturePin.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#f39c12' }),
                            stroke: new ol.style.Stroke({ color: '#ffffff', width: 2 })
                        })
                    }));
                    if (valuationMarkersSource) {
                        valuationMarkersSource.addFeature(fieldCapturePin);
                    }
                    showToast('Map location captured for field entry.', 'success');
                    ol.Observable.unByKey(fieldCaptureListener);
                    fieldCaptureListener = null;
                });
            }

            async function syncFieldEntry(entryId) {
                const entries = getStoredFieldEntries();
                const entry = entries.find(item => item.id === entryId);
                if (!entry) {
                    showToast('Field entry not found.', 'error');
                    return;
                }
                if (entry.synced) {
                    showToast('Entry already synced.', 'info');
                    return;
                }
                if (!navigator.onLine) {
                    showToast('You are offline. Connect to the internet to sync entries.', 'warning');
                    return;
                }

                try {
                    const payload = {
                        site_name: entry.siteName,
                        district: entry.district,
                        county: entry.county || '',
                        village_name: entry.village_name || '',
                        tenure: entry.tenure,
                        property_type: entry.propertyType,
                        latitude: parseFloat(entry.latitude),
                        longitude: parseFloat(entry.longitude),
                        visit_date: entry.visitDate,
                        notes: entry.notes
                    };
                    let synced = false;
                    const { error: rpcError } = await supabase.rpc('valuer_sync_field_visit', payload);
                    if (!rpcError) {
                        synced = true;
                    } else {
                        console.warn('Field visit RPC failed:', rpcError);
                        const { error: valuerDirectError } = await supabase
                            .from(`${VALUER_SCHEMA}.field_visits`)
                            .insert([{ ...payload, created_at: new Date().toISOString() }]);
                        if (!valuerDirectError) {
                            synced = true;
                        } else {
                            console.warn('Field visit direct insert failed:', valuerDirectError);
                            const { error: legacyDirectError } = await supabase
                                .from('field_visits')
                                .insert([{ ...payload, created_at: new Date().toISOString() }]);
                            if (!legacyDirectError) {
                                synced = true;
                            } else {
                                throw legacyDirectError;
                            }
                        }
                    }

                    if (synced) {
                        entry.synced = true;
                        persistFieldEntries(entries);
                        renderFieldCaptureEntries();
                        showToast('Field entry synced successfully.', 'success');
                    }
                } catch (error) {
                    console.error('Failed to sync field entry:', error);
                    showToast('Failed to sync entry: ' + (error.message || 'Unknown error'), 'error');
                }
            }

            async function syncPendingFieldEntries() {
                const entries = getStoredFieldEntries();
                const pendingEntries = entries.filter(entry => !entry.synced);
                if (!pendingEntries.length) {
                    showToast('No pending field entries to sync.', 'info');
                    return;
                }
                if (!navigator.onLine) {
                    showToast('You are offline. Connect to the internet to sync entries.', 'warning');
                    return;
                }

                for (const entry of pendingEntries) {
                    // eslint-disable-next-line no-await-in-loop
                    await syncFieldEntry(entry.id);
                }
            }

            // Switch valuation tab
            function switchValuationTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.valuation-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.getAttribute('data-tab') === tabName) {
                        tab.classList.add('active');
                    }
                });

                // Update tab content
                document.querySelectorAll('.valuation-tab-content').forEach(content => {
                    content.classList.remove('active');
                    if (content.id === tabName + '-tab') {
                        content.classList.add('active');
                    }
                });

                // Cancel any active tool when switching tabs
                cancelValuationTool();
            }


            // Tool 1: Start adding property (following property listing pattern)
            function startAddProperty() {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Valuation tools are available for valuer accounts only.', 'warning');
                    return;
                }
                // Ensure valuation layer is initialized
                initializeValuationLayer();

                if (!valuationMarkersSource) {
                    showToast('Error: Map not ready. Please wait a moment and try again.', 'error');
                    return;
                }

                // Cancel any existing tool
                cancelValuationTool();
                valuationState.activeTool = 'add-property';

                const btn = document.getElementById('startAddPropertyBtn');
                if (!btn) return;
                btn.textContent = 'Click on map to place property';
                btn.disabled = true;

                showToast('Click on the map to select property location', 'info');

                // Add click listener (following property listing pattern)
                valuationClickListener = map.on('singleclick', function (evt) {
                    if (!valuationState.isOpen || valuationState.activeTool !== 'add-property') return;

                    const coordinate = evt.coordinate;
                    const lonLat = ol.proj.toLonLat(coordinate);

                    selectedValuationCoordinate = {
                        mapCoord: coordinate,
                        lon: lonLat[0],
                        lat: lonLat[1]
                    };

                    // Handle location selection
                    handleValuationLocationSelection(coordinate, lonLat);

                    // Remove listener after first click
                    ol.Observable.unByKey(valuationClickListener);
                    valuationClickListener = null;

                    btn.innerHTML = '<i class="fas fa-plus-circle"></i> Start';
                    btn.disabled = false;
                });
            }

            // Handle valuation location selection (following property listing pattern)
            function handleValuationLocationSelection(coordinate, lonLat) {
                // Remove previous pin if exists
                if (currentValuationPin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(currentValuationPin);
                }

                // Create temporary pin marker
                currentValuationPin = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate),
                    isTemporary: true
                });

                // Add temporary pin to map
                valuationMarkersSource.addFeature(currentValuationPin);

                // Show property form
                showPropertyForm(coordinate);

                showToast('Location selected! Now fill in the property details', 'success');
            }


            // Show property form
            function showPropertyForm(coordinate) {
                const container = document.getElementById('propertyFormContainer');
                container.style.display = 'block';

                // Scroll to form
                container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Cancel add property
            function cancelAddProperty() {
                // Remove temporary pin
                if (currentValuationPin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(currentValuationPin);
                    currentValuationPin = null;
                }

                // Remove click listener
                if (valuationClickListener) {
                    ol.Observable.unByKey(valuationClickListener);
                    valuationClickListener = null;
                }

                document.getElementById('propertyFormContainer').style.display = 'none';
                document.getElementById('propertyForm').reset();
                selectedValuationCoordinate = null;

                const btn = document.getElementById('startAddPropertyBtn');
                if (btn) {
                    btn.innerHTML = '<i class="fas fa-plus-circle"></i> Start';
                    btn.disabled = false;
                }
            }

            // Format UGX
            function formatUGX(amount) {
                return new Intl.NumberFormat('en-UG', {
                    style: 'currency',
                    currency: 'UGX',
                    minimumFractionDigits: 0
                }).format(amount);
            }

            // Save property to Supabase
            async function savePropertyToSupabase(e) {
                e.preventDefault();

                if (!selectedValuationCoordinate) {
                    showToast('No location selected. Please place a marker on the map first.', 'error');
                    return;
                }

                // Get current user
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) {
                    showToast('Please log in to save property valuations', 'error');
                    return;
                }

                // Use stored coordinate (already in EPSG:3857)
                const coordinate = selectedValuationCoordinate.mapCoord;
                const lonLat = [selectedValuationCoordinate.lon, selectedValuationCoordinate.lat];

                // Collect form data
                const scopeRadio = document.querySelector('input[name="propertyValuationScope"]:checked');
                const landValue = parseFloat(document.getElementById('propertyLandValue').value) || 0;
                const improvementsValue = parseFloat(document.getElementById('propertyImprovementsValue').value) || 0;
                const totalValue = landValue + improvementsValue;

                const formData = {
                    user_id: user.id,
                    location: `SRID=4326;POINT(${lonLat[0]} ${lonLat[1]})`, // PostGIS POINT format (lon, lat)
                    district: document.getElementById('propertyDistrict').value,
                    county: document.getElementById('propertyCounty').value,
                    village_name: document.getElementById('propertyVillage').value,
                    plot_number: document.getElementById('propertyPlotNumber').value,
                    block_number: document.getElementById('propertyBlockNumber').value,
                    tenure: document.getElementById('propertyTenure').value,
                    valuation_method: document.getElementById('propertyValuationMethod').value,
                    price_ugx: totalValue,
                    land_value_ugx: landValue,
                    improvements_value_ugx: improvementsValue > 0 ? improvementsValue : null,
                    valuation_scope: scopeRadio ? scopeRadio.value : 'Land Only',
                    property_type: document.getElementById('propertyType').value,
                    property_size_sqm: parseFloat(document.getElementById('propertySizeSQM').value) || 0,
                    property_size_acres: parseFloat(document.getElementById('propertySizeAcres').value) || 0,
                    number_of_rooms: parseInt(document.getElementById('propertyRooms').value) || null,
                    number_of_floors: parseInt(document.getElementById('propertyFloors').value) || null,
                    property_age_years: parseInt(document.getElementById('propertyAge').value) || null,
                    property_condition: document.getElementById('propertyCondition').value || null,
                    road_access: document.getElementById('propertyRoadAccess').value || null,
                    zoning: document.getElementById('propertyZoning').value || null,
                    land_use: document.getElementById('propertyLandUse').value || null,
                    legal_status: document.getElementById('propertyLegalStatus').value || null,
                    has_electricity: document.getElementById('propertyHasElectricity').checked,
                    has_water: document.getElementById('propertyHasWater').checked,
                    proximity_schools_km: parseFloat(document.getElementById('propertyProximitySchools').value) || null,
                    proximity_hospitals_km: parseFloat(document.getElementById('propertyProximityHospitals').value) || null,
                    proximity_markets_km: parseFloat(document.getElementById('propertyProximityMarkets').value) || null,
                    valuation_date: document.getElementById('propertyValuationDate').value,
                    surveyor_name: document.getElementById('propertySurveyorName').value || null,
                    surveyor_id: document.getElementById('propertySurveyorID').value || null,
                    notes: document.getElementById('propertyNotes').value || null,
                    is_auto_calculated: false,
                    confidence_level: null,
                    proprietor_name: document.getElementById('propertyProprietor').value || null
                };

                // Validate required fields
                if (!formData.district || !formData.county || !formData.village_name || !formData.plot_number ||
                    !formData.tenure || !formData.valuation_method || !formData.land_value_ugx ||
                    !formData.property_type || !formData.property_size_sqm || !formData.valuation_date) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                // Upload images before saving
                showToast('Uploading images...', 'info');
                const propertyImage1 = document.getElementById('propertyImage1Input').files[0];
                const propertyImage2 = document.getElementById('propertyImage2Input').files[0];
                const documentImage1 = document.getElementById('documentImage1Input').files[0];
                const documentImage2 = document.getElementById('documentImage2Input').files[0];

                const [propertyImage1Url, propertyImage2Url, documentImage1Url, documentImage2Url] = await Promise.all([
                    propertyImage1 ? uploadValuationImage(propertyImage1, 'property1') : Promise.resolve(null),
                    propertyImage2 ? uploadValuationImage(propertyImage2, 'property2') : Promise.resolve(null),
                    documentImage1 ? uploadValuationImage(documentImage1, 'document1') : Promise.resolve(null),
                    documentImage2 ? uploadValuationImage(documentImage2, 'document2') : Promise.resolve(null)
                ]);

                // Add image URLs to formData
                formData.property_image_1_url = propertyImage1Url;
                formData.property_image_2_url = propertyImage2Url;
                formData.document_image_1_url = documentImage1Url;
                formData.document_image_2_url = documentImage2Url;

                try {
                    const rpcPayload = {
                        p_user_id: formData.user_id,
                        p_location_lon: lonLat[0],
                        p_location_lat: lonLat[1],
                        p_district: formData.district,
                        p_county: formData.county,
                        p_village_name: formData.village_name,
                        p_plot_number: formData.plot_number,
                        p_tenure: formData.tenure,
                        p_valuation_method: formData.valuation_method,
                        p_price_ugx: formData.price_ugx,
                        p_land_value_ugx: formData.land_value_ugx,
                        p_improvements_value_ugx: formData.improvements_value_ugx,
                        p_valuation_scope: formData.valuation_scope,
                        p_property_type: formData.property_type,
                        p_property_size_sqm: formData.property_size_sqm,
                        p_valuation_date: formData.valuation_date,
                        p_block_number: formData.block_number,
                        p_property_size_acres: formData.property_size_acres,
                        p_number_of_rooms: formData.number_of_rooms,
                        p_number_of_floors: formData.number_of_floors,
                        p_property_age_years: formData.property_age_years,
                        p_property_condition: formData.property_condition,
                        p_road_access: formData.road_access,
                        p_zoning: formData.zoning,
                        p_land_use: formData.land_use,
                        p_legal_status: formData.legal_status,
                        p_has_electricity: formData.has_electricity,
                        p_has_water: formData.has_water,
                        p_proximity_schools_km: formData.proximity_schools_km,
                        p_proximity_hospitals_km: formData.proximity_hospitals_km,
                        p_proximity_markets_km: formData.proximity_markets_km,
                        p_surveyor_name: formData.surveyor_name,
                        p_surveyor_id: formData.surveyor_id,
                        p_notes: formData.notes,
                        p_is_auto_calculated: formData.is_auto_calculated,
                        p_confidence_level: formData.confidence_level,
                        p_property_image_1_url: formData.property_image_1_url,
                        p_property_image_2_url: formData.property_image_2_url,
                        p_document_image_1_url: formData.document_image_1_url,
                        p_document_image_2_url: formData.document_image_2_url,
                        p_proprietor_name: formData.proprietor_name
                    };
                    const directInsertPayload = {
                        user_id: formData.user_id,
                        location: `POINT(${lonLat[0]} ${lonLat[1]})`,
                        district: formData.district,
                        county: formData.county,
                        village_name: formData.village_name,
                        plot_number: formData.plot_number,
                        block_number: formData.block_number,
                        tenure: formData.tenure,
                        valuation_method: formData.valuation_method,
                        price_ugx: formData.price_ugx,
                        land_value_ugx: formData.land_value_ugx,
                        improvements_value_ugx: formData.improvements_value_ugx,
                        valuation_scope: formData.valuation_scope,
                        property_type: formData.property_type,
                        property_size_sqm: formData.property_size_sqm,
                        property_size_acres: formData.property_size_acres,
                        number_of_rooms: formData.number_of_rooms,
                        number_of_floors: formData.number_of_floors,
                        property_age_years: formData.property_age_years,
                        property_condition: formData.property_condition,
                        road_access: formData.road_access,
                        zoning: formData.zoning,
                        land_use: formData.land_use,
                        legal_status: formData.legal_status,
                        has_electricity: formData.has_electricity,
                        has_water: formData.has_water,
                        proximity_schools_km: formData.proximity_schools_km,
                        proximity_hospitals_km: formData.proximity_hospitals_km,
                        proximity_markets_km: formData.proximity_markets_km,
                        valuation_date: formData.valuation_date,
                        surveyor_name: formData.surveyor_name,
                        surveyor_id: formData.surveyor_id,
                        notes: formData.notes,
                        is_auto_calculated: false,
                        confidence_level: null,
                        property_image_1_url: formData.property_image_1_url,
                        property_image_2_url: formData.property_image_2_url,
                        document_image_1_url: formData.document_image_1_url,
                        document_image_2_url: formData.document_image_2_url,
                        proprietor_name: formData.proprietor_name
                    };

                    let insertError = null;

                    const { error: valuerRpcError } = await supabase.rpc(VALUER_RPC_INSERT, rpcPayload);
                    if (valuerRpcError) {
                        console.warn('Valuer schema RPC insert failed:', valuerRpcError);
                        const { error: legacyRpcError } = await supabase.rpc('insert_property_valuation', rpcPayload);
                        if (legacyRpcError) {
                            console.warn('Legacy RPC insert failed:', legacyRpcError);
                            const { error: valuerInsertError } = await supabase
                                .from(VALUER_TABLE)
                                .insert([directInsertPayload])
                                .select();
                            if (valuerInsertError) {
                                console.warn('Valuer schema direct insert failed:', valuerInsertError);
                                const { error: legacyInsertError } = await supabase
                                    .from('property_valuations')
                                    .insert([directInsertPayload])
                                    .select();
                                if (legacyInsertError) {
                                    insertError = legacyInsertError;
                                }
                            }
                        }
                    }

                    if (insertError) {
                        throw insertError;
                    }

                    showToast('Property valuation saved successfully!', 'success');

                    // Remove temporary pin and create permanent marker
                    if (currentValuationPin && valuationMarkersSource) {
                        valuationMarkersSource.removeFeature(currentValuationPin);
                    }

                    // Add permanent marker
                    const permanentMarker = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        type: 'property-valuation',
                        ...formData
                    });
                    valuationMarkersSource.addFeature(permanentMarker);

                    currentValuationPin = null;
                    selectedValuationCoordinate = null;

                    // Reset form
                    cancelAddProperty();

                } catch (error) {
                    console.error('Error saving property:', error);
                    showToast('Error saving property: ' + (error.message || 'Unknown error'), 'error');
                }
            }

            // Tool 2: Start auto-valuation (NEW WORKFLOW: Map click first, then form)
            async function startAutoValuation() {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Valuation tools are available for valuer accounts only.', 'warning');
                    return;
                }
                // Ensure valuation layer is initialized
                initializeValuationLayer();

                if (!valuationMarkersSource) {
                    showToast('Error: Map not ready. Please wait a moment and try again.', 'error');
                    return;
                }

                // Get selected district from form
                const selectedDistrict = document.getElementById('autoValueDistrict')?.value;

                // If district is selected, load and display existing properties for that district
                if (selectedDistrict) {
                    await loadDistrictPropertiesForAutoValue(selectedDistrict);
                }

                // Cancel any existing tool
                cancelValuationTool();
                valuationState.activeTool = 'auto-value';

                const btn = document.getElementById('startAutoValueBtn');
                if (!btn) return;
                btn.textContent = 'Click on map to mark property location';
                btn.disabled = true;

                showToast('Click on the map to mark the property location', 'info');

                // Add click listener - user clicks map first
                valuationClickListener = map.on('singleclick', function (evt) {
                    if (!valuationState.isOpen || valuationState.activeTool !== 'auto-value') return;

                    const coordinate = evt.coordinate;
                    const lonLat = ol.proj.toLonLat(coordinate);

                    // Handle location selection (show form)
                    handleAutoValueLocationSelection(coordinate, lonLat);

                    // Remove listener after first click
                    ol.Observable.unByKey(valuationClickListener);
                    valuationClickListener = null;

                    btn.innerHTML = '<i class="fas fa-calculator"></i> Start Auto-Valuation';
                    btn.disabled = false;
                });
            }

            // Load district properties for auto-value (display on map)
            async function loadDistrictPropertiesForAutoValue(district) {
                if (!district) return;

                try {
                    showToast(`Loading existing valuations for ${district}...`, 'info');
                    const userId = await ensureValuationUserId();
                    if (!userId) {
                        showToast('Unable to load comparables: valuer identity missing.', 'error');
                        return;
                    }

                    // Query properties for this district (exclude auto-calculated)
                    // Try public schema first, fallback to valuer schema if it exists
                    let properties = [];
                    let error = null;

                    const { data: publicData, error: publicError } = await supabase
                        .from('property_valuations')
                        .select('*')
                        .eq('district', district)
                        .eq('is_auto_calculated', false)
                        .eq('user_id', userId);

                    if (!publicError && Array.isArray(publicData)) {
                        properties = publicData;
                    } else {
                        error = publicError;
                        // Try valuer schema as fallback
                        const { data: valuerData, error: valuerError } = await supabase
                            .from(VALUER_TABLE)
                            .select('*')
                            .eq('district', district)
                            .eq('is_auto_calculated', false)
                            .eq('user_id', userId);

                        if (!valuerError && Array.isArray(valuerData)) {
                            properties = valuerData;
                        } else {
                            error = valuerError || publicError;
                        }
                    }

                    if (error) {
                        console.error('Error loading district properties:', error);
                        showToast(`Error loading properties: ${error.message || 'Unknown error'}`, 'error');
                        return;
                    }

                    if (!properties || properties.length === 0) {
                        showToast(`No existing valuations found for ${district}`, 'info');
                        return;
                    }

                    // Clear existing auto-value markers
                    if (valuationMarkersSource) {
                        const features = valuationMarkersSource.getFeatures().filter(f =>
                            f.get('type') === 'auto-value-district'
                        );
                        features.forEach(f => valuationMarkersSource.removeFeature(f));
                    }

                    // Add markers for each property
                    properties.forEach(prop => {
                        const coords = parseLocation(prop.location);
                        if (!coords) return;

                        const coord = ol.proj.transform([coords.lon, coords.lat], 'EPSG:4326', 'EPSG:3857');
                        const marker = new ol.Feature({
                            geometry: new ol.geom.Point(coord),
                            type: 'auto-value-district',
                            propertyData: prop
                        });

                        // Style marker (blue circle for district properties)
                        marker.setStyle(new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({
                                    color: 'rgba(52, 152, 219, 0.8)' // Blue
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#2980b9',
                                    width: 2
                                })
                            })
                        }));

                        valuationMarkersSource.addFeature(marker);
                    });

                    // Zoom to properties if available
                    if (properties.length > 0 && valuationMarkersSource.getFeatures().length > 0) {
                        const extent = valuationMarkersSource.getExtent();
                        map.getView().fit(extent, { padding: [100, 100, 100, 100], maxZoom: 12 });
                    }

                    showToast(`Loaded ${properties.length} existing valuation(s) for ${district}`, 'success');

                } catch (error) {
                    console.error('Error loading district properties for auto-value:', error);
                }
            }

            // Add event listener to district dropdown in auto-value form to load properties when changed
            function setupAutoValueDistrictListener() {
                const autoValueDistrict = document.getElementById('autoValueDistrict');
                if (autoValueDistrict) {
                    autoValueDistrict.addEventListener('change', function () {
                        const district = this.value;
                        if (district) {
                            loadDistrictPropertiesForAutoValue(district);
                        } else {
                            // Clear district markers if no district selected
                            if (valuationMarkersSource) {
                                const features = valuationMarkersSource.getFeatures().filter(f =>
                                    f.get('type') === 'auto-value-district'
                                );
                                features.forEach(f => valuationMarkersSource.removeFeature(f));
                            }
                        }
                    });
                }
            }

            // Handle auto-value location selection (NEW: shows form after map click)
            function handleAutoValueLocationSelection(coordinate, lonLat) {
                // Remove previous pin if exists
                if (currentValuationPin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(currentValuationPin);
                }

                // Create temporary pin marker
                currentValuationPin = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate),
                    isTemporary: true
                });

                // Add temporary pin to map
                valuationMarkersSource.addFeature(currentValuationPin);

                // Store coordinate
                selectedValuationCoordinate = {
                    mapCoord: coordinate,
                    lon: lonLat[0],
                    lat: lonLat[1]
                };

                // Show form
                const formContainer = document.getElementById('autoValueFormContainer');
                formContainer.style.display = 'block';

                // Update location info
                const locationInfo = document.getElementById('autoValueLocationInfo');
                locationInfo.textContent = `Location: ${lonLat[1].toFixed(6)}, ${lonLat[0].toFixed(6)}`;

                // Scroll to form
                formContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                showToast('Location marked! Please fill in the property details below', 'success');
            }

            // Generate Auto-Valuation Report (NEW: called from form submission)
            async function generateAutoValuationReport() {
                // Validate form
                const form = document.getElementById('autoValuePropertyForm');
                if (!form.checkValidity()) {
                    form.reportValidity();
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                if (!selectedValuationCoordinate) {
                    showToast('No location selected. Please mark a location on the map first.', 'error');
                    return;
                }

                const userId = await ensureValuationUserId();
                if (!userId) {
                    showToast('Unable to determine valuer identity. Please sign in again.', 'error');
                    return;
                }

                // Collect form data
                const formData = collectAutoValueFormData();
                const filters = collectAutoValueFilters();

                // Get radius from form (default 2km)
                const radiusKm = parseFloat(document.getElementById('autoValueRadius').value) || 2;
                const radiusMeters = radiusKm * 1000;

                showToast('Calculating property value...', 'info');

                // Get coordinates
                const coordinate = selectedValuationCoordinate.mapCoord;
                const lon = selectedValuationCoordinate.lon;
                const lat = selectedValuationCoordinate.lat;

                try {
                    let comparables = [];
                    const manualComparables = Array.from(valuationState.selectedComparables.values()).filter(prop => !prop.user_id || prop.user_id === userId);

                    if (manualComparables.length) {
                        comparables = manualComparables;
                        showToast(`Using ${manualComparables.length} manually selected comparable(s).`, 'info');
                    } else {
                        let filteredComparables = valuationState.filteredComparables;
                        const filtersMatch = areComparableFiltersEqual(valuationState.lastComparableFilters, filters);

                        if (!Array.isArray(filteredComparables) || !filteredComparables.length || !filtersMatch) {
                            try {
                                filteredComparables = assignComparableIds(await fetchFilteredComparables(filters));
                                valuationState.filteredComparables = filteredComparables;
                                valuationState.lastComparableFilters = { ...filters };
                            } catch (filterError) {
                                console.warn('Filtered comparables lookup failed:', filterError);
                                filteredComparables = [];
                            }
                        }

                        if (Array.isArray(filteredComparables) && filteredComparables.length) {
                            comparables = filteredComparables.filter(prop => {
                                if (prop.user_id && prop.user_id !== userId) return false;
                                const coords = getPropertyCoordinates(prop);
                                if (!coords) return false;
                                const distance = haversineDistance(lat, lon, coords.lat, coords.lon);
                                return distance <= radiusKm;
                            });
                            if (comparables.length) {
                                showToast(`Found ${comparables.length} comparable(s) within ${radiusKm}km using current filters.`, 'success');
                            }
                        }
                    }

                    if (!comparables.length) {
                        let rpcError = null;
                        const { data: valuerRpcData, error: valuerRpcError } = await supabase.rpc(VALUER_RPC_GET_RADIUS, {
                            p_lon: lon,
                            p_lat: lat,
                            p_radius_meters: radiusMeters,
                            p_village_name: formData.village_name || null,
                            p_county: formData.county || null,
                            p_district: formData.district || null,
                            p_valuation_scope: formData.valuation_scope || null
                        });

                        if (!valuerRpcError && Array.isArray(valuerRpcData)) {
                            comparables = valuerRpcData;
                        } else {
                            if (valuerRpcError) {
                                console.warn('Valuer schema radius RPC failed:', valuerRpcError);
                                rpcError = valuerRpcError;
                            }
                            const { data: legacyRpcData, error: legacyRpcError } = await supabase.rpc('get_properties_in_radius', {
                                p_lon: lon,
                                p_lat: lat,
                                p_radius_meters: radiusMeters,
                                p_village_name: formData.village_name || null,
                                p_county: formData.county || null,
                                p_district: formData.district || null,
                                p_valuation_scope: formData.valuation_scope || null
                            });
                            if (!legacyRpcError && Array.isArray(legacyRpcData)) {
                                comparables = legacyRpcData;
                                rpcError = null;
                            } else {
                                if (legacyRpcError) {
                                    console.warn('Legacy radius RPC failed:', legacyRpcError);
                                    rpcError = legacyRpcError;
                                }
                                const { data: valuerDirectData, error: valuerDirectError } = await supabase
                                    .from(VALUER_TABLE)
                                    .select('*')
                                    .eq('is_auto_calculated', false)
                                    .eq('user_id', userId);
                                if (!valuerDirectError && Array.isArray(valuerDirectData)) {
                                    comparables = valuerDirectData;
                                    rpcError = null;
                                } else {
                                    if (valuerDirectError) {
                                        console.warn('Valuer schema direct query failed:', valuerDirectError);
                                        rpcError = valuerDirectError;
                                    }
                                    const { data: legacyDirectData, error: legacyDirectError } = await supabase
                                        .from('property_valuations')
                                        .select('*')
                                        .eq('is_auto_calculated', false)
                                        .eq('user_id', userId);
                                    if (legacyDirectError) {
                                        throw legacyDirectError;
                                    }
                                    comparables = legacyDirectData || [];
                                    rpcError = null;
                                }
                            }
                        }

                        if (rpcError) {
                            showToast('Fallback comparable search encountered errors. Results may be incomplete.', 'warning');
                        }

                        const filteredByCriteria = Array.isArray(comparables) ? comparables.filter(prop => {
                            if (prop.user_id && prop.user_id !== userId) return false;
                            if (filters.property_type && prop.property_type !== filters.property_type) return false;
                            if (filters.tenure && prop.tenure !== filters.tenure) return false;
                            if (filters.valuation_method && prop.valuation_method !== filters.valuation_method) return false;
                            if (filters.price_min !== null && Number(prop.price_ugx) < filters.price_min) return false;
                            if (filters.price_max !== null && Number(prop.price_ugx) > filters.price_max) return false;
                            const coords = getPropertyCoordinates(prop);
                            if (!coords) return false;
                            const distance = haversineDistance(lat, lon, coords.lat, coords.lon);
                            return distance <= radiusKm;
                        }) : [];

                        comparables = assignComparableIds(filteredByCriteria);
                    }

                    if (!comparables.length) {
                        showToast('No comparable properties found. Try expanding filters or radius, or select comparables manually.', 'warning');
                    }

                    await processAutoValuationWithReport(comparables || [], lon, lat, coordinate, formData, radiusKm);

                } catch (error) {
                    console.error('Error calculating auto-valuation:', error);
                    showToast('Error calculating valuation: ' + (error.message || 'Unknown error'), 'error');
                }
            }

            // Collect form data from auto-value form
            function collectAutoValueFormData() {
                const scopeRadio = document.querySelector('input[name="autoValueScope"]:checked');
                return {
                    district: document.getElementById('autoValueDistrict').value,
                    county: document.getElementById('autoValueCounty').value,
                    village_name: document.getElementById('autoValueVillage').value,
                    plot_number: document.getElementById('autoValuePlotNumber').value,
                    block_number: document.getElementById('autoValueBlockNumber').value || null,
                    tenure: document.getElementById('autoValueTenure').value,
                    property_type: document.getElementById('autoValuePropertyType').value,
                    property_size_sqm: parseFloat(document.getElementById('autoValuePropertySizeSQM').value) || 0,
                    property_size_acres: parseFloat(document.getElementById('autoValuePropertySizeAcres').value) || 0,
                    number_of_rooms: parseInt(document.getElementById('autoValueRooms').value) || null,
                    number_of_floors: parseInt(document.getElementById('autoValueFloors').value) || null,
                    property_condition: document.getElementById('autoValueCondition').value || null,
                    road_access: document.getElementById('autoValueRoadAccess').value || null,
                    zoning: document.getElementById('autoValueZoning').value || null,
                    land_use: document.getElementById('autoValueLandUse').value || null,
                    legal_status: document.getElementById('autoValueLegalStatus').value || null,
                    has_electricity: document.getElementById('autoValueHasElectricity').checked,
                    has_water: document.getElementById('autoValueHasWater').checked,
                    proximity_schools_km: parseFloat(document.getElementById('autoValueProximitySchools').value) || null,
                    proximity_hospitals_km: parseFloat(document.getElementById('autoValueProximityHospitals').value) || null,
                    proximity_markets_km: parseFloat(document.getElementById('autoValueProximityMarkets').value) || null,
                    valuation_date: document.getElementById('autoValueValuationDate').value,
                    surveyor_name: document.getElementById('autoValueSurveyorName').value || null,
                    surveyor_id: document.getElementById('autoValueSurveyorID').value || null,
                    notes: document.getElementById('autoValueNotes').value || null,
                    valuation_scope: scopeRadio ? scopeRadio.value : 'Land Only',
                    strict_village_match: document.getElementById('strictVillageMatch').checked,
                    lat: selectedValuationCoordinate ? selectedValuationCoordinate.lat : null,
                    lon: selectedValuationCoordinate ? selectedValuationCoordinate.lon : null,
                    branding: {
                        client_name: document.getElementById('reportClientName')?.value || null,
                        reference: document.getElementById('reportReference')?.value || null,
                        valuer_name: document.getElementById('reportBrandName')?.value || null
                    }
                };
            }

            function collectAutoValueFilters() {
                const district = document.getElementById('autoValueDistrict')?.value || '';
                const propertyType = document.getElementById('autoValuePropertyType')?.value || '';
                const tenureFilter = document.getElementById('autoValueTenureFilter')?.value || '';
                const tenureFromForm = document.getElementById('autoValueTenure')?.value || '';
                const valuationMethod = document.getElementById('autoValueValuationMethodFilter')?.value || '';
                const minInput = document.getElementById('autoValueMinPriceFilter');
                const maxInput = document.getElementById('autoValueMaxPriceFilter');

                const priceMin = minInput && minInput.value !== '' ? parseFloat(minInput.value) : null;
                const priceMax = maxInput && maxInput.value !== '' ? parseFloat(maxInput.value) : null;

                return {
                    district,
                    property_type: propertyType || '',
                    tenure: tenureFilter || tenureFromForm || '',
                    valuation_method: valuationMethod || '',
                    price_min: Number.isFinite(priceMin) ? priceMin : null,
                    price_max: Number.isFinite(priceMax) ? priceMax : null
                };
            }

            function applyFiltersToBuilder(builder, filters, userId) {
                if (!builder || !filters) return builder;
                const {
                    district,
                    county,
                    village_name,
                    property_type,
                    tenure,
                    valuation_method,
                    valuation_scope,
                    price_min,
                    price_max
                } = filters;

                if (district) builder = builder.eq('district', district);
                if (county) builder = builder.eq('county', county);
                if (village_name) builder = builder.eq('village_name', village_name);
                if (property_type) builder = builder.eq('property_type', property_type);
                if (tenure) builder = builder.eq('tenure', tenure);
                if (valuation_method) builder = builder.eq('valuation_method', valuation_method);
                if (valuation_scope) builder = builder.eq('valuation_scope', valuation_scope);
                if (price_min !== null) builder = builder.gte('price_ugx', price_min);
                if (price_max !== null) builder = builder.lte('price_ugx', price_max);
                if (userId) builder = builder.eq('user_id', userId);
                return builder;
            }

            function areComparableFiltersEqual(a, b) {
                if (!a || !b) return false;
                const keys = ['district', 'property_type', 'tenure', 'valuation_method', 'price_min', 'price_max'];
                return keys.every(key => {
                    const aVal = a[key] ?? null;
                    const bVal = b[key] ?? null;
                    return aVal === bVal;
                });
            }

            function assignComparableIds(comparables) {
                if (!Array.isArray(comparables)) return [];
                return comparables.map((prop, index) => {
                    const id = getComparableId(prop, index);
                    return { ...prop, __comparableId: id };
                });
            }

            async function fetchFilteredComparables(filters) {
                const userId = await ensureValuationUserId();
                if (!userId) {
                    console.warn('Cannot load comparables: missing valuer identity.');
                    return [];
                }
                let comparables = [];

                // Try public schema first (most common)
                const publicBuilder = applyFiltersToBuilder(
                    supabase.from('property_valuations').select('*').eq('is_auto_calculated', false),
                    filters,
                    userId
                );

                const { data: publicData, error: publicError } = await publicBuilder;
                if (!publicError && Array.isArray(publicData)) {
                    comparables = publicData;
                } else {
                    if (publicError) {
                        console.warn('Public schema filter query failed:', publicError);
                    }
                    // Fallback to valuer schema if it exists
                    const valuerBuilder = applyFiltersToBuilder(
                        supabase.from(VALUER_TABLE).select('*').eq('is_auto_calculated', false),
                        filters,
                        userId
                    );
                    const { data: valuerData, error: valuerError } = await valuerBuilder;
                    if (valuerError) {
                        // If both fail, throw the original public error
                        throw publicError || valuerError;
                    }
                    comparables = Array.isArray(valuerData) ? valuerData : [];
                }

                return comparables.filter(prop => getPropertyCoordinates(prop));
            }

            function getComparableId(prop, fallbackIndex) {
                if (!prop) return `comparable-${fallbackIndex}`;
                return (
                    prop.__comparableId ||
                    prop.id ||
                    prop.uuid ||
                    prop.property_id ||
                    prop.record_id ||
                    prop.sid ||
                    `comparable-${fallbackIndex}`
                );
            }

            async function loadComparablesForAutoValue() {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Valuation tools are available for valuer accounts only.', 'warning');
                    return;
                }

                const filters = collectAutoValueFilters();
                if (!filters.district) {
                    showToast('Please select a district before loading comparables.', 'warning');
                    return;
                }

                showToast('Loading comparable properties...', 'info');

                try {
                    initializeValuationLayer();
                    if (!valuationMarkersSource) {
                        showToast('Unable to prepare map layer. Please try again.', 'error');
                        return;
                    }

                    const comparables = assignComparableIds(await fetchFilteredComparables(filters));
                    valuationState.filteredComparables = comparables;
                    valuationState.lastComparableFilters = { ...filters };
                    valuationState.selectedComparables.clear();
                    valuationState.enableComparableMapSelect = false;
                    disableComparableMapSelection();
                    const mapSelectBtn = document.getElementById('toggleComparableMapSelectBtn');
                    if (mapSelectBtn) {
                        mapSelectBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Enable Map Selection';
                        mapSelectBtn.classList.remove('active');
                    }

                    renderAutoValueComparablesList(comparables);
                    if (comparables.length) {
                        showToast(`Loaded ${comparables.length} comparable property(ies). Select the ones you need.`, 'success');
                    } else {
                        showToast('No comparables found with the selected filters.', 'warning');
                    }
                } catch (error) {
                    console.error('Error loading comparables:', error);
                    showToast('Error loading comparables. Please adjust filters and try again.', 'error');
                }
            }

            function renderAutoValueComparablesList(comparables) {
                const container = document.getElementById('autoValueComparablesListContainer');
                const listEl = document.getElementById('autoValueComparablesList');
                if (!container || !listEl) return;

                container.style.display = 'block';

                const validIds = new Set(comparables.map(prop => prop.__comparableId));
                Array.from(valuationState.selectedComparables.keys()).forEach(id => {
                    if (!validIds.has(id)) {
                        valuationState.selectedComparables.delete(id);
                    }
                });

                comparableFeatureIndex.forEach(feature => {
                    if (valuationMarkersSource) {
                        valuationMarkersSource.removeFeature(feature);
                    }
                });
                comparableFeatureIndex.clear();

                if (!comparables.length) {
                    listEl.innerHTML = '<p style="padding: 10px;">No comparables found. Adjust filters and try again.</p>';
                    refreshSelectedComparablesSummary();
                    return;
                }

                const listHTML = comparables.map((prop, index) => {
                    const comparableId = prop.__comparableId || getComparableId(prop, index);
                    const coords = getPropertyCoordinates(prop);
                    const selected = valuationState.selectedComparables.has(comparableId);
                    if (coords && valuationMarkersSource) {
                        const coord = ol.proj.transform([coords.lon, coords.lat], 'EPSG:4326', 'EPSG:3857');
                        const feature = new ol.Feature({
                            geometry: new ol.geom.Point(coord),
                            type: 'auto-value-comparable',
                            comparableId,
                            propertyData: prop
                        });
                        feature.setStyle(createComparableFeatureStyle(selected));
                        valuationMarkersSource.addFeature(feature);
                        comparableFeatureIndex.set(comparableId, feature);
                    }

                    return `
                    <div class="valuation-property-item auto-value-comparable-item ${selected ? 'selected' : ''}" data-comparable-id="${comparableId}">
                        <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer;">
                            <input type="checkbox" class="comparable-checkbox" data-comparable-id="${comparableId}" ${selected ? 'checked' : ''} style="margin-top: 4px;">
                            <div style="flex: 1;">
                                <div class="valuation-property-price">${prop.price_ugx ? formatUGX(prop.price_ugx) : 'UGX 0'}</div>
                                <div><strong>Plot:</strong> ${prop.plot_number || 'N/A'} | <strong>Block:</strong> ${prop.block_number || 'N/A'}</div>
                                <div><strong>District:</strong> ${prop.district || 'N/A'} | <strong>Type:</strong> ${prop.property_type || 'N/A'}</div>
                                <div><strong>Tenure:</strong> ${prop.tenure || 'N/A'} | <strong>Method:</strong> ${prop.valuation_method || 'N/A'}</div>
                                <div><strong>Date:</strong> ${prop.valuation_date || 'N/A'}</div>
                            </div>
                        </label>
                    </div>
                `;
                }).join('');

                listEl.innerHTML = listHTML;

                listEl.querySelectorAll('.comparable-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (event) => {
                        const id = event.target.dataset.comparableId;
                        setComparableSelection(id, event.target.checked);
                    });
                });

                listEl.querySelectorAll('.auto-value-comparable-item').forEach(item => {
                    item.addEventListener('click', (event) => {
                        if (event.target.closest('input')) return;
                        const checkbox = item.querySelector('input');
                        if (!checkbox) return;
                        checkbox.checked = !checkbox.checked;
                        const id = checkbox.dataset.comparableId;
                        setComparableSelection(id, checkbox.checked);
                    });
                });

                refreshSelectedComparablesSummary();
            }

            function createComparableFeatureStyle(isSelected) {
                return new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: isSelected ? 11 : 8,
                        fill: new ol.style.Fill({
                            color: isSelected ? 'rgba(142, 68, 173, 0.9)' : 'rgba(155, 89, 182, 0.7)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: isSelected ? '#6c3483' : '#8e44ad',
                            width: 2
                        })
                    })
                });
            }

            function setComparableSelection(id, isSelected) {
                if (!id) return;
                const property = valuationState.filteredComparables.find(prop => prop.__comparableId === id);
                if (!property) return;

                if (isSelected) {
                    valuationState.selectedComparables.set(id, property);
                } else {
                    valuationState.selectedComparables.delete(id);
                }

                const item = document.querySelector(`.auto-value-comparable-item[data-comparable-id="${id}"]`);
                if (item) {
                    item.classList.toggle('selected', isSelected);
                    const checkbox = item.querySelector('.comparable-checkbox');
                    if (checkbox && checkbox.checked !== isSelected) {
                        checkbox.checked = isSelected;
                    }
                }

                const feature = comparableFeatureIndex.get(id);
                if (feature) {
                    feature.setStyle(createComparableFeatureStyle(isSelected));
                }

                refreshSelectedComparablesSummary();
            }

            function refreshSelectedComparablesSummary() {
                const summaryEl = document.getElementById('autoValueSelectedSummary');
                if (!summaryEl) return;

                const count = valuationState.selectedComparables.size;
                if (!count) {
                    summaryEl.textContent = 'No comparables selected.';
                    return;
                }

                const prices = Array.from(valuationState.selectedComparables.values())
                    .filter(prop => typeof prop.price_ugx === 'number')
                    .map(prop => prop.price_ugx);
                const average = prices.length
                    ? prices.reduce((sum, val) => sum + val, 0) / prices.length
                    : null;
                summaryEl.textContent = `Selected ${count} comparable(s)${average ? ` | Avg price: ${formatUGX(average)}` : ''}`;
            }

            function useSelectedComparables() {
                const count = valuationState.selectedComparables.size;
                if (!count) {
                    showToast('No comparables selected yet. Tick some properties first.', 'warning');
                    return;
                }
                showToast(`Will use ${count} manually selected comparable(s) for auto-valuation.`, 'success');
            }

            function clearSelectedComparables() {
                if (!valuationState.selectedComparables.size) {
                    showToast('Selection already empty.', 'info');
                    return;
                }

                valuationState.selectedComparables.clear();
                document.querySelectorAll('.comparable-checkbox').forEach(cb => { cb.checked = false; });
                document.querySelectorAll('.auto-value-comparable-item').forEach(item => item.classList.remove('selected'));
                comparableFeatureIndex.forEach(feature => feature.setStyle(createComparableFeatureStyle(false)));
                refreshSelectedComparablesSummary();
                showToast('Cleared selected comparables.', 'info');
            }

            function toggleComparableMapSelectionMode() {
                if (!valuationState.filteredComparables.length) {
                    showToast('Load comparables before enabling map selection.', 'warning');
                    return;
                }

                valuationState.enableComparableMapSelect = !valuationState.enableComparableMapSelect;
                const btn = document.getElementById('toggleComparableMapSelectBtn');

                if (valuationState.enableComparableMapSelect) {
                    enableComparableMapSelection();
                    if (btn) {
                        btn.innerHTML = '<i class="fas fa-mouse-pointer"></i> Disable Map Selection';
                        btn.classList.add('active');
                    }
                    showToast('Click comparable pins on the map to toggle selection.', 'info');
                } else {
                    disableComparableMapSelection();
                    if (btn) {
                        btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Enable Map Selection';
                        btn.classList.remove('active');
                    }
                    showToast('Map selection disabled.', 'info');
                }
            }

            function enableComparableMapSelection() {
                if (comparableSelectionListener) {
                    ol.Observable.unByKey(comparableSelectionListener);
                }
                comparableSelectionListener = map.on('singleclick', function (evt) {
                    if (!valuationState.enableComparableMapSelect) return;
                    const feature = map.forEachFeatureAtPixel(evt.pixel, (feat) => feat);
                    if (!feature || feature.get('type') !== 'auto-value-comparable') return;
                    const comparableId = feature.get('comparableId');
                    const currentlySelected = valuationState.selectedComparables.has(comparableId);
                    setComparableSelection(comparableId, !currentlySelected);
                });
            }

            function disableComparableMapSelection() {
                if (comparableSelectionListener) {
                    ol.Observable.unByKey(comparableSelectionListener);
                    comparableSelectionListener = null;
                }
                valuationState.enableComparableMapSelect = false;
                const mapSelectBtn = document.getElementById('toggleComparableMapSelectBtn');
                if (mapSelectBtn) {
                    mapSelectBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Enable Map Selection';
                    mapSelectBtn.classList.remove('active');
                }
            }

            // Parse location from various formats
            function parseWkbPoint(hexString) {
                if (typeof hexString !== 'string') return null;
                const clean = hexString.trim();
                if (!clean || clean.length < 40 || clean.length % 2 !== 0) return null;

                try {
                    const bytes = new Uint8Array(clean.length / 2);
                    for (let i = 0; i < clean.length; i += 2) {
                        const byte = parseInt(clean.substr(i, 2), 16);
                        if (Number.isNaN(byte)) return null;
                        bytes[i / 2] = byte;
                    }

                    const dataView = new DataView(bytes.buffer);
                    const littleEndian = dataView.getUint8(0) === 1;
                    const typeWithFlags = dataView.getUint32(1, littleEndian);
                    const wkbType = typeWithFlags & 0xffff;
                    const hasZ = (typeWithFlags & 0x80000000) !== 0;
                    const hasM = (typeWithFlags & 0x40000000) !== 0;
                    const hasSrid = (typeWithFlags & 0x20000000) !== 0;

                    if (wkbType !== 1) return null; // Only handle POINT
                    if (hasZ || hasM) return null; // Ignore 3D/measure for now

                    let offset = 5;
                    if (hasSrid) {
                        offset += 4; // skip SRID
                    }

                    if (bytes.length < offset + 16) return null;
                    const x = dataView.getFloat64(offset, littleEndian);
                    const y = dataView.getFloat64(offset + 8, littleEndian);

                    if (Number.isNaN(x) || Number.isNaN(y)) return null;
                    return { lon: x, lat: y };
                } catch (error) {
                    console.warn('Failed to parse WKB point:', error);
                    return null;
                }
            }

            function parseLocation(location) {
                if (!location) return null;

                // If it's a PostGIS POINT string
                if (typeof location === 'string' && location.includes('POINT')) {
                    const match = location.match(/POINT\(([^)]+)\)/);
                    if (match) {
                        const coords = match[1].split(' ');
                        return { lon: parseFloat(coords[0]), lat: parseFloat(coords[1]) };
                    }
                }

                // If it's GeoJSON
                if (location.type === 'Point' && location.coordinates) {
                    return { lon: location.coordinates[0], lat: location.coordinates[1] };
                }

                // If it's EWKB / hex-encoded point
                if (typeof location === 'string' && /^[0-9A-Fa-f]+$/.test(location.trim())) {
                    return parseWkbPoint(location);
                }

                return null;
            }

            function getPropertyCoordinates(prop) {
                if (!prop) return null;
                const parsed = parseLocation(prop.location);
                if (parsed && !Number.isNaN(parsed.lon) && !Number.isNaN(parsed.lat)) {
                    return parsed;
                }

                const lonCandidates = [
                    prop.location_lon,
                    prop.longitude,
                    prop.lon,
                    prop.lng,
                    prop.long
                ];
                const latCandidates = [
                    prop.location_lat,
                    prop.latitude,
                    prop.lat
                ];

                const lonCandidate = lonCandidates.find(value => value !== null && value !== undefined && value !== '');
                const latCandidate = latCandidates.find(value => value !== null && value !== undefined && value !== '');

                if (lonCandidate !== undefined && latCandidate !== undefined) {
                    const lon = Number(lonCandidate);
                    const lat = Number(latCandidate);
                    if (!Number.isNaN(lon) && !Number.isNaN(lat)) {
                        return { lon, lat };
                    }
                }

                return null;
            }

            // Haversine distance calculation
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c; // Distance in km
            }

            // Helper: Calculate Property Type Match Score
            function calculatePropertyTypeMatchScore(subjectType, comparableType) {
                if (!subjectType || !comparableType) return 0.5; // Neutral if unknown
                subjectType = subjectType.trim();
                comparableType = comparableType.trim();

                if (subjectType === comparableType) return 1.0;

                const typeCategories = {
                    'Residential': ['Residential', 'Apartment', 'House', 'Condominium', 'Bungalow'],
                    'Commercial': ['Commercial', 'Office', 'Retail', 'Shop', 'Mall', 'Hotel'],
                    'Industrial': ['Industrial', 'Warehouse', 'Factory'],
                    'Agricultural': ['Agricultural', 'Farm', 'Ranch', 'Land'],
                    'Institutional': ['Institutional', 'School', 'Hospital', 'Church']
                };

                // Check if in same category
                for (const [category, types] of Object.entries(typeCategories)) {
                    const subjectIn = types.some(t => subjectType.includes(t));
                    const compIn = types.some(t => comparableType.includes(t));
                    if (subjectIn && compIn) {
                        return 0.7; // Same category but not exact match
                    }
                }

                return 0.3; // Different categories
            }

            // Helper: Calculate Tenure Adjustment
            function calculateTenureAdjustment(subjectTenure, comparableTenure) {
                if (!subjectTenure || !comparableTenure) return 1.0;

                const adjustments = {
                    'Freehold->Freehold': 1.0,
                    'Freehold->Leasehold': 0.85,  // Freehold is worth more
                    'Leasehold->Freehold': 1.15,  // Adjust comparable up
                    'Leasehold->Leasehold': 1.0,
                    'Mailo->Mailo': 1.0,
                    'Mailo->Freehold': 0.95,
                    'Freehold->Mailo': 1.05,
                    'Mailo->Leasehold': 0.90,
                    'Leasehold->Mailo': 1.10
                };

                const key = `${subjectTenure}->${comparableTenure}`;
                return adjustments[key] || 1.0;
            }

            // Helper: Calculate Size Adjustment (Economies of Scale)
            function calculateSizeAdjustment(subjectSize, comparableSize) {
                if (!subjectSize || !comparableSize || comparableSize === 0) return 1.0;

                const ratio = subjectSize / comparableSize;

                if (ratio > 1.5) {
                    // Subject is significantly larger. Reduce comparable price.
                    return Math.max(0.7, 1.0 - (Math.log10(ratio) * 0.3));
                } else if (ratio < 0.67) {
                    // Subject is significantly smaller. Increase comparable price.
                    return Math.min(1.3, 1.0 + (Math.log10(1 / ratio) * 0.3));
                }

                return 1.0; // No adjustment for similar sizes
            }

            // Helper: Calculate Recency Weight
            function calculateRecencyWeight(valuationDate) {
                if (!valuationDate) return 0.5; // Default low weight if no date

                const date = new Date(valuationDate);
                const now = new Date();
                const ageInDays = (now - date) / (1000 * 60 * 60 * 24);

                if (ageInDays < 0) return 1.0; // Future date? Treat as new

                // Exponential decay with 6-month (180 day) half-life
                return Math.max(0.1, Math.exp(-ageInDays / 180));
            }

            // Filter comparables by scope and location hierarchy
            function filterComparablesByScopeAndLocation(
                comparables,
                targetScope,
                villageName,
                county,
                district,
                strictVillageMatch
            ) {
                // Priority 1: Same village, matching scope
                let villageMatches = comparables.filter(c =>
                    c.village_name === villageName &&
                    isScopeCompatible(c.valuation_scope, targetScope)
                );

                if (villageMatches.length >= 3 || strictVillageMatch) {
                    return villageMatches.length >= 3 ? villageMatches : [];
                }

                // Priority 2: Same county, matching scope
                let countyMatches = comparables.filter(c =>
                    c.county === county &&
                    isScopeCompatible(c.valuation_scope, targetScope)
                );

                if (countyMatches.length >= 3) {
                    return countyMatches;
                }

                // Priority 3: Same district, matching scope
                let districtMatches = comparables.filter(c =>
                    c.district === district &&
                    isScopeCompatible(c.valuation_scope, targetScope)
                );

                if (districtMatches.length >= 3) {
                    return districtMatches;
                }

                // Priority 4: Any compatible scope (with location preference)
                let allCompatible = comparables.filter(c =>
                    isScopeCompatible(c.valuation_scope, targetScope)
                );

                // Sort by location hierarchy preference
                allCompatible.sort((a, b) => {
                    const aScore = getLocationMatchScore(a, villageName, county, district);
                    const bScore = getLocationMatchScore(b, villageName, county, district);
                    return bScore - aScore;
                });

                return allCompatible;
            }

            function isScopeCompatible(comparableScope, targetScope) {
                if (comparableScope === targetScope) return true;

                if (targetScope === 'Land Only') {
                    return comparableScope === 'Land Only' ||
                        comparableScope === 'Land + Improvements' ||
                        comparableScope === 'Total (Unspecified)';
                }

                if (targetScope === 'Land + Improvements') {
                    return comparableScope === 'Land + Improvements' ||
                        comparableScope === 'Total (Unspecified)';
                }

                return false;
            }

            function getLocationMatchScore(comparable, villageName, county, district) {
                let score = 0;
                if (comparable.village_name === villageName) score += 10;
                if (comparable.county === county) score += 5;
                if (comparable.district === district) score += 2;
                return score;
            }

            // Calculate land value using comparables
            async function calculateLandValue(comparables, propertySizeSQM, formData) {
                const distances = [];
                const landValues = [];
                const landValuesPerSQM = [];
                const comparableDetails = []; // Store detailed adjustment data

                // Get reference radius from form or default to 2km logic
                const radiusKm = parseFloat(document.getElementById('autoValueRadius')?.value) || 2;
                const effectiveRadius = radiusKm * 0.4; // Controlled decay factor

                comparables.forEach(prop => {
                    const propCoords = parseLocation(prop.location);
                    if (!propCoords) return;

                    const distance = haversineDistance(
                        formData.lat || 0,
                        formData.lon || 0,
                        propCoords.lat,
                        propCoords.lon
                    );
                    distances.push(distance);

                    // Extract land value based on scope
                    let landValue = null;
                    if (prop.land_value_ugx) {
                        landValue = prop.land_value_ugx;
                    } else if (prop.valuation_scope === 'Land Only') {
                        landValue = prop.price_ugx;
                    } else if (prop.valuation_scope === 'Land + Improvements' && prop.improvements_value_ugx) {
                        landValue = prop.price_ugx - prop.improvements_value_ugx;
                    } else {
                        // Estimate: assume 60% land, 40% improvements for mixed properties
                        landValue = prop.price_ugx * 0.6;
                    }

                    if (landValue && prop.property_size_sqm > 0) {
                        landValues.push(landValue);
                        const pricePerSQM = landValue / prop.property_size_sqm;
                        landValuesPerSQM.push(pricePerSQM);

                        // Calculate Adjustments
                        const distanceWeight = Math.exp(-distance / effectiveRadius);
                        const typeMatchScore = calculatePropertyTypeMatchScore(formData.property_type, prop.property_type);
                        const tenureAdjustment = calculateTenureAdjustment(formData.tenure, prop.tenure);
                        const sizeAdjustment = calculateSizeAdjustment(propertySizeSQM, prop.property_size_sqm);
                        const recencyWeight = calculateRecencyWeight(prop.valuation_date);

                        // Calculate Overall Weight
                        const overallWeight = distanceWeight * typeMatchScore * recencyWeight;

                        // Adjusted Unit Price for Valuation
                        // We adjust the COMPARABLE's unit price to make it indicate what the SUBJECT would be worth
                        // Adjusted Price = Unadjusted Price * Tenure Adj * Size Adj
                        const adjustedPricePerSQM = pricePerSQM * tenureAdjustment * sizeAdjustment;

                        comparableDetails.push({
                            prop: prop,
                            unadjustedPricePerSQM: pricePerSQM,
                            adjustedPricePerSQM: adjustedPricePerSQM,
                            weight: overallWeight,
                            adjustments: {
                                distance: distance,
                                distanceWeight: distanceWeight,
                                typeMatch: typeMatchScore,
                                tenureAdj: tenureAdjustment,
                                sizeAdj: sizeAdjustment,
                                recencyWeight: recencyWeight
                            }
                        });
                    }
                });

                // Weighted average
                let totalWeight = 0;
                let weightedSum = 0;

                comparableDetails.forEach(item => {
                    totalWeight += item.weight;
                    weightedSum += item.adjustedPricePerSQM * item.weight;
                });

                const weightedAvgPricePerSQM = totalWeight > 0 ? weightedSum / totalWeight : 0;
                const estimatedLandValue = weightedAvgPricePerSQM * propertySizeSQM;

                // Calculate enhanced confidence
                const avgDistance = distances.length > 0 ? distances.reduce((a, b) => a + b, 0) / distances.length : 0;

                // Average scores for confidence metric
                const avgRecency = comparableDetails.reduce((sum, item) => sum + item.adjustments.recencyWeight, 0) / (comparableDetails.length || 1);
                const avgTypeMatch = comparableDetails.reduce((sum, item) => sum + item.adjustments.typeMatch, 0) / (comparableDetails.length || 1);

                const confidenceComponents = {
                    distance: Math.max(0, 100 - (avgDistance * 50)) * 0.25,
                    count: Math.min(100, (comparableDetails.length / 10) * 100) * 0.20,
                    recency: (avgRecency * 100) * 0.20,
                    typeMatch: (avgTypeMatch * 100) * 0.15,
                    consistency: 0 // Placeholder for variance score
                };

                // Add consistency score (lower variance = higher confidence)
                if (comparableDetails.length > 1) {
                    const prices = comparableDetails.map(c => c.adjustedPricePerSQM);
                    const mean = prices.reduce((a, b) => a + b) / prices.length;
                    const variance = prices.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / prices.length;
                    const cv = Math.sqrt(variance) / mean; // Coefficient of variation
                    // CV of 0.1 (10%) is great (100 score), CV of 0.5 (50%) is poor (0 score)
                    confidenceComponents.consistency = Math.max(0, 100 - (cv * 200)) * 0.20;
                } else {
                    confidenceComponents.consistency = 50 * 0.20; // Default for single comp
                }

                const confidence = Math.min(100, Math.round(
                    confidenceComponents.distance +
                    confidenceComponents.count +
                    confidenceComponents.recency +
                    confidenceComponents.typeMatch +
                    confidenceComponents.consistency
                ));

                return {
                    landValue: estimatedLandValue,
                    landValuePerSQM: weightedAvgPricePerSQM,
                    confidence: confidence,
                    method: 'Sales Comparison Approach (Enhanced)',
                    comparablesUsed: comparableDetails.length,
                    averageDistance: avgDistance,
                    comparableDetails: comparableDetails // Pass this through for report
                };
            }

            // Calculate improvements value using multiple methods
            async function calculateImprovementsValue(formData, comparables, landValue) {
                const methods = [];

                // Method 1: Cost Approach (if building data available)
                if (formData.number_of_rooms && formData.number_of_floors) {
                    const costApproach = calculateImprovementsByCostApproach(formData);
                    if (costApproach) {
                        methods.push({
                            method: 'Cost Approach',
                            value: costApproach,
                            confidence: 75
                        });
                    }
                }

                // Method 2: Extract from comparables with improvements
                const improvementsComparables = comparables.filter(c =>
                    c.improvements_value_ugx && c.improvements_value_ugx > 0
                );

                if (improvementsComparables.length >= 3) {
                    const comparableMethod = calculateImprovementsFromComparables(
                        improvementsComparables,
                        formData.property_size_sqm
                    );
                    if (comparableMethod) {
                        methods.push({
                            method: 'Comparable Improvements',
                            value: comparableMethod,
                            confidence: 80
                        });
                    }
                }

                // Method 3: Residual Method (Total - Land)
                const totalComparables = comparables.filter(c =>
                    c.valuation_scope === 'Land + Improvements' ||
                    c.valuation_scope === 'Total (Unspecified)'
                );

                if (totalComparables.length >= 3) {
                    const residualMethod = calculateImprovementsByResidual(
                        totalComparables,
                        formData.property_size_sqm,
                        landValue
                    );
                    if (residualMethod) {
                        methods.push({
                            method: 'Residual Method',
                            value: residualMethod,
                            confidence: 70
                        });
                    }
                }

                // Use weighted average of available methods
                if (methods.length === 0) {
                    return null; // Cannot calculate
                }

                const totalWeight = methods.reduce((sum, m) => sum + m.confidence, 0);
                const weightedValue = methods.reduce((sum, m) =>
                    sum + (m.value * m.confidence), 0
                ) / totalWeight;

                const avgConfidence = totalWeight / methods.length;

                return {
                    improvementsValue: weightedValue,
                    improvementsValuePerSQM: weightedValue / formData.property_size_sqm,
                    confidence: Math.round(avgConfidence),
                    methods: methods,
                    primaryMethod: methods[0].method
                };
            }

            // Cost Approach for improvements
            function calculateImprovementsByCostApproach(formData) {
                // Construction cost per sqm by property type and location
                const constructionCosts = {
                    'Residential': {
                        'Kampala': 800000,
                        'Wakiso': 700000,
                        'default': 600000
                    },
                    'Commercial': {
                        'Kampala': 1200000,
                        'Wakiso': 1000000,
                        'default': 900000
                    },
                    'default': {
                        'default': 500000
                    }
                };

                const propertyType = formData.property_type || 'Residential';
                const district = formData.district || '';
                const costs = constructionCosts[propertyType] || constructionCosts['default'];
                const costPerSQM = costs[district] || costs['default'] || 500000;

                // Estimate building area (assume 60% of plot for residential, 40% for commercial)
                const plotCoverage = propertyType === 'Residential' ? 0.6 : 0.4;
                const buildingArea = formData.property_size_sqm * plotCoverage;

                // Replacement cost
                const replacementCost = costPerSQM * buildingArea;

                // Depreciation based on age and condition
                const age = formData.property_age_years || 0;
                const condition = formData.property_condition || 'Good';

                const conditionMultipliers = {
                    'Excellent': 0.95,
                    'Good': 0.85,
                    'Fair': 0.70,
                    'Poor': 0.50
                };

                const conditionDepreciation = 1 - (conditionMultipliers[condition] || 0.85);
                const ageDepreciation = Math.min(0.5, age * 0.02); // Max 50% depreciation
                const totalDepreciation = Math.min(0.8, conditionDepreciation + ageDepreciation);

                const depreciatedValue = replacementCost * (1 - totalDepreciation);

                return depreciatedValue;
            }

            // Calculate improvements from comparables
            function calculateImprovementsFromComparables(comparables, propertySizeSQM) {
                const improvementsPerSQMList = [];
                let totalWeight = 0;
                let weightedSum = 0;

                comparables.forEach(c => {
                    if (c.property_size_sqm > 0 && c.improvements_value_ugx > 0) {
                        const valuePerSQM = c.improvements_value_ugx / c.property_size_sqm;

                        // Weight by recency and size similarity
                        // Improvements value per SQM should be roughly similar for similar sized plots
                        const recencyWeight = calculateRecencyWeight(c.valuation_date);
                        const sizeAdjustment = calculateSizeAdjustment(propertySizeSQM, c.property_size_sqm);

                        // Improvements generally don't scale linearly with plot size (smaller plots have higher density)
                        // So we adjust the comparable's unit value to match subject's scale
                        const adjustedValuePerSQM = valuePerSQM * sizeAdjustment;

                        const weight = recencyWeight; // Use recency as primary weight

                        totalWeight += weight;
                        weightedSum += adjustedValuePerSQM * weight;

                        improvementsPerSQMList.push(adjustedValuePerSQM);
                    }
                });

                if (totalWeight === 0) return null;

                const weightedAvg = weightedSum / totalWeight;
                return weightedAvg * propertySizeSQM;
            }

            // Calculate improvements via residual method
            function calculateImprovementsByResidual(comparables, propertySizeSQM, estimatedLandValue) {
                const residuals = [];
                let totalWeight = 0;
                let weightedSum = 0;

                // Land Value per SQM
                const landValuePerSQM = estimatedLandValue / propertySizeSQM;

                comparables.forEach(c => {
                    // Residual = Total Price - (Estimated Land Value * Comp Size)
                    // We assume the land value per SQM is applicable to the comparable (with adjustments)

                    const recencyWeight = calculateRecencyWeight(c.valuation_date);

                    // Adjust our estimated land unit value to the comparable's size
                    // (Inverse of size adjustment: if comp is larger, its unit land value should be lower)
                    const sizeAdj = calculateSizeAdjustment(c.property_size_sqm, propertySizeSQM); // Switch args
                    const compLandValue = landValuePerSQM * sizeAdj * c.property_size_sqm;

                    const residualImprovements = c.price_ugx - compLandValue;

                    if (residualImprovements > 0) {
                        residuals.push(residualImprovements);
                        totalWeight += recencyWeight;
                        weightedSum += residualImprovements * recencyWeight;
                    }
                });

                if (totalWeight === 0) return null;

                return weightedSum / totalWeight;
            }

            // Residual method: Total - Land
            function calculateImprovementsByResidual(comparables, propertySizeSQM, estimatedLandValue) {
                const totalPerSQM = comparables
                    .filter(c => c.property_size_sqm > 0)
                    .map(c => c.price_ugx / c.property_size_sqm);

                if (totalPerSQM.length === 0) return null;

                const avgTotalPerSQM = totalPerSQM.reduce((a, b) => a + b, 0) / totalPerSQM.length;
                const estimatedTotal = avgTotalPerSQM * propertySizeSQM;

                return Math.max(0, estimatedTotal - estimatedLandValue);
            }

            // Calculate overall confidence
            function calculateOverallConfidence(landCalc, improvementsCalc, comparablesCount) {
                let confidence = landCalc.confidence || 70;

                if (improvementsCalc) {
                    confidence = (confidence * 0.6) + (improvementsCalc.confidence * 0.4);
                }

                // Adjust for comparables count
                const countAdjustment = Math.min(10, comparablesCount - 3);
                confidence = Math.min(100, confidence + countAdjustment);

                return Math.round(confidence);
            }

            // Calculate statistics
            function calculateStatistics(comparables, propertySizeSQM, distancesWithData = null) {
                const prices = comparables.map(c => c.price_ugx).filter(p => p > 0);
                const landValues = comparables.map(c => c.land_value_ugx || c.price_ugx).filter(v => v > 0);

                // Calculate basic statistics
                const avgPrice = prices.length ? Math.round(prices.reduce((a, b) => a + b, 0) / prices.length) : 0;
                const minPrice = prices.length ? Math.round(Math.min(...prices)) : 0;
                const maxPrice = prices.length ? Math.round(Math.max(...prices)) : 0;
                const avgLandValue = landValues.length ? Math.round(landValues.reduce((a, b) => a + b, 0) / landValues.length) : 0;

                // Calculate median price
                const sortedPrices = [...prices].sort((a, b) => a - b);
                const medianPrice = sortedPrices.length > 0
                    ? (sortedPrices.length % 2 === 0
                        ? Math.round((sortedPrices[sortedPrices.length / 2 - 1] + sortedPrices[sortedPrices.length / 2]) / 2)
                        : Math.round(sortedPrices[Math.floor(sortedPrices.length / 2)]))
                    : 0;

                // Calculate standard deviation
                const variance = prices.length > 0
                    ? prices.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / prices.length
                    : 0;
                const stdDev = Math.round(Math.sqrt(variance));

                // Calculate price per SQM statistics
                let avgPricePerSQM = 0;
                let weightedAvgPricePerSQM = 0;
                let medianPricePerSQM = 0;

                if (distancesWithData && distancesWithData.length > 0) {
                    const pricesPerSQM = distancesWithData
                        .map(item => item.pricePerSQM)
                        .filter(p => p !== null && p > 0 && Number.isFinite(p));

                    if (pricesPerSQM.length > 0) {
                        avgPricePerSQM = Math.round(pricesPerSQM.reduce((a, b) => a + b, 0) / pricesPerSQM.length);

                        // Calculate weighted average (distance-based)
                        let totalWeight = 0;
                        let weightedSum = 0;
                        distancesWithData.forEach(item => {
                            if (item.pricePerSQM && item.pricePerSQM > 0 && Number.isFinite(item.pricePerSQM)) {
                                const weight = 1 / (item.distance + 0.1); // Distance-based weight
                                totalWeight += weight;
                                weightedSum += item.pricePerSQM * weight;
                            }
                        });
                        weightedAvgPricePerSQM = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0;

                        // Calculate median price per SQM
                        const sortedPricesPerSQM = [...pricesPerSQM].sort((a, b) => a - b);
                        medianPricePerSQM = sortedPricesPerSQM.length > 0
                            ? (sortedPricesPerSQM.length % 2 === 0
                                ? Math.round((sortedPricesPerSQM[sortedPricesPerSQM.length / 2 - 1] + sortedPricesPerSQM[sortedPricesPerSQM.length / 2]) / 2)
                                : Math.round(sortedPricesPerSQM[Math.floor(sortedPricesPerSQM.length / 2)]))
                            : 0;
                    }
                }

                return {
                    avgPrice,
                    minPrice,
                    maxPrice,
                    medianPrice,
                    stdDev,
                    avgPricePerSQM,
                    weightedAvgPricePerSQM,
                    medianPricePerSQM,
                    avgLandValue
                };
            }

            // Identify risk indicators
            function identifyRiskIndicators(landCalc, improvementsCalc, comparables) {
                const risks = [];

                if (comparables.length < 5) {
                    risks.push('Fewer than 5 comparables available');
                }

                if (landCalc.averageDistance > 5000) {
                    risks.push('Comparables are located far from subject property (>5km average)');
                }

                if (improvementsCalc && improvementsCalc.confidence < 60) {
                    risks.push('Improvements value calculation has low confidence');
                }

                if (landCalc.confidence < 60) {
                    risks.push('Land value calculation has low confidence');
                }

                return risks;
            }

            // Process auto-valuation results and generate comprehensive report
            async function processAutoValuationWithReport(properties, lon, lat, coord, formData, radiusKm) {
                const propertySizeSQM = formData.property_size_sqm || 100;
                const valuationScope = formData.valuation_scope || 'Land Only';
                const strictVillageMatch = formData.strict_village_match !== false;

                // Filter comparables by scope and location hierarchy
                let filteredComparables = filterComparablesByScopeAndLocation(
                    properties,
                    valuationScope,
                    formData.village_name,
                    formData.county,
                    formData.district,
                    strictVillageMatch
                );

                if (!filteredComparables || filteredComparables.length < 3) {
                    showToast(`Insufficient data: Only ${filteredComparables?.length || 0} comparable(s) found. Need at least 3.`, 'warning');

                    // Still show form data but indicate insufficient data
                    const reportContainer = document.getElementById('autoValueReportContainer');
                    const reportDiv = document.getElementById('autoValueReport');

                    reportDiv.innerHTML = `
                    <div class="valuation-report-section">
                        <h3><i class="fas fa-exclamation-triangle"></i> Insufficient Data</h3>
                        <p>Only ${filteredComparables?.length || 0} comparable property(ies) found within ${radiusKm}km radius.</p>
                        <p>Please add more property valuations or use manual input instead.</p>
                        <p><strong>Note:</strong> A minimum of 3 comparable properties is required for accurate auto-valuation.</p>
                    </div>
                `;

                    reportContainer.style.display = 'block';
                    displayAutoValuationInsights({ comparables: [] });
                    return;
                }

                // Phase 1: Calculate Land Value (Always)
                const landCalculation = await calculateLandValue(
                    filteredComparables,
                    propertySizeSQM,
                    formData
                );

                // Phase 2: Calculate Improvements Value (If requested)
                let improvementsCalculation = null;
                if (valuationScope === 'Land + Improvements') {
                    improvementsCalculation = await calculateImprovementsValue(
                        formData,
                        filteredComparables,
                        landCalculation.landValue
                    );
                }

                // Calculate total value
                const totalValue = landCalculation.landValue +
                    (improvementsCalculation?.improvementsValue || 0);

                // Calculate confidence
                const confidence = calculateOverallConfidence(
                    landCalculation,
                    improvementsCalculation,
                    filteredComparables.length
                );

                // Prepare comparables with distance data
                const distancesWithData = filteredComparables.map(prop => {
                    const propCoords = parseLocation(prop.location);
                    if (!propCoords) return null;
                    const distance = haversineDistance(lat, lon, propCoords.lat, propCoords.lon);
                    return {
                        prop: prop,
                        distance: distance,
                        price: prop.price_ugx,
                        pricePerSQM: prop.property_size_sqm > 0 ? prop.price_ugx / prop.property_size_sqm : null,
                        propertySizeSQM: prop.property_size_sqm || null,
                        source: 'valuation'
                    };
                }).filter(item => item !== null);

                distancesWithData.sort((a, b) => a.distance - b.distance);

                // Calculate statistics (now with distancesWithData for accurate calculations)
                const statistics = calculateStatistics(filteredComparables, propertySizeSQM, distancesWithData);

                // Identify risk indicators
                const riskIndicators = identifyRiskIndicators(landCalculation, improvementsCalculation, filteredComparables);

                // Comparable summaries
                const typeCounts = {};
                const tenureCounts = {};
                let recentComparables = 0;
                filteredComparables.forEach(prop => {
                    const typeKey = (prop.property_type || 'Unknown').trim();
                    const tenureKey = (prop.tenure || 'Unknown').trim();
                    typeCounts[typeKey] = (typeCounts[typeKey] || 0) + 1;
                    tenureCounts[tenureKey] = (tenureCounts[tenureKey] || 0) + 1;

                    if (prop.valuation_date) {
                        const valuationDate = new Date(prop.valuation_date);
                        const diffDays = (Date.now() - valuationDate.getTime()) / (1000 * 60 * 60 * 24);
                        if (diffDays <= 180) {
                            recentComparables += 1;
                        }
                    }
                });

                const dominantPropertyType = Object.entries(typeCounts)
                    .sort((a, b) => b[1] - a[1])[0] || ['Unknown', 0];
                const dominantTenure = Object.entries(tenureCounts)
                    .sort((a, b) => b[1] - a[1])[0] || ['Unknown', 0];

                // Calculate distance statistics from distancesWithData
                const distances = distancesWithData
                    .map(d => Number(d.distance))
                    .filter(d => Number.isFinite(d) && d >= 0); // Include 0 distance if any

                const avgDistance = distances.length > 0
                    ? distances.reduce((a, b) => a + b, 0) / distances.length
                    : 0;

                const sortedDistances = [...distances].sort((a, b) => a - b);
                const medianDistance = sortedDistances.length > 0
                    ? (sortedDistances.length % 2 === 0
                        ? (sortedDistances[sortedDistances.length / 2 - 1] + sortedDistances[sortedDistances.length / 2]) / 2
                        : sortedDistances[Math.floor(sortedDistances.length / 2)])
                    : 0;

                const comparableSummary = {
                    dominantPropertyType: dominantPropertyType[0],
                    dominantPropertyTypeShare: filteredComparables.length ? ((dominantPropertyType[1] / filteredComparables.length) * 100).toFixed(1) : '0.0',
                    dominantTenure: dominantTenure[0],
                    dominantTenureShare: filteredComparables.length ? ((dominantTenure[1] / filteredComparables.length) * 100).toFixed(1) : '0.0',
                    averageDistance: Number.isFinite(avgDistance) ? (avgDistance / 1000).toFixed(2) : '0.00',
                    medianDistance: Number.isFinite(medianDistance) ? (medianDistance / 1000).toFixed(2) : '0.00',
                    priceRange: { min: statistics.minPrice, max: statistics.maxPrice },
                    recentComparables
                };

                const valuationNotes = [];
                if (formData.notes) {
                    valuationNotes.push(`Valuer note: ${formData.notes}`);
                }
                if (recentComparables > 0) {
                    valuationNotes.push(`${recentComparables} comparable(s) captured within the last 180 days.`);
                }
                if (!valuationNotes.length) {
                    valuationNotes.push('No additional valuer notes recorded.');
                }

                // Store report data
                valuationState.reportData = {
                    formData: formData,
                    location: { lon, lat, coord },
                    generatedAt: new Date().toISOString(),
                    valuationScope: valuationScope,
                    landValue: Math.round(landCalculation.landValue),
                    improvementsValue: improvementsCalculation ? Math.round(improvementsCalculation.improvementsValue) : null,
                    totalValue: Math.round(totalValue),
                    estimatedPrice: Math.round(totalValue),
                    landValuePerSQM: landCalculation.landValuePerSQM,
                    improvementsValuePerSQM: improvementsCalculation?.improvementsValuePerSQM || null,
                    estimatedPricePerSQM: totalValue / propertySizeSQM,
                    confidence: confidence,
                    radiusKm: radiusKm,
                    comparablesCount: filteredComparables.length,
                    landCalculation: landCalculation,
                    improvementsCalculation: improvementsCalculation,
                    comparables: distancesWithData,
                    statistics: statistics,
                    riskIndicators: riskIndicators,
                    comparableSummary: comparableSummary,
                    valuationNotes: valuationNotes
                };

                // Generate and display report
                const template = valuationState.reportTemplate || 'detailed';
                generateEnhancedValuationReport(valuationState.reportData);
                displayAutoValuationInsights(valuationState.reportData);

                // Auto-save to Supabase
                await autoSaveValuationToSupabase(valuationState.reportData);
            }

            // Generate enhanced valuation report with value breakdown
            function generateEnhancedValuationReport(reportData) {


                const reportContainer = document.getElementById('autoValueReportContainer');
                const reportDiv = document.getElementById('autoValueReport');

                if (!reportContainer || !reportDiv) return;

                const formContainer = document.getElementById('autoValueFormContainer');
                if (formContainer) formContainer.style.display = 'none';
                reportContainer.style.display = 'block';

                const { formData, location, valuationScope, landValue, improvementsValue,
                    totalValue, confidence, comparablesCount, landCalculation,
                    improvementsCalculation, statistics, riskIndicators, comparableSummary } = reportData;

                function formatCurrency(amount) {
                    return new Intl.NumberFormat('en-UG', {
                        style: 'currency',
                        currency: 'UGX',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    }).format(amount);
                }

                reportDiv.innerHTML = `
                <div class="enhanced-valuation-report">
                    <!-- Header -->
                    <div class="report-header" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 30px;
                        border-radius: 8px 8px 0 0;
                        margin-bottom: 0;
                    ">
                        <h2 style="margin: 0 0 10px 0; font-size: 24px;">
                            <i class="fas fa-file-alt"></i> Property Valuation Report
                        </h2>
                        <div style="opacity: 0.9; font-size: 14px;">
                            Generated: ${new Date(reportData.generatedAt).toLocaleString()}
                        </div>
                        ${formData.proprietor_name ? `<div style="margin-top: 10px; font-size: 16px;"><strong>Valuation For:</strong> ${formData.proprietor_name}</div>` : ''}
                    </div>
                    
                    <!-- Executive Summary -->
                    <div class="report-section" style="
                        background: #f8f9fa;
                        padding: 25px;
                        border-bottom: 2px solid #dee2e6;
                    ">
                        <h3 style="margin-top: 0; color: #495057;">
                            <i class="fas fa-chart-line"></i> Executive Summary
                        </h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 15px;">
                            <div class="summary-card" style="
                                background: white;
                                padding: 20px;
                                border-radius: 8px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            ">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px;">TOTAL VALUE</div>
                                <div style="font-size: 28px; font-weight: bold; color: #28a745;">
                                    ${formatCurrency(totalValue)}
                                </div>
                                <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                                    Confidence: ${confidence}%
                                </div>
                            </div>
                            
                            <div class="summary-card" style="
                                background: white;
                                padding: 20px;
                                border-radius: 8px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            ">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px;">LAND VALUE</div>
                                <div style="font-size: 24px; font-weight: bold; color: #007bff;">
                                    ${formatCurrency(landValue)}
                                </div>
                                <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                                    ${formatCurrency(landCalculation.landValuePerSQM)}/sqm
                                </div>
                            </div>
                            
                            ${improvementsValue ? `
                            <div class="summary-card" style="
                                background: white;
                                padding: 20px;
                                border-radius: 8px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            ">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px;">IMPROVEMENTS</div>
                                <div style="font-size: 24px; font-weight: bold; color: #ffc107;">
                                    ${formatCurrency(improvementsValue)}
                                </div>
                                <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                                    ${formatCurrency(improvementsCalculation.improvementsValuePerSQM)}/sqm
                                </div>
                            </div>
                            ` : ''}
                            
                            <div class="summary-card" style="
                                background: white;
                                padding: 20px;
                                border-radius: 8px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            ">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px;">COMPARABLES</div>
                                <div style="font-size: 24px; font-weight: bold; color: #17a2b8;">
                                    ${comparablesCount}
                                </div>
                                <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                                    Used in calculation
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Property Details -->
                    <div class="report-section" style="padding: 25px; border-bottom: 1px solid #dee2e6;">
                        <h3 style="margin-top: 0; color: #495057;">
                            <i class="fas fa-info-circle"></i> Property Details
                        </h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 15px;">
                            <div><strong>Location:</strong> ${formData.village_name}, ${formData.county}, ${formData.district}</div>
                            ${formData.proprietor_name ? `<div><strong>Proprietor/Owner:</strong> ${formData.proprietor_name}</div>` : ''}
                            <div><strong>Plot Number:</strong> ${formData.plot_number}</div>
                            <div><strong>Property Type:</strong> ${formData.property_type}</div>
                            <div><strong>Tenure:</strong> ${formData.tenure}</div>
                            <div><strong>Size:</strong> ${formData.property_size_sqm.toLocaleString()} sqm (${(formData.property_size_sqm / 4046.86).toFixed(4)} acres)</div>
                            <div><strong>Valuation Date:</strong> ${new Date(formData.valuation_date).toLocaleDateString()}</div>
                        </div>
                    </div>
                    
                    <!-- Methodology Section -->
                    <div class="report-section" style="padding: 25px; border-bottom: 1px solid #dee2e6; background: #fdfdfe;">
                        <h3 style="margin-top: 0; color: #495057;">
                            <i class="fas fa-book-open"></i> Valuation Methodology
                        </h3>
                        <div style="max-width: 800px; color: #555; line-height: 1.6;">
                            <p style="margin-bottom: 10px;">This valuation was conducted using the <strong>Sales Comparison Approach (Enhanced)</strong>, which estimates the value of the subject property by comparing it to similar properties that have recently sold or been valued in the same market.</p>
                            
                            <h4 style="font-size: 16px; margin: 15px 0 8px 0; color: #2c3e50;">Key Adjustment Factors:</h4>
                            <ul style="padding-left: 20px; margin: 0;">
                                <li><strong>Distance Weighting:</strong> Properties closer to the subject are weighted more heavily using exponentially decaying weights.</li>
                                <li><strong>Property Type Matching:</strong> Properties of the same type (e.g., Residential vs Commercial) receive higher similarity scores.</li>
                                <li><strong>Size Adjustment:</strong> Unit prices are adjusted to account for economies of scale (smaller plots typically command higher prices per sqm).</li>
                                <li><strong>Tenure Adjustment:</strong> Adjustments are made for differences in land tenure (e.g., Freehold vs Leasehold).</li>
                                <li><strong>Recency:</strong> More recent valuations are given greater weight to reflect current market conditions.</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Risk Indicators -->
                    ${riskIndicators && riskIndicators.length > 0 ? `
                    <div class="report-section" style="padding: 25px; border-bottom: 1px solid #dee2e6; background: #fff3cd;">
                        <h3 style="margin-top: 0; color: #856404;">
                            <i class="fas fa-exclamation-triangle"></i> Risk Indicators
                        </h3>
                        <ul style="margin: 15px 0 0 0; padding-left: 20px;">
                            ${riskIndicators.map(risk => `<li style="margin-bottom: 8px;">${risk}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    <!-- Comparables Summary -->
                    <div class="report-section" style="padding: 25px; border-bottom: 1px solid #dee2e6;">
                        <h3 style="margin-top: 0; color: #495057;">
                            <i class="fas fa-list"></i> Comparables Summary
                        </h3>
                        <div style="margin-top: 15px;">
                            <p><strong>${comparablesCount}</strong> comparable properties used in calculation</p>
                            <p>Average distance: ${comparableSummary.averageDistance} km</p>
                            <p>Price range: ${formatCurrency(statistics.minPrice || 0)} - ${formatCurrency(statistics.maxPrice || 0)}</p>
                        </div>
                        
                        <!-- Comparables Table -->
                        <div style="overflow-x: auto; margin-top: 20px;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                                <thead>
                                    <tr style="background: #e9ecef;">
                                        <th style="padding: 10px; text-align: left;">Location</th>
                                        <th style="padding: 10px; text-align: left;">Proprietor</th>
                                        <th style="padding: 10px; text-align: center;">Images</th>
                                        <th style="padding: 10px; text-align: right;">Size (sqm)</th>
                                        <th style="padding: 10px; text-align: right;">Price (UGX)</th>
                                        <th style="padding: 10px; text-align: right;">Adjusted /sqm</th>
                                        <th style="padding: 10px; text-align: right;">Weight</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${landCalculation.comparableDetails ? landCalculation.comparableDetails.slice(0, 10).map((item, idx) => {
                    const prop = item.prop;
                    const hasImages = prop.property_image_1_url || prop.property_image_2_url || prop.document_image_1_url;
                    return `
                                        <tr style="border-bottom: 1px solid #dee2e6;">
                                            <td style="padding: 10px;">${prop.village_name}, ${prop.district}<br><small>${item.adjustments.distance.toFixed(2)} km away</small></td>
                                            <td style="padding: 10px;">${prop.proprietor_name || '-'}</td>
                                            <td style="padding: 10px; text-align: center;">${hasImages ? '📷' : '-'}</td>
                                            <td style="padding: 10px; text-align: right;">${prop.property_size_sqm.toLocaleString()}</td>
                                            <td style="padding: 10px; text-align: right;">${formatCurrency(prop.price_ugx)}</td>
                                            <td style="padding: 10px; text-align: right;">${formatCurrency(item.adjustedPricePerSQM)}</td>
                                            <td style="padding: 10px; text-align: right;">${(item.weight * 100).toFixed(1)}%</td>
                                        </tr>
                                        `;
                }).join('') : '<tr><td colspan="7">No detail data available</td></tr>'}
                                </tbody>
                            </table>
                            <div style="font-size: 0.8rem; color: #666; margin-top: 5px; text-align: right;">* Showing top 10 weighted comparables</div>
                        </div>
                    </div>

                    <!-- Charts Section -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; padding: 25px; border-bottom: 1px solid #dee2e6;">
                         <div>
                            <h4 style="margin: 0 0 10px 0;">Price Distribution</h4>
                            <div style="height: 250px;"><canvas id="priceDistributionChart"></canvas></div>
                        </div>
                        <div>
                            <h4 style="margin: 0 0 10px 0;">Distance vs Price</h4>
                            <div style="height: 250px;"><canvas id="distancePriceChart"></canvas></div>
                        </div>
                    </div>
                </div>

                <!-- Detailed Comparable Pages Container -->
                <div id="comparableDetailPages"></div>
                `;

                // Render charts after DOM is updated
                setTimeout(() => {
                    try {
                        renderPriceDistributionChart(reportData);
                        renderDistancePriceChart(reportData);

                        // Generate Detail Pages
                        if (landCalculation.comparableDetails) {
                            generateComparableDetailPages(landCalculation.comparableDetails, formData, document.getElementById('comparableDetailPages'));
                        }
                    } catch (error) {
                        console.error('Error rendering report extras:', error);
                    }
                }, 300);

                // Scroll to report
                reportContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                showToast('Valuation report generated successfully!', 'success');
            }

            // Generate dedicated detailed pages for each comparable
            function generateComparableDetailPages(comparables, subjectProperty, container) {
                if (!comparables || !container) return;

                const pagesHTML = comparables.map((item, idx) => {
                    const prop = item.prop;
                    const adj = item.adjustments;

                    const images = [];
                    if (prop.property_image_1_url) images.push({ url: prop.property_image_1_url, label: 'Property Front' });
                    if (prop.property_image_2_url) images.push({ url: prop.property_image_2_url, label: 'Property Side/Back' });
                    if (prop.document_image_1_url) images.push({ url: prop.document_image_1_url, label: 'Document 1' });
                    if (prop.document_image_2_url) images.push({ url: prop.document_image_2_url, label: 'Document 2' });

                    return `
                    <div class="comparable-page" style="
                        page-break-before: always;
                        padding: 40px;
                        background: white;
                        margin-top: 30px;
                        border-top: 4px solid #667eea;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #eee; padding-bottom: 15px; margin-bottom: 20px;">
                            <h2 style="margin: 0; color: #2c3e50;">Comparable #${idx + 1} Analysis</h2>
                            <div style="background: #667eea; color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold;">
                                ${prop.village_name}
                            </div>
                        </div>

                        <!-- Details Grid -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                            <div>
                                <h3 style="color: #667eea; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Property Details</h3>
                                <table style="width: 100%; border-collapse: collapse;">
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Proprietor:</strong></td><td style="text-align: right;">${prop.proprietor_name || 'N/A'}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>District:</strong></td><td style="text-align: right;">${prop.district}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>County:</strong></td><td style="text-align: right;">${prop.county}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Block/Plot:</strong></td><td style="text-align: right;">${prop.block_number || ''}/${prop.plot_number}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Type:</strong></td><td style="text-align: right;">${prop.property_type}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Tenure:</strong></td><td style="text-align: right;">${prop.tenure}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Size:</strong></td><td style="text-align: right;">${prop.property_size_sqm.toLocaleString()} sqm</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Date:</strong></td><td style="text-align: right;">${new Date(prop.valuation_date).toLocaleDateString()}</td></tr>
                                </table>
                            </div>
                            
                            <div>
                                <h3 style="color: #667eea; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Valuation Analysis</h3>
                                <table style="width: 100%; border-collapse: collapse;">
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Sold/Valued Price:</strong></td><td style="text-align: right; color: #27ae60; font-weight: bold;">UGX ${prop.price_ugx.toLocaleString()}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Price / SQM:</strong></td><td style="text-align: right;">${item.unadjustedPricePerSQM.toFixed(0).toLocaleString()}</td></tr>
                                    <tr><td style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;"><strong>Distance to Subject:</strong></td><td style="text-align: right;">${adj.distance.toFixed(2)} km</td></tr>
                                    
                                    <tr><td colspan="2" style="padding-top: 15px; padding-bottom: 5px; color: #7f8c8d;"><strong>Adjustment Factors Applied:</strong></td></tr>
                                    <tr><td style="padding: 4px 0; font-size: 0.9em;">Type Match Score:</td><td style="text-align: right; font-family: monospace;">${adj.typeMatch.toFixed(2)}</td></tr>
                                    <tr><td style="padding: 4px 0; font-size: 0.9em;">Tenure Adjustment:</td><td style="text-align: right; font-family: monospace;">${adj.tenureAdj.toFixed(2)}</td></tr>
                                    <tr><td style="padding: 4px 0; font-size: 0.9em;">Size Adjustment:</td><td style="text-align: right; font-family: monospace;">${adj.sizeAdj.toFixed(2)}</td></tr>
                                    <tr><td style="padding: 4px 0; font-size: 0.9em;">Location/Dist. Weight:</td><td style="text-align: right; font-family: monospace;">${adj.distanceWeight.toFixed(3)}</td></tr>
                                    
                                    <tr><td style="padding: 10px 0; border-top: 2px solid #eee;"><strong>Net Weighted Value / SQM:</strong></td><td style="text-align: right; font-weight: bold; border-top: 2px solid #eee;">${item.adjustedPricePerSQM.toFixed(0).toLocaleString()}</td></tr>
                                </table>
                            </div>
                        </div>

                        <!-- Images Section -->
                        <h3 style="color: #2c3e50; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px;">Property Images</h3>
                        ${images.length > 0 ? `
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                            ${images.map(img => `
                                <div style="border: 1px solid #ddd; padding: 5px; border-radius: 4px; background: #fff;">
                                    <div style="height: 250px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #f9f9f9;">
                                        <img src="${img.url}" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="${img.label}">
                                    </div>
                                    <div style="padding: 8px; text-align: center; font-size: 0.9em; color: #555;">${img.label}</div>
                                </div>
                            `).join('')}
                        </div>
                        ` : `
                        <div style="padding: 40px; text-align: center; background: #f9f9f9; border-radius: 8px; color: #999;">
                            <i class="fas fa-image" style="font-size: 3em; margin-bottom: 10px; opacity: 0.3;"></i>
                            <div style="font-size: 1.1em;">No images available for this comparable</div>
                        </div>
                        `}
                    </div>
                    `;
                }).join('');

                container.innerHTML = pagesHTML;
            }

            // Export Enhanced Report to PDF
            function exportEnhancedReportPDF() {
                const element = document.getElementById('autoValueReportContainer');
                if (!element) {
                    showToast('Report container not found.', 'error');
                    return;
                }

                // Show toast to indicate process started
                showToast('Generating PDF... This may take a moment.', 'info');

                // Clone the element to modify for PDF without affecting view
                const clone = element.cloneNode(true);

                // Remove buttons from clone
                const buttons = clone.querySelectorAll('button');
                buttons.forEach(btn => btn.remove());

                // Ensure all images are loaded or have fallbacks
                const images = clone.querySelectorAll('img');
                images.forEach(img => {
                    // Force crossOrigin for html2canvas
                    img.crossOrigin = 'Anonymous';
                });

                // Generate timestamp
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const filename = `Valuation_Report_${timestamp}.pdf`;

                // Options for html2pdf
                const opt = {
                    margin: [10, 10, 10, 10], // top, left, bottom, right in mm
                    filename: filename,
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: {
                        scale: 2,
                        useCORS: true,
                        logging: false,
                        letterRendering: true
                    },
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                    pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
                };

                // Execute export
                if (typeof html2pdf === 'undefined') {
                    showToast('PDF library not loaded. Please refresh and try again.', 'error');
                    return;
                }

                html2pdf().set(opt).from(clone).save().then(() => {
                    showToast('PDF exported successfully!', 'success');
                }).catch(err => {
                    console.error('PDF Export Error:', err);
                    showToast('Failed to export PDF: ' + (err.message || 'Unknown error'), 'error');
                });
            }

            // Render Price Distribution Chart
            function renderPriceDistributionChart(reportData) {
                const canvas = document.getElementById('priceDistributionChart');
                if (!canvas) {
                    console.warn('Price Distribution Chart canvas not found');
                    return;
                }
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded');
                    return;
                }

                const comparables = reportData.comparables || [];
                if (comparables.length === 0) {
                    console.warn('No comparables data for price distribution chart');
                    return;
                }

                const prices = comparables.map(c => {
                    const price = c.price || c.prop?.price_ugx || 0;
                    return Number(price);
                }).filter(p => p > 0 && Number.isFinite(p));

                if (prices.length === 0) {
                    console.warn('No valid prices for price distribution chart');
                    return;
                }

                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);
                const range = maxPrice - minPrice;
                const bins = Math.min(10, Math.max(5, Math.ceil(Math.sqrt(prices.length))));
                const binWidth = range / bins;

                const histogramData = Array(bins).fill(0);
                const binLabels = [];

                prices.forEach(price => {
                    let binIndex = Math.min(Math.floor((price - minPrice) / binWidth), bins - 1);
                    histogramData[binIndex]++;
                });

                for (let i = 0; i < bins; i++) {
                    const binStart = minPrice + (i * binWidth);
                    const binEnd = binStart + binWidth;
                    binLabels.push(`${formatUGX(binStart)} - ${formatUGX(binEnd)}`);
                }

                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                const existingChart = Chart.getChart(canvas);
                if (existingChart) existingChart.destroy();

                const subjectPrice = Number(reportData.totalValue || reportData.estimatedPrice || 0);

                // Create plugin to mark subject property price
                const subjectPricePlugin = {
                    id: 'subjectPriceMarker',
                    afterDraw: (chart) => {
                        if (!Number.isFinite(subjectPrice) || subjectPrice <= 0) return;
                        const { ctx, chartArea, scales } = chart;
                        const xScale = scales.x;
                        if (!xScale || !chartArea) return;

                        // Find which bin the subject price falls into
                        let binIndex = Math.min(Math.floor((subjectPrice - minPrice) / binWidth), bins - 1);
                        binIndex = Math.max(0, Math.min(binIndex, bins - 1)); // Clamp to valid range

                        // Get the pixel position for this bin (category scale)
                        const x = xScale.getPixelForValue(binLabels[binIndex]);

                        if (!Number.isFinite(x) || x < chartArea.left || x > chartArea.right) return;

                        ctx.save();
                        ctx.strokeStyle = '#facc15';
                        ctx.fillStyle = '#facc15';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Draw triangle marker
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top - 5);
                        ctx.lineTo(x - 8, chartArea.top - 15);
                        ctx.lineTo(x + 8, chartArea.top - 15);
                        ctx.closePath();
                        ctx.fill();

                        // Draw label
                        ctx.fillStyle = '#92400e';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Subject Property', x, chartArea.top - 20);
                        ctx.restore();
                    }
                };

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: 'Number of Comparables',
                            data: histogramData,
                            backgroundColor: 'rgba(52, 152, 219, 0.65)',
                            borderColor: 'rgba(52, 152, 219, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Price Distribution (UGX)'
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Properties'
                                }
                            },
                            x: {
                                type: 'category',
                                title: {
                                    display: true,
                                    text: 'Price Range (UGX)'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    },
                    plugins: Number.isFinite(subjectPrice) && subjectPrice > 0 ? [subjectPricePlugin] : []
                });
            }

            // Render Distance vs Price Chart
            function renderDistancePriceChart(reportData) {
                const canvas = document.getElementById('distancePriceChart');
                if (!canvas) {
                    console.warn('Distance vs Price Chart canvas not found');
                    return;
                }
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded');
                    return;
                }

                const comparables = reportData.comparables || [];
                if (comparables.length === 0) {
                    console.warn('No comparables data for distance vs price chart');
                    return;
                }

                const scatterData = comparables
                    .map(c => {
                        const distance = Number(c.distance) || 0;
                        const price = Number(c.price || c.prop?.price_ugx || 0);
                        return {
                            x: distance / 1000, // Convert to km
                            y: price
                        };
                    })
                    .filter(point => Number.isFinite(point.x) && Number.isFinite(point.y) && point.x >= 0 && point.y > 0);

                if (scatterData.length === 0) {
                    console.warn('No valid scatter data for distance vs price chart');
                    return;
                }

                const ctx = canvas.getContext('2d');

                // Destroy existing chart if it exists
                const existingChart = Chart.getChart(canvas);
                if (existingChart) existingChart.destroy();

                const subjectPrice = Number(reportData.totalValue || reportData.estimatedPrice || 0);
                const subjectDistance = 0; // Subject property is at distance 0 (center point)

                // Create datasets array
                const datasets = [{
                    label: 'Comparable Properties',
                    data: scatterData,
                    backgroundColor: 'rgba(52, 152, 219, 0.6)',
                    borderColor: 'rgba(52, 152, 219, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7
                }];

                // Add subject property point if valid
                if (Number.isFinite(subjectPrice) && subjectPrice > 0) {
                    datasets.push({
                        label: 'Subject Property',
                        data: [{ x: subjectDistance, y: subjectPrice }],
                        backgroundColor: '#facc15',
                        borderColor: '#92400e',
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        pointStyle: 'triangle'
                    });
                }

                new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Distance vs Price Relationship'
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const label = context.dataset.label || '';
                                        const x = context.parsed.x.toFixed(2);
                                        const y = formatUGX(context.parsed.y);
                                        return `${label}: Distance: ${x} km, Price: ${y}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Distance (km)'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Price (UGX)'
                                },
                                ticks: {
                                    callback: function (value) {
                                        return formatUGX(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // Generate comprehensive valuation report HTML with charts
            function generateValuationReportHTML(reportData, template = 'detailed', options = {}) {
                valuationState.reportTemplate = template;
                const notify = options.notify !== false;
                const reportContainer = document.getElementById('autoValueReportContainer');
                const reportDiv = document.getElementById('autoValueReport');

                // Hide form and show report
                const formContainer = document.getElementById('autoValueFormContainer');
                if (formContainer) formContainer.style.display = 'none';
                reportContainer.style.display = 'block';

                const branding = reportData.formData.branding || {};
                const riskIndicators = reportData.riskIndicators || [];
                const comparableSummary = reportData.comparableSummary || {};
                const valuationNotes = reportData.valuationNotes || [];
                const comparablesList = Array.isArray(reportData.comparables) ? reportData.comparables : [];
                const stats = reportData.statistics || {};
                const generatedAt = reportData.generatedAt ? new Date(reportData.generatedAt) : new Date();
                const valuationDate = reportData.formData.valuation_date ? new Date(reportData.formData.valuation_date) : null;
                const propertySizeSQM = Number(reportData.formData.property_size_sqm) || 0;
                const propertySizeDisplay = propertySizeSQM
                    ? `${propertySizeSQM.toLocaleString()} sqm (${(propertySizeSQM / 4046.86).toFixed(4)} acres)`
                    : 'Not provided';
                const coordinateDisplay = reportData.location?.lat && reportData.location?.lon
                    ? `${reportData.location.lat.toFixed(5)}, ${reportData.location.lon.toFixed(5)}`
                    : null;
                const clientName = branding.client_name || 'Confidential client';
                const reportReference = branding.reference || 'Unreferenced';
                const valuerName = branding.valuer_name || reportData.formData.surveyor_name || 'Valuation team';
                const reportSubtitle = reportData.formData.plot_number
                    ? `Plot ${reportData.formData.plot_number}${reportData.formData.block_number ? ` · Block ${reportData.formData.block_number}` : ''}`
                    : (reportData.formData.district || 'Subject Property');
                const heroMetaItems = [
                    { label: 'Generated', value: generatedAt.toLocaleString() },
                    { label: 'Valuation Date', value: valuationDate ? valuationDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) : 'Not provided' },
                    { label: 'Comparables', value: `${reportData.comparablesCount}` },
                    { label: 'Radius', value: reportData.radiusKm ? `${reportData.radiusKm} km radius` : null },
                    { label: 'Reference', value: reportReference },
                    { label: 'Coordinates', value: coordinateDisplay }
                ].filter(item => item.value);

                const summarySection = `
                <section class="valuation-report-hero">
                    <div class="valuation-hero-top">
                        <div>
                            <div class="valuation-hero-eyebrow">Automated Comparable Analysis</div>
                            <h1>${reportSubtitle}</h1>
                            <p class="valuation-hero-subtitle">Prepared for ${clientName}</p>
                        </div>
                        <div class="valuation-hero-value">
                            <span class="value-label">Estimated Value</span>
                            <span class="value-amount">${formatUGX(reportData.estimatedPrice)}</span>
                            <span class="confidence-chip ${getConfidenceClass(reportData.confidence)}">
                                <i class="fas fa-shield-alt"></i> ${reportData.confidence}% confidence
                            </span>
                            <p style="margin: 8px 0 0; font-size: 0.85rem; opacity: 0.85;">
                                Based on ${reportData.comparablesCount} comparable properties within ${reportData.radiusKm || 0}km
                            </p>
                        </div>
                    </div>
                    <div class="valuation-meta-grid">
                        ${heroMetaItems.map(item => `
                            <div class="valuation-chip">
                                <span>${item.label}</span>
                                <strong>${item.value}</strong>
                            </div>
                        `).join('')}
                    </div>
                </section>`;

                const propertyDetails = [
                    { label: 'District', value: reportData.formData.district || 'N/A' },
                    { label: 'Tenure', value: reportData.formData.tenure || 'N/A' },
                    { label: 'Property Type', value: reportData.formData.property_type || 'N/A' },
                    { label: 'Property Size', value: propertySizeDisplay },
                    { label: 'Plot Number', value: reportData.formData.plot_number || 'N/A' },
                    { label: 'Block Number', value: reportData.formData.block_number || 'N/A' },
                    { label: 'Location', value: coordinateDisplay || 'Not captured' }
                ];

                const clientDetails = [
                    { label: 'Client / Institution', value: clientName },
                    { label: 'Reference', value: reportReference },
                    { label: 'Prepared By', value: valuerName },
                    { label: 'Surveyor', value: reportData.formData.surveyor_name || 'Not provided' },
                    { label: 'Valuation Notes', value: reportData.formData.notes || 'Not recorded' }
                ];

                const renderDefinitionList = (items) => items.map(item => `
                <li>
                    <span>${item.label}</span>
                    <strong>${item.value}</strong>
                </li>
            `).join('');

                const detailsSection = `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-info-circle"></i> Assignment Overview</h3>
                    <div class="valuation-card-grid">
                        <div class="valuation-card">
                            <div class="valuation-card-title"><i class="fas fa-map"></i> Property Profile</div>
                            <ul class="valuation-definition-list">
                                ${renderDefinitionList(propertyDetails)}
                            </ul>
                        </div>
                        <div class="valuation-card">
                            <div class="valuation-card-title"><i class="fas fa-user-tie"></i> Client & Valuer</div>
                            <ul class="valuation-definition-list">
                                ${renderDefinitionList(clientDetails)}
                            </ul>
                        </div>
                    </div>
                </section>`;

                const metricCards = [
                    { label: 'Average Price / SQM', value: Number.isFinite(stats.avgPricePerSQM) ? formatUGX(stats.avgPricePerSQM) : 'N/A' },
                    { label: 'Weighted Price / SQM', value: Number.isFinite(stats.weightedAvgPricePerSQM) ? formatUGX(stats.weightedAvgPricePerSQM) : 'N/A' },
                    { label: 'Price Range', value: `${formatUGX(stats.minPrice || 0)} – ${formatUGX(stats.maxPrice || 0)}` },
                    { label: 'Comparables Used', value: reportData.comparablesCount }
                ];

                const statsSection = `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-chart-line"></i> Key Metrics</h3>
                    <div class="valuation-metric-grid">
                        ${metricCards.map(card => `
                            <div class="valuation-metric-card">
                                <div class="metric-label">${card.label}</div>
                                <div class="metric-value">${card.value}</div>
                            </div>
                        `).join('')}
                    </div>
                    <table class="valuation-report-table">
                        <tr><th>Metric</th><th>Value</th></tr>
                        <tr><td>Estimated Value</td><td>${formatUGX(reportData.estimatedPrice)}</td></tr>
                        <tr><td>Average Comparable Price</td><td>${Number.isFinite(stats.avgPrice) ? formatUGX(stats.avgPrice) : 'N/A'}</td></tr>
                        <tr><td>Median Comparable Price</td><td>${Number.isFinite(stats.medianPrice) ? formatUGX(stats.medianPrice) : 'N/A'}</td></tr>
                        <tr><td>Price per SQM</td><td>${Number.isFinite(reportData.estimatedPricePerSQM) ? formatUGX(reportData.estimatedPricePerSQM) : 'N/A'}</td></tr>
                        <tr><td>Standard Deviation</td><td>${Number.isFinite(stats.stdDev) ? formatUGX(stats.stdDev) : 'N/A'}</td></tr>
                    </table>
                </section>`;

                const riskSection = riskIndicators.length ? `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-exclamation-circle"></i> Risk Indicators</h3>
                    <div class="valuation-risk-grid">
                        ${riskIndicators.map(item => `<div class="valuation-risk-pill"><i class="fas fa-info-circle"></i> ${item}</div>`).join('')}
                    </div>
                </section>` : '';

                const summaryInsightsSection = `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-balance-scale"></i> Comparable Summary</h3>
                    <div class="valuation-card">
                        <ul class="valuation-definition-list">
                            <li><span>Dominant Property Type</span><strong>${comparableSummary.dominantPropertyType || 'N/A'} (${comparableSummary.dominantPropertyTypeShare || '0.0'}%)</strong></li>
                            <li><span>Dominant Tenure</span><strong>${comparableSummary.dominantTenure || 'N/A'} (${comparableSummary.dominantTenureShare || '0.0'}%)</strong></li>
                            <li><span>Average Distance</span><strong>${comparableSummary.averageDistance || '0.00'} km</strong></li>
                            <li><span>Median Distance</span><strong>${comparableSummary.medianDistance || '0.00'} km</strong></li>
                            <li><span>Price Range</span><strong>${formatUGX(comparableSummary.priceRange?.min || 0)} – ${formatUGX(comparableSummary.priceRange?.max || 0)}</strong></li>
                            <li><span>Recent Comparables (≤180 days)</span><strong>${comparableSummary.recentComparables || 0}</strong></li>
                        </ul>
                    </div>
                </section>`;

                const notesSection = `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-sticky-note"></i> Valuation Notes</h3>
                    <ul class="valuation-note-list">
                        ${valuationNotes.map(note => `<li>${note}</li>`).join('')}
                    </ul>
                </section>`;

                const chartsSection = `
                <div class="valuation-report-section">
                    <h3><i class="fas fa-chart-bar"></i> Price Distribution</h3>
                    <div class="valuation-chart-container">
                        <canvas id="priceDistributionChart"></canvas>
                    </div>
                </div>
                
                <div class="valuation-report-section">
                    <h3><i class="fas fa-chart-scatter"></i> Distance vs Price</h3>
                    <div class="valuation-chart-container">
                        <canvas id="distancePriceChart"></canvas>
                    </div>
                </div>`;

                const comparablesTableRows = comparablesList.map((comp, idx) => {
                    const base = comp.prop || {};
                    const coords = getPropertyCoordinates(base);
                    const coordLabel = coords
                        ? `${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}`
                        : 'N/A';
                    const priceValue = comp.price ?? base.price_ugx ?? 0;
                    const sizeValue = Number.isFinite(comp.propertySizeSQM)
                        ? comp.propertySizeSQM
                        : Number(base.property_size_sqm);
                    const sizeLabel = Number.isFinite(sizeValue)
                        ? Number(sizeValue).toLocaleString()
                        : 'N/A';
                    const pricePerSqmValue = Number.isFinite(comp.pricePerSQM)
                        ? comp.pricePerSQM
                        : (Number.isFinite(sizeValue) && sizeValue > 0
                            ? priceValue / sizeValue
                            : null);
                    const pricePerSqmLabel = Number.isFinite(pricePerSqmValue)
                        ? formatUGX(pricePerSqmValue)
                        : 'N/A';
                    const distanceLabel = Number.isFinite(comp.distance)
                        ? comp.distance.toFixed(3)
                        : 'N/A';
                    return `
                    <tr>
                        <td>${idx + 1}</td>
                        <td>${formatUGX(priceValue)}</td>
                        <td>${pricePerSqmLabel}</td>
                        <td>${sizeLabel}</td>
                        <td>${distanceLabel}</td>
                        <td>${coordLabel}</td>
                        <td>${base.district || 'N/A'}</td>
                        <td>${base.tenure || 'N/A'}</td>
                        <td>${base.property_type || 'N/A'}</td>
                    </tr>
                `;
                }).join('');

                const comparablesTableBody = comparablesTableRows || `
                <tr>
                    <td colspan="9" style="text-align:center; padding: 18px;">No comparables captured for this valuation.</td>
                </tr>`;

                const comparablesSection = `
                <section class="valuation-report-section">
                    <h3><i class="fas fa-list"></i> Comparable Properties (${comparablesList.length})</h3>
                    <p style="font-size: 0.85rem; color: #5b6b92; margin-bottom: 10px;">
                        This appendix lists the comparables sourced from your private valuation records for this assignment.
                    </p>
                    <div class="valuation-table-scroll">
                        <table class="valuation-report-table valuation-report-table--compact">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Price (UGX)</th>
                                    <th>Price/SQM</th>
                                    <th>Size (sqm)</th>
                                    <th>Distance (km)</th>
                                    <th>Coordinates</th>
                                    <th>District</th>
                                    <th>Tenure</th>
                                    <th>Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${comparablesTableBody}
                            </tbody>
                        </table>
                    </div>
                </section>`;

                const templateSelector = `
                <div class="report-template-selector">
                    <label for="reportTemplateSelect"><i class="fas fa-palette"></i> Report template</label>
                    <select id="reportTemplateSelect">
                        <option value="summary">Summary letter</option>
                        <option value="detailed">Detailed valuation report</option>
                        <option value="comparables">Comparables appendix</option>
                    </select>
                </div>`;

                const sections = [];
                if (template === 'summary') {
                    sections.push(summarySection, detailsSection);
                } else if (template === 'comparables') {
                    sections.push(summarySection, statsSection, riskSection, summaryInsightsSection, notesSection, comparablesSection, chartsSection);
                } else {
                    sections.push(summarySection, detailsSection, statsSection, riskSection, summaryInsightsSection, notesSection, chartsSection, comparablesSection);
                }

                reportDiv.innerHTML = templateSelector + sections.join('');
                const templateSelect = document.getElementById('reportTemplateSelect');
                if (templateSelect) {
                    templateSelect.value = template;
                    templateSelect.addEventListener('change', (event) => {
                        valuationState.reportTemplate = event.target.value;
                        generateValuationReportHTML(reportData, valuationState.reportTemplate, { notify: false });
                    });
                }

                if (template === 'summary') {
                    if (valuationState.charts) {
                        valuationState.charts.forEach(chart => {
                            if (chart && chart.destroy) chart.destroy();
                        });
                        valuationState.charts = [];
                    }
                } else {
                    setTimeout(() => {
                        createValuationCharts(reportData);
                    }, 100);
                }

                // Scroll to report
                reportContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

                if (notify) {
                    showToast('Valuation report generated successfully!', 'success');
                }
            }

            function displayAutoValuationInsights(reportData) {
                const insightsBox = document.getElementById('autoValueInsightsBox');
                const insightsContent = document.getElementById('autoValueInsightsContent');
                if (!insightsBox || !insightsContent) return;
                const comparables = reportData?.comparables || [];
                if (!comparables.length) {
                    insightsBox.style.display = 'none';
                    insightsContent.innerHTML = '';
                    return;
                }

                const prices = comparables.map(c => c.price).sort((a, b) => a - b);
                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);
                const stats = reportData.statistics || {};
                const medianPrice = stats.medianPrice || prices[Math.floor(prices.length / 2)];
                const stdDev = stats.stdDev || 0;
                const recommendedLow = Math.max(minPrice, medianPrice - stdDev);
                const recommendedHigh = Math.min(maxPrice, medianPrice + stdDev);
                const avgPricePerSqm = stats.avgPricePerSQM || 0;
                const weightedPricePerSqm = stats.weightedAvgPricePerSQM || avgPricePerSqm || 0;
                const confidence = reportData.confidence || 0;
                const confidenceLabel = confidence >= 70 ? 'High' : confidence >= 40 ? 'Moderate' : 'Indicative';

                insightsContent.innerHTML = `
                <p style="margin-bottom: 12px;">
                    These insights summarise comparable activity in ${reportData.formData.district}, without revealing individual valuer records.
                </p>
                <ul style="margin-left: 18px; line-height: 1.5;">
                    <li>Median comparable price: <strong>${formatUGX(medianPrice)}</strong></li>
                    <li>Suggested valuation band: <strong>${formatUGX(recommendedLow)}</strong> – <strong>${formatUGX(recommendedHigh)}</strong> (based on current confidence level)</li>
                    <li>Price per sqm (average / weighted): <strong>${formatUGX(avgPricePerSqm)}</strong> / <strong>${formatUGX(weightedPricePerSqm)}</strong></li>
                    <li>Observed range among ${comparables.length} comparables: <strong>${formatUGX(minPrice)}</strong> – <strong>${formatUGX(maxPrice)}</strong></li>
                    <li>Confidence appraisal: <strong>${confidenceLabel}</strong> (${confidence}%)</li>
                </ul>
                <p style="font-size: 0.85rem; color: #555;">
                    Use these metrics to sanity-check your valuation judgement. Review individual comparables and field notes before finalising the reported value.
                </p>
            `;

                insightsBox.style.display = 'block';
            }

            // Create Chart.js charts for the valuation report
            function createValuationCharts(reportData) {
                if (valuationState.reportTemplate === 'summary') {
                    if (valuationState.charts) {
                        valuationState.charts.forEach(chart => {
                            if (chart && chart.destroy) chart.destroy();
                        });
                    }
                    valuationState.charts = [];
                    return;
                }

                if (valuationState.charts) {
                    valuationState.charts.forEach(chart => {
                        if (chart && chart.destroy) chart.destroy();
                    });
                }
                valuationState.charts = [];

                const subjectPrice = Number(reportData.estimatedPrice);
                const upscaleCanvas = (canvas, fallbackWidth = 900, fallbackHeight = 360) => {
                    if (!canvas) return;
                    const dpr = window.devicePixelRatio || 1;
                    const displayWidth = canvas.clientWidth || fallbackWidth;
                    const displayHeight = canvas.clientHeight || fallbackHeight;
                    canvas.width = displayWidth * dpr;
                    canvas.height = displayHeight * dpr;
                };

                const createSubjectPricePlugin = (priceValue) => ({
                    id: 'subjectPriceMarker',
                    afterDraw: (chart) => {
                        if (!Number.isFinite(priceValue)) return;
                        const { ctx, chartArea, scales } = chart;
                        const xScale = scales.x;
                        if (!xScale) return;
                        const x = xScale.getPixelForValue(priceValue);
                        if (x < chartArea.left || x > chartArea.right) return;
                        ctx.save();
                        ctx.strokeStyle = '#facc15';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 4]);
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#facc15';
                        ctx.font = '12px "Inter", "Arial", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('Subject value', x, chartArea.top - 6);
                        ctx.restore();
                    }
                });

                const priceDistCanvas = document.getElementById('priceDistributionChart');
                if (priceDistCanvas && typeof Chart !== 'undefined') {
                    const prices = reportData.comparables
                        .map(c => Number(c.price))
                        .filter(price => Number.isFinite(price));

                    if (prices.length) {
                        const ctx = priceDistCanvas.getContext('2d');
                        upscaleCanvas(priceDistCanvas);

                        const minPrice = Math.min(...prices);
                        const maxPrice = Math.max(...prices);
                        const binCount = Math.min(12, Math.max(6, Math.ceil(Math.sqrt(prices.length))));
                        const rawBinSize = (maxPrice - minPrice) / binCount;
                        const binSize = rawBinSize > 0 ? rawBinSize : Math.max(1, maxPrice || 1);

                        const bins = Array.from({ length: binCount }, (_, idx) => ({
                            start: minPrice + idx * binSize,
                            end: minPrice + (idx + 1) * binSize,
                            count: 0
                        }));

                        prices.forEach(price => {
                            const binIndex = Math.min(
                                Math.floor((price - minPrice) / binSize),
                                binCount - 1
                            );
                            bins[binIndex].count += 1;
                        });

                        const histogramData = bins.map(bin => ({
                            x: Number(bin.start + (bin.end - bin.start) / 2),
                            y: bin.count
                        }));

                        const priceDistChart = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                datasets: [{
                                    label: 'Comparable count',
                                    data: histogramData,
                                    parsing: false,
                                    backgroundColor: 'rgba(52, 152, 219, 0.65)',
                                    borderColor: 'rgba(52, 152, 219, 1)',
                                    borderWidth: 1,
                                    barPercentage: 0.95
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Price Distribution (UGX)'
                                    },
                                    legend: {
                                        display: false
                                    }
                                },
                                scales: {
                                    x: {
                                        type: 'linear',
                                        ticks: {
                                            callback: (value) => formatUGX(value)
                                        },
                                        title: {
                                            display: true,
                                            text: 'Price (UGX)'
                                        }
                                    },
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            stepSize: 1
                                        },
                                        title: {
                                            display: true,
                                            text: 'Count'
                                        }
                                    }
                                }
                            },
                            plugins: Number.isFinite(subjectPrice)
                                ? [createSubjectPricePlugin(subjectPrice)]
                                : []
                        });

                        valuationState.charts.push(priceDistChart);
                    }
                }

                const distancePriceCanvas = document.getElementById('distancePriceChart');
                if (distancePriceCanvas && typeof Chart !== 'undefined') {
                    const ctx = distancePriceCanvas.getContext('2d');
                    const scatterData = reportData.comparables
                        .filter(c => Number.isFinite(c.distance) && Number.isFinite(c.price))
                        .map(c => ({
                            x: Number(c.distance),
                            y: Number(c.price)
                        }));

                    upscaleCanvas(distancePriceCanvas);

                    const datasets = [{
                        label: 'Comparable Properties',
                        data: scatterData,
                        backgroundColor: 'rgba(52, 211, 153, 0.7)',
                        borderColor: 'rgba(5, 150, 105, 1)',
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }];

                    if (Number.isFinite(subjectPrice)) {
                        datasets.push({
                            label: 'Subject Property',
                            data: [{ x: 0, y: subjectPrice }],
                            backgroundColor: '#fbbf24',
                            borderColor: '#92400e',
                            pointRadius: 7,
                            pointHoverRadius: 9,
                            pointStyle: 'triangle'
                        });
                    }

                    const distancePriceChart = new Chart(ctx, {
                        type: 'scatter',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Distance vs Price Relationship'
                                }
                            },
                            elements: {
                                line: {
                                    borderWidth: 0
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Distance (km)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Price (UGX)'
                                    },
                                    ticks: {
                                        callback: function (value) {
                                            return formatUGX(value);
                                        }
                                    }
                                }
                            }
                        }
                    });

                    valuationState.charts.push(distancePriceChart);
                }
            }

            // Auto-save valuation to Supabase
            async function autoSaveValuationToSupabase(reportData) {
                try {
                    const user = await supabase.auth.getUser();
                    if (!user || !user.data || !user.data.user) {
                        showToast('Error: User not authenticated', 'error');
                        return;
                    }

                    const userId = user.data.user.id;
                    const formData = reportData.formData;

                    // Prepare data for Supabase
                    const valuationData = {
                        user_id: userId,
                        location_lon: reportData.location.lon,
                        location_lat: reportData.location.lat,
                        district: formData.district,
                        county: formData.county,
                        village_name: formData.village_name,
                        plot_number: formData.plot_number,
                        block_number: formData.block_number,
                        tenure: formData.tenure,
                        valuation_method: 'Auto-Calculated',
                        price_ugx: reportData.totalValue,
                        land_value_ugx: reportData.landValue,
                        improvements_value_ugx: reportData.improvementsValue,
                        valuation_scope: reportData.valuationScope || 'Land Only',
                        property_type: formData.property_type,
                        property_size_sqm: formData.property_size_sqm,
                        property_size_acres: formData.property_size_acres,
                        number_of_rooms: formData.number_of_rooms,
                        number_of_floors: formData.number_of_floors,
                        property_condition: formData.property_condition,
                        road_access: formData.road_access,
                        zoning: formData.zoning,
                        land_use: formData.land_use,
                        legal_status: formData.legal_status,
                        has_electricity: formData.has_electricity,
                        has_water: formData.has_water,
                        proximity_schools_km: formData.proximity_schools_km,
                        proximity_hospitals_km: formData.proximity_hospitals_km,
                        proximity_markets_km: formData.proximity_markets_km,
                        valuation_date: formData.valuation_date,
                        surveyor_name: formData.surveyor_name,
                        surveyor_id: formData.surveyor_id,
                        notes: formData.notes,
                        is_auto_calculated: true,
                        confidence_level: reportData.confidence
                    };

                    // Use RPC function or direct insert
                    // Try public schema RPC first
                    let insertError = null;

                    // Prepare data with location as POINT for PostGIS
                    const insertPayload = {
                        ...valuationData,
                        location: `POINT(${reportData.location.lon} ${reportData.location.lat})`
                    };

                    // Remove location_lat and location_lon if they exist (use location POINT instead)
                    delete insertPayload.location_lat;
                    delete insertPayload.location_lon;

                    // Try public schema RPC first
                    const { error: publicRpcError } = await supabase.rpc('insert_property_valuation', insertPayload);
                    if (publicRpcError) {
                        console.warn('Public schema RPC auto-save failed:', publicRpcError);
                        // Try direct insert to public schema
                        const { error: publicDirectError } = await supabase
                            .from('property_valuations')
                            .insert([insertPayload])
                            .select();
                        if (publicDirectError) {
                            console.warn('Public schema direct auto-save failed:', publicDirectError);
                            // Try valuer schema as last resort
                            const { error: valuerDirectError } = await supabase
                                .from(VALUER_TABLE)
                                .insert([insertPayload])
                                .select();
                            if (valuerDirectError) {
                                console.warn('Valuer schema direct auto-save failed:', valuerDirectError);
                                insertError = valuerDirectError;
                            }
                        }
                    }

                    if (insertError) {
                        throw insertError;
                    }

                    showToast('Valuation auto-saved to database', 'success');

                } catch (error) {
                    console.error('Error auto-saving valuation:', error);
                    showToast('Warning: Could not auto-save valuation: ' + (error.message || 'Unknown error'), 'warning');
                }
            }

            async function confirmValuationExport(exportType, recordCount) {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Valuation exports are limited to valuer accounts.', 'warning');
                    return false;
                }
                const message = `You are about to export ${recordCount} record(s) as ${exportType}. This action will be logged. Continue?`;
                const confirmed = window.confirm(message);
                if (!confirmed) {
                    showToast('Export cancelled.', 'info');
                }
                return confirmed;
            }

            async function logValuationExport(exportType, details = {}) {
                const logPayload = {
                    export_type: exportType,
                    record_count: details.recordCount ?? null,
                    context: details.context ?? null
                };
                try {
                    await supabase.rpc('valuer_log_export', logPayload);
                } catch (rpcError) {
                    console.warn('Export log RPC failed:', rpcError);
                    try {
                        await supabase
                            .from(`${VALUER_SCHEMA}.export_audit`)
                            .insert([{ ...logPayload, created_at: new Date().toISOString() }]);
                    } catch (tableError) {
                        console.warn('Export audit insert failed:', tableError);
                        try {
                            const existing = JSON.parse(localStorage.getItem('valuationExportAudit') || '[]');
                            existing.push({ ...logPayload, timestamp: new Date().toISOString() });
                            localStorage.setItem('valuationExportAudit', JSON.stringify(existing));
                        } catch (storageError) {
                            console.warn('Local export audit storage failed:', storageError);
                        }
                    }
                }
            }

            // Export valuation report to CSV
            async function exportValuationReportToCSV() {
                if (!valuationState.reportData) {
                    showToast('No report data available', 'error');
                    return;
                }
                const recordCount = valuationState.reportData.comparablesCount || 0;
                const templateName = valuationState.reportTemplate || 'detailed';
                if (!(await confirmValuationExport(`valuation report CSV (${templateName})`, recordCount))) {
                    return;
                }

                const reportData = valuationState.reportData;
                const formData = reportData.formData;
                const branding = formData.branding || {};
                const comparables = reportData.comparables || [];
                const generatedAt = new Date().toLocaleString();

                let csv = 'GSP.NET-Auto Value Report\n';
                csv += `Generated At,${generatedAt}\n`;
                csv += `Valuer,${branding.valuer_name || formData.surveyor_name || 'N/A'}\n`;
                csv += `Client,${branding.client_name || 'Confidential'}\n`;
                csv += `Reference,${branding.reference || 'N/A'}\n\n`;

                csv += 'Property Summary\n';
                csv += 'Field,Value\n';
                csv += `Plot Number,${formData.plot_number || 'N/A'}\n`;
                csv += `Block Number,${formData.block_number || 'N/A'}\n`;
                csv += `District,${formData.district || 'N/A'}\n`;
                csv += `Tenure,${formData.tenure || 'N/A'}\n`;
                csv += `Property Type,${formData.property_type || 'N/A'}\n`;
                csv += `Property Size (sqm),${formData.property_size_sqm || 'N/A'}\n`;
                csv += `Valuation Date,${formData.valuation_date || 'N/A'}\n`;
                csv += `Coordinates,"${reportData.location.lat.toFixed(6)}, ${reportData.location.lon.toFixed(6)}"\n\n`;

                csv += 'Valuation Metrics\n';
                csv += 'Metric,Value\n';
                csv += `Estimated Value (UGX),${reportData.estimatedPrice}\n`;
                csv += `Confidence (%),${reportData.confidence}\n`;
                csv += `Comparables Used,${reportData.comparablesCount}\n`;
                csv += `Search Radius (km),${reportData.radiusKm}\n`;
                csv += `Estimated Price per SQM (UGX),${Math.round(reportData.estimatedPricePerSQM)}\n`;
                csv += `Average Comparable (UGX),${reportData.statistics.avgPrice}\n`;
                csv += `Median Comparable (UGX),${reportData.statistics.medianPrice}\n`;
                csv += `Minimum Comparable (UGX),${reportData.statistics.minPrice}\n`;
                csv += `Maximum Comparable (UGX),${reportData.statistics.maxPrice}\n`;
                csv += `Average Price per SQM (UGX),${reportData.statistics.avgPricePerSQM}\n`;
                csv += `Weighted Price per SQM (UGX),${reportData.statistics.weightedAvgPricePerSQM}\n`;
                csv += `Standard Deviation (UGX),${reportData.statistics.stdDev}\n\n`;

                csv += 'Risk Indicators\n';
                const riskIndicators = reportData.riskIndicators || [];
                if (riskIndicators.length) {
                    riskIndicators.forEach((risk, index) => {
                        csv += `Risk ${index + 1},${risk}\n`;
                    });
                } else {
                    csv += 'Risk 1,None identified\n';
                }
                csv += '\n';

                const summary = reportData.comparableSummary || {};
                csv += 'Comparable Summary\n';
                csv += `Dominant Property Type,${summary.dominantPropertyType || 'N/A'} (${summary.dominantPropertyTypeShare || '0.0'}%)\n`;
                csv += `Dominant Tenure,${summary.dominantTenure || 'N/A'} (${summary.dominantTenureShare || '0.0'}%)\n`;
                csv += `Average Distance (km),${summary.averageDistance || '0.00'}\n`;
                csv += `Median Distance (km),${summary.medianDistance || '0.00'}\n`;
                csv += `Price Range (UGX),${formatUGX(summary.priceRange?.min || 0)} - ${formatUGX(summary.priceRange?.max || 0)}\n`;
                csv += `Recent Comparables (≤180 days),${summary.recentComparables || 0}\n\n`;

                csv += 'Valuation Notes\n';
                const valuationNotes = reportData.valuationNotes || [];
                if (valuationNotes.length) {
                    valuationNotes.forEach((note, index) => {
                        csv += `Note ${index + 1},${note}\n`;
                    });
                } else {
                    csv += 'Note 1,No additional notes captured\n';
                }
                csv += '\n';

                csv += 'Comparable Properties\n';
                csv += 'Index,Distance (km),Price (UGX),Price/SQM,Size (sqm),District,Tenure,Property Type,Valuation Method,Plot,Block\n';
                comparables.forEach((comp, index) => {
                    const base = comp.prop || {};
                    const size = comp.propertySizeSQM || base.property_size_sqm || '';
                    const priceValue = comp.price ?? base.price_ugx ?? '';
                    const pricePerSqm = comp.pricePerSQM
                        ? Math.round(comp.pricePerSQM)
                        : (size ? Math.round(Number(priceValue) / Number(size)) : '');
                    csv += [
                        index + 1,
                        comp.distance !== undefined ? comp.distance.toFixed(3) : '',
                        priceValue,
                        pricePerSqm,
                        size,
                        base.district || '',
                        base.tenure || '',
                        base.property_type || '',
                        base.valuation_method || '',
                        base.plot_number || '',
                        base.block_number || ''
                    ].join(',') + '\n';
                });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `GSP_NET_AUTO_VALUE_${formData.plot_number || 'report'}_${Date.now()}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showToast('Report exported to CSV successfully', 'success');
                await logValuationExport('valuation_report_csv', {
                    recordCount,
                    context: `valuation-report-${templateName}`
                });
            }

            // Export valuation report to PDF
            async function exportValuationReportToPDF() {
                if (!valuationState.reportData) {
                    showToast('No report data available', 'error');
                    return;
                }
                if (typeof window.jspdf === 'undefined' || typeof window.html2canvas === 'undefined') {
                    showToast('Export libraries not loaded. Please refresh the page.', 'error');
                    return;
                }

                const { jsPDF } = window.jspdf;
                const reportData = valuationState.reportData;
                const formData = reportData.formData;
                const branding = formData.branding || {};
                const comparablesList = Array.isArray(reportData.comparables) ? reportData.comparables : [];
                const recordCount = reportData.comparablesCount || comparablesList.length || 0;
                const templateName = valuationState.reportTemplate || 'detailed';
                if (!(await confirmValuationExport(`valuation report PDF (${templateName})`, recordCount))) {
                    return;
                }

                showToast('Generating PDF...', 'info');

                const doc = new jsPDF('p', 'mm', 'a4');
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 15;
                const generatedLabel = reportData.generatedAt
                    ? new Date(reportData.generatedAt).toLocaleString()
                    : new Date().toLocaleString();
                const clientName = branding.client_name || 'Confidential client';
                const reportReference = branding.reference || 'Unreferenced';
                const valuerName = branding.valuer_name || formData.surveyor_name || 'Valuation team';
                const coordinateDisplay = reportData.location
                    ? `${reportData.location.lat.toFixed(6)}, ${reportData.location.lon.toFixed(6)}`
                    : 'Not captured';
                const valuationDate = formData.valuation_date
                    ? new Date(formData.valuation_date).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' })
                    : 'Not provided';
                const propertySizeSQM = Number(formData.property_size_sqm) || 0;
                const propertySizeDisplay = propertySizeSQM
                    ? `${propertySizeSQM.toLocaleString()} sqm (${(propertySizeSQM / 4046.86).toFixed(4)} acres)`
                    : 'Not provided';

                const formatCurrencySafe = (value) => Number.isFinite(value) ? formatUGX(value) : 'N/A';
                const ensureSpace = (buffer = 0) => {
                    if (yPos + buffer > pageHeight - 20) {
                        doc.addPage();
                        yPos = 20;
                    }
                };
                const writeSectionTitle = (title, accentColor = [26, 42, 108]) => {
                    ensureSpace(12);
                    // Light background bar
                    doc.setFillColor(245, 247, 250);
                    doc.rect(margin - 2, yPos - 3, pageWidth - (margin * 2) + 4, 8, 'F');
                    // Colored accent line
                    doc.setFillColor(...accentColor);
                    doc.rect(margin - 2, yPos - 3, 3, 8, 'F');
                    // Title text - bold and larger
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...accentColor);
                    doc.text(title, margin + 5, yPos + 2);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(10);
                    yPos += 12;
                };
                const writeKeyValueRow = (label, value) => {
                    ensureSpace();
                    doc.setFont('helvetica', 'bold');
                    doc.text(label, margin, yPos);
                    doc.setFont('helvetica', 'normal');
                    const text = doc.splitTextToSize(String(value ?? 'N/A'), pageWidth - (margin + 55));
                    doc.text(text, margin + 55, yPos);
                    yPos += 6 * text.length;
                };
                const writeBulletList = (items) => {
                    if (!items.length) {
                        writeKeyValueRow('•', 'None recorded');
                        return;
                    }
                    items.forEach(item => {
                        ensureSpace();
                        doc.text(`• ${item}`, margin, yPos);
                        yPos += 6;
                    });
                };
                const formatCompactUGX = (value) => {
                    if (!Number.isFinite(value)) return 'N/A';
                    if (Math.abs(value) >= 1e9) return `UGX ${(value / 1e9).toFixed(2)}B`;
                    if (Math.abs(value) >= 1e6) return `UGX ${(value / 1e6).toFixed(2)}M`;
                    if (Math.abs(value) >= 1e3) return `UGX ${(value / 1e3).toFixed(2)}K`;
                    return formatUGX(value);
                };
                const truncateText = (text, maxChars) => {
                    if (!text) return 'N/A';
                    const str = String(text);
                    return str.length > maxChars ? `${str.slice(0, maxChars - 1)}…` : str;
                };

                // Helper function to draw tables with faint borders
                const drawTable = (headers, rows, columnWidths, options = {}) => {
                    const {
                        startX = margin,
                        headerBgColor = [240, 240, 240],
                        borderColor = [180, 180, 180],
                        rowBgColor = [250, 250, 250],
                        rowHeight = 7,
                        headerHeight = 8
                    } = options;

                    const tableWidth = columnWidths.reduce((sum, w) => sum + w, 0);
                    let tableX = startX;
                    let tableY = yPos;

                    ensureSpace(headerHeight + (rows.length * rowHeight) + 5);

                    // Draw header row with faint background
                    doc.setFillColor(...headerBgColor);
                    doc.rect(tableX, tableY, tableWidth, headerHeight, 'F');

                    // Draw header borders
                    doc.setDrawColor(...borderColor);
                    doc.setLineWidth(0.1);
                    doc.rect(tableX, tableY, tableWidth, headerHeight);

                    // Draw header text
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.setTextColor(0, 0, 0);
                    let xPos = tableX + 2;
                    headers.forEach((header, idx) => {
                        const headerText = truncateText(header, Math.floor(columnWidths[idx] / 2));
                        doc.text(headerText, xPos, tableY + 5);
                        // Draw vertical line between columns
                        if (idx < headers.length - 1) {
                            doc.line(xPos + columnWidths[idx], tableY, xPos + columnWidths[idx], tableY + headerHeight);
                        }
                        xPos += columnWidths[idx];
                    });

                    // Draw data rows
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(8);
                    tableY += headerHeight;

                    rows.forEach((row, rowIdx) => {
                        // Check if we need a new page
                        if (tableY + rowHeight > pageHeight - 30) {
                            doc.addPage();
                            tableY = 20;
                            // Redraw header on new page
                            doc.setFillColor(...headerBgColor);
                            doc.rect(tableX, tableY, tableWidth, headerHeight, 'F');
                            doc.setDrawColor(...borderColor);
                            doc.rect(tableX, tableY, tableWidth, headerHeight);
                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(9);
                            xPos = tableX + 2;
                            headers.forEach((header, idx) => {
                                const headerText = truncateText(header, Math.floor(columnWidths[idx] / 2));
                                doc.text(headerText, xPos, tableY + 5);
                                if (idx < headers.length - 1) {
                                    doc.line(xPos + columnWidths[idx], tableY, xPos + columnWidths[idx], tableY + headerHeight);
                                }
                                xPos += columnWidths[idx];
                            });
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(8);
                            tableY += headerHeight;
                        }

                        // Draw row border
                        doc.setDrawColor(200, 200, 200); // Even fainter for data rows
                        doc.rect(tableX, tableY, tableWidth, rowHeight);

                        // Alternate row background for better readability
                        if (rowIdx % 2 === 0) {
                            doc.setFillColor(...rowBgColor);
                            doc.rect(tableX, tableY, tableWidth, rowHeight, 'F');
                        }

                        // Draw row data
                        xPos = tableX + 2;
                        row.forEach((cell, colIdx) => {
                            const cellText = truncateText(String(cell ?? 'N/A'), Math.floor(columnWidths[colIdx] / 2));
                            doc.text(cellText, xPos, tableY + 5);
                            // Draw vertical line between columns
                            if (colIdx < row.length - 1) {
                                doc.line(xPos + columnWidths[colIdx], tableY, xPos + columnWidths[colIdx], tableY + rowHeight);
                            }
                            xPos += columnWidths[colIdx];
                        });

                        tableY += rowHeight;
                    });

                    yPos = tableY + 5;
                };

                // Helper function for high-resolution chart rendering
                const renderChartForPDF = async (canvasId, title, scaleFactor = 2.5) => {
                    const canvas = document.getElementById(canvasId);
                    if (!canvas) {
                        console.warn(`Chart canvas ${canvasId} not found`);
                        return false;
                    }

                    try {
                        // Wait a bit to ensure chart is fully rendered
                        await new Promise(resolve => setTimeout(resolve, 300));

                        // Get the Chart.js instance (works with Chart.js v3+)
                        let chartInstance = null;
                        if (typeof Chart !== 'undefined' && Chart.getChart) {
                            chartInstance = Chart.getChart(canvas);
                        } else if (canvas.chart) {
                            // Fallback for older Chart.js versions
                            chartInstance = canvas.chart;
                        }

                        // Even without chart instance, we can still export the canvas
                        // The chart should already be rendered on the canvas

                        // Create a temporary high-resolution canvas
                        const tempCanvas = document.createElement('canvas');
                        const originalWidth = canvas.width;
                        const originalHeight = canvas.height;
                        tempCanvas.width = originalWidth * scaleFactor;
                        tempCanvas.height = originalHeight * scaleFactor;
                        const tempCtx = tempCanvas.getContext('2d');

                        // Scale up the context
                        tempCtx.scale(scaleFactor, scaleFactor);

                        // Draw the original canvas to the temp canvas
                        tempCtx.drawImage(canvas, 0, 0);

                        // Export as high-resolution image
                        const chartImage = tempCanvas.toDataURL('image/png', 1.0);

                        // Add to PDF
                        doc.addPage();
                        yPos = 20; // Reset to top of page
                        writeSectionTitle(title);
                        yPos += 3; // Small gap after title

                        const availableWidth = pageWidth - margin * 2;
                        const availableHeight = pageHeight - yPos - 30; // Leave space for footer
                        const ratio = Math.min(availableWidth / tempCanvas.width, availableHeight / tempCanvas.height);
                        const imgWidth = tempCanvas.width * ratio;
                        const imgHeight = tempCanvas.height * ratio;
                        const imgX = (pageWidth - imgWidth) / 2; // Center horizontally
                        const imgY = yPos;

                        doc.addImage(chartImage, 'PNG', imgX, imgY, imgWidth, imgHeight, undefined, 'FAST');
                        yPos += imgHeight + 10;

                        return true;
                    } catch (error) {
                        console.warn(`Failed to render ${title} chart for PDF:`, error);
                        // Fallback to original method
                        const fallbackCanvas = document.getElementById(canvasId);
                        if (fallbackCanvas) {
                            try {
                                const chartImage = fallbackCanvas.toDataURL('image/png', 1.0);
                                doc.addPage();
                                yPos = 20; // Reset to top of page
                                writeSectionTitle(title);
                                yPos += 3; // Small gap after title
                                const availableWidth = pageWidth - margin * 2;
                                const availableHeight = pageHeight - yPos - 30;
                                const ratio = Math.min(availableWidth / fallbackCanvas.width, availableHeight / fallbackCanvas.height);
                                const imgWidth = fallbackCanvas.width * ratio;
                                const imgHeight = fallbackCanvas.height * ratio;
                                const imgX = (pageWidth - imgWidth) / 2; // Center horizontally
                                const imgY = yPos;
                                doc.addImage(chartImage, 'PNG', imgX, imgY, imgWidth, imgHeight, undefined, 'FAST');
                                yPos += imgHeight + 10;
                                return true;
                            } catch (fallbackError) {
                                console.warn(`Fallback chart export also failed:`, fallbackError);
                            }
                        }
                        doc.addPage();
                        yPos = 20; // Reset to top of page
                        writeSectionTitle(title);
                        doc.setFontSize(10);
                        doc.text(`${title} chart unavailable.`, margin, yPos);
                        yPos += 10;
                        return false;
                    }
                };

                // Note: addPageNumberAndFooter is now integrated directly into the main export flow

                // Helper function to add signature section
                const addSignatureSection = (pageNum) => {
                    const signatureY = pageHeight - 20; // Position above footer

                    doc.setFontSize(8);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont('helvetica', 'normal');
                    doc.text('Prepared by:', margin, signatureY);

                    // Signature line for valuer name
                    doc.setDrawColor(150, 150, 150);
                    doc.setLineWidth(0.2);
                    doc.line(margin + 25, signatureY + 2, margin + 75, signatureY + 2);

                    doc.text('Date:', margin + 90, signatureY);
                    // Date line
                    doc.line(margin + 100, signatureY + 2, margin + 150, signatureY + 2);
                };

                doc.setFillColor(26, 42, 108);
                doc.roundedRect(10, 10, pageWidth - 20, 32, 4, 4, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(16);
                doc.text('Property Valuation Report', pageWidth / 2, 22, { align: 'center' });
                doc.setFontSize(12);
                doc.text(`${formatUGX(reportData.estimatedPrice)} • ${reportData.confidence}% confidence`, pageWidth / 2, 30, { align: 'center' });
                doc.setFontSize(10);
                doc.text(`${clientName} • Ref ${reportReference} • Generated ${generatedLabel}`, pageWidth / 2, 36, { align: 'center' });
                doc.setTextColor(0, 0, 0);
                doc.setFont('helvetica', 'normal');

                let yPos = 52;

                writeSectionTitle('Property Profile');
                [
                    ['District', formData.district || 'N/A'],
                    ['Tenure', formData.tenure || 'N/A'],
                    ['Property Type', formData.property_type || 'N/A'],
                    ['Property Size', propertySizeDisplay],
                    ['Coordinates', coordinateDisplay],
                    ['Valuation Date', valuationDate]
                ].forEach(([label, value]) => writeKeyValueRow(label, value));

                writeSectionTitle('Client & Assignment');
                [
                    ['Client / Institution', clientName],
                    ['Reference', reportReference],
                    ['Prepared By', valuerName],
                    ['Surveyor', formData.surveyor_name || 'Not provided'],
                    ['Survey Notes', formData.notes || 'No additional notes recorded.']
                ].forEach(([label, value]) => writeKeyValueRow(label, value));

                const stats = reportData.statistics || {};
                writeSectionTitle('Key Metrics');
                const keyMetricsHeaders = ['Metric', 'Value'];
                const keyMetricsRows = [
                    ['Estimated Value (UGX)', formatCurrencySafe(reportData.estimatedPrice)],
                    ['Price per SQM (UGX)', formatCurrencySafe(reportData.estimatedPricePerSQM)],
                    ['Weighted Price per SQM (UGX)', formatCurrencySafe(stats.weightedAvgPricePerSQM)],
                    ['Average Comparable (UGX)', formatCurrencySafe(stats.avgPrice)],
                    ['Median Comparable (UGX)', formatCurrencySafe(stats.medianPrice)],
                    ['Minimum Comparable (UGX)', formatCurrencySafe(stats.minPrice)],
                    ['Maximum Comparable (UGX)', formatCurrencySafe(stats.maxPrice)],
                    ['Standard Deviation (UGX)', formatCurrencySafe(stats.stdDev)],
                    ['Comparables Used', reportData.comparablesCount || comparablesList.length || 'N/A'],
                    ['Search Radius (km)', reportData.radiusKm || 'N/A']
                ];
                drawTable(keyMetricsHeaders, keyMetricsRows, [90, 95]);

                const riskIndicators = reportData.riskIndicators || [];
                writeSectionTitle('Risk Indicators');
                writeBulletList(riskIndicators);

                const valuationNotes = reportData.valuationNotes || [];
                writeSectionTitle('Valuation Notes');
                writeBulletList(valuationNotes);

                const summary = reportData.comparableSummary || {};
                writeSectionTitle('Comparable Summary');
                const summaryHeaders = ['Attribute', 'Value'];
                const summaryRows = [
                    ['Dominant Property Type', summary.dominantPropertyType ? `${summary.dominantPropertyType} (${summary.dominantPropertyTypeShare || '0.0'}%)` : 'N/A'],
                    ['Dominant Tenure', summary.dominantTenure ? `${summary.dominantTenure} (${summary.dominantTenureShare || '0.0'}%)` : 'N/A'],
                    ['Average Distance (km)', summary.averageDistance || '0.00'],
                    ['Median Distance (km)', summary.medianDistance || '0.00'],
                    ['Price Range', `${formatUGX(summary.priceRange?.min || 0)} – ${formatUGX(summary.priceRange?.max || 0)}`],
                    ['Recent Comparables (≤180 days)', summary.recentComparables || 0]
                ];
                drawTable(summaryHeaders, summaryRows, [90, 95]);

                writeSectionTitle('Comparable Properties');
                const comparablesRowsData = comparablesList.map((comp, idx) => {
                    const base = comp.prop || {};
                    const coords = getPropertyCoordinates(base);
                    const coordLabel = coords ? `${coords.lat.toFixed(5)}, ${coords.lon.toFixed(5)}` : 'N/A';
                    const priceValue = comp.price ?? base.price_ugx ?? 0;
                    const sizeValue = Number.isFinite(comp.propertySizeSQM)
                        ? comp.propertySizeSQM
                        : Number(base.property_size_sqm);
                    const sizeLabel = Number.isFinite(sizeValue) ? Number(sizeValue).toLocaleString() : 'N/A';
                    const pricePerSqmValue = Number.isFinite(comp.pricePerSQM)
                        ? comp.pricePerSQM
                        : (Number.isFinite(sizeValue) && sizeValue > 0 ? priceValue / sizeValue : null);
                    const pricePerSqmLabel = Number.isFinite(pricePerSqmValue) ? formatCompactUGX(pricePerSqmValue) : 'N/A';
                    const distanceLabel = Number.isFinite(comp.distance) ? comp.distance.toFixed(3) : 'N/A';
                    return [
                        `${idx + 1}`,
                        formatCompactUGX(priceValue),
                        pricePerSqmLabel,
                        sizeLabel,
                        distanceLabel,
                        coordLabel,
                        base.district || 'N/A',
                        base.tenure || 'N/A'
                    ];
                });

                if (!comparablesRowsData.length) {
                    doc.text('No comparables captured for this valuation.', margin, yPos);
                    yPos += 6;
                } else {
                    const headers = ['#', 'Price', 'Price/SQM', 'Size', 'Dist (km)', 'Coords', 'District', 'Tenure'];
                    const columnWidths = [8, 28, 28, 20, 20, 45, 25, 25];
                    drawTable(headers, comparablesRowsData, columnWidths);
                }

                // Export charts with high resolution
                await renderChartForPDF('priceDistributionChart', 'Price Distribution');
                await renderChartForPDF('distancePriceChart', 'Distance vs Price');

                // Add page numbers, footer, and signature to all pages
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    // Footer text
                    doc.setFontSize(9);
                    doc.setTextColor(100, 100, 100);
                    doc.text('Generated by Auto-Valuation System of GSP.NET UG', pageWidth / 2, pageHeight - 10, { align: 'center' });
                    // Page number
                    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
                    // Signature section (on every page, positioned above footer)
                    addSignatureSection(i);
                }

                const filename = `GSP.NET-AUTO_VALUE_${formData.plot_number || 'report'}_${Date.now()}.pdf`;
                doc.save(filename);

                showToast('PDF exported successfully', 'success');
                await logValuationExport('valuation_report_pdf', {
                    recordCount,
                    context: 'valuation-report-gspnet-auto'
                });
            }

            // Close valuation report
            function closeValuationReport() {
                const reportContainer = document.getElementById('autoValueReportContainer');
                if (reportContainer) reportContainer.style.display = 'none';

                // Destroy charts
                if (valuationState.charts) {
                    valuationState.charts.forEach(chart => {
                        if (chart && chart.destroy) chart.destroy();
                    });
                    valuationState.charts = null;
                }

                // Clear report data
                valuationState.reportData = null;
            }

            // Get confidence class
            function getConfidenceClass(confidence) {
                if (confidence >= 70) return 'confidence-high';
                if (confidence >= 40) return 'confidence-medium';
                return 'confidence-low';
            }

            // Cancel auto-valuation
            function cancelAutoValuation() {
                // Remove pin from map
                if (currentValuationPin && valuationMarkersSource) {
                    valuationMarkersSource.removeFeature(currentValuationPin);
                    currentValuationPin = null;
                }

                // Hide form and report containers
                const formContainer = document.getElementById('autoValueFormContainer');
                const reportContainer = document.getElementById('autoValueReportContainer');
                if (formContainer) formContainer.style.display = 'none';
                if (reportContainer) reportContainer.style.display = 'none';
                const insightsBox = document.getElementById('autoValueInsightsBox');
                const insightsContent = document.getElementById('autoValueInsightsContent');
                if (insightsBox) insightsBox.style.display = 'none';
                if (insightsContent) insightsContent.innerHTML = '';

                // Reset button text
                const btn = document.getElementById('startAutoValueBtn');
                if (btn) {
                    btn.innerHTML = '<i class="fas fa-calculator"></i> Start Auto-Valuation';
                    btn.disabled = false;
                }

                // Clear state
                valuationState.autoValueData = null;
                valuationState.reportData = null;
                valuationState.filteredComparables = [];
                valuationState.selectedComparables.clear();
                valuationState.enableComparableMapSelect = false;
                valuationState.lastComparableFilters = null;
                selectedValuationCoordinate = null;

                if (valuationMarkersSource) {
                    const comparableFeatures = valuationMarkersSource.getFeatures().filter(f =>
                        f.get('type') === 'auto-value-comparable'
                    );
                    comparableFeatures.forEach(f => valuationMarkersSource.removeFeature(f));
                }
                comparableFeatureIndex.clear();
                if (comparableSelectionListener) {
                    ol.Observable.unByKey(comparableSelectionListener);
                    comparableSelectionListener = null;
                }
                const mapSelectBtn = document.getElementById('toggleComparableMapSelectBtn');
                if (mapSelectBtn) {
                    mapSelectBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Enable Map Selection';
                    mapSelectBtn.classList.remove('active');
                }

                // Destroy charts if any
                if (valuationState.charts) {
                    valuationState.charts.forEach(chart => {
                        if (chart && chart.destroy) chart.destroy();
                    });
                    valuationState.charts = null;
                }

                // Cancel click listener
                if (valuationClickListener) {
                    ol.Observable.unByKey(valuationClickListener);
                    valuationClickListener = null;
                }
            }

            // Save auto-valuation to Supabase
            async function saveAutoValuationToSupabase() {
                if (!valuationState.autoValueData || !selectedValuationCoordinate) {
                    showToast('No auto-valuation data to save', 'error');
                    return;
                }

                try {
                    await autoSaveValuationToSupabase();
                    showToast('Auto-valuation saved successfully!', 'success');
                } catch (error) {
                    console.error('Error saving auto-valuation:', error);
                    showToast('Error saving valuation: ' + (error.message || 'Unknown error'), 'error');
                }
            }

            // Village autocomplete functionality
            let villageAutocompleteCache = {};

            async function initializeVillageAutocomplete() {
                const villageInput = document.getElementById('propertyVillage');
                const autoValueVillageInput = document.getElementById('autoValueVillage');

                [villageInput, autoValueVillageInput].forEach(input => {
                    if (!input) return;

                    let autocompleteContainer = null;
                    let currentSuggestions = [];
                    let selectedIndex = -1;

                    input.addEventListener('input', async function (e) {
                        const searchTerm = this.value.trim();
                        const district = document.getElementById('propertyDistrict')?.value ||
                            document.getElementById('autoValueDistrict')?.value;
                        const county = document.getElementById('propertyCounty')?.value ||
                            document.getElementById('autoValueCounty')?.value;

                        if (searchTerm.length < 2) {
                            hideAutocomplete();
                            return;
                        }

                        // Check cache
                        const cacheKey = `${district || 'all'}_${county || 'all'}_${searchTerm.toLowerCase()}`;
                        if (villageAutocompleteCache[cacheKey]) {
                            showAutocompleteSuggestions(villageAutocompleteCache[cacheKey], this);
                            return;
                        }

                        // Fetch from database
                        try {
                            const { data, error } = await supabase.rpc('search_villages', {
                                p_district: district || null,
                                p_county: county || null,
                                p_search_term: searchTerm,
                                p_limit: 10
                            });

                            if (error) throw error;

                            const suggestions = (data || []).map(v => ({
                                district: v.district,
                                county: v.county,
                                village: v.village_name,
                                usage: v.usage_count
                            }));

                            villageAutocompleteCache[cacheKey] = suggestions;
                            showAutocompleteSuggestions(suggestions, this);
                        } catch (error) {
                            console.error('Village autocomplete error:', error);
                        }
                    });

                    input.addEventListener('keydown', function (e) {
                        if (!autocompleteContainer || autocompleteContainer.style.display === 'none') return;

                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            selectedIndex = Math.min(selectedIndex + 1, currentSuggestions.length - 1);
                            updateAutocompleteSelection();
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            selectedIndex = Math.max(selectedIndex - 1, -1);
                            updateAutocompleteSelection();
                        } else if (e.key === 'Enter' && selectedIndex >= 0) {
                            e.preventDefault();
                            selectAutocompleteSuggestion(currentSuggestions[selectedIndex]);
                        } else if (e.key === 'Escape') {
                            hideAutocomplete();
                        }
                    });

                    function showAutocompleteSuggestions(suggestions, inputElement) {
                        currentSuggestions = suggestions;
                        selectedIndex = -1;

                        if (!autocompleteContainer) {
                            autocompleteContainer = document.createElement('div');
                            autocompleteContainer.className = 'village-autocomplete';
                            autocompleteContainer.style.cssText = `
                            position: absolute;
                            background: white;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                            max-height: 200px;
                            overflow-y: auto;
                            z-index: 10000;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                            display: none;
                        `;
                            document.body.appendChild(autocompleteContainer);
                        }

                        if (suggestions.length === 0) {
                            autocompleteContainer.innerHTML = '<div style="padding: 10px; color: #999;">No villages found</div>';
                        } else {
                            autocompleteContainer.innerHTML = suggestions.map((s, idx) => `
                            <div class="autocomplete-item" data-index="${idx}" style="
                                padding: 10px;
                                cursor: pointer;
                                border-bottom: 1px solid #f0f0f0;
                            ">
                                <strong>${s.village}</strong>
                                <div style="font-size: 0.85em; color: #666; margin-top: 2px;">
                                    ${s.county ? s.county + ', ' : ''}${s.district}
                                    ${s.usage > 0 ? ` · Used ${s.usage} time(s)` : ''}
                                </div>
                            </div>
                        `).join('');

                            // Add click handlers
                            autocompleteContainer.querySelectorAll('.autocomplete-item').forEach((item, idx) => {
                                item.addEventListener('click', () => {
                                    selectAutocompleteSuggestion(suggestions[idx]);
                                });
                                item.addEventListener('mouseenter', () => {
                                    selectedIndex = idx;
                                    updateAutocompleteSelection();
                                });
                            });
                        }

                        // Position container
                        const rect = inputElement.getBoundingClientRect();
                        autocompleteContainer.style.top = (rect.bottom + window.scrollY) + 'px';
                        autocompleteContainer.style.left = (rect.left + window.scrollX) + 'px';
                        autocompleteContainer.style.width = rect.width + 'px';
                        autocompleteContainer.style.display = 'block';
                    }

                    function updateAutocompleteSelection() {
                        const items = autocompleteContainer.querySelectorAll('.autocomplete-item');
                        items.forEach((item, idx) => {
                            if (idx === selectedIndex) {
                                item.style.backgroundColor = '#e3f2fd';
                            } else {
                                item.style.backgroundColor = 'white';
                            }
                        });
                    }

                    function selectAutocompleteSuggestion(suggestion) {
                        input.value = suggestion.village;

                        // Auto-fill county if empty
                        const countyInput = document.getElementById('propertyCounty') ||
                            document.getElementById('autoValueCounty');
                        if (countyInput && !countyInput.value && suggestion.county) {
                            countyInput.value = suggestion.county;
                        }

                        hideAutocomplete();
                        input.dispatchEvent(new Event('change'));
                    }

                    function hideAutocomplete() {
                        if (autocompleteContainer) {
                            autocompleteContainer.style.display = 'none';
                        }
                        selectedIndex = -1;
                    }

                    // Hide on outside click
                    document.addEventListener('click', (e) => {
                        if (!input.contains(e.target) &&
                            (!autocompleteContainer || !autocompleteContainer.contains(e.target))) {
                            hideAutocomplete();
                        }
                    });
                });
            }

            // Tool 3: Load district properties
            async function loadDistrictProperties() {
                if (window.__valuationFeaturesEnabled !== true) {
                    showToast('Valuation tools are available for valuer accounts only.', 'warning');
                    return;
                }
                const userId = await ensureValuationUserId();
                if (!userId) {
                    showToast('Unable to load properties: valuer identity missing.', 'error');
                    return;
                }
                const district = document.getElementById('viewDistrict').value;
                const county = document.getElementById('viewCounty')?.value || '';
                const village = document.getElementById('viewVillage')?.value || '';
                const propertyType = document.getElementById('viewPropertyType').value;
                const priceMin = parseFloat(document.getElementById('viewPriceMin').value) || null;
                const priceMax = parseFloat(document.getElementById('viewPriceMax').value) || null;
                const valuationMethod = document.getElementById('viewValuationMethod').value;
                const tenure = document.getElementById('viewTenure').value;
                const filters = {
                    district,
                    county: county || null,
                    village_name: village || null,
                    property_type: propertyType,
                    tenure,
                    valuation_method: valuationMethod,
                    price_min: priceMin || null,
                    price_max: priceMax || null
                };

                showToast('Loading properties...', 'info');

                try {
                    let effectiveProperties = [];
                    const { data: valuerProperties, error } = await applyFiltersToBuilder(
                        supabase.from(VALUER_TABLE).select('*'),
                        filters,
                        userId
                    );

                    if (!error && Array.isArray(valuerProperties)) {
                        effectiveProperties = valuerProperties;
                    } else {
                        if (error) {
                            console.warn('Valuer schema district query failed:', error);
                        }
                        const { data: legacyProperties, error: legacyError } = await applyFiltersToBuilder(
                            supabase.from('property_valuations').select('*'),
                            filters,
                            userId
                        );
                        if (legacyError) {
                            throw legacyError;
                        }
                        effectiveProperties = Array.isArray(legacyProperties) ? legacyProperties : [];
                    }

                    const listElement = document.getElementById('viewPropertiesList');
                    const exportBtn = document.getElementById('exportPropertiesBtn');

                    if (!effectiveProperties.length) {
                        showToast('No properties found matching criteria', 'info');
                        if (listElement) listElement.style.display = 'none';
                        if (exportBtn) exportBtn.style.display = 'none';
                        return;
                    }

                    // Ensure valuation source is initialized
                    initializeValuationLayer();

                    if (!valuationMarkersSource) {
                        showToast('Error: Unable to initialize map layer. Please try again.', 'error');
                        return;
                    }

                    // Clear existing markers
                    const features = valuationMarkersSource.getFeatures().filter(f =>
                        f.get('type') === 'property-view' || f.get('type') === 'property-valuation'
                    );
                    features.forEach(f => valuationMarkersSource.removeFeature(f));

                    // Add markers for each property
                    effectiveProperties.forEach(prop => {
                        const coords = getPropertyCoordinates(prop);
                        if (!coords) return;

                        const coord = ol.proj.transform([coords.lon, coords.lat], 'EPSG:4326', 'EPSG:3857');
                        const marker = new ol.Feature({
                            geometry: new ol.geom.Point(coord),
                            type: 'property-view',
                            propertyData: prop
                        });

                        valuationMarkersSource.addFeature(marker);
                    });

                    // Zoom to properties
                    if (effectiveProperties.length > 0 && valuationMarkersSource.getFeatures().length > 0) {
                        const extent = valuationMarkersSource.getExtent();
                        map.getView().fit(extent, { padding: [50, 50, 50, 50], maxZoom: 15 });
                    }

                    // Store properties for CSV export
                    loadedPropertiesForExport = effectiveProperties;

                    // Display list
                    displayPropertiesList(effectiveProperties);
                    if (exportBtn) exportBtn.style.display = 'block';

                    showToast(`Loaded ${effectiveProperties.length} property(ies)`, 'success');

                } catch (error) {
                    console.error('Error loading properties:', error);
                    showToast('Error loading properties: ' + (error.message || 'Unknown error'), 'error');
                }
            }

            // Display properties list
            function displayPropertiesList(properties) {
                const listContainer = document.getElementById('viewPropertiesList');
                if (!listContainer) return;

                if (properties.length === 0) {
                    listContainer.innerHTML = '<p>No properties found</p>';
                    listContainer.style.display = 'block';
                    return;
                }

                const listHTML = properties.map((prop, index) => `
                <div class="valuation-property-item" data-index="${index}">
                    <div class="valuation-property-price">${formatUGX(prop.price_ugx)}</div>
                    <div><strong>Plot:</strong> ${prop.plot_number || 'N/A'} | <strong>Block:</strong> ${prop.block_number || 'N/A'}</div>
                    <div><strong>District:</strong> ${prop.district || 'N/A'} | <strong>Type:</strong> ${prop.property_type || 'N/A'}</div>
                    <div><strong>Date:</strong> ${prop.valuation_date || 'N/A'}</div>
                </div>
            `).join('');

                listContainer.innerHTML = listHTML;
                listContainer.style.display = 'block';

                // Add click handlers
                listContainer.querySelectorAll('.valuation-property-item').forEach((item, index) => {
                    item.addEventListener('click', function () {
                        const prop = properties[index];
                        const coords = getPropertyCoordinates(prop);
                        if (coords) {
                            const coord = ol.proj.transform([coords.lon, coords.lat], 'EPSG:4326', 'EPSG:3857');
                            map.getView().setCenter(coord);
                            map.getView().setZoom(16);
                        }
                    });
                });
            }

            // Export properties to CSV
            async function exportPropertiesToCSV() {
                if (!loadedPropertiesForExport || loadedPropertiesForExport.length === 0) {
                    showToast('No properties loaded to export', 'warning');
                    return;
                }
                const properties = loadedPropertiesForExport;
                if (!(await confirmValuationExport('valuation dataset CSV', properties.length))) {
                    return;
                }

                // Build CSV content
                let csv = 'Property Valuations Export\n';
                csv += `Generated: ${new Date().toLocaleString()}\n`;
                csv += `Total Properties: ${properties.length}\n\n`;

                // CSV Headers
                csv += 'District,Plot Number,Block Number,Tenure,Valuation Method,Price (UGX),Property Type,Size (sqm),Size (acres),Rooms,Floors,Age (years),Condition,Road Access,Zoning,Land Use,Legal Status,Electricity,Water,Schools (km),Hospitals (km),Markets (km),Valuation Date,Surveyor Name,Surveyor ID,Latitude,Longitude,Notes\n';

                // CSV Data
                properties.forEach(prop => {
                    const coords = parseLocation(prop.location);
                    const lat = coords ? coords.lat : '';
                    const lon = coords ? coords.lon : '';

                    csv += `"${prop.district || ''}","${prop.plot_number || ''}","${prop.block_number || ''}",`;
                    csv += `"${prop.tenure || ''}","${prop.valuation_method || ''}",${prop.price_ugx || 0},`;
                    csv += `"${prop.property_type || ''}",${prop.property_size_sqm || 0},${prop.property_size_acres || 0},`;
                    csv += `${prop.number_of_rooms || ''},${prop.number_of_floors || ''},${prop.property_age_years || ''},`;
                    csv += `"${prop.property_condition || ''}","${prop.road_access || ''}","${prop.zoning || ''}",`;
                    csv += `"${prop.land_use || ''}","${prop.legal_status || ''}",${prop.has_electricity ? 'Yes' : 'No'},`;
                    csv += `${prop.has_water ? 'Yes' : 'No'},${prop.proximity_schools_km || ''},`;
                    csv += `${prop.proximity_hospitals_km || ''},${prop.proximity_markets_km || ''},`;
                    csv += `"${prop.valuation_date || ''}","${prop.surveyor_name || ''}","${prop.surveyor_id || ''}",`;
                    csv += `${lat},${lon},"${(prop.notes || '').replace(/"/g, '""')}"\n`; // Escape quotes in notes
                });

                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `property_valuations_export_${Date.now()}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showToast(`Exported ${properties.length} properties to CSV`, 'success');
                await logValuationExport('valuation_dataset_csv', {
                    recordCount: properties.length,
                    context: 'valuation-properties'
                });
            }

            // ========================================
            //  NEW FEATURES JAVASCRIPT FUNCTIONS
            // ========================================

            // Global state for new features
            const featureState = {
                theme: localStorage.getItem('theme') || 'light',
                pinnedMessages: JSON.parse(localStorage.getItem('pinnedMessages') || '[]')
            };

            // Initialize theme on load
            if (featureState.theme === 'dark') {
                const chatPanel = document.getElementById('chatPanel');
                if (chatPanel) chatPanel.classList.add('dark-theme');
                const icon = document.querySelector('#themeToggleBtn i');
                if (icon) icon.className = 'fas fa-sun';
            }

            //1. Dark/Light Theme Toggle (Chat Only)
            function toggleTheme() {
                const chatPanel = document.getElementById('chatPanel');
                const icon = document.querySelector('#themeToggleBtn i');

                if (chatPanel.classList.contains('dark-theme')) {
                    chatPanel.classList.remove('dark-theme');
                    featureState.theme = 'light';
                    if (icon) icon.className = 'fas fa-moon';
                    showToast('Light theme activated', 'success');
                } else {
                    chatPanel.classList.add('dark-theme');
                    featureState.theme = 'dark';
                    if (icon) icon.className = 'fas fa-sun';
                    showToast('Dark theme activated', 'success');
                }

                localStorage.setItem('theme', featureState.theme);
            }

            // 2. Message Search Functionality
            function setupSearchListeners() {
                const searchBtn = document.getElementById('searchMessagesBtn');
                const clearSearchBtn = document.getElementById('clearSearchBtn');
                const searchInput = document.getElementById('messageSearchInput');

                if (searchBtn) searchBtn.addEventListener('click', searchMessages);
                if (clearSearchBtn) clearSearchBtn.addEventListener('click', clearMessageSearch);
                if (searchInput) searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') searchMessages();
                });
            }

            function toggleSearchBar() {
                const searchBar = document.getElementById('chatSearchBar');
                if (searchBar) {
                    searchBar.style.display = searchBar.style.display === 'none' ? 'flex' : 'none';
                    if (searchBar.style.display === 'flex') {
                        document.getElementById('messageSearchInput').focus();
                    }
                }
            }

            function searchMessages() {
                const searchInput = document.getElementById('messageSearchInput');
                const query = searchInput.value.toLowerCase().trim();

                if (!query) {
                    showToast('Please enter a search term', 'warning');
                    return;
                }

                const messages = document.querySelectorAll('.message-item');
                let foundCount = 0;

                messages.forEach(msg => {
                    msg.classList.remove('highlighted');
                    const content = msg.textContent.toLowerCase();
                    if (content.includes(query)) {
                        msg.classList.add('highlighted');
                        foundCount++;
                        // Scroll to first match
                        if (foundCount === 1) {
                            msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                });

                showToast(`Found ${foundCount} message(s)`, foundCount > 0 ? 'success' : 'info');
            }

            function clearMessageSearch() {
                document.getElementById('messageSearchInput').value = '';
                document.querySelectorAll('.message-item').forEach(msg => {
                    msg.classList.remove('highlighted');
                });
            }

            // 3. Message Pinning
            function togglePinMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (!messageElement) return;

                const message = chatState.messages.find(m => m.id === messageId);
                if (!message) return;

                const pinnedIndex = featureState.pinnedMessages.findIndex(p => p.id === messageId);

                if (pinnedIndex > -1) {
                    // Unpin
                    featureState.pinnedMessages.splice(pinnedIndex, 1);
                    messageElement.classList.remove('pinned');
                    showToast('Message unpinned', 'info');
                } else {
                    // Pin
                    featureState.pinnedMessages.push({
                        id: messageId,
                        content: message.content,
                        username: message.username,
                        timestamp: message.timestamp
                    });
                    messageElement.classList.add('pinned');
                    showToast('Message pinned', 'success');
                }

                localStorage.setItem('pinnedMessages', JSON.stringify(featureState.pinnedMessages));
                renderPinnedMessages();
            }

            function renderPinnedMessages() {
                const section = document.getElementById('pinnedMessagesSection');
                const list = document.getElementById('pinnedMessagesList');

                if (!section || !list) return;

                if (featureState.pinnedMessages.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                list.innerHTML = '';

                featureState.pinnedMessages.forEach(msg => {
                    const item = document.createElement('div');
                    item.className = 'pinned-message-item';
                    item.innerHTML = `
                    <div><strong>${msg.username}</strong>: ${msg.content.substring(0, 60)}${msg.content.length > 60 ? '...' : ''}</div>
                    <button class="unpin-btn" onclick="togglePinMessage('${msg.id}')">×</button>
                `;
                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('unpin-btn')) {
                            const messageEl = document.querySelector(`[data-message-id="${msg.id}"]`);
                            if (messageEl) messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    });
                    list.appendChild(item);
                });
            }

            // Coordinate Sharing with Map Popup
            let coordSelectionActive = false;
            let coordClickListener = null;
            let selectedCoordinate = null;
            let popupOverlay = null;

            // Initialize popup overlay
            function initializeCoordPopup() {
                const popupElement = document.getElementById('coordPopup');

                popupOverlay = new ol.Overlay({
                    element: popupElement,
                    positioning: 'bottom-center',
                    stopEvent: false,
                    offset: [0, -10]
                });

                map.addOverlay(popupOverlay);
            }

            function showCoordModal() {
                if (!map) {
                    showToast('Map not available', 'error');
                    return;
                }

                // Initialize popup if not done
                if (!popupOverlay) {
                    initializeCoordPopup();
                }

                // Activate coordinate selection mode
                coordSelectionActive = true;

                // Enable crosshair cursor
                enableCrosshair();

                showToast('Click on the map to select a location', 'info');

                // Add click listener
                coordClickListener = map.on('singleclick', function (evt) {
                    const coordinate = evt.coordinate;
                    const lonLat = ol.proj.toLonLat(coordinate);

                    selectedCoordinate = {
                        mapCoord: coordinate,
                        lon: lonLat[0],
                        lat: lonLat[1]
                    };

                    // Show popup at clicked location
                    showCoordPopup(coordinate, lonLat);
                });
            }

            function showCoordPopup(coordinate, lonLat) {
                const popupElement = document.getElementById('coordPopup');
                const coordsDisplay = document.getElementById('popupCoords');
                const descriptionInput = document.getElementById('popupDescription');

                // Display coordinates in decimal degrees
                const dd = `${lonLat[1].toFixed(6)}, ${lonLat[0].toFixed(6)}`;
                coordsDisplay.textContent = dd;

                // Store the exact map coordinate (not lon/lat) for accuracy
                selectedCoordinate.exactMapCoord = coordinate;

                // Clear previous description
                descriptionInput.value = '';

                // Position popup at clicked location
                popupOverlay.setPosition(coordinate);
                popupElement.style.display = 'block';

                // Focus on description input
                setTimeout(() => {
                    descriptionInput.focus();
                }, 100);

                // Disable crosshair cursor since location is selected
                disableCrosshair();
            }

            function setupCoordModalListeners() {
                const closerBtn = document.getElementById('popupCloser');
                const cancelBtn = document.getElementById('popupCancelBtn');
                const shareBtn = document.getElementById('popupShareBtn');

                if (closerBtn) closerBtn.addEventListener('click', closeCoordPopup);
                if (cancelBtn) cancelBtn.addEventListener('click', closeCoordPopup);
                if (shareBtn) shareBtn.addEventListener('click', shareCoordFromPopup);

                // Allow Enter key to submit
                const descInput = document.getElementById('popupDescription');
                if (descInput) {
                    descInput.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') {
                            shareCoordFromPopup();
                        }
                    });
                }
            }

            function shareCoordFromPopup() {
                if (!selectedCoordinate) {
                    showToast('No location selected', 'warning');
                    return;
                }

                const description = document.getElementById('popupDescription').value.trim();
                if (!description) {
                    showToast('Please add a description', 'warning');
                    document.getElementById('popupDescription').focus();
                    return;
                }

                const coordsText = document.getElementById('popupCoords').textContent;

                // Use the exact map coordinate that was clicked for perfect accuracy
                const exactCenter = selectedCoordinate.exactMapCoord || selectedCoordinate.mapCoord;

                // Ensure center is stored as array [x, y] for JSON serialization
                const centerArray = Array.isArray(exactCenter) ? exactCenter : [exactCenter[0], exactCenter[1]];

                const locationData = {
                    center: centerArray,  // Store exact map coordinate as array
                    lat: selectedCoordinate.lat,
                    lon: selectedCoordinate.lon,
                    zoom: 18,  // Fixed zoom level for 50m view
                    description: description,
                    timestamp: new Date().toISOString(),
                    username: chatState.currentUser.username
                };

                // Create message
                const locationText = `📍 **${description}**\n\n**Coordinates:** ${coordsText}\n\n*Click to view on map*`;

                sendMessage(locationText, 'location', locationData);
                closeCoordPopup();
                showToast('Location shared!', 'success');
            }

            function closeCoordPopup() {
                // Hide popup
                const popupElement = document.getElementById('coordPopup');
                popupElement.style.display = 'none';
                if (popupOverlay) {
                    popupOverlay.setPosition(undefined);
                }

                // Reset state
                coordSelectionActive = false;
                selectedCoordinate = null;

                // Disable crosshair cursor
                disableCrosshair();

                // Remove click listener
                if (coordClickListener) {
                    ol.Observable.unByKey(coordClickListener);
                    coordClickListener = null;
                }
            }

            // 7. Map Screenshot
            function captureMapScreenshot() {
                if (!map) {
                    showToast('Map not available', 'error');
                    return;
                }

                showToast('Capturing screenshot...', 'info');

                map.once('rendercomplete', function () {
                    const mapCanvas = document.createElement('canvas');
                    const size = map.getSize();
                    mapCanvas.width = size[0];
                    mapCanvas.height = size[1];
                    const mapContext = mapCanvas.getContext('2d');

                    Array.prototype.forEach.call(
                        document.querySelectorAll('.ol-layer canvas'),
                        function (canvas) {
                            if (canvas.width > 0) {
                                const opacity = canvas.parentNode.style.opacity;
                                mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
                                const transform = canvas.style.transform;
                                const matrix = transform.match(/^matrix\(([^\(]*)\)$/)[1].split(',').map(Number);
                                CanvasRenderingContext2D.prototype.setTransform.apply(mapContext, matrix);
                                mapContext.drawImage(canvas, 0, 0);
                            }
                        }
                    );

                    const dataURL = mapCanvas.toDataURL('image/png');

                    // Share screenshot in chat
                    const message = `📷 **Map Screenshot**\n\n*Captured at ${new Date().toLocaleTimeString()}*`;
                    sendMessage(message, 'screenshot', { image: dataURL });

                    // Also download
                    const link = document.createElement('a');
                    link.download = `map-screenshot-${Date.now()}.png`;
                    link.href = dataURL;
                    link.click();

                    showToast('Screenshot captured and shared!', 'success');
                });

                map.renderSync();
            }

            // Initialize pinned messages on load
            renderPinnedMessages();

            // ========================================
            //  CUSTOM CROSSHAIR CURSOR SYSTEM
            // ========================================

            // Global crosshair control functions
            function enableCrosshair() {
                if (!map) return;
                const mapViewport = map.getViewport();
                if (mapViewport) {
                    mapViewport.classList.add('crosshair-active');
                }
            }

            function disableCrosshair() {
                if (!map) return;
                const mapViewport = map.getViewport();
                if (mapViewport) {
                    mapViewport.classList.remove('crosshair-active');
                }
            }

            // ========================================
            //  PROPERTY LISTING SYSTEM
            // ========================================

            // Property state management
            let propertyClickListener = null;
            let propertyOverlay = null;
            let selectedPropertyCoordinate = null;
            let propertyMarkersLayer = null;
            let propertyMarkersSource = null;
            let propertyListingPanelOpen = false;
            let propertyLocationSelected = false;
            let currentPropertyPin = null;

            // Initialize property markers layer
            function initializePropertyLayer() {
                if (propertyMarkersSource) return;

                propertyMarkersSource = new ol.source.Vector();
                propertyMarkersLayer = new ol.layer.Vector({
                    source: propertyMarkersSource,
                    zIndex: 999,
                    style: function (feature) {
                        const price = feature.get('price_ugx');
                        const priceText = formatPrice(price);

                        return new ol.style.Style({
                            image: new ol.style.Icon({
                                anchor: [0.5, 1],
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="%2327ae60" stroke="%23ffffff" stroke-width="2" d="M16 0C10.5 0 6 4.5 6 10c0 8 10 22 10 22s10-14 10-22c0-5.5-4.5-10-10-10zm0 14c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>',
                                scale: 1.3
                            }),
                            text: new ol.style.Text({
                                text: priceText,
                                offsetY: -40,
                                font: 'bold 12px Arial',
                                fill: new ol.style.Fill({ color: '#fff' }),
                                stroke: new ol.style.Stroke({ color: '#27ae60', width: 3 }),
                                backgroundFill: new ol.style.Fill({ color: 'rgba(39, 174, 96, 0.9)' }),
                                padding: [4, 6, 4, 6]
                            })
                        });
                    }
                });

                map.addLayer(propertyMarkersLayer);
            }

            // Toggle Property Listing Panel
            function togglePropertyListingPanel() {
                const panel = document.getElementById('propertyListingPanel');

                if (!panel) return;

                if (propertyListingPanelOpen) {
                    // Close panel
                    panel.style.display = 'none';
                    propertyListingPanelOpen = false;
                    propertyLocationSelected = false;

                    // Remove map click listener
                    if (propertyClickListener) {
                        ol.Observable.unByKey(propertyClickListener);
                        propertyClickListener = null;
                    }

                    // Disable crosshair
                    disableCrosshair();

                    // Remove temporary pin if exists
                    if (currentPropertyPin && propertyMarkersSource) {
                        propertyMarkersSource.removeFeature(currentPropertyPin);
                        currentPropertyPin = null;
                    }

                    // Reset form
                    resetPropertyForm();
                } else {
                    // Open panel
                    panel.style.display = 'flex';
                    propertyListingPanelOpen = true;
                    propertyLocationSelected = false;

                    // Initialize property layer
                    initializePropertyLayer();

                    // Show instruction overlay
                    document.getElementById('locationInstructionOverlay').style.display = 'flex';
                    document.getElementById('propertyCoordsBadge').style.display = 'none';

                    // Disable form
                    const form = document.getElementById('propertyListingForm');
                    form.classList.remove('active');
                    document.getElementById('savePropertyListingBtn').disabled = true;
                    console.log('Save button disabled when panel opens');

                    // Enable crosshair
                    enableCrosshair();

                    showToast('Click on the map to select property location, or use the "Use Current Map Center" button', 'info');

                    // Add click listener
                    propertyClickListener = map.on('singleclick', function (evt) {
                        console.log('Map clicked, propertyListingPanelOpen:', propertyListingPanelOpen);
                        if (!propertyListingPanelOpen) return;

                        const coordinate = evt.coordinate;
                        const lonLat = ol.proj.toLonLat(coordinate);
                        console.log('Map click coordinates:', lonLat);

                        selectedPropertyCoordinate = {
                            mapCoord: coordinate,
                            lon: lonLat[0],
                            lat: lonLat[1]
                        };

                        // Handle location selection
                        handleLocationSelection(coordinate, lonLat);

                        // Remove listener after first click
                        ol.Observable.unByKey(propertyClickListener);
                        propertyClickListener = null;
                        disableCrosshair();
                    });
                }
            }

            // Handle map location selection
            function handleLocationSelection(coordinate, lonLat) {
                console.log('handleLocationSelection called with coordinates:', lonLat);

                // Remove previous pin if exists
                if (currentPropertyPin && propertyMarkersSource) {
                    propertyMarkersSource.removeFeature(currentPropertyPin);
                }

                // Create temporary pin marker
                currentPropertyPin = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate),
                    isTemporary: true
                });

                // Add temporary pin to map
                propertyMarkersSource.addFeature(currentPropertyPin);

                // Update UI
                propertyLocationSelected = true;

                // Hide instruction overlay
                document.getElementById('locationInstructionOverlay').style.display = 'none';

                // Show coordinates badge
                const coordsBadge = document.getElementById('propertyCoordsBadge');
                const coordsText = document.getElementById('propertyCoords');
                coordsText.textContent = `${lonLat[1].toFixed(6)}, ${lonLat[0].toFixed(6)}`;
                coordsBadge.style.display = 'flex';

                // Activate form
                const form = document.getElementById('propertyListingForm');
                form.classList.add('active');
                document.getElementById('savePropertyListingBtn').disabled = false;
                console.log('Save button enabled after location selection');

                // Auto-fill district using reverse geocoding
                reverseGeocodeDistrict(lonLat[1], lonLat[0]);

                // Focus on first input
                setTimeout(() => {
                    document.getElementById('propertyDistrict').focus();
                }, 300);

                showToast('Location selected! Now fill in the property details', 'success');
            }

            // Mark Property - Start process (legacy function name for compatibility)
            function startMarkProperty() {
                togglePropertyListingPanel();
            }

            // Reset property form
            function resetPropertyForm() {
                const form = document.getElementById('propertyListingForm');
                if (!form) return;
                const getField = (id) => form.querySelector('#' + id) || form.querySelector('[id="' + id + '"]');
                if (getField('propertyDistrict')) getField('propertyDistrict').value = '';
                if (getField('propertySeller')) getField('propertySeller').value = '';
                if (getField('propertyContact')) getField('propertyContact').value = '';
                if (getField('propertyPlot')) getField('propertyPlot').value = '';
                if (getField('propertyBlock')) getField('propertyBlock').value = '';
                if (getField('propertyArea')) getField('propertyArea').value = '';
                if (getField('propertyTenure')) getField('propertyTenure').value = '';
                if (getField('propertyPrice')) getField('propertyPrice').value = '';
                const pricePreview = document.getElementById('pricePreview');
                if (pricePreview) pricePreview.textContent = '';

                selectedPropertyCoordinate = null;
            }

            // Reverse geocoding to get district
            async function reverseGeocodeDistrict(lat, lon) {
                const loader = document.getElementById('districtLoader');
                const districtInput = document.getElementById('propertyDistrict');

                try {
                    loader.style.display = 'inline-block';

                    // Use Nominatim (OpenStreetMap) reverse geocoding
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`,
                        {
                            headers: {
                                'Accept': 'application/json'
                            }
                        }
                    );

                    if (response.ok) {
                        const data = await response.json();
                        const address = data.address;

                        // Try to get district/county from address
                        const district = address.county || address.state_district || address.city || address.town || '';

                        if (district) {
                            districtInput.value = district;
                            showToast(`District detected: ${district}`, 'success');
                        }
                    }
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    // Silently fail - user can manually enter district
                } finally {
                    loader.style.display = 'none';
                }
            }

            // Format price with commas
            function formatPrice(price) {
                if (!price) return '0';
                return price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            }

            // Update price preview as user types
            document.addEventListener('DOMContentLoaded', function () {
                const priceInput = document.getElementById('propertyPrice');
                if (priceInput) {
                    priceInput.addEventListener('input', function () {
                        const preview = document.getElementById('pricePreview');
                        if (this.value) {
                            preview.textContent = `UGX ${formatPrice(this.value)}`;
                        } else {
                            preview.textContent = '';
                        }
                    });
                }
            });

            // Save property to Supabase
            async function saveProperty() {
                console.log('saveProperty called, selectedPropertyCoordinate:', selectedPropertyCoordinate);

                // #region agent log - hypothesis A: auth check
                fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: 'webmap.html:saveProperty',
                        message: 'saveProperty function entry',
                        data: {
                            hasSelectedCoordinate: !!selectedPropertyCoordinate,
                            selectedPropertyCoordinate: selectedPropertyCoordinate
                        },
                        sessionId: 'debug-session',
                        runId: 'pre-fix',
                        hypothesisId: 'A',
                        timestamp: Date.now()
                    })
                }).catch(() => { });
                // #endregion

                if (!selectedPropertyCoordinate) {
                    showToast('Please select a location on the map', 'warning');
                    return;
                }

                // Get form values - use form-scoped queries to avoid duplicate ID conflicts
                const form = document.getElementById('propertyListingForm');
                if (!form) {
                    console.error('Property listing form not found');
                    showToast('Form not found - please reload the page', 'error');
                    return;
                }
                const district = (form.querySelector('#propertyDistrict') || form.querySelector('[id="propertyDistrict"]'))?.value?.trim() || '';
                const seller = (form.querySelector('#propertySeller') || form.querySelector('[id="propertySeller"]'))?.value?.trim() || '';
                const contact = (form.querySelector('#propertyContact') || form.querySelector('[id="propertyContact"]'))?.value?.trim() || '';
                const plot = (form.querySelector('#propertyPlot') || form.querySelector('[id="propertyPlot"]'))?.value?.trim() || '';
                const block = (form.querySelector('#propertyBlock') || form.querySelector('[id="propertyBlock"]'))?.value?.trim() || '';
                const area = (form.querySelector('#propertyArea') || form.querySelector('[id="propertyArea"]'))?.value || '';
                const tenure = (form.querySelector('#propertyTenure') || form.querySelector('[id="propertyTenure"]'))?.value || '';
                const price = (form.querySelector('#propertyPrice') || form.querySelector('[id="propertyPrice"]'))?.value || '';

                console.log('Form values extracted:', { district, seller, contact, plot, block, area, tenure, price });

                // #region agent log - hypothesis C: form data extraction
                fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: 'webmap.html:saveProperty',
                        message: 'form data extracted',
                        data: {
                            district: district,
                            seller: seller,
                            contact: contact,
                            plot: plot,
                            block: block,
                            area: area,
                            tenure: tenure,
                            price: price
                        },
                        sessionId: 'debug-session',
                        runId: 'pre-fix',
                        hypothesisId: 'C',
                        timestamp: Date.now()
                    })
                }).catch(() => { });
                // #endregion

                // Validate required fields
                // #region agent log - hypothesis G: validation logic
                fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: 'webmap.html:saveProperty',
                        message: 'starting validation checks',
                        data: {
                            district: district,
                            seller: seller,
                            contact: contact,
                            tenure: tenure,
                            price: price
                        },
                        sessionId: 'debug-session',
                        runId: 'pre-fix2',
                        hypothesisId: 'G',
                        timestamp: Date.now()
                    })
                }).catch(() => { });
                // #endregion

                if (!district) {
                    // #region agent log - hypothesis G: district validation failure
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'district validation failed - should show toast',
                            data: { district: district },
                            sessionId: 'debug-session',
                            runId: 'pre-fix2',
                            hypothesisId: 'G',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    showToast('District is required', 'warning');
                    form.querySelector('#propertyDistrict')?.focus();
                    return;
                }
                if (!seller) {
                    showToast('Seller name is required', 'warning');
                    form.querySelector('#propertySeller')?.focus();
                    return;
                }
                if (!contact) {
                    showToast('Contact is required', 'warning');
                    form.querySelector('#propertyContact')?.focus();
                    return;
                }
                if (!tenure) {
                    // #region agent log - hypothesis G: tenure validation failure
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'tenure validation failed - should show toast',
                            data: { tenure: tenure },
                            sessionId: 'debug-session',
                            runId: 'pre-fix2',
                            hypothesisId: 'G',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    showToast('Tenure type is required', 'warning');
                    form.querySelector('#propertyTenure')?.focus();
                    return;
                }
                if (!price || price <= 0) {
                    showToast('Valid price is required', 'warning');
                    form.querySelector('#propertyPrice')?.focus();
                    return;
                }

                // #region agent log - hypothesis G: validation passed
                fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: 'webmap.html:saveProperty',
                        message: 'validation passed - proceeding to image upload',
                        data: {
                            district: district,
                            seller: seller,
                            contact: contact,
                            tenure: tenure,
                            price: price
                        },
                        sessionId: 'debug-session',
                        runId: 'pre-fix2',
                        hypothesisId: 'G',
                        timestamp: Date.now()
                    })
                }).catch(() => { });
                // #endregion

                try {
                    // Upload property images if selected
                    let imageUrls = [];
                    const imageInputs = ['propertyImage1', 'propertyImage2'];

                    // #region agent log - hypothesis F: image upload issues
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'starting image upload process',
                            data: {
                                imageInputs: imageInputs
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'F',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    for (const inputId of imageInputs) {
                        const input = document.getElementById(inputId);
                        if (input.files && input.files[0]) {
                            // #region agent log - hypothesis F: image upload details
                            fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    location: 'webmap.html:saveProperty',
                                    message: 'processing image upload',
                                    data: {
                                        inputId: inputId,
                                        fileName: input.files[0].name,
                                        fileSize: input.files[0].size,
                                        fileType: input.files[0].type
                                    },
                                    sessionId: 'debug-session',
                                    runId: 'pre-fix',
                                    hypothesisId: 'F',
                                    timestamp: Date.now()
                                })
                            }).catch(() => { });
                            // #endregion
                            const file = input.files[0];
                            if (file.size > 5 * 1024 * 1024) {
                                showToast(`Image ${inputId.slice(-1)} must be smaller than 5MB`, 'warning');
                                // Re-enable save button so user can try again
                                const saveBtn = document.getElementById('savePropertyListingBtn');
                                if (saveBtn) saveBtn.disabled = false;
                                return;
                            }

                            showToast(`Uploading image ${inputId.slice(-1)}...`, 'info');
                            // #region agent log - hypothesis F: image upload call
                            fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    location: 'webmap.html:saveProperty',
                                    message: 'calling uploadPropertyImage',
                                    data: {
                                        inputId: inputId,
                                        fileName: file.name,
                                        fileSize: file.size
                                    },
                                    sessionId: 'debug-session',
                                    runId: 'pre-fix',
                                    hypothesisId: 'F',
                                    timestamp: Date.now()
                                })
                            }).catch(() => { });
                            // #endregion

                            const imageUrl = await uploadPropertyImage(file);

                            // #region agent log - hypothesis F: image upload result
                            fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    location: 'webmap.html:saveProperty',
                                    message: 'uploadPropertyImage result',
                                    data: {
                                        inputId: inputId,
                                        success: !!imageUrl,
                                        imageUrl: imageUrl
                                    },
                                    sessionId: 'debug-session',
                                    runId: 'pre-fix',
                                    hypothesisId: 'F',
                                    timestamp: Date.now()
                                })
                            }).catch(() => { });
                            // #endregion

                            if (imageUrl) {
                                imageUrls.push(imageUrl);
                            } else {
                                showToast(`Failed to upload image ${inputId.slice(-1)}`, 'error');
                                // Re-enable save button so user can try again
                                const saveBtn = document.getElementById('savePropertyListingBtn');
                                if (saveBtn) saveBtn.disabled = false;
                                return;
                            }
                        }
                    }

                    // #region agent log - hypothesis A: user authentication
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'user authentication check',
                            data: {
                                hasCurrentUser: !!chatState.currentUser,
                                currentUser: chatState.currentUser ? {
                                    id: chatState.currentUser.id,
                                    username: chatState.currentUser.username
                                } : null
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'A',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    // Validate user is logged in
                    if (!chatState.currentUser || !chatState.currentUser.id) {
                        showToast('Please log in to list a property', 'error');
                        return;
                    }

                    // Ensure username exists (fallback to email or 'User' if not set)
                    const username = chatState.currentUser.username ||
                        (chatState.currentUser.email ? chatState.currentUser.email.split('@')[0] : 'User');

                    // Prepare data for Supabase
                    const propertyData = {
                        user_id: chatState.currentUser.id,
                        username: username,
                        lat: selectedPropertyCoordinate.lat,
                        lon: selectedPropertyCoordinate.lon,
                        district: district,
                        seller_name: seller,
                        contact: contact,
                        plot_number: plot || null,
                        block_number: block || null,
                        area_sqm: area ? parseInt(area) : null,
                        price_ugx: parseInt(price),
                        tenure: tenure,
                        status: 'available',
                        image_urls: imageUrls.length > 0 ? imageUrls : null
                    };

                    // #region agent log - hypothesis C: data preparation
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'property data prepared for Supabase',
                            data: {
                                propertyData: propertyData,
                                imageUrls: imageUrls,
                                imageUrlsLength: imageUrls.length
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'C',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    // #region agent log - hypothesis B: Supabase permissions, hypothesis D: network/API issues
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'about to call Supabase insert',
                            data: {
                                supabaseAvailable: typeof supabase !== 'undefined' && !!supabase,
                                tableName: 'property_listings'
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'B',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    // Insert into Supabase
                    const { data, error } = await supabase
                        .from('property_listings')
                        .insert([propertyData])
                        .select();

                    // #region agent log - hypothesis B: Supabase permissions, hypothesis D: network/API issues
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'Supabase insert result',
                            data: {
                                success: !error,
                                error: error ? {
                                    message: error.message,
                                    details: error.details,
                                    hint: error.hint,
                                    code: error.code
                                } : null,
                                data: data,
                                dataLength: data ? data.length : 0
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'B',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    if (error) {
                        console.error('Error saving property:', error);
                        showToast('Failed to save property listing', 'error');
                        return;
                    }

                    // Remove temporary pin
                    if (currentPropertyPin && propertyMarkersSource) {
                        propertyMarkersSource.removeFeature(currentPropertyPin);
                        currentPropertyPin = null;
                    }

                    // Add permanent marker to map
                    addPropertyMarker(selectedPropertyCoordinate.mapCoord, data[0]);

                    // #region agent log - hypothesis B: success confirmation
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'property saved successfully',
                            data: {
                                savedData: data,
                                savedId: data && data[0] ? data[0].id : null
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'B',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    showToast('Property listing saved successfully!', 'success');

                    // Reset button state
                    const saveBtn = document.getElementById('savePropertyListingBtn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = '<i class="fas fa-save"></i> Save Property';
                    }

                    // Close the panel
                    togglePropertyListingPanel();

                } catch (error) {
                    // #region agent log - hypothesis E: JavaScript errors
                    fetch('http://127.0.0.1:7242/ingest/2866f7e4-488b-44a9-893a-149a99e08935', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: 'webmap.html:saveProperty',
                            message: 'uncaught error in saveProperty',
                            data: {
                                errorMessage: error.message,
                                errorStack: error.stack,
                                errorName: error.name
                            },
                            sessionId: 'debug-session',
                            runId: 'pre-fix',
                            hypothesisId: 'E',
                            timestamp: Date.now()
                        })
                    }).catch(() => { });
                    // #endregion

                    console.error('Error saving property:', error);
                    showToast('Failed to save property listing', 'error');
                }
            }

            // Add property marker to map
            function addPropertyMarker(coordinate, propertyData) {
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate),
                    ...propertyData
                });

                propertyMarkersSource.addFeature(feature);

                // Add click handler to show property details
                feature.on('click', function () {
                    showPropertyDetails(propertyData);
                });
            }

            // Close property popup (legacy function, now calls togglePropertyListingPanel)
            function closePropertyPopup() {
                if (propertyListingPanelOpen) {
                    togglePropertyListingPanel();
                }
            }

            // Property Search Functions
            function togglePropertySearch() {
                const panel = document.getElementById('propertySearchPanel');
                if (panel.style.display === 'none' || !panel.style.display) {
                    panel.style.display = 'flex';
                    // Do NOT load all properties initially - wait for user search
                    document.getElementById('propSearchDistrict').focus();
                } else {
                    panel.style.display = 'none';
                    // Optional: Clear search results when closing?
                    // clearPropertyMarkers(); 
                }
            }

            // Search properties
            async function searchProperties() {
                const district = document.getElementById('propSearchDistrict').value.trim();
                const priceMin = document.getElementById('propSearchPriceMin').value;
                const priceMax = document.getElementById('propSearchPriceMax').value;
                const tenure = document.getElementById('propSearchTenure').value; // Get tenure value

                console.log('Searching properties with:', { district, priceMin, priceMax, tenure });

                if (!district) {
                    showToast('Please enter a district name', 'warning');
                    document.getElementById('propSearchDistrict').focus();
                    return;
                }

                try {
                    showToast('Searching properties...', 'info');

                    // Build query
                    let query = supabase
                        .from('property_listings')
                        .select('*')
                        .ilike('district', `%${district}%`);
                    // .eq('status', 'available'); // Temporarily removed status filter for debugging

                    // Add price filters if provided
                    if (priceMin) {
                        query = query.gte('price_ugx', parseInt(priceMin));
                    }
                    if (priceMax) {
                        query = query.lte('price_ugx', parseInt(priceMax));
                    }
                    // Add tenure filter
                    if (tenure) {
                        query = query.eq('tenure', tenure);
                    }

                    console.log('Sending query to Supabase...');
                    const { data, error } = await query;
                    console.log('Supabase response:', { data, error });

                    if (error) {
                        console.error('Error searching properties:', error);
                        showToast('Database Error: ' + (error.message || JSON.stringify(error)), 'error');
                        return;
                    }

                    if (!data || data.length === 0) {
                        console.warn('No data returned.');
                        showToast(`No properties found matching "${district}". (Check console for details)`, 'warning');
                    } else {
                        showToast(`Found ${data.length} properties`, 'success');
                    }

                    // Display results regardless of count (clears list if empty)
                    displaySearchResults(data || []);
                    plotPropertiesOnMap(data || []);

                } catch (error) {
                    console.error('Error searching properties:', error);
                    showToast('Search failed', 'error');
                }
            }

            // Load all available properties
            async function loadAllProperties() {
                try {
                    const { data, error } = await supabase
                        .from('property_listings')
                        .select('*')
                        .eq('status', 'available')
                        .order('created_at', { ascending: false })
                        .limit(100);

                    if (error) {
                        console.error('Error loading properties:', error);
                        return;
                    }

                    displaySearchResults(data);
                    plotPropertiesOnMap(data);

                } catch (error) {
                    console.error('Error loading properties:', error);
                }
            }

            // Display search results in panel
            function displaySearchResults(properties) {
                console.log('displaySearchResults called with:', properties);
                // Use querySelector to target the specific panel elements to avoid ID duplicates
                const resultsList = document.querySelector('.property-search-panel #propertyResultsList');
                const resultsCount = document.querySelector('.property-search-panel #resultsCount');

                if (!resultsList) {
                    console.error('propertyResultsList element not found!');
                    return;
                }

                // Ensure list is visible
                resultsList.style.display = 'block';

                resultsCount.textContent = `${properties.length} ${properties.length === 1 ? 'property' : 'properties'}`;

                if (!properties || properties.length === 0) {
                    resultsList.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;">No properties found</div>';
                    return;
                }

                resultsList.innerHTML = '';

                properties.forEach(prop => {
                    try {
                        const card = document.createElement('div');
                        card.className = 'property-card';

                        // Image handling
                        const imageUrls = Array.isArray(prop.image_urls) ? prop.image_urls : [];
                        const hasImages = imageUrls.length > 0;
                        const imageUrl = hasImages ? prop.image_urls[0] : 'https://placehold.co/100x100?text=No+Image';
                        const imageCount = hasImages ? prop.image_urls.length : 0;

                        card.innerHTML = `
                    <div class="property-card-content-wrapper" style="display: flex; gap: 10px;">
                        <div class="property-card-image" style="width: 100px; height: 100px; flex-shrink: 0; position: relative; border-radius: 8px; overflow: hidden; background: #eee;">
                            <img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" alt="Property">
                            ${hasImages ? `<div style="position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.6); color: white; padding: 2px 6px; font-size: 10px; border-top-left-radius: 6px;">📷 ${imageCount}</div>` : ''}
                        </div>
                        <div class="property-card-info" style="flex: 1; min-width: 0;">
                            <div class="property-card-header" style="margin-bottom: 5px;">
                                <div class="property-title" style="font-weight: 600; font-size: 1.1rem; color: #333;">${prop.district}</div>
                                <div class="property-price" style="color: #2ecc71; font-weight: 700;">UGX ${formatPrice(prop.price_ugx)}</div>
                            </div>
                            <div class="property-details" style="font-size: 0.9rem; color: #666; margin-bottom: 5px;">
                                <div class="property-detail-item">Plot: ${prop.plot_number || 'N/A'} • Block: ${prop.block_number || 'N/A'}</div>
                                <div class="property-detail-item">Area: ${prop.area_sqm ? formatPrice(prop.area_sqm) + ' m²' : 'N/A'}</div>
                            </div>
                            <div class="property-actions" style="display: flex; gap: 8px; margin-top: 5px;">
                                <button class="btn-fly-to" style="padding: 4px 8px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;"><i class="fas fa-map-marker-alt"></i> Locate</button>
                                ${hasImages ? `<button class="btn-view-photos" style="padding: 4px 8px; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;"><i class="fas fa-images"></i> Photos</button>` : ''}
                            </div>
                        </div>
                    </div>
                `;

                        // Locate button
                        card.querySelector('.btn-fly-to').addEventListener('click', (e) => {
                            e.stopPropagation();
                            flyToProperty(prop);
                        });

                        // Photos button
                        if (hasImages) {
                            card.querySelector('.btn-view-photos').addEventListener('click', (e) => {
                                e.stopPropagation();
                                showPropertyGallery(prop);
                            });
                        }

                        // Card click (default to locate)
                        card.addEventListener('click', () => {
                            flyToProperty(prop);
                        });

                        resultsList.appendChild(card);
                    } catch (e) {
                        console.error('Error displaying property card:', e);
                    }
                });
            }

            // Show Property Gallery Modal
            function showPropertyGallery(property) {
                if (!property.image_urls || property.image_urls.length === 0) return;

                // Create modal if it doesn't exist
                let modal = document.getElementById('propertyGalleryModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'propertyGalleryModal';
                    modal.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0,0,0,0.9); z-index: 20000; display: flex;
                        flex-direction: column; align-items: center; justify-content: center;
                    `;
                    modal.innerHTML = `
                        <button id="closeGalleryBtn" style="position: absolute; top: 20px; right: 20px; background: none; border: none; color: white; font-size: 30px; cursor: pointer;">&times;</button>
                        <div class="gallery-content" style="position: relative; max-width: 90%; max-height: 80vh;">
                            <img id="galleryMainImage" src="" style="max-width: 100%; max-height: 80vh; object-fit: contain; border-radius: 8px;">
                            <button id="prevImgBtn" style="position: absolute; left: -50px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); color: white; border: none; padding: 15px; border-radius: 50%; cursor: pointer;">❮</button>
                            <button id="nextImgBtn" style="position: absolute; right: -50px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); color: white; border: none; padding: 15px; border-radius: 50%; cursor: pointer;">❯</button>
                        </div>
                        <div id="galleryIndicators" style="display: flex; gap: 10px; margin-top: 20px; overflow-x: auto; max-width: 90%; padding-bottom: 10px;"></div>
                        <div style="color: white; margin-top: 10px; font-size: 1.1rem;">${property.district} - UGX ${formatPrice(property.price_ugx)}</div>
                    `;
                    document.body.appendChild(modal);

                    // Close event
                    document.getElementById('closeGalleryBtn').onclick = () => {
                        modal.style.display = 'none';
                    };

                    // Click outside to close
                    modal.onclick = (e) => {
                        if (e.target === modal) modal.style.display = 'none';
                    };
                }

                modal.style.display = 'flex';

                let currentImageIndex = 0;
                const images = property.image_urls;
                const mainImage = document.getElementById('galleryMainImage');
                const indicators = document.getElementById('galleryIndicators');
                const prevBtn = document.getElementById('prevImgBtn');
                const nextBtn = document.getElementById('nextImgBtn');

                function updateGallery() {
                    mainImage.src = images[currentImageIndex];

                    // Update indicators
                    indicators.innerHTML = '';
                    images.forEach((url, index) => {
                        const thumb = document.createElement('img');
                        thumb.src = url;
                        thumb.style.cssText = `
                            width: 60px; height: 60px; object-fit: cover; border-radius: 4px; 
                            cursor: pointer; border: 2px solid ${index === currentImageIndex ? '#3498db' : 'transparent'};
                            opacity: ${index === currentImageIndex ? '1' : '0.6'}; transition: all 0.2s;
                        `;
                        thumb.onclick = (e) => {
                            e.stopPropagation();
                            currentImageIndex = index;
                            updateGallery();
                        };
                        indicators.appendChild(thumb);
                    });

                    // Update buttons
                    prevBtn.style.display = images.length > 1 ? 'block' : 'none';
                    nextBtn.style.display = images.length > 1 ? 'block' : 'none';
                }

                prevBtn.onclick = (e) => {
                    e.stopPropagation();
                    currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
                    updateGallery();
                };

                nextBtn.onclick = (e) => {
                    e.stopPropagation();
                    currentImageIndex = (currentImageIndex + 1) % images.length;
                    updateGallery();
                };

                updateGallery();
            }

            // Plot properties on map
            function plotPropertiesOnMap(properties) {
                // Clear existing markers
                clearPropertyMarkers();

                // Initialize layer if needed
                initializePropertyLayer();

                properties.forEach(prop => {
                    const coordinate = ol.proj.fromLonLat([prop.lon, prop.lat]);
                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        ...prop
                    });

                    propertyMarkersSource.addFeature(feature);
                });

                // Add click handler to show property details
                map.on('singleclick', function (evt) {
                    map.forEachFeatureAtPixel(evt.pixel, function (feature) {
                        if (feature.get('price_ugx')) {
                            showPropertyDetails(feature.getProperties());
                            return true;
                        }
                    });
                });
            }

            // Fly to property location
            function flyToProperty(property) {
                const center = ol.proj.fromLonLat([property.lon, property.lat]);

                map.getView().animate({
                    center: center,
                    zoom: 18,
                    duration: 1500
                });

                // Close search panel to show map - DISABLED to keep list open for browsing
                // togglePropertySearch();

                showToast(`Flying to property in ${property.district}`, 'info');
            }

            // Show property details in popup (custom modal)
            function showPropertyDetails(property) {
                // Check for existing modal
                let modal = document.getElementById('propertyDetailsModal');
                if (modal) modal.remove();

                const hasImages = property.image_urls && property.image_urls.length > 0;

                modal = document.createElement('div');
                modal.id = 'propertyDetailsModal';
                modal.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: white; padding: 25px; border-radius: 12px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.4); z-index: 20000;
                    width: 90%; max-width: 400px;
                `;

                modal.innerHTML = `
                    <button id="closeDetailsBtn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 20px; cursor: pointer; color: #666;">&times;</button>
                    <h3 style="margin: 0 0 15px 0; color: #2c3e50; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px;">
                        <i class="fas fa-home"></i> Property Details
                    </h3>
                    <div style="font-size: 0.95rem; color: #444; line-height: 1.6;">
                        <div><strong>District:</strong> ${property.district}</div>
                        <div><strong>Price:</strong> <span style="color: #27ae60; font-weight: bold;">UGX ${formatPrice(property.price_ugx)}</span></div>
                        <div><strong>Area:</strong> ${property.area_sqm ? formatPrice(property.area_sqm) + ' m²' : 'N/A'}</div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #eee;">
                            <div><strong>Seller:</strong> ${property.seller_name}</div>
                            <div><strong>Contact:</strong> <a href="tel:${property.contact}" style="color: #3498db; text-decoration: none;">${property.contact}</a></div>
                        </div>
                         <div style="margin-top: 10px; font-size: 0.85rem; color: #7f8c8d;">
                            Plot: ${property.plot_number || 'N/A'} • Block: ${property.block_number || 'N/A'}
                        </div>
                    </div>
                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        ${hasImages ?
                        `<button id="viewPhotosBtn" style="flex: 1; padding: 10px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                                <i class="fas fa-images"></i> View Photos
                             </button>` :
                        '<button disabled style="flex: 1; padding: 10px; background: #eee; color: #999; border: none; border-radius: 6px; font-weight: 600;">No Photos</button>'
                    }
                        <button id="closeModalBtn" style="flex: 1; padding: 10px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Close</button>
                    </div>
                `;

                document.body.appendChild(modal);

                // Add backdrop
                let backdrop = document.createElement('div');
                backdrop.id = 'detailsBackdrop';
                backdrop.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 19999;
                `;
                document.body.appendChild(backdrop);

                // Event Listeners
                const close = () => {
                    if (modal) modal.remove();
                    if (backdrop) backdrop.remove();
                };

                document.getElementById('closeDetailsBtn').onclick = close;
                document.getElementById('closeModalBtn').onclick = close;
                backdrop.onclick = close;

                if (hasImages) {
                    document.getElementById('viewPhotosBtn').onclick = () => {
                        // Keep details open or close it? Let's close it to focus on gallery
                        close();
                        showPropertyGallery(property);
                    };
                }

                // Add Export PDF Button logic
                const exportBtn = document.createElement('button');
                exportBtn.id = 'exportPropertyPDFBtn';
                exportBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Export PDF';
                exportBtn.style.cssText = `
                    flex: 1; padding: 10px; background: #27ae60; color: white; border: none; 
                    border-radius: 6px; cursor: pointer; font-weight: 600;
                `;

                // Insert export button before Close button
                const modalButtons = modal.querySelector('div[style*="margin-top: 20px"]');
                const closeBtn = document.getElementById('closeModalBtn');
                if (modalButtons && closeBtn) {
                    modalButtons.insertBefore(exportBtn, closeBtn);
                }

                exportBtn.onclick = () => {
                    if (typeof exportPopupPDF === 'function') {
                        // Pass property data directly to handle images even if hidden
                        exportPopupPDF('propertyDetailsModal', 'Property_Details', property);
                    } else {
                        alert('PDF Export function not ready.');
                    }
                };
            }

            // Show Comparable Details popup for valuations (with image viewer)
            function showComparableDetails(valuation) {
                // Check for existing modal
                let modal = document.getElementById('comparableDetailsModal');
                if (modal) modal.remove();

                // Collect available images
                const images = [];
                if (valuation.property_image_1_url) images.push({ url: valuation.property_image_1_url, label: 'Property Image 1' });
                if (valuation.property_image_2_url) images.push({ url: valuation.property_image_2_url, label: 'Property Image 2' });
                if (valuation.document_image_1_url) images.push({ url: valuation.document_image_1_url, label: 'Document Image 1' });
                if (valuation.document_image_2_url) images.push({ url: valuation.document_image_2_url, label: 'Document Image 2' });

                const hasImages = images.length > 0;
                let currentImageIndex = 0;

                modal = document.createElement('div');
                modal.id = 'comparableDetailsModal';
                modal.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: white; padding: 25px; border-radius: 12px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.4); z-index: 20000;
                    width: 90%; max-width: 600px; max-height: 90vh; overflow-y: auto;
                `;

                modal.innerHTML = `
                    <button id="closeComparableBtn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 20px; cursor: pointer; color: #666;">&times;</button>
                    <h3 style="margin: 0 0 15px 0; color: #2c3e50; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px;">
                        <i class="fas fa-balance-scale"></i> Comparable Details
                    </h3>
                    
                    <!-- Property Details Section -->
                    <div style="font-size: 0.95rem; color: #444; line-height: 1.8;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div><strong>District:</strong> ${valuation.district || 'N/A'}</div>
                            <div><strong>County:</strong> ${valuation.county || 'N/A'}</div>
                            <div><strong>Village:</strong> ${valuation.village_name || 'N/A'}</div>
                            <div><strong>Proprietor:</strong> ${valuation.proprietor_name || 'N/A'}</div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div><strong>Plot Number:</strong> ${valuation.plot_number || 'N/A'}</div>
                            <div><strong>Block Number:</strong> ${valuation.block_number || 'N/A'}</div>
                            <div><strong>Property Type:</strong> ${valuation.property_type || 'N/A'}</div>
                            <div><strong>Tenure:</strong> ${valuation.tenure || 'N/A'}</div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div><strong>Size:</strong> ${valuation.property_size_sqm ? formatPrice(valuation.property_size_sqm) + ' m²' : 'N/A'}</div>
                            <div><strong>Valuation Date:</strong> ${valuation.valuation_date || 'N/A'}</div>
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #eee;">
                            <div><strong>Price:</strong> <span style="color: #27ae60; font-weight: bold; font-size: 1.1rem;">UGX ${formatPrice(valuation.price_ugx || 0)}</span></div>
                            ${valuation.land_value_ugx ? `<div style="font-size: 0.9rem; color: #666;">Land Value: UGX ${formatPrice(valuation.land_value_ugx)}</div>` : ''}
                            ${valuation.improvements_value_ugx ? `<div style="font-size: 0.9rem; color: #666;">Improvements: UGX ${formatPrice(valuation.improvements_value_ugx)}</div>` : ''}
                        </div>
                        ${valuation.surveyor_name ? `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #eee;">
                            <div><strong>Surveyor:</strong> ${valuation.surveyor_name}</div>
                        </div>` : ''}
                    </div>

                    <!-- Image Viewer Section -->
                    ${hasImages ? `
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #f0f0f0;">
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">
                                <i class="fas fa-images"></i> Attached Images
                            </h4>
                            
                            <!-- Full-size Image Display -->
                            <div id="comparableImageDisplay" style="position: relative; background: #f8f9fa; border-radius: 8px; overflow: hidden; margin-bottom: 15px;">
                                <img id="comparableCurrentImage" src="${images[0].url}" 
                                    style="width: 100%; height: auto; display: block; max-height: 400px; object-fit: contain;">
                                <div id="comparableImageLabel" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 0.85rem;">
                                    ${images[0].label}
                                </div>
                                ${images.length > 1 ? `
                                    <button id="comparablePrevBtn" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px;">
                                        &#8249;
                                    </button>
                                    <button id="comparableNextBtn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px;">
                                        &#8250;
                                    </button>
                                ` : ''}
                            </div>

                            <!-- Thumbnail Grid -->
                            ${images.length > 1 ? `
                                <div id="comparableThumbnails" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px;">
                                    ${images.map((img, idx) => `
                                        <div class="comparable-thumbnail" data-index="${idx}" style="cursor: pointer; border: 2px solid ${idx === 0 ? '#3498db' : '#ddd'}; border-radius: 6px; overflow: hidden; aspect-ratio: 1; position: relative;">
                                            <img src="${img.url}" style="width: 100%; height: 100%; object-fit: cover;">
                                            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.6); color: white; font-size: 0.7rem; padding: 2px 4px; text-align: center;">
                                                ${img.label.replace('Image ', '')}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    ` : '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center; color: #666;"><i class="fas fa-image" style="font-size: 2rem; opacity: 0.3; margin-bottom: 10px;"></i><div>No images attached</div></div>'}

                    <!-- Bottom Actions -->
                    <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
                        <button id="exportComparablePDFBtn" style="padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            <i class="fas fa-file-pdf"></i> Export PDF
                        </button>
                        <button id="closeComparableModalBtn" style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Close
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);

                // Add backdrop
                let backdrop = document.createElement('div');
                backdrop.id = 'comparableBackdrop';
                backdrop.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 19999;
                `;
                document.body.appendChild(backdrop);

                // Close handlers
                const close = () => {
                    if (modal) modal.remove();
                    if (backdrop) backdrop.remove();
                };

                document.getElementById('closeComparableBtn').onclick = close;
                document.getElementById('closeComparableModalBtn').onclick = close;
                backdrop.onclick = close;

                // Export PDF Button Listener
                const exportPdfBtn = document.getElementById('exportComparablePDFBtn');
                if (exportPdfBtn) {
                    exportPdfBtn.onclick = () => {
                        if (typeof exportPopupPDF === 'function') {
                            exportPopupPDF('comparableDetailsModal', 'Comparable_Details', valuation, images);
                        } else {
                            alert('PDF Export function not ready.');
                        }
                    };
                }

                // Image navigation
                if (hasImages && images.length > 1) {
                    const updateImage = (index) => {
                        currentImageIndex = index;
                        const imgElement = document.getElementById('comparableCurrentImage');
                        const labelElement = document.getElementById('comparableImageLabel');
                        imgElement.src = images[index].url;
                        labelElement.textContent = images[index].label;

                        // Update thumbnail borders
                        document.querySelectorAll('.comparable-thumbnail').forEach((thumb, idx) => {
                            thumb.style.border = idx === index ? '2px solid #3498db' : '2px solid #ddd';
                        });
                    };

                    document.getElementById('comparablePrevBtn').onclick = () => {
                        const newIndex = (currentImageIndex - 1 + images.length) % images.length;
                        updateImage(newIndex);
                    };

                    document.getElementById('comparableNextBtn').onclick = () => {
                        const newIndex = (currentImageIndex + 1) % images.length;
                        updateImage(newIndex);
                    };

                    // Thumbnail click handlers
                    document.querySelectorAll('.comparable-thumbnail').forEach(thumb => {
                        thumb.onclick = () => {
                            const index = parseInt(thumb.dataset.index);
                            updateImage(index);
                        };
                    });
                }
            }

            // Clear property markers from map
            function clearPropertyMarkers() {
                if (propertyMarkersSource) {
                    propertyMarkersSource.clear();
                }
            }

            // Clear search form
            function clearPropertySearch() {
                document.getElementById('propSearchDistrict').value = '';
                document.getElementById('propSearchPriceMin').value = '';
                document.getElementById('propSearchPriceMax').value = '';
                document.getElementById('propertyResultsList').innerHTML = '';
                document.getElementById('resultsCount').textContent = '0 properties';
                clearPropertyMarkers();
            }

            // Setup property event listeners
            function setupPropertyListeners() {
                const markPropertyBtn = document.getElementById('markPropertyBtn');
                const propertySearchBtn = document.getElementById('propertySearchBtn');
                const savePropertyBtn = document.getElementById('savePropertyListingBtn');
                const cancelPropertyBtn = document.getElementById('cancelPropertyListingBtn');
                const closePropertyListing = document.getElementById('closePropertyListing');
                const closeSearch = document.getElementById('closePropertySearch');
                const searchBtn = document.getElementById('propSearchBtn');
                const clearSearchBtn = document.getElementById('propSearchClearBtn');

                if (markPropertyBtn) markPropertyBtn.addEventListener('click', startMarkProperty);
                if (propertySearchBtn) propertySearchBtn.addEventListener('click', togglePropertySearch);

                // Use current location button
                const useCurrentLocationBtn = document.getElementById('useCurrentLocationBtn');
                if (useCurrentLocationBtn) {
                    useCurrentLocationBtn.addEventListener('click', function () {
                        console.log('Use current location button clicked');
                        const center = map.getView().getCenter();
                        const lonLat = ol.proj.toLonLat(center);
                        console.log('Using current map center:', lonLat);
                        handleLocationSelection(center, lonLat);

                        // Remove click listener since location is selected
                        if (propertyClickListener) {
                            ol.Observable.unByKey(propertyClickListener);
                            propertyClickListener = null;
                            disableCrosshair();
                        }
                    });
                }

                if (savePropertyBtn) {
                    savePropertyBtn.addEventListener('click', function (e) {
                        console.log('Save Property button clicked, disabled state:', savePropertyBtn.disabled);
                        if (savePropertyBtn.disabled) {
                            console.log('Button is disabled, preventing save');
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        saveProperty();
                    });
                }
                if (cancelPropertyBtn) {
                    cancelPropertyBtn.addEventListener('click', function (e) {
                        console.log('Cancel Property button clicked');
                        e.preventDefault();
                        e.stopPropagation();
                        togglePropertyListingPanel();
                    });
                }

                // Valuation Image Upload Event Listeners
                const imageInputs = [
                    { btnId: 'propertyImage1Btn', inputId: 'propertyImage1Input', previewId: 'propertyImagesPreview', type: 'property1' },
                    { btnId: 'propertyImage2Btn', inputId: 'propertyImage2Input', previewId: 'propertyImagesPreview', type: 'property2' },
                    { btnId: 'documentImage1Btn', inputId: 'documentImage1Input', previewId: 'documentImagesPreview', type: 'document1' },
                    { btnId: 'documentImage2Btn', inputId: 'documentImage2Input', previewId: 'documentImagesPreview', type: 'document2' }
                ];

                imageInputs.forEach(({ btnId, inputId, previewId, type }) => {
                    const btn = document.getElementById(btnId);
                    const input = document.getElementById(inputId);
                    if (btn && input) {
                        btn.addEventListener('click', () => input.click());
                        input.addEventListener('change', (e) => handleValuationImagePreview(e, previewId, type));
                    }
                });

                if (closePropertyListing) closePropertyListing.addEventListener('click', togglePropertyListingPanel);
                if (closeSearch) closeSearch.addEventListener('click', togglePropertySearch);
                if (searchBtn) searchBtn.addEventListener('click', searchProperties);
                if (clearSearchBtn) clearSearchBtn.addEventListener('click', clearPropertySearch);

                // Enter key to search
                const searchDistrictInput = document.getElementById('propSearchDistrict');
                if (searchDistrictInput) {
                    searchDistrictInput.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') searchProperties();
                    });
                }
            }

            // Initialize property system on load
            document.addEventListener('DOMContentLoaded', function () {
                setupPropertyListeners();
            });

            // Close chat when clicking outside (optional)
            document.addEventListener('click', (e) => {
                const chatPanel = document.getElementById('chatPanel');
                const chatBtn = document.getElementById('chatBtn');

                if (chatState.isOpen &&
                    chatPanel && chatBtn &&
                    !chatPanel.contains(e.target) &&
                    !chatBtn.contains(e.target)) {
                    toggleChatPanel();
                }
            });

            // ============================================
            // SOCIAL CHAT SYSTEM IMPLEMENTATION
            // ============================================

            // Chat System State
            const ChatSystem = {
                currentMode: 'rooms', // 'rooms' or 'inbox'
                currentRoom: 'general',
                currentChatPartner: null,
                currentUser: null,
                subscriptions: [],
                posts: new Map(),
                comments: new Map(),
                users: new Map(),
                messages: new Map()
            };

            // Initialize Social Chat System
            async function initializeSocialChat() {
                console.log('🚀 Initializing Social Chat System...');

                try {
                    // Get supabase instance - check multiple possible locations
                    const supabaseInstance = supabase || window.supabaseClient || (typeof window.supabase !== 'undefined' ? window.supabase.createClient : null);

                    if (!supabaseInstance || !supabaseInstance.auth) {
                        console.error('❌ Error initializing Social Chat System: Supabase not initialized');
                        return;
                    }

                    // Get current user from Supabase auth
                    const { data: { user }, error: authError } = await supabaseInstance.auth.getUser();

                    if (authError) {
                        console.warn('⚠️ Auth error:', authError);
                    }

                    if (user) {
                        ChatSystem.currentUser = {
                            id: user.id,
                            email: user.email,
                            username: user.email.split('@')[0] || 'User'
                        };

                        console.log('✅ User authenticated:', ChatSystem.currentUser);

                        // Create or update user profile
                        try {
                            await createOrUpdateUserProfile(ChatSystem.currentUser);
                            console.log('✅ User profile created/updated');
                        } catch (profileError) {
                            console.warn('⚠️ Could not create/update profile:', profileError);
                        }
                    } else {
                        // Demo mode
                        ChatSystem.currentUser = {
                            id: 'demo-user',
                            email: 'demo@example.com',
                            username: 'Demo User'
                        };
                        console.log('⚠️ Demo mode - user not authenticated');
                    }

                    // Setup event listeners
                    setupSocialChatEventListeners();

                    // Load initial data
                    await loadChatRooms();
                    await loadUsersList();

                    // Setup real-time subscriptions
                    setupRealtimeSubscriptions();

                    console.log('✅ Social Chat System initialized successfully');

                } catch (error) {
                    console.error('❌ Error initializing Social Chat System:', error);
                    console.error('Error details:', error);
                }
            }

            // ============================================
            // CHAT ROOMS FUNCTIONS
            // ============================================

            // Load chat rooms
            async function loadChatRooms() {
                try {
                    const { data: rooms, error } = await supabase
                        .from('chat_rooms')
                        .select('*')
                        .order('created_at', { ascending: true });

                    if (error) throw error;

                    const roomSelect = document.getElementById('room-select');
                    if (!roomSelect) {
                        console.error('❌ Room select element not found');
                        return;
                    }

                    roomSelect.innerHTML = '';

                    if (rooms && rooms.length > 0) {
                        rooms.forEach(room => {
                            const option = document.createElement('option');
                            option.value = room.id;
                            option.textContent = room.name;
                            roomSelect.appendChild(option);
                        });

                        // Load posts for default room
                        await loadRoomPosts(rooms[0].id);
                    } else {
                        // Create default room if none exists
                        await createDefaultRoom();
                    }

                } catch (error) {
                    console.error('❌ Error loading chat rooms:', error);
                    showUserMessage('Error loading chat rooms', 'error');
                }
            }

            // Create default room
            async function createDefaultRoom() {
                try {
                    const { data, error } = await supabase
                        .from('chat_rooms')
                        .insert([{
                            name: 'General Chat',
                            created_by: ChatSystem.currentUser.id
                        }])
                        .select()
                        .single();

                    if (error) throw error;

                    // Reload rooms
                    await loadChatRooms();

                } catch (error) {
                    console.error('❌ Error creating default room:', error);
                }
            }

            // Load room posts
            async function loadRoomPosts(roomId) {
                try {
                    console.log('📝 Loading posts for room:', roomId);

                    const { data: posts, error } = await supabase
                        .from('room_posts')
                        .select('*')
                        .eq('room_id', roomId)
                        .order('created_at', { ascending: false });

                    if (error) throw error;

                    ChatSystem.currentRoom = roomId;
                    await renderPosts(posts || []);

                } catch (error) {
                    console.error('❌ Error loading room posts:', error);
                    showUserMessage('Error loading posts', 'error');
                }
            }

            // Image upload functions
            async function uploadChatImage(file) {
                const formData = new FormData();
                formData.append('file', file);

                // Generate unique filename
                const timestamp = Date.now();
                const randomId = Math.random().toString(36).substr(2, 9);
                const fileName = `chat-${timestamp}-${randomId}.${file.name.split('.').pop()}`;

                // Use Cloudflare Worker endpoint for chat images
                const uploadUrl = 'https://nlis-image-upload.kiggundumuhamad.workers.dev/images/chat/' + fileName;

                try {
                    const response = await fetch(uploadUrl, {
                        method: 'PUT',
                        body: file,
                        headers: {
                            'Content-Type': file.type
                        }
                    });

                    if (response.ok) {
                        // The Worker should return the public URL
                        // Construct the public URL using data.geospatialnetworkug.xyz domain
                        const publicUrl = 'https://data.geospatialnetworkug.xyz/images/chat/' + fileName;
                        return publicUrl;
                    } else {
                        throw new Error('Upload failed');
                    }
                } catch (error) {
                    console.error('Chat image upload error:', error);
                    showUserMessage('Image upload failed', 'error');
                    return null;
                }
            }

            async function uploadPropertyImage(file) {
                // Generate unique filename
                const timestamp = Date.now();
                const randomId = Math.random().toString(36).substr(2, 9);
                const fileName = `property-${timestamp}-${randomId}.${file.name.split('.').pop()}`;

                try {
                    const response = await fetch('https://nlis-image-upload.kiggundumuhamad.workers.dev/images/land_for_sale/' + fileName, {
                        method: 'PUT',
                        body: file,
                        headers: {
                            'Content-Type': file.type
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        return data.previewUrl;
                    } else {
                        throw new Error('Upload failed');
                    }
                } catch (error) {
                    console.error('Property image upload error:', error);
                    showToast('Image upload failed', 'error');
                    return null;
                }
            }

            // Valuation Image Upload Functions
            async function uploadValuationImage(file, imageType) {
                if (!file) return null;
                if (!file.type.startsWith('image/')) {
                    showToast('Please select an image file', 'error');
                    return null;
                }

                const timestamp = Date.now();
                const randomId = Math.random().toString(36).substr(2, 9);
                const extension = file.name.split('.').pop();
                const fileName = `valuation-${imageType}-${timestamp}-${randomId}.${extension}`;
                const uploadUrl = 'https://nlis-image-upload.kiggundumuhamad.workers.dev/images/valuation/' + fileName;

                try {
                    console.log(`📤 Uploading ${imageType} image:`, fileName);
                    const response = await fetch(uploadUrl, {
                        method: 'PUT',
                        body: file,
                        headers: { 'Content-Type': file.type }
                    });

                    if (response.ok) {
                        const publicUrl = 'https://data.geospatialnetworkug.xyz/images/valuation/' + fileName;
                        console.log(`✅ Image uploaded successfully:`, publicUrl);
                        return publicUrl;
                    } else {
                        throw new Error('Upload failed');
                    }
                } catch (error) {
                    console.error('Valuation image upload error:', error);
                    showToast('Image upload failed. Please try again.', 'error');
                    return null;
                }
            }

            function handleValuationImagePreview(event, previewContainerId, imageType) {
                const file = event.target.files[0];
                if (!file) return;
                if (!file.type.startsWith('image/')) {
                    showToast('Please select an image file', 'error');
                    event.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    const previewContainer = document.getElementById(previewContainerId);
                    const inputId = event.target.id;
                    const previewItem = document.createElement('div');
                    previewItem.className = 'valuation-image-preview-item';
                    previewItem.dataset.inputId = inputId;
                    previewItem.innerHTML = `
                        <img src="${e.target.result}" alt="${imageType} preview">
                        <button type="button" class="valuation-image-remove-btn" 
                            onclick="removeValuationImage('${inputId}', '${previewContainerId}')" title="Remove image">×</button>
                    `;
                    const existingPreview = previewContainer.querySelector(`[data-input-id="${inputId}"]`);
                    if (existingPreview) existingPreview.remove();
                    previewContainer.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            }

            function removeValuationImage(inputId, previewContainerId) {
                const input = document.getElementById(inputId);
                if (input) input.value = '';
                const previewContainer = document.getElementById(previewContainerId);
                const previewItem = previewContainer.querySelector(`[data-input-id="${inputId}"]`);
                if (previewItem) previewItem.remove();
            }
            window.removeValuationImage = removeValuationImage;

            // Handle image selection and preview
            function handleImageSelection(inputId, previewId, buttonId) {
                const input = document.getElementById(inputId);
                const preview = document.getElementById(previewId);
                const button = document.getElementById(buttonId);

                if (button) {
                    button.addEventListener('click', () => {
                        input.click();
                    });
                }

                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        if (file.size > 5 * 1024 * 1024) { // 5MB limit
                            showUserMessage('Image must be smaller than 5MB', 'warning');
                            input.value = '';
                            return;
                        }

                        // Show loading state
                        if (button) {
                            button.disabled = true;
                            button.innerHTML = '<span class="image-upload-loading"></span>Uploading...';
                        }

                        const reader = new FileReader();
                        reader.onload = (e) => {
                            preview.innerHTML = `<img src="${e.target.result}" style="max-width: 200px; max-height: 150px;" />
                                           <button class="remove-image-btn" onclick="removeImage('${inputId}', '${previewId}', '${buttonId}')">×</button>`;
                            preview.style.display = 'block';

                            // Reset loading state
                            if (button) {
                                button.disabled = false;
                                button.innerHTML = '<i class="fas fa-image"></i>';
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }

            // Handle image preview
            function handleImagePreview(event, previewId, buttonId, inputId) {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.type.startsWith('image/')) {
                    showToast('Please select an image file', 'warning');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    const preview = document.getElementById(previewId);
                    preview.innerHTML = `
                        <div style="position: relative; display: inline-block;">
                            <img src="${e.target.result}" style="max-height: 100px; border-radius: 8px;">
                            <button onclick="removeImage('${inputId}', '${previewId}', '${buttonId}')" 
                                style="position: absolute; top: -5px; right: -5px; background: red; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px;">&times;</button>
                        </div>
                    `;
                    preview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }

            // Remove selected image
            function removeImage(inputId, previewId, buttonId) {
                document.getElementById(inputId).value = '';
                document.getElementById(previewId).style.display = 'none';
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = false;
                    button.innerHTML = '<i class="fas fa-image"></i>';
                }
            }

            // Image modal function
            function openImageModal(imageUrl) {
                // Remove existing modal if any
                const existingModal = document.querySelector('.image-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'image-modal';
                modal.innerHTML = `
                <div class="image-modal-content">
                    <span class="image-modal-close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <img src="${imageUrl}" style="max-width: 100%; max-height: 80vh;" />
                </div>
            `;
                document.body.appendChild(modal);

                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Create new post
            async function createPost(content, coordinates = null, imageFile = null) {
                if (!content.trim() && !imageFile) {
                    showUserMessage('Please enter some content or add an image', 'warning');
                    return;
                }

                try {
                    let imageUrl = null;
                    if (imageFile) {
                        showUserMessage('Uploading image...', 'info');
                        imageUrl = await uploadChatImage(imageFile);
                        if (!imageUrl) {
                            showUserMessage('Image upload failed', 'error');
                            return;
                        }
                    }

                    const postData = {
                        room_id: ChatSystem.currentRoom,
                        user_id: ChatSystem.currentUser.id,
                        username: ChatSystem.currentUser.username,
                        content: content.trim(),
                        coordinates: coordinates,
                        zoom_level: coordinates ? map.getView().getZoom() : null,
                        image_url: imageUrl
                    };

                    const { data, error } = await supabase
                        .from('room_posts')
                        .insert([postData])
                        .select()
                        .single();

                    if (error) throw error;

                    console.log('✅ Post created:', data.id);
                    showUserMessage('Post created successfully', 'success');

                    // Clear input
                    document.getElementById('post-input').value = '';
                    removeImage('post-image-input', 'post-image-preview', 'post-image-btn');

                } catch (error) {
                    console.error('❌ Error creating post:', error);
                    showUserMessage('Error creating post', 'error');
                }
            }

            // Load post comments
            async function loadPostComments(postId) {
                try {
                    const { data: comments, error } = await supabase
                        .from('post_comments')
                        .select('*')
                        .eq('post_id', postId)
                        .order('created_at', { ascending: true });

                    if (error) throw error;

                    ChatSystem.comments.set(postId, comments || []);
                    return comments || [];

                } catch (error) {
                    console.error('❌ Error loading comments:', error);
                    return [];
                }
            }

            // Add comment to post
            async function addComment(postId, content) {
                if (!content.trim()) {
                    showUserMessage('Please enter a comment', 'warning');
                    return;
                }

                try {
                    const commentData = {
                        post_id: postId,
                        user_id: ChatSystem.currentUser.id,
                        username: ChatSystem.currentUser.username,
                        content: content.trim()
                    };

                    const { data, error } = await supabase
                        .from('post_comments')
                        .insert([commentData])
                        .select()
                        .single();

                    if (error) throw error;

                    console.log('✅ Comment added:', data.id);

                    // Reload comments for this post
                    await loadPostComments(postId);
                    await renderPosts(); // Refresh posts display

                } catch (error) {
                    console.error('❌ Error adding comment:', error);
                    showUserMessage('Error adding comment', 'error');
                }
            }

            // Toggle post reaction
            async function toggleReaction(postId, type) {
                try {
                    const existingReaction = await supabase
                        .from('post_reactions')
                        .select('*')
                        .eq('post_id', postId)
                        .eq('user_id', ChatSystem.currentUser.id)
                        .single();

                    if (existingReaction.data) {
                        // Update existing reaction
                        if (existingReaction.data.reaction_type === type) {
                            // Remove reaction
                            const { error } = await supabase
                                .from('post_reactions')
                                .delete()
                                .eq('id', existingReaction.data.id);

                            if (error) throw error;
                        } else {
                            // Change reaction type
                            const { error } = await supabase
                                .from('post_reactions')
                                .update({ reaction_type: type })
                                .eq('id', existingReaction.data.id);

                            if (error) throw error;
                        }
                    } else {
                        // Create new reaction
                        const { error } = await supabase
                            .from('post_reactions')
                            .insert([{
                                post_id: postId,
                                user_id: ChatSystem.currentUser.id,
                                reaction_type: type
                            }]);

                        if (error) throw error;
                    }

                    // Reload posts to update reaction counts
                    await loadRoomPosts(ChatSystem.currentRoom);

                } catch (error) {
                    console.error('❌ Error toggling reaction:', error);
                }
            }

            // ============================================
            // RENDERING FUNCTIONS
            // ============================================

            // Render posts
            async function renderPosts(posts = null) {
                const container = document.getElementById('posts-container');
                if (!container) return;

                if (!posts) {
                    // Get current posts from state
                    const { data } = await supabase
                        .from('room_posts')
                        .select('*')
                        .eq('room_id', ChatSystem.currentRoom)
                        .order('created_at', { ascending: false });
                    posts = data || [];
                }

                container.innerHTML = '';

                for (const post of posts) {
                    const postElement = await renderPost(post);
                    container.appendChild(postElement);
                }
            }

            // Render individual post
            async function renderPost(post) {
                const postElement = document.createElement('div');
                postElement.className = 'post-card';
                postElement.dataset.postId = post.id;

                // Get reactions count
                const { data: reactions } = await supabase
                    .from('post_reactions')
                    .select('*')
                    .eq('post_id', post.id);

                const likes = reactions?.filter(r => r.reaction_type === 'like').length || 0;
                const dislikes = reactions?.filter(r => r.reaction_type === 'dislike').length || 0;

                // Check user's reaction
                const userReaction = reactions?.find(r => r.user_id === ChatSystem.currentUser.id);

                // Get comments count
                const comments = await loadPostComments(post.id);
                const commentsCount = comments.length;

                postElement.innerHTML = `
                <div class="post-header">
                    <div class="post-avatar">${post.username.charAt(0).toUpperCase()}</div>
                    <div class="post-user-info">
                        <div class="post-username">@${post.username}</div>
                        <div class="post-time">${formatTime(post.created_at)}</div>
                    </div>
                </div>
                <div class="post-content">${escapeHtml(post.content)}</div>
                ${post.image_url ? `
                    <div class="post-image" style="margin-top: 12px;">
                        <img src="${escapeHtml(post.image_url)}" alt="Post image" style="max-width: 100%; max-height: 400px; border-radius: 8px; cursor: pointer;" onclick="window.open('${escapeHtml(post.image_url)}', '_blank')" />
                    </div>
                ` : ''}
                ${post.coordinates ? `
                    <div class="post-location">
                        📍 Location: ${post.coordinates.lat?.toFixed(4)}, ${post.coordinates.lon?.toFixed(4)}
                    </div>
                ` : ''}
                <div class="post-actions">
                    <button class="reaction-btn ${userReaction?.reaction_type === 'like' ? 'liked' : ''}" 
                            onclick="toggleReaction('${post.id}', 'like')">
                        <span class="icon">👍</span>
                        <span class="like-count">${likes}</span>
                    </button>
                    <button class="reaction-btn ${userReaction?.reaction_type === 'dislike' ? 'disliked' : ''}" 
                            onclick="toggleReaction('${post.id}', 'dislike')">
                        <span class="icon">👎</span>
                        <span class="dislike-count">${dislikes}</span>
                    </button>
                    <button class="comment-toggle" onclick="toggleComments('${post.id}')">
                        <span class="icon">💬</span>
                        <span>Comments (${commentsCount})</span>
                    </button>
                </div>
                <div class="comments-section" id="comments-${post.id}" style="display: none;">
                    <div class="comments-list" id="comments-list-${post.id}">
                        ${await renderComments(comments)}
                    </div>
                    <div class="add-comment-form">
                        <textarea class="comment-input" placeholder="Add a comment..." rows="2"></textarea>
                        <button class="comment-submit-btn" onclick="submitComment('${post.id}')">Comment</button>
                    </div>
                </div>
            `;

                return postElement;
            }

            // Render comments
            async function renderComments(comments) {
                if (!comments || comments.length === 0) {
                    return '<div class="no-comments">No comments yet. Be the first to comment!</div>';
                }

                return comments.map(comment => `
                <div class="comment-item">
                    <div class="comment-avatar">${comment.username.charAt(0).toUpperCase()}</div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-username">@${comment.username}</span>
                            <span class="comment-time">${formatTime(comment.created_at)}</span>
                        </div>
                        <div class="comment-text">${escapeHtml(comment.content)}</div>
                    </div>
                </div>
            `).join('');
            }

            // ============================================
            // INBOX FUNCTIONS
            // ============================================

            // Load users list
            async function loadUsersList() {
                try {
                    console.log('🔍 Loading users list...');
                    console.log('Current user:', ChatSystem.currentUser);

                    // First, try to load ALL users (to debug)
                    let query = supabase
                        .from('user_profiles')
                        .select('*')
                        .order('username');

                    console.log('Executing query...');
                    const { data: users, error } = await query;

                    console.log('Query result:', { users, error });

                    if (error) {
                        console.error('❌ Supabase error loading users:', error);
                        console.error('Error details:', JSON.stringify(error, null, 2));

                        // Show the error to help debug
                        showUserMessage(`Error loading users: ${error.message}`, 'error');
                        renderUsersList([]);
                        return;
                    }

                    console.log(`📊 Found ${users?.length || 0} total users in database`);

                    // Filter out current user if authenticated
                    let filteredUsers = users || [];
                    if (ChatSystem.currentUser && ChatSystem.currentUser.id) {
                        filteredUsers = filteredUsers.filter(user => user.id !== ChatSystem.currentUser.id);
                        console.log(`📊 After filtering current user: ${filteredUsers.length} users`);
                    }

                    // Store users in ChatSystem
                    ChatSystem.users.clear();
                    filteredUsers.forEach(user => {
                        ChatSystem.users.set(user.id, user);
                    });

                    console.log('Rendering users list...');
                    renderUsersList(filteredUsers);
                    console.log(`✅ Successfully loaded and displayed ${filteredUsers.length} users`);

                } catch (error) {
                    console.error('❌ Unexpected error loading users:', error);
                    console.error('Error stack:', error.stack);
                    renderUsersList([]);
                    showUserMessage(`Error: ${error.message}`, 'error');
                }
            }

            // Render users list
            function renderUsersList(users) {
                console.log('🎨 Rendering users list, received:', users);
                const container = document.getElementById('users-container');

                if (!container) {
                    console.error('❌ Users container not found! Check if element with id="users-container" exists.');
                    return;
                }

                container.innerHTML = '';

                if (!users || users.length === 0) {
                    console.log('⚠️ No users to render, showing empty state');
                    container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #999;">
                        <p>No users found</p>
                        <p style="font-size: 12px; margin-top: 8px;">Users will appear here once they sign up</p>
                    </div>
                `;
                    return;
                }

                console.log(`🎨 Rendering ${users.length} users`);
                let renderedCount = 0;

                users.forEach((user, index) => {
                    if (!user || !user.id) {
                        console.warn(`⚠️ Skipping invalid user at index ${index}:`, user);
                        return; // Skip invalid users
                    }

                    // Use username, display_name, or email as fallback
                    const displayName = user.username || user.display_name || user.email?.split('@')[0] || 'User';
                    const firstLetter = displayName.charAt(0).toUpperCase();

                    console.log(`  - Rendering user ${index + 1}: ${displayName} (${user.id})`);

                    const userElement = document.createElement('div');
                    userElement.className = 'user-item';
                    userElement.dataset.userId = user.id;
                    userElement.innerHTML = `
                    <div class="user-avatar">${firstLetter}</div>
                    <div class="user-info">
                        <div class="user-name">${displayName}</div>
                        <div class="user-status">${user.is_online ? 'Online' : 'Offline'}</div>
                    </div>
                    <div class="user-online-indicator ${user.is_online ? '' : 'offline'}"></div>
                `;

                    userElement.addEventListener('click', () => {
                        console.log('👆 User clicked:', displayName);
                        selectChatPartner(user.id);
                    });
                    container.appendChild(userElement);
                    renderedCount++;
                });

                console.log(`✅ Successfully rendered ${renderedCount} users in the UI`);
            }

            // Select chat partner
            async function selectChatPartner(userId) {
                const user = ChatSystem.users.get(userId);
                if (!user) {
                    console.error('❌ User not found:', userId);
                    return;
                }

                ChatSystem.currentChatPartner = user;

                // Update UI - highlight selected user
                document.querySelectorAll('.user-item').forEach(item => {
                    item.classList.remove('selected');
                });
                const selectedElement = document.querySelector(`[data-user-id="${userId}"]`);
                if (selectedElement) {
                    selectedElement.classList.add('selected');
                }

                // Update chat partner name
                const partnerNameEl = document.getElementById('chat-partner-name');
                if (partnerNameEl) {
                    partnerNameEl.textContent = user.username || 'Unknown User';
                }

                // Show conversation area, hide users list and no-user message
                const usersList = document.querySelector('.users-list');
                const chatConversation = document.querySelector('.chat-conversation');
                const noUserMessage = document.getElementById('no-user-selected');
                if (usersList) usersList.style.display = 'none';
                if (chatConversation) chatConversation.style.display = 'flex';
                if (noUserMessage) noUserMessage.style.display = 'none';

                // Load conversation
                await loadConversation(userId);
            }

            // Load conversation
            async function loadConversation(partnerId) {
                try {
                    const { data: messages, error } = await supabase
                        .from('private_messages')
                        .select('*')
                        .or(`and(sender_id.eq.${ChatSystem.currentUser.id},receiver_id.eq.${partnerId}),and(sender_id.eq.${partnerId},receiver_id.eq.${ChatSystem.currentUser.id})`)
                        .order('created_at', { ascending: true });

                    if (error) throw error;

                    ChatSystem.messages.set(partnerId, messages || []);
                    renderMessages(messages || []);

                    // Ensure input area is visible
                    const messageInputArea = document.querySelector('.message-input-area');
                    if (messageInputArea) messageInputArea.style.display = 'flex';

                } catch (error) {
                    console.error('❌ Error loading conversation:', error);
                    showUserMessage('Error loading conversation', 'error');
                }
            }

            // Send private message
            async function sendPrivateMessage(receiverId, content, imageFile = null) {
                if (!content.trim() && !imageFile) {
                    showUserMessage('Please enter a message or add an image', 'warning');
                    return;
                }

                try {
                    let imageUrl = null;
                    if (imageFile) {
                        showUserMessage('Uploading image...', 'info');
                        imageUrl = await uploadChatImage(imageFile);
                        if (!imageUrl) {
                            showUserMessage('Image upload failed', 'error');
                            return;
                        }
                    }

                    const receiver = ChatSystem.users.get(receiverId);
                    const messageData = {
                        sender_id: ChatSystem.currentUser.id,
                        receiver_id: receiverId,
                        sender_username: ChatSystem.currentUser.username,
                        receiver_username: receiver.username,
                        content: content.trim(),
                        image_url: imageUrl
                    };

                    const { data, error } = await supabase
                        .from('private_messages')
                        .insert([messageData])
                        .select()
                        .single();

                    if (error) throw error;

                    console.log('✅ Message sent:', data.id);

                    // Clear input
                    document.getElementById('message-input').value = '';
                    removeImage('message-image-input', 'message-image-preview', 'message-image-btn');

                    // Reload conversation
                    await loadConversation(receiverId);

                } catch (error) {
                    console.error('❌ Error sending message:', error);
                    const errorMessage = error.message || error.details || JSON.stringify(error);
                    console.error('Error details:', errorMessage);
                    showUserMessage(`Error sending message: ${errorMessage}`, 'error');
                }
            }

            // Render messages
            function renderMessages(messages) {
                const container = document.getElementById('messages-container');
                if (!container) return;

                container.innerHTML = '';

                messages.forEach(message => {
                    // Robust check for sender ID (handle string vs number)
                    const isSent = String(message.sender_id) === String(ChatSystem.currentUser.id);
                    console.log(`Msg ${message.id}: Sender=${message.sender_id}, Me=${ChatSystem.currentUser.id}, isSent=${isSent}`);

                    const messageElement = document.createElement('div');
                    // Force flex layout and alignment via inline styles to override any conflicting CSS
                    messageElement.className = `message-item ${isSent ? 'sent' : 'received'}`;
                    messageElement.style.cssText = `
                        display: flex;
                        width: 100%;
                        justify-content: ${isSent ? 'flex-end' : 'flex-start'};
                        margin-bottom: 10px;
                    `;

                    messageElement.innerHTML = `
                    <div class="message-bubble">
                        <div class="message-text">${escapeHtml(message.content || '')}</div>
                        ${message.image_url ? `
                            <div class="message-image" style="margin-top: 8px;">
                                <img src="${escapeHtml(message.image_url)}" alt="Shared image" style="max-width: 100%; max-height: 300px; border-radius: 8px; cursor: pointer;" onclick="window.open('${escapeHtml(message.image_url)}', '_blank')" />
                            </div>
                        ` : ''}
                        <div class="message-time">${formatTime(message.created_at)}</div>
                        ${isSent ? `
                            <div class="message-status">
                                ${message.is_read ? '<span class="read">✓✓</span>' : '<span class="delivered">✓</span>'}
                            </div>
                        ` : ''}
                    </div>
                `;

                    container.appendChild(messageElement);
                });

                // Scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================

            // Create or update user profile
            async function createOrUpdateUserProfile(user) {
                try {
                    const { data, error } = await supabase
                        .from('user_profiles')
                        .upsert([{
                            id: user.id,
                            username: user.username,
                            display_name: user.username,
                            is_online: true,
                            last_seen: new Date().toISOString()
                        }], { onConflict: 'id' })
                        .select()
                        .single();

                    if (error) throw error;
                    return data;

                } catch (error) {
                    console.error('❌ Error creating/updating user profile:', error);
                    return null;
                }
            }

            // Setup real-time subscriptions
            function setupRealtimeSubscriptions() {
                console.log('🔄 Setting up real-time subscriptions...');

                // Subscribe to room posts
                const postsChannel = supabase
                    .channel('room_posts')
                    .on('postgres_changes',
                        { event: '*', schema: 'public', table: 'room_posts' },
                        async (payload) => {
                            console.log('📝 Post change received:', payload);
                            if (payload.new && payload.new.room_id === ChatSystem.currentRoom) {
                                await loadRoomPosts(ChatSystem.currentRoom);
                            }
                        }
                    )
                    .subscribe();

                // Subscribe to post comments
                const commentsChannel = supabase
                    .channel('post_comments')
                    .on('postgres_changes',
                        { event: '*', schema: 'public', table: 'post_comments' },
                        async (payload) => {
                            console.log('💬 Comment change received:', payload);
                            await loadRoomPosts(ChatSystem.currentRoom);
                        }
                    )
                    .subscribe();

                // Subscribe to post reactions
                const reactionsChannel = supabase
                    .channel('post_reactions')
                    .on('postgres_changes',
                        { event: '*', schema: 'public', table: 'post_reactions' },
                        async (payload) => {
                            console.log('👍 Reaction change received:', payload);
                            await loadRoomPosts(ChatSystem.currentRoom);
                        }
                    )
                    .subscribe();

                // Subscribe to private messages
                const messagesChannel = supabase
                    .channel('private_messages')
                    .on('postgres_changes',
                        {
                            event: 'INSERT',
                            schema: 'public',
                            table: 'private_messages',
                            filter: `receiver_id=eq.${ChatSystem.currentUser.id}`
                        },
                        async (payload) => {
                            console.log('📨 New message received:', payload);
                            if (ChatSystem.currentChatPartner &&
                                payload.new.sender_id === ChatSystem.currentChatPartner.id) {
                                await loadConversation(ChatSystem.currentChatPartner.id);
                            }
                        }
                    )
                    .subscribe();

                // Subscribe to user presence
                const presenceChannel = supabase
                    .channel('online_users')
                    .on('presence', { event: 'sync' }, () => {
                        console.log('👥 Presence sync received');
                        updateUserPresence();
                    })
                    .subscribe(async (status) => {
                        if (status === 'SUBSCRIBED') {
                            await supabase
                                .channel('online_users')
                                .track({
                                    user_id: ChatSystem.currentUser.id,
                                    username: ChatSystem.currentUser.username,
                                    online_at: new Date().toISOString()
                                });
                        }
                    });

                ChatSystem.subscriptions.push(postsChannel, commentsChannel, reactionsChannel, messagesChannel, presenceChannel);
            }

            // Update user presence
            async function updateUserPresence() {
                try {
                    const { data, error } = await supabase
                        .from('user_profiles')
                        .update({
                            is_online: true,
                            last_seen: new Date().toISOString()
                        })
                        .eq('id', ChatSystem.currentUser.id);

                    if (error) throw error;

                } catch (error) {
                    console.error('❌ Error updating user presence:', error);
                }
            }

            // Format time
            function formatTime(dateString) {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;

                return date.toLocaleDateString();
            }

            // Escape HTML
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Show user message
            function showUserMessage(message, type = 'info') {
                console.log(`💬 ${type.toUpperCase()}: ${message}`);

                // Create toast notification
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10001;
                max-width: 300px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#2196f3'};
            `;

                document.body.appendChild(toast);

                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 4000);
            }

            // ============================================
            // EVENT HANDLERS
            // ============================================

            // Setup event listeners
            function setupSocialChatEventListeners() {
                console.log('🎧 Setting up social chat event listeners...');

                // Tab switching
                document.getElementById('tab-rooms')?.addEventListener('click', () => switchTab('rooms'));
                document.getElementById('tab-inbox')?.addEventListener('click', () => switchTab('inbox'));

                // Room selection
                document.getElementById('room-select')?.addEventListener('change', async (e) => {
                    await loadRoomPosts(e.target.value);
                });

                // Post submission
                document.getElementById('post-submit-btn')?.addEventListener('click', async () => {
                    const content = document.getElementById('post-input').value;
                    const imageInput = document.getElementById('post-image-input');
                    const imageFile = imageInput && imageInput.files[0] ? imageInput.files[0] : null;
                    await createPost(content, null, imageFile);
                });

                // Share location (chatroom)
                document.getElementById('share-location-btn')?.addEventListener('click', () => {
                    const center = map.getView().getCenter();
                    const lonLat = ol.proj.toLonLat(center);
                    const content = document.getElementById('post-input').value;
                    const locationInfo = `\n📍 Location: ${lonLat[1].toFixed(4)}, ${lonLat[0].toFixed(4)}`;
                    document.getElementById('post-input').value = content + locationInfo;
                });

                // Share location (inbox)
                document.getElementById('message-share-location-btn')?.addEventListener('click', () => {
                    const center = map.getView().getCenter();
                    const lonLat = ol.proj.toLonLat(center);
                    const content = document.getElementById('message-input').value;
                    const locationInfo = `\n📍 Location: ${lonLat[1].toFixed(4)}, ${lonLat[0].toFixed(4)}`;
                    document.getElementById('message-input').value = content + locationInfo;
                });

                // User search
                document.getElementById('user-search')?.addEventListener('input', (e) => {
                    filterUsers(e.target.value);
                });

                // Message sending
                document.getElementById('message-send-btn')?.addEventListener('click', async () => {
                    if (!ChatSystem.currentChatPartner) return;
                    const content = document.getElementById('message-input').value;
                    const imageInput = document.getElementById('message-image-input');
                    const imageFile = imageInput && imageInput.files[0] ? imageInput.files[0] : null;
                    await sendPrivateMessage(ChatSystem.currentChatPartner.id, content, imageFile);
                });

                // Message Image Button
                // Message Image Button
                const msgImgBtn = document.getElementById('message-image-btn');
                const msgImgInput = document.getElementById('message-image-input');

                if (msgImgBtn && msgImgInput) {
                    console.log('✅ Found message image elements, attaching listeners');
                    msgImgBtn.addEventListener('click', () => {
                        console.log('📸 Message image button clicked');
                        msgImgInput.click();
                    });

                    // Message Image Input Change (Preview)
                    msgImgInput.addEventListener('change', (e) => {
                        console.log('📁 File selected for message');
                        handleImagePreview(
                            e,
                            'message-image-preview',
                            'message-image-btn',
                            'message-image-input'
                        );
                    });
                } else {
                    console.error('❌ Could not find message image button or input!');
                }

                // Message Image Input Change (Preview)
                document.getElementById('message-image-input')?.addEventListener('change', (e) => {
                    handleImagePreview(
                        e,
                        'message-image-preview',
                        'message-image-btn',
                        'message-image-input'
                    );
                });

                // Back to users button
                document.getElementById('back-to-users')?.addEventListener('click', () => {
                    // Hide conversation, show users list
                    const usersList = document.querySelector('.users-list');
                    const chatConversation = document.querySelector('.chat-conversation');
                    const noUserMessage = document.getElementById('no-user-selected');
                    if (usersList) usersList.style.display = 'flex';
                    if (chatConversation) chatConversation.style.display = 'none';
                    if (noUserMessage) noUserMessage.style.display = 'flex';

                    // Clear selected user
                    ChatSystem.currentChatPartner = null;
                    document.querySelectorAll('.user-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    const partnerNameEl = document.getElementById('chat-partner-name');
                    if (partnerNameEl) partnerNameEl.textContent = 'Select a user';
                });

                // Enter key handlers
                document.getElementById('post-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('post-submit-btn').click();
                    }
                });

                document.getElementById('message-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('message-send-btn').click();
                    }
                });

                // Initialize image upload handling
                handleImageSelection('post-image-input', 'post-image-preview', 'post-image-btn');
                handleImageSelection('message-image-input', 'message-image-preview', 'message-image-btn');

                console.log('✅ Social chat event listeners set up');
            }

            // Switch between tabs
            async function switchTab(tab) {
                ChatSystem.currentMode = tab;

                // Update tab buttons
                document.querySelectorAll('.chat-tab').forEach(t => t.classList.remove('active'));
                document.getElementById(`tab-${tab}`).classList.add('active');

                // Update views
                document.querySelectorAll('.chat-view').forEach(v => v.classList.remove('active'));
                document.getElementById(`${tab}-view`).classList.add('active');

                // Load users list when switching to inbox tab
                if (tab === 'inbox') {
                    await loadUsersList();
                    // Show the "select user" message initially
                    const noUserMessage = document.getElementById('no-user-selected');
                    if (noUserMessage) noUserMessage.style.display = 'flex';

                    // Ensure conversation is hidden and users list is shown initially
                    const usersList = document.querySelector('.users-list');
                    const chatConversation = document.querySelector('.chat-conversation');
                    if (usersList) usersList.style.display = 'flex';
                    if (chatConversation) chatConversation.style.display = 'none';

                    // Ensure input area is hidden initially
                    const messageInputArea = document.querySelector('.message-input-area');
                    if (messageInputArea) messageInputArea.style.display = 'none';
                }

                console.log(`📱 Switched to ${tab} tab`);
            }

            // Filter users
            function filterUsers(searchTerm) {
                const users = Array.from(ChatSystem.users.values());
                const filtered = users.filter(user =>
                    user.username.toLowerCase().includes(searchTerm.toLowerCase())
                );
                renderUsersList(filtered);
            }

            // Toggle comments section
            function toggleComments(postId) {
                const commentsSection = document.getElementById(`comments-${postId}`);
                if (commentsSection.style.display === 'none') {
                    commentsSection.style.display = 'block';
                } else {
                    commentsSection.style.display = 'none';
                }
            }

            // Submit comment
            async function submitComment(postId) {
                const commentInput = document.querySelector(`#comments-${postId} .comment-input`);
                const content = commentInput.value;
                if (content.trim()) {
                    await addComment(postId, content);
                    commentInput.value = '';
                }
            }

            // Initialize when DOM is ready
            document.addEventListener('DOMContentLoaded', function () {
                // Initialize after a short delay to ensure other systems are ready
                setTimeout(() => {
                    initializeSocialChat();
                }, 1000);
            });

            // Make functions globally available
            window.toggleReaction = toggleReaction;
            window.toggleComments = toggleComments;
            window.submitComment = submitComment;
            window.switchTab = switchTab;

        </script>

        <!-- Social Chat System Panel -->
        <div class="chat-panel" id="chatPanel">
            <div class="chat-header">
                <div class="chat-tabs">
                    <button id="tab-rooms" class="chat-tab active">Chat Rooms</button>
                    <button id="tab-inbox" class="chat-tab">Inbox</button>
                </div>
                <div class="chat-controls">
                    <button type="button" class="icon-btn" id="propertySearchBtn" title="Property Search">
                        <i class="fas fa-search-location"></i>
                    </button>
                    <button type="button" class="icon-btn" id="markPropertyBtn" title="List Property for Sale">
                        <i class="fas fa-home"></i>
                        <i class="fas fa-plus-circle icon-overlay"></i>
                    </button>
                    <button type="button" class="icon-btn" id="themeToggleBtn" title="Toggle Dark/Light Mode">
                        <i class="fas fa-moon"></i>
                    </button>
                    <span class="online-count" id="onlineCount">0 online</span>
                    <button type="button" class="chat-close" id="chatClose" aria-label="Close chat">&times;</button>
                </div>
            </div>

            <!-- Chat Rooms View -->
            <div id="rooms-view" class="chat-view active">
                <div class="room-selector">
                    <select id="room-select" class="room-dropdown">
                        <option value="general">General Chat</option>
                    </select>
                </div>
                <div id="posts-container" class="posts-list">
                    <!-- Posts will appear here -->
                </div>
                <div class="post-input-area">
                    <textarea id="post-input" placeholder="Share your thoughts..." rows="3"></textarea>
                    <div class="post-actions">
                        <input type="file" id="post-image-input" accept="image/*" style="display: none;" />
                        <button id="post-image-btn" title="Add Image" class="image-upload-btn">
                            <i class="fas fa-image"></i>
                        </button>
                        <button id="share-location-btn" title="Share Location">
                            <i class="fas fa-crosshairs"></i>
                        </button>
                        <button id="post-submit-btn" class="post-submit">Post</button>
                    </div>
                    <div id="post-image-preview" class="image-preview" style="display: none;"></div>
                </div>
            </div>

            <!-- Inbox View -->
            <div id="inbox-view" class="chat-view">
                <div class="inbox-layout">
                    <div class="users-list">
                        <input type="text" id="user-search" placeholder="Search users..." class="user-search-input">
                        <div id="users-container" class="users-container">
                            <!-- Users will appear here -->
                        </div>
                    </div>
                    <div class="chat-conversation">
                        <div class="conversation-header">
                            <span id="chat-partner-name">Select a user</span>
                            <div class="conversation-actions">
                                <button id="back-to-users" class="back-btn" title="Back to users">
                                    <i class="fas fa-arrow-left"></i>
                                </button>
                            </div>
                        </div>
                        <div id="messages-container" class="messages-list">
                            <!-- Private messages will appear here -->
                            <div id="no-user-selected" class="no-user-message"
                                style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666; font-style: italic;">
                                Select a user to start chatting
                            </div>
                        </div>
                        <div class="message-input-area">
                            <textarea id="message-input" placeholder="Type a message..." rows="3"></textarea>
                            <div class="message-actions">
                                <div style="display: flex; gap: 8px;">
                                    <input type="file" id="message-image-input" accept="image/*"
                                        style="display: none;" />
                                    <button id="message-image-btn" title="Add Image" class="image-upload-btn">
                                        <i class="fas fa-image"></i>
                                    </button>
                                    <button id="message-share-location-btn" title="Share Location"
                                        class="image-upload-btn">
                                        <i class="fas fa-crosshairs"></i>
                                    </button>
                                </div>
                                <button id="message-send-btn" class="message-send">Send</button>
                            </div>
                            <div id="message-image-preview" class="image-preview" style="display: none;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Property Valuation Panel -->
        <div class="valuation-panel" id="valuationPanel">
            <div class="valuation-header">
                <h3><i class="fas fa-coins"></i> Property Valuation</h3>
                <button type="button" class="valuation-close" id="valuationClose" aria-label="Close">&times;</button>
            </div>

            <div class="valuation-body">
                <div class="valuation-tabs">
                    <button class="valuation-tab active" data-tab="add-property">Value a Property</button>
                    <button class="valuation-tab" data-tab="auto-value">Auto-Value</button>
                    <button class="valuation-tab" data-tab="field-capture">Field Capture</button>
                    <button class="valuation-tab" data-tab="view-properties">View Properties</button>
                    <button class="valuation-tab" data-tab="migration-admin" style="display: none;"
                        id="migrationAdminTab">Migration Admin</button>
                </div>

                <!-- Tool 1: Value a Property -->
                <div id="add-property-tab" class="valuation-tab-content active">
                    <div class="valuation-info-box">
                        <h4><i class="fas fa-info-circle"></i> Instructions</h4>
                        <p>Click "Start" to activate map selection, then click on the map to place a property marker and
                            fill in the property details.</p>
                    </div>
                    <button type="button" class="valuation-btn" id="startAddPropertyBtn">
                        <i class="fas fa-plus-circle"></i> Start
                    </button>
                    <div id="propertyFormContainer" style="display: none;">
                        <form id="propertyForm">
                            <div class="valuation-form-group">
                                <label for="propertyDistrict">District *</label>
                                <select id="propertyDistrict" required>
                                    <option value="">Select District</option>
                                    <!-- Districts will be populated by JavaScript -->
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyCounty">County *</label>
                                <input type="text" id="propertyCounty" required placeholder="Enter county name">
                                <small class="form-hint">County within the selected district</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyVillage">Village/Parish Name *</label>
                                <input type="text" id="propertyVillage" required
                                    placeholder="Start typing village name..." autocomplete="off">
                                <small class="form-hint">Village autocomplete will suggest existing villages</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyProprietor">Proprietor/Owner Name</label>
                                <input type="text" id="propertyProprietor"
                                    placeholder="Enter property owner/proprietor name">
                                <small class="form-hint">Name of the property owner or proprietor</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyPlotNumber">Plot Number *</label>
                                <input type="text" id="propertyPlotNumber" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyBlockNumber">Block Number</label>
                                <input type="text" id="propertyBlockNumber">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyTenure">Tenure *</label>
                                <select id="propertyTenure" required>
                                    <option value="">Select Tenure</option>
                                    <option value="Freehold">Freehold</option>
                                    <option value="Leasehold">Leasehold</option>
                                    <option value="Customary">Customary</option>
                                    <option value="Mailo">Mailo</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyValuationMethod">Valuation Method *</label>
                                <select id="propertyValuationMethod" required>
                                    <option value="">Select Method</option>
                                    <option value="Comparable Sales">Comparable Sales</option>
                                    <option value="Income Approach">Income Approach</option>
                                    <option value="Cost Approach">Cost Approach</option>
                                    <option value="Hybrid">Hybrid</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label>Valuation Scope *</label>
                                <div class="radio-group" style="display: flex; flex-direction: column; gap: 10px;">
                                    <label style="display: flex; align-items: center; gap: 8px;">
                                        <input type="radio" name="propertyValuationScope" value="Land Only" checked>
                                        <span>Land Only</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px;">
                                        <input type="radio" name="propertyValuationScope" value="Land + Improvements">
                                        <span>Land + Improvements</span>
                                    </label>
                                </div>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyLandValue">Land Value (UGX) *</label>
                                <input type="number" id="propertyLandValue" min="0" step="0.01" required>
                                <small class="form-hint">Value of the bare land</small>
                            </div>
                            <div class="valuation-form-group" id="propertyImprovementsValueGroup"
                                style="display: none;">
                                <label for="propertyImprovementsValue">Improvements Value (UGX)</label>
                                <input type="number" id="propertyImprovementsValue" min="0" step="0.01">
                                <small class="form-hint">Value of buildings, structures, and other improvements</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyTotalValue">Total Value (UGX)</label>
                                <input type="number" id="propertyTotalValue" readonly
                                    style="background-color: #f5f5f5; font-weight: bold;">
                                <small class="form-hint">Auto-calculated: Land Value + Improvements Value</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyPriceUGX">Total Price (UGX)</label>
                                <input type="number" id="propertyPriceUGX" min="0" step="1000" readonly
                                    style="background-color: #f5f5f5; font-weight: bold;">
                                <small class="form-hint">Auto-calculated from Land Value + Improvements Value</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyType">Property Type *</label>
                                <select id="propertyType" required>
                                    <option value="">Select Type</option>
                                    <option value="Residential">Residential</option>
                                    <option value="Commercial">Commercial</option>
                                    <option value="Agricultural">Agricultural</option>
                                    <option value="Industrial">Industrial</option>
                                    <option value="Mixed">Mixed</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertySizeSQM">Property Size (Square Meters) *</label>
                                <input type="number" id="propertySizeSQM" min="0" step="0.01" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertySizeAcres">Property Size (Acres)</label>
                                <input type="number" id="propertySizeAcres" min="0" step="0.01" readonly>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyRooms">Number of Rooms</label>
                                <input type="number" id="propertyRooms" min="0">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyFloors">Number of Floors</label>
                                <input type="number" id="propertyFloors" min="0">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyAge">Property Age (Years)</label>
                                <input type="number" id="propertyAge" min="0">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyCondition">Property Condition</label>
                                <select id="propertyCondition">
                                    <option value="">Select Condition</option>
                                    <option value="Excellent">Excellent</option>
                                    <option value="Good">Good</option>
                                    <option value="Fair">Fair</option>
                                    <option value="Poor">Poor</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyRoadAccess">Road Access</label>
                                <select id="propertyRoadAccess">
                                    <option value="">Select Access</option>
                                    <option value="Tarmac">Tarmac</option>
                                    <option value="Murram">Murram</option>
                                    <option value="Footpath">Footpath</option>
                                    <option value="None">None</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyZoning">Zoning</label>
                                <input type="text" id="propertyZoning">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyLandUse">Land Use</label>
                                <select id="propertyLandUse">
                                    <option value="">Select Land Use</option>
                                    <option value="Residential">Residential</option>
                                    <option value="Commercial">Commercial</option>
                                    <option value="Agricultural">Agricultural</option>
                                    <option value="Industrial">Industrial</option>
                                    <option value="Mixed">Mixed</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyLegalStatus">Legal Status</label>
                                <select id="propertyLegalStatus">
                                    <option value="">Select Status</option>
                                    <option value="Titled">Titled</option>
                                    <option value="Leasehold">Leasehold</option>
                                    <option value="Customary">Customary</option>
                                    <option value="Pending">Pending</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label>
                                    <input type="checkbox" id="propertyHasElectricity"> Has Electricity
                                </label>
                            </div>
                            <div class="valuation-form-group">
                                <label>
                                    <input type="checkbox" id="propertyHasWater"> Has Water
                                </label>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyProximitySchools">Proximity to Schools (km)</label>
                                <input type="number" id="propertyProximitySchools" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyProximityHospitals">Proximity to Hospitals (km)</label>
                                <input type="number" id="propertyProximityHospitals" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyProximityMarkets">Proximity to Markets (km)</label>
                                <input type="number" id="propertyProximityMarkets" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertyValuationDate">Valuation Date *</label>
                                <input type="date" id="propertyValuationDate" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertySurveyorName">Surveyor Name</label>
                                <input type="text" id="propertySurveyorName">
                            </div>
                            <div class="valuation-form-group">
                                <label for="propertySurveyorID">Surveyor ID</label>
                                <input type="text" id="propertySurveyorID">
                            </div>

                            <!-- Image Upload Section -->
                            <div class="valuation-form-group valuation-image-upload-section">
                                <h4 style="margin-bottom: 15px; color: #333; font-size: 1rem;">
                                    <i class="fas fa-images"></i> Property Images
                                </h4>

                                <!-- Property Images -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">
                                        Property Photos (2)
                                    </label>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                                        <input type="file" id="propertyImage1Input" accept="image/*"
                                            style="display: none;" />
                                        <button type="button" class="valuation-image-btn" id="propertyImage1Btn">
                                            <i class="fas fa-camera"></i> Photo 1
                                        </button>

                                        <input type="file" id="propertyImage2Input" accept="image/*"
                                            style="display: none;" />
                                        <button type="button" class="valuation-image-btn" id="propertyImage2Btn">
                                            <i class="fas fa-camera"></i> Photo 2
                                        </button>
                                    </div>
                                    <div id="propertyImagesPreview" class="valuation-image-preview-grid"></div>
                                </div>

                                <!-- Document Images -->
                                <div>
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">
                                        Supporting Documents (2)
                                    </label>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                                        <input type="file" id="documentImage1Input" accept="image/*"
                                            style="display: none;" />
                                        <button type="button" class="valuation-image-btn" id="documentImage1Btn">
                                            <i class="fas fa-file-image"></i> Document 1
                                        </button>

                                        <input type="file" id="documentImage2Input" accept="image/*"
                                            style="display: none;" />
                                        <button type="button" class="valuation-image-btn" id="documentImage2Btn">
                                            <i class="fas fa-file-image"></i> Document 2
                                        </button>
                                    </div>
                                    <div id="documentImagesPreview" class="valuation-image-preview-grid"></div>
                                </div>

                                <small class="form-hint" style="display: block; margin-top: 10px;">
                                    <i class="fas fa-info-circle"></i> Upload clear photos of the property and
                                    supporting documents (title deeds, surveys, etc.)
                                </small>
                            </div>

                            <div class="valuation-form-group">
                                <label for="propertyNotes">Notes</label>
                                <textarea id="propertyNotes" rows="4"></textarea>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button type="button" class="valuation-btn secondary" id="cancelPropertyBtn">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                                <button type="submit" class="valuation-btn" id="savePropertyBtn">
                                    <i class="fas fa-save"></i> Save Property
                                </button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Tool 2: Auto-Value Property -->
                <div id="auto-value-tab" class="valuation-tab-content">
                    <div class="valuation-info-box">
                        <h4><i class="fas fa-info-circle"></i> Auto-Valuation Workflow</h4>
                        <p><strong>Step 1:</strong> Click "Start Auto-Valuation" and mark the property location on the
                            map.<br>
                            <strong>Step 2:</strong> Fill in the property details below.<br>
                            <strong>Step 3:</strong> Generate the valuation report.
                        </p>
                    </div>
                    <button type="button" class="valuation-btn" id="startAutoValueBtn">
                        <i class="fas fa-calculator"></i> Start Auto-Valuation
                    </button>

                    <!-- Property Form for Auto-Valuation (hidden initially) -->
                    <div id="autoValueFormContainer" style="display: none;">
                        <div class="valuation-info-box" style="margin-top: 15px;">
                            <h4><i class="fas fa-map-marker-alt"></i> Location Selected</h4>
                            <p id="autoValueLocationInfo">Location marked on map. Please fill in property details below.
                            </p>
                        </div>
                        <form id="autoValuePropertyForm">
                            <div class="valuation-form-group">
                                <label for="autoValueDistrict">District *</label>
                                <select id="autoValueDistrict" required>
                                    <option value="">Select District</option>
                                    <!-- Districts will be populated by JavaScript -->
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueCounty">County *</label>
                                <input type="text" id="autoValueCounty" required placeholder="Enter county name">
                                <small class="form-hint">County within the selected district</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueVillage">Village/Parish Name *</label>
                                <input type="text" id="autoValueVillage" required
                                    placeholder="Start typing village name..." autocomplete="off">
                                <small class="form-hint">Village autocomplete will suggest existing villages</small>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValuePlotNumber">Plot Number *</label>
                                <input type="text" id="autoValuePlotNumber" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueBlockNumber">Block Number</label>
                                <input type="text" id="autoValueBlockNumber">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueTenure">Tenure *</label>
                                <select id="autoValueTenure" required>
                                    <option value="">Select Tenure</option>
                                    <option value="Freehold">Freehold</option>
                                    <option value="Leasehold">Leasehold</option>
                                    <option value="Customary">Customary</option>
                                    <option value="Mailo">Mailo</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValuePropertyType">Property Type *</label>
                                <select id="autoValuePropertyType" required>
                                    <option value="">Select Type</option>
                                    <option value="Residential">Residential</option>
                                    <option value="Commercial">Commercial</option>
                                    <option value="Agricultural">Agricultural</option>
                                    <option value="Industrial">Industrial</option>
                                    <option value="Mixed">Mixed</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValuePropertySizeSQM">Property Size (Square Meters) *</label>
                                <input type="number" id="autoValuePropertySizeSQM" min="0" step="0.01" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValuePropertySizeAcres">Property Size (Acres)</label>
                                <input type="number" id="autoValuePropertySizeAcres" min="0" step="0.01" readonly>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueRooms">Number of Rooms</label>
                                <input type="number" id="autoValueRooms" min="0">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueFloors">Number of Floors</label>
                                <input type="number" id="autoValueFloors" min="0">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueCondition">Property Condition</label>
                                <select id="autoValueCondition">
                                    <option value="">Select Condition</option>
                                    <option value="Excellent">Excellent</option>
                                    <option value="Good">Good</option>
                                    <option value="Fair">Fair</option>
                                    <option value="Poor">Poor</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueRoadAccess">Road Access</label>
                                <select id="autoValueRoadAccess">
                                    <option value="">Select Access</option>
                                    <option value="Tarmac">Tarmac</option>
                                    <option value="Murram">Murram</option>
                                    <option value="Footpath">Footpath</option>
                                    <option value="None">None</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueZoning">Zoning</label>
                                <input type="text" id="autoValueZoning">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueLandUse">Land Use</label>
                                <select id="autoValueLandUse">
                                    <option value="">Select Land Use</option>
                                    <option value="Residential">Residential</option>
                                    <option value="Commercial">Commercial</option>
                                    <option value="Agricultural">Agricultural</option>
                                    <option value="Industrial">Industrial</option>
                                    <option value="Mixed">Mixed</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueLegalStatus">Legal Status</label>
                                <select id="autoValueLegalStatus">
                                    <option value="">Select Status</option>
                                    <option value="Titled">Titled</option>
                                    <option value="Leasehold">Leasehold</option>
                                    <option value="Customary">Customary</option>
                                    <option value="Pending">Pending</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label>
                                    <input type="checkbox" id="autoValueHasElectricity"> Has Electricity
                                </label>
                            </div>
                            <div class="valuation-form-group">
                                <label>
                                    <input type="checkbox" id="autoValueHasWater"> Has Water
                                </label>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueProximitySchools">Proximity to Schools (km)</label>
                                <input type="number" id="autoValueProximitySchools" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueProximityHospitals">Proximity to Hospitals (km)</label>
                                <input type="number" id="autoValueProximityHospitals" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueProximityMarkets">Proximity to Markets (km)</label>
                                <input type="number" id="autoValueProximityMarkets" min="0" step="0.1">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueValuationDate">Valuation Date *</label>
                                <input type="date" id="autoValueValuationDate" required>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueSurveyorName">Surveyor Name</label>
                                <input type="text" id="autoValueSurveyorName">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueSurveyorID">Surveyor ID</label>
                                <input type="text" id="autoValueSurveyorID">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueNotes">Notes</label>
                                <textarea id="autoValueNotes" rows="3"></textarea>
                            </div>
                            <hr style="margin: 20px 0; border: none; border-top: 1px solid rgba(0,0,0,0.1);">
                            <div class="valuation-info-box">
                                <h4><i class="fas fa-calculator"></i> Auto-Valuation Scope</h4>
                                <p>Select what to calculate: Land value only or total value (land + improvements).</p>
                            </div>
                            <div class="valuation-form-group">
                                <label>Calculate *</label>
                                <div class="radio-group" style="display: flex; flex-direction: column; gap: 10px;">
                                    <label style="display: flex; align-items: center; gap: 8px;">
                                        <input type="radio" name="autoValueScope" value="Land Only" checked>
                                        <span>Land Value Only (Recommended)</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px;">
                                        <input type="radio" name="autoValueScope" value="Land + Improvements">
                                        <span>Total Value (Land + Improvements)</span>
                                        <small style="display: block; color: #666; margin-top: 4px; margin-left: 24px;">
                                            Requires comparables with improvements data
                                        </small>
                                    </label>
                                </div>
                            </div>
                            <div class="valuation-info-box">
                                <h4><i class="fas fa-filter"></i> Comparable Search Priority</h4>
                                <p>System will search in this order:</p>
                                <ol style="margin: 10px 0; padding-left: 20px;">
                                    <li>Same Village (Primary)</li>
                                    <li>Same County (Secondary)</li>
                                    <li>Same District (Fallback)</li>
                                </ol>
                            </div>
                            <div class="valuation-form-group">
                                <label>
                                    <input type="checkbox" id="strictVillageMatch" checked>
                                    Strict Village Match (Recommended)
                                </label>
                                <small class="form-hint">
                                    If unchecked, will expand to county/district if village has insufficient comparables
                                </small>
                            </div>
                            <hr style="margin: 20px 0; border: none; border-top: 1px solid rgba(0,0,0,0.1);">
                            <div class="valuation-info-box">
                                <h4><i class="fas fa-filter"></i> Comparable Filters</h4>
                                <p>Reuse the same criteria as "View Properties" to source comparables before running
                                    auto-valuation.</p>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueTenureFilter">Tenure Filter</label>
                                <select id="autoValueTenureFilter">
                                    <option value="">All Tenures</option>
                                    <option value="Freehold">Freehold</option>
                                    <option value="Leasehold">Leasehold</option>
                                    <option value="Customary">Customary</option>
                                    <option value="Mailo">Mailo</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueValuationMethodFilter">Valuation Method Filter</label>
                                <select id="autoValueValuationMethodFilter">
                                    <option value="">All Methods</option>
                                    <option value="Comparable Sales">Comparable Sales</option>
                                    <option value="Income Approach">Income Approach</option>
                                    <option value="Cost Approach">Cost Approach</option>
                                    <option value="Hybrid">Hybrid</option>
                                </select>
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueMinPriceFilter">Min Price (UGX)</label>
                                <input type="number" id="autoValueMinPriceFilter" min="0" step="1000">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueMaxPriceFilter">Max Price (UGX)</label>
                                <input type="number" id="autoValueMaxPriceFilter" min="0" step="1000">
                            </div>
                            <div class="valuation-form-group">
                                <button type="button" class="valuation-btn secondary" id="loadComparablesBtn">
                                    <i class="fas fa-search"></i> Load Comparables
                                </button>
                            </div>
                            <div id="autoValueComparablesListContainer" class="valuation-form-group"
                                style="display: none;">
                                <div class="valuation-info-box" style="margin-bottom: 10px;">
                                    <h4><i class="fas fa-list-ul"></i> Manual Comparable Selection</h4>
                                    <p>Select properties from the list or toggle map selection mode to pick pins
                                        directly.</p>
                                    <div id="autoValueSelectedSummary" style="font-weight: 600;"></div>
                                </div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                                    <button type="button" class="valuation-btn" id="useSelectedComparablesBtn">
                                        <i class="fas fa-check-circle"></i> Use Selected
                                    </button>
                                    <button type="button" class="valuation-btn secondary"
                                        id="clearSelectedComparablesBtn">
                                        <i class="fas fa-times-circle"></i> Clear Selection
                                    </button>
                                    <button type="button" class="valuation-btn secondary"
                                        id="toggleComparableMapSelectBtn">
                                        <i class="fas fa-map-marker-alt"></i> Enable Map Selection
                                    </button>
                                </div>
                                <div id="autoValueComparablesList" class="valuation-properties-list"
                                    style="max-height: 220px; overflow-y: auto;">
                                    <!-- Comparables will be injected here -->
                                </div>
                            </div>
                            <div class="valuation-form-group">
                                <label for="reportClientName">Client / Institution</label>
                                <input type="text" id="reportClientName" placeholder="e.g., ABC Commercial Bank">
                            </div>
                            <div class="valuation-form-group">
                                <label for="reportReference">Report Reference</label>
                                <input type="text" id="reportReference" placeholder="e.g., VAL-2025-001">
                            </div>
                            <div class="valuation-form-group">
                                <label for="reportBrandName">Prepared By</label>
                                <input type="text" id="reportBrandName"
                                    placeholder="Your valuation firm or valuer name">
                            </div>
                            <div class="valuation-form-group">
                                <label for="autoValueRadius">Calculation Radius (km) *</label>
                                <input type="number" id="autoValueRadius" min="0.5" max="10" step="0.5" value="2"
                                    required>
                                <small>Radius within which to search for comparable properties</small>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button type="button" class="valuation-btn secondary" id="cancelAutoValueBtn">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                                <button type="button" class="valuation-btn" id="generateReportBtn">
                                    <i class="fas fa-file-alt"></i> Generate Valuation Report
                                </button>
                            </div>
                        </form>
                    </div>
                    <div class="valuation-info-box" id="autoValueInsightsBox" style="display: none; margin-top: 20px;">
                        <h4><i class="fas fa-lightbulb"></i> Market Insights</h4>
                        <div id="autoValueInsightsContent"></div>
                    </div>

                    <!-- Report Display Container -->
                    <div id="autoValueReportContainer" style="display: none;">
                        <div class="valuation-report" id="autoValueReport">
                            <!-- Report will be generated here -->
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button type="button" class="valuation-btn secondary" id="closeReportBtn">
                                <i class="fas fa-times"></i> Close Report
                            </button>
                            <button type="button" class="valuation-btn" id="exportReportCSVBtn">
                                <i class="fas fa-file-csv"></i> Export CSV
                            </button>
                            <button type="button" class="valuation-btn" id="exportReportPDFBtn">
                                <i class="fas fa-file-pdf"></i> Export PDF
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tool 3: Field Data Capture -->
                <div id="field-capture-tab" class="valuation-tab-content">
                    <div class="valuation-info-box">
                        <h4><i class="fas fa-clipboard-list"></i> Field Data Capture</h4>
                        <p>Record property observations during site visits. Entries are stored offline and can be synced
                            to the cloud when you have a connection.</p>
                    </div>
                    <form id="fieldCaptureForm">
                        <div class="valuation-form-group">
                            <label for="fieldSiteName">Site / Client Reference *</label>
                            <input type="text" id="fieldSiteName" required placeholder="e.g., Plot 12 Nile Avenue">
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldCaptureDistrict">District *</label>
                            <select id="fieldCaptureDistrict" required>
                                <option value="">Select District</option>
                            </select>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldCaptureCounty">County *</label>
                            <input type="text" id="fieldCaptureCounty" required placeholder="Enter county name">
                            <small class="form-hint">County within the selected district</small>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldCaptureVillage">Village/Parish Name *</label>
                            <input type="text" id="fieldCaptureVillage" required
                                placeholder="Start typing village name..." autocomplete="off">
                            <small class="form-hint">Village autocomplete will suggest existing villages</small>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldCaptureTenure">Tenure</label>
                            <select id="fieldCaptureTenure">
                                <option value="">Select Tenure</option>
                                <option value="Freehold">Freehold</option>
                                <option value="Leasehold">Leasehold</option>
                                <option value="Customary">Customary</option>
                                <option value="Mailo">Mailo</option>
                            </select>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldCapturePropertyType">Property Type</label>
                            <select id="fieldCapturePropertyType">
                                <option value="">Select Type</option>
                                <option value="Residential">Residential</option>
                                <option value="Commercial">Commercial</option>
                                <option value="Agricultural">Agricultural</option>
                                <option value="Industrial">Industrial</option>
                                <option value="Mixed">Mixed</option>
                            </select>
                        </div>
                        <div class="valuation-form-group"
                            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                            <div>
                                <label for="fieldLatitude">Latitude *</label>
                                <input type="text" id="fieldLatitude" required placeholder="e.g., 0.3476">
                            </div>
                            <div>
                                <label for="fieldLongitude">Longitude *</label>
                                <input type="text" id="fieldLongitude" required placeholder="e.g., 32.5825">
                            </div>
                        </div>
                        <div class="valuation-form-group">
                            <button type="button" class="valuation-btn secondary" id="fieldUseLocationBtn">
                                <i class="fas fa-location-arrow"></i> Use Device Location
                            </button>
                            <button type="button" class="valuation-btn secondary" id="fieldMapSelectBtn">
                                <i class="fas fa-map-marker-alt"></i> Select on Map
                            </button>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldVisitDate">Visit Date *</label>
                            <input type="date" id="fieldVisitDate" required>
                        </div>
                        <div class="valuation-form-group">
                            <label for="fieldNotes">Observations</label>
                            <textarea id="fieldNotes" rows="4"
                                placeholder="Record structural condition, access, neighborhood details..."></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button type="submit" class="valuation-btn" data-action="offline">
                                <i class="fas fa-save"></i> Save Offline
                            </button>
                            <button type="reset" class="valuation-btn secondary">
                                <i class="fas fa-undo"></i> Clear
                            </button>
                        </div>
                    </form>
                    <div class="valuation-info-box" id="fieldCapturePendingBox" style="margin-top: 20px;">
                        <h4><i class="fas fa-sync-alt"></i> Pending Sync</h4>
                        <p style="font-size: 0.85rem; color: #555;">Entries saved offline appear here. Sync when you are
                            back online.</p>
                        <div id="fieldCapturePendingList" class="valuation-pending-list">
                            <p style="margin: 0;">No pending field entries.</p>
                        </div>
                        <button type="button" class="valuation-btn secondary" id="fieldSyncAllBtn"
                            style="margin-top: 12px;">
                            <i class="fas fa-cloud-upload-alt"></i> Sync Pending Entries
                        </button>
                    </div>
                </div>

                <!-- Tool 3: View Properties -->
                <div id="view-properties-tab" class="valuation-tab-content">
                    <div class="valuation-info-box">
                        <h4><i class="fas fa-info-circle"></i> View Properties</h4>
                        <p>Select filters to view properties by district, county, village and other criteria. Properties
                            will be displayed on the map and in a list below.</p>
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewDistrict">District</label>
                        <select id="viewDistrict">
                            <option value="">All Districts</option>
                            <option value="Kampala">Kampala</option>
                            <option value="Wakiso">Wakiso</option>
                            <option value="Mukono">Mukono</option>
                            <option value="Jinja">Jinja</option>
                            <option value="Mbarara">Mbarara</option>
                            <option value="Gulu">Gulu</option>
                            <option value="Lira">Lira</option>
                            <option value="Mbale">Mbale</option>
                            <option value="Masaka">Masaka</option>
                            <option value="Fort Portal">Fort Portal</option>
                            <option value="Arua">Arua</option>
                            <option value="Entebbe">Entebbe</option>
                        </select>
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewCounty">County</label>
                        <input type="text" id="viewCounty" placeholder="Enter county name">
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewVillage">Village/Parish Name</label>
                        <input type="text" id="viewVillage" placeholder="Enter village/parish name">
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewProprietor">Proprietor/Owner Name</label>
                        <input type="text" id="viewProprietor" placeholder="Enter proprietor/owner name">
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewPropertyType">Property Type</label>
                        <select id="viewPropertyType">
                            <option value="">All Types</option>
                            <option value="Residential">Residential</option>
                            <option value="Commercial">Commercial</option>
                            <option value="Agricultural">Agricultural</option>
                            <option value="Industrial">Industrial</option>
                            <option value="Mixed">Mixed</option>
                        </select>
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewPriceMin">Min Price (UGX)</label>
                        <input type="number" id="viewPriceMin" min="0" step="1000">
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewPriceMax">Max Price (UGX)</label>
                        <input type="number" id="viewPriceMax" min="0" step="1000">
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewValuationMethod">Valuation Method</label>
                        <select id="viewValuationMethod">
                            <option value="">All Methods</option>
                            <option value="Comparable Sales">Comparable Sales</option>
                            <option value="Income Approach">Income Approach</option>
                            <option value="Cost Approach">Cost Approach</option>
                            <option value="Hybrid">Hybrid</option>
                        </select>
                    </div>
                    <div class="valuation-form-group">
                        <label for="viewTenure">Tenure</label>
                        <select id="viewTenure">
                            <option value="">All Tenures</option>
                            <option value="Freehold">Freehold</option>
                            <option value="Leasehold">Leasehold</option>
                            <option value="Customary">Customary</option>
                            <option value="Mailo">Mailo</option>
                        </select>
                    </div>
                    <button type="button" class="valuation-btn" id="viewPropertiesBtn">
                        <i class="fas fa-search"></i> View Properties
                    </button>
                    <button type="button" class="valuation-btn secondary" id="exportPropertiesBtn"
                        style="display: none;">
                        <i class="fas fa-download"></i> Export to CSV
                    </button>
                    <div id="viewPropertiesList" class="valuation-properties-list"
                        style="display: none; margin-top: 20px;">
                        <!-- Properties list will appear here -->
                    </div>
                </div>

                <!-- Tool 5: Migration Admin -->
                <div id="migration-admin-tab" class="valuation-tab-content">
                    <div class="valuation-info-box">
                        <h4><i class="fas fa-database"></i> Data Migration Admin</h4>
                        <p>Review and update existing property valuation records that need migration to the new format
                            with location hierarchy and value breakdown.</p>
                    </div>
                    <div class="valuation-form-group">
                        <label for="migrationStatusFilter">Migration Status</label>
                        <select id="migrationStatusFilter">
                            <option value="Needs Review">Needs Review</option>
                            <option value="Migrated">Migrated</option>
                            <option value="All">All</option>
                        </select>
                    </div>
                    <div class="valuation-form-group">
                        <label for="migrationDistrictFilter">District</label>
                        <select id="migrationDistrictFilter">
                            <option value="">All Districts</option>
                        </select>
                    </div>
                    <button type="button" class="valuation-btn" id="loadMigrationRecordsBtn">
                        <i class="fas fa-search"></i> Load Records
                    </button>
                    <div id="migrationRecordsList" class="valuation-properties-list"
                        style="display: none; margin-top: 20px; max-height: 500px;">
                        <!-- Migration records will appear here -->
                    </div>
                    <div id="migrationStats"
                        style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; display: none;">
                        <h4>Migration Statistics</h4>
                        <div id="migrationStatsContent"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Coordinate Selection Popup (appears on map) -->
        <div id="coordPopup" class="ol-popup" style="display: none;">
            <button type="button" class="popup-closer" id="popupCloser" aria-label="Close">&times;</button>
            <div class="popup-content">
                <h4>📍 Share Location</h4>
                <div class="popup-coords" id="popupCoords"></div>
                <input type="text" id="popupDescription" class="popup-input"
                    placeholder="Add description (e.g., Land for sale, Meeting point...)" maxlength="100" />
                <div class="popup-actions">
                    <button type="button" class="popup-btn share-btn" id="popupShareBtn">
                        <i class="fas fa-share"></i> Share
                    </button>
                    <button type="button" class="popup-btn cancel-btn" id="popupCancelBtn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Property Listing Panel -->
        <div class="property-listing-panel" id="propertyListingPanel" style="display: none;">
            <div class="property-listing-header">
                <h3><i class="fas fa-home"></i> List Property for Sale</h3>
                <button type="button" class="close-btn" id="closePropertyListing" aria-label="Close">&times;</button>
            </div>

            <div class="property-listing-body">
                <!-- Instruction overlay (shown when no location selected) -->
                <div class="location-instruction-overlay" id="locationInstructionOverlay">
                    <i class="fas fa-map-marker-alt"></i>
                    <h4>Select Property Location</h4>
                    <p>Option 1: Click anywhere on the map to mark your property's location.<br>Option 2: Use the button
                        below to select the current map center.</p>
                    <button type="button" class="valuation-btn" id="useCurrentLocationBtn" style="margin-top: 15px;">
                        <i class="fas fa-crosshairs"></i> Use Current Map Center
                    </button>
                </div>

                <!-- Coordinates display (hidden until location selected) -->
                <div class="property-coords-badge" id="propertyCoordsBadge" style="display: none;">
                    <i class="fas fa-map-pin"></i>
                    <div class="coords-text" id="propertyCoords"></div>
                </div>

                <!-- Property form (disabled until location selected) -->
                <form class="property-listing-form" id="propertyListingForm">
                    <div class="form-row">
                        <label>District <span class="loading-spinner" id="districtLoader"
                                style="display: none;"></span></label>
                        <input type="text" id="propertyDistrict" placeholder="e.g., Kampala" required />
                    </div>

                    <div class="form-row">
                        <label>Seller Name</label>
                        <input type="text" id="propertySeller" placeholder="e.g., John Doe" required />
                    </div>

                    <div class="form-row">
                        <label>Contact</label>
                        <input type="tel" id="propertyContact" placeholder="+256 700 123456" required />
                    </div>

                    <div class="form-row-split">
                        <div>
                            <label>Plot Number</label>
                            <input type="text" id="propertyPlot" placeholder="e.g., 123" />
                        </div>
                        <div>
                            <label>Block Number</label>
                            <input type="text" id="propertyBlock" placeholder="e.g., A" />
                        </div>
                    </div>

                    <div class="form-row">
                        <label>Area (Square Meters)</label>
                        <input type="number" id="propertyArea" placeholder="e.g., 5000" min="1" />
                    </div>

                    <div class="form-row">
                        <label>Tenure Type</label>
                        <select id="propertyTenure" class="popup-input" required>
                            <option value="">Select tenure type...</option>
                            <option value="Freehold">Freehold</option>
                            <option value="Leasehold">Leasehold</option>
                            <option value="Mailo">Mailo</option>
                            <option value="Customary">Customary</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label>Price (UGX)</label>
                        <input type="number" id="propertyPrice" placeholder="e.g., 50000000" required />
                        <div class="price-preview" id="pricePreview"></div>
                    </div>

                    <div class="form-row">
                        <label>Property Images (Max 2)</label>
                        <div class="image-upload-section">
                            <div class="image-upload-item">
                                <input type="file" id="propertyImage1" accept="image/*" />
                                <div id="propertyImage1Preview" class="image-preview-small"></div>
                            </div>
                            <div class="image-upload-item">
                                <input type="file" id="propertyImage2" accept="image/*" />
                                <div id="propertyImage2Preview" class="image-preview-small"></div>
                            </div>
                        </div>
                        <small class="upload-hint">Upload up to 2 images showing your property (max 5MB each)</small>
                    </div>

                </form>

                <div class="property-form-actions">
                    <button type="button" class="save-property-btn" id="savePropertyListingBtn" disabled>
                        <i class="fas fa-save"></i> Save Property
                    </button>
                    <button type="button" class="cancel-property-btn" id="cancelPropertyListingBtn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Property Search Panel -->
        <div class="property-search-panel" id="propertySearchPanel" style="display: none;">
            <div class="search-panel-header">
                <h3><i class="fas fa-search-location"></i> Property Search</h3>
                <button type="button" class="close-btn" id="closePropertySearch" aria-label="Close">&times;</button>
            </div>

            <div class="search-panel-body">
                <div class="search-form">
                    <div class="form-group">
                        <label>District</label>
                        <input type="text" id="propSearchDistrict" class="search-input"
                            placeholder="Enter district name..." required />
                    </div>

                    <div class="form-group">
                        <label>Price Range (UGX)</label>
                        <div class="price-range">
                            <input type="number" id="propSearchPriceMin" class="search-input half"
                                placeholder="Min price" />
                            <span class="range-separator">to</span>
                            <input type="number" id="propSearchPriceMax" class="search-input half"
                                placeholder="Max price" />
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Tenure Type</label>
                        <select id="propSearchTenure" class="search-input">
                            <option value="">All tenure types</option>
                            <option value="Freehold">Freehold</option>
                            <option value="Leasehold">Leasehold</option>
                            <option value="Mailo">Mailo</option>
                            <option value="Customary">Customary</option>
                        </select>
                    </div>

                    <div class="search-actions">
                        <button type="button" class="search-action-btn primary" id="propSearchBtn">
                            <i class="fas fa-search"></i> Search
                        </button>
                        <button type="button" class="search-action-btn secondary" id="propSearchClearBtn">
                            <i class="fas fa-eraser"></i> Clear
                        </button>
                    </div>
                </div>

                <div class="search-results" id="propertySearchResults">
                    <div class="results-header">
                        <h4>Search Results</h4>
                        <span class="results-count" id="resultsCount">0 properties</span>
                    </div>
                    <div class="results-list" id="propertyResultsList">
                        <!-- Search results will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Project Library JavaScript Functions -->
        <script>
            // ============================================
            // PROJECT LIBRARY FUNCTIONALITY
            // ============================================
            // Note: This code runs after the main script to ensure all dependencies are loaded

            // Wait for all dependencies to be available
            function waitForDependencies(callback) {
                let checkCount = 0;
                const maxChecks = 100; // 10 seconds (100 * 100ms)

                const checkDependencies = setInterval(() => {
                    checkCount++;
                    // Check dependencies - use window object to access global variables
                    const mapReady = typeof window.map !== 'undefined';
                    const pinsReady = typeof projectPinsSource !== 'undefined' || typeof window.projectPinsSource !== 'undefined';
                    const supabaseReady = typeof supabase !== 'undefined' || typeof window.supabase !== 'undefined';
                    // Only check window.UGANDA_DISTRICTS to avoid ReferenceError if const is not yet initialized
                    const districtsReady = typeof window.UGANDA_DISTRICTS !== 'undefined';
                    const crsReady = typeof window.UGANDA_COORDINATE_SYSTEMS !== 'undefined';
                    const toastReady = typeof showToast === 'function' || typeof window.showToast === 'function';

                    if (mapReady && pinsReady && supabaseReady && districtsReady && crsReady && toastReady) {
                        clearInterval(checkDependencies);
                        callback();
                    } else if (checkCount >= maxChecks) {
                        clearInterval(checkDependencies);
                        console.warn('Project Library: Some dependencies not loaded after 10 seconds', {
                            map: mapReady,
                            pins: pinsReady,
                            supabase: supabaseReady,
                            districts: districtsReady,
                            crs: crsReady,
                            toast: toastReady
                        });
                        // Try to initialize anyway - we'll handle missing dependencies gracefully
                        callback();
                    }
                }, 100);
            }

            // Handle Project Location Click
            function handleProjectLocationClick(event) {
                if (!projectLibraryState.locationSelectionActive) return;

                const coordinate = event.coordinate;
                const lonLat = ol.proj.toLonLat(coordinate);

                // Remove previous pin if exists
                if (projectLibraryState.currentProjectPin && projectPinsSource) {
                    projectPinsSource.removeFeature(projectLibraryState.currentProjectPin);
                }

                // Create temporary pin marker with custom styling
                projectLibraryState.currentProjectPin = new ol.Feature({
                    geometry: new ol.geom.Point(coordinate),
                    isTemporary: true,
                    label: 'Project Location'
                });

                // Style the temporary pin
                projectLibraryState.currentProjectPin.setStyle(new ol.style.Style({
                    image: new ol.style.Icon({
                        anchor: [0.5, 1],
                        src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="%23e67e22" stroke="%23ffffff" stroke-width="2" d="M16 0C10.5 0 6 4.5 6 10c0 8 10 22 10 22s10-14 10-22c0-5.5-4.5-10-10-10zm0 14c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>',
                        scale: 1.5
                    }),
                    text: new ol.style.Text({
                        text: 'Project Location',
                        offsetY: -40,
                        font: 'bold 12px sans-serif',
                        fill: new ol.style.Fill({ color: '#e67e22' }),
                        stroke: new ol.style.Stroke({ color: 'white', width: 3 })
                    })
                }));

                projectPinsSource.addFeature(projectLibraryState.currentProjectPin);

                // Store coordinates
                projectLibraryState.selectedProjectCoordinate = {
                    lat: lonLat[1],
                    lon: lonLat[0],
                    mapCoord: coordinate
                };

                // Update UI based on current upload type
                const uploadType = projectLibraryState.currentUploadType;
                if (uploadType === 'fileCsv') {
                    document.getElementById('fileCsvCoords').style.display = 'flex';
                    document.getElementById('fileCsvCoordsText').textContent =
                        `Lat: ${lonLat[1].toFixed(6)}, Lon: ${lonLat[0].toFixed(6)}`;

                    // Update button state
                    const btn = document.getElementById('fileCsvLocationBtn');
                    btn.classList.add('location-selected');
                    btn.innerHTML = '<i class="fas fa-check-circle"></i> Location Selected';

                    const formContainer = document.getElementById('fileCsvFormContainer');
                    formContainer.style.opacity = '1';
                    formContainer.style.pointerEvents = 'auto';
                    document.getElementById('fileCsvSaveBtn').disabled = false;
                } else if (uploadType === 'dwgDxf') {
                    document.getElementById('dwgDxfCoords').style.display = 'flex';
                    document.getElementById('dwgDxfCoordsText').textContent =
                        `Lat: ${lonLat[1].toFixed(6)}, Lon: ${lonLat[0].toFixed(6)}`;

                    // Update button state
                    const btn = document.getElementById('dwgDxfLocationBtn');
                    btn.classList.add('location-selected');
                    btn.innerHTML = '<i class="fas fa-check-circle"></i> Location Selected';

                    const formContainer = document.getElementById('dwgDxfFormContainer');
                    formContainer.style.opacity = '1';
                    formContainer.style.pointerEvents = 'auto';
                    document.getElementById('dwgDxfSaveBtn').disabled = false;
                }

                projectLibraryState.projectLocationSelected = true;
                showToast('Project location selected! You can now fill in the form.', 'success');

                // Stop location selection
                stopLocationSelection();
            }

            // Handle Location Button Click
            function handleLocationButtonClick(uploadType) {
                // Reset button state
                if (uploadType === 'fileCsv') {
                    const btn = document.getElementById('fileCsvLocationBtn');
                    btn.classList.remove('location-selected');
                    btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Select Project Location on Map';
                    document.getElementById('fileCsvCoords').style.display = 'none';
                } else if (uploadType === 'dwgDxf') {
                    const btn = document.getElementById('dwgDxfLocationBtn');
                    btn.classList.remove('location-selected');
                    btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Select Project Location on Map';
                    document.getElementById('dwgDxfCoords').style.display = 'none';
                }

                // Remove existing pin
                if (projectLibraryState.currentProjectPin) {
                    projectPinsSource.removeFeature(projectLibraryState.currentProjectPin);
                    projectLibraryState.currentProjectPin = null;
                }

                projectLibraryState.selectedProjectCoordinate = null;
                projectLibraryState.projectLocationSelected = false;

                // Disable form
                if (uploadType === 'fileCsv') {
                    const formContainer = document.getElementById('fileCsvFormContainer');
                    formContainer.style.opacity = '0.5';
                    formContainer.style.pointerEvents = 'none';
                    document.getElementById('fileCsvSaveBtn').disabled = true;
                } else if (uploadType === 'dwgDxf') {
                    const formContainer = document.getElementById('dwgDxfFormContainer');
                    formContainer.style.opacity = '0.5';
                    formContainer.style.pointerEvents = 'none';
                    document.getElementById('dwgDxfSaveBtn').disabled = true;
                }

                // Start location selection
                startLocationSelection(uploadType);
            }

            // Start Location Selection
            function startLocationSelection(uploadType) {
                projectLibraryState.currentUploadType = uploadType;
                projectLibraryState.locationSelectionActive = true;
                projectLibraryState.projectLocationSelected = false;

                // Remove previous listener if exists
                if (projectLibraryState.projectLocationListener) {
                    ol.Observable.unByKey(projectLibraryState.projectLocationListener);
                }

                // Add map click listener
                projectLibraryState.projectLocationListener = map.on('singleclick', handleProjectLocationClick);

                showToast('Click on the map to select project location', 'info');
            }

            // Stop Location Selection
            function stopLocationSelection() {
                projectLibraryState.locationSelectionActive = false;
                if (projectLibraryState.projectLocationListener) {
                    ol.Observable.unByKey(projectLibraryState.projectLocationListener);
                    projectLibraryState.projectLocationListener = null;
                }
            }

            // Update File/CSV Dynamic Fields
            function updateFileCsvFields(nature) {
                const container = document.getElementById('fileCsvDynamicFields');
                container.innerHTML = '';

                if (nature === 'control_points') {
                    container.innerHTML = `
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvProjectName">Project Name *</label>
                        <input type="text" id="fileCsvProjectName" class="form-input" placeholder="Enter project name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvProjectCode">Project Code</label>
                        <input type="text" id="fileCsvProjectCode" class="form-input" placeholder="Enter project code">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvDistrict">District *</label>
                        <select id="fileCsvDistrict" class="form-select" required>
                            <option value="">Select District</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSurveyor">Surveyor *</label>
                        <input type="text" id="fileCsvSurveyor" class="form-input" placeholder="Enter surveyor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSupervisor">Supervisor *</label>
                        <input type="text" id="fileCsvSupervisor" class="form-input" placeholder="Enter supervisor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSurveyDate">Survey Date</label>
                        <input type="date" id="fileCsvSurveyDate" class="form-input">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvDatum">Datum</label>
                        <select id="fileCsvDatum" class="form-select">
                            <option value="">Select Datum</option>
                            <option value="WGS84">WGS84</option>
                            <option value="Arc1960">Arc1960</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvAccuracyLevel">Accuracy Level</label>
                        <select id="fileCsvAccuracyLevel" class="form-select">
                            <option value="">Select Level</option>
                            <option value="High">High</option>
                            <option value="Medium">Medium</option>
                            <option value="Low">Low</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvNumberOfPoints">Number of Points</label>
                        <input type="number" id="fileCsvNumberOfPoints" class="form-input" min="0">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvAdditionalInfo">Additional Information</label>
                        <textarea id="fileCsvAdditionalInfo" class="form-input" rows="3" placeholder="Enter additional information"></textarea>
                    </div>
                `;
                } else if (nature === 'jrj') {
                    container.innerHTML = `
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvDistrict">District *</label>
                        <select id="fileCsvDistrict" class="form-select" required>
                            <option value="">Select District</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvCounty">County</label>
                        <input type="text" id="fileCsvCounty" class="form-input" placeholder="Enter county">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvBlockNumber">Block Number</label>
                        <input type="text" id="fileCsvBlockNumber" class="form-input" placeholder="Enter block number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvPlotNumber">Plot Number</label>
                        <input type="text" id="fileCsvPlotNumber" class="form-input" placeholder="Enter plot number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSurveyor">Surveyor *</label>
                        <input type="text" id="fileCsvSurveyor" class="form-input" placeholder="Enter surveyor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSupervisor">Supervisor *</label>
                        <input type="text" id="fileCsvSupervisor" class="form-input" placeholder="Enter supervisor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvCompany">Company</label>
                        <input type="text" id="fileCsvCompany" class="form-input" placeholder="Enter company name">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSurveyDate">Survey Date</label>
                        <input type="date" id="fileCsvSurveyDate" class="form-input">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvCoordinateSystem">Coordinate System</label>
                        <select id="fileCsvCoordinateSystem" class="form-select">
                            <option value="">Select Coordinate System</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvParish">Parish</label>
                        <input type="text" id="fileCsvParish" class="form-input" placeholder="Enter parish">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvVillage">Village</label>
                        <input type="text" id="fileCsvVillage" class="form-input" placeholder="Enter village">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvLandUseType">Land Use Type</label>
                        <input type="text" id="fileCsvLandUseType" class="form-input" placeholder="Enter land use type">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvReferenceNumber">Reference Number</label>
                        <input type="text" id="fileCsvReferenceNumber" class="form-input" placeholder="Enter reference number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvAdditionalInfo">Additional Notes from Surveyor</label>
                        <textarea id="fileCsvAdditionalInfo" class="form-input" rows="3" placeholder="Enter additional notes"></textarea>
                    </div>
                `;
                } else if (nature === 'other') {
                    container.innerHTML = `
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvProjectName">Project Name *</label>
                        <input type="text" id="fileCsvProjectName" class="form-input" placeholder="Enter project name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvCoordinateSystem">Coordinate System</label>
                        <select id="fileCsvCoordinateSystem" class="form-select">
                            <option value="">Select Coordinate System</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvDistrict">District *</label>
                        <select id="fileCsvDistrict" class="form-select" required>
                            <option value="">Select District</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSurveyor">Surveyor *</label>
                        <input type="text" id="fileCsvSurveyor" class="form-input" placeholder="Enter surveyor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvSupervisor">Supervisor *</label>
                        <input type="text" id="fileCsvSupervisor" class="form-input" placeholder="Enter supervisor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="fileCsvAdditionalInfo">Additional Information</label>
                        <textarea id="fileCsvAdditionalInfo" class="form-input" rows="3" placeholder="Enter additional information"></textarea>
                    </div>
                `;
                }

                // Populate district dropdowns
                const districtSelects = container.querySelectorAll('#fileCsvDistrict');
                if (districtSelects.length > 0) {
                    let districts = null;
                    try {
                        districts = (typeof window.UGANDA_DISTRICTS !== 'undefined' ? window.UGANDA_DISTRICTS : null);
                    } catch (e) {
                        districts = null;
                    }
                    if (districts && Array.isArray(districts)) {
                        districtSelects.forEach(select => {
                            districts.forEach(district => {
                                const option = document.createElement('option');
                                option.value = district;
                                option.textContent = district;
                                select.appendChild(option);
                            });
                        });
                    } else {
                        console.warn('Project Library: UGANDA_DISTRICTS not available for fileCsvDistrict dropdown');
                    }
                }

                // Populate coordinate system dropdowns
                const crsSelects = container.querySelectorAll('#fileCsvCoordinateSystem');
                if (crsSelects.length > 0) {
                    const crsSystems = typeof UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? UGANDA_COORDINATE_SYSTEMS : (typeof window.UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? window.UGANDA_COORDINATE_SYSTEMS : null);
                    if (crsSystems && Array.isArray(crsSystems)) {
                        crsSelects.forEach(select => {
                            crsSystems.forEach(crs => {
                                const option = document.createElement('option');
                                option.value = crs.value;
                                option.textContent = crs.label;
                                select.appendChild(option);
                            });
                        });
                    } else {
                        console.warn('Project Library: UGANDA_COORDINATE_SYSTEMS not available for fileCsvCoordinateSystem dropdown');
                    }
                }
            }

            // Update DWG/DXF Dynamic Fields
            function updateDwgDxfFields(nature) {
                const container = document.getElementById('dwgDxfDynamicFields');
                container.innerHTML = '';

                if (nature === 'land_survey') {
                    container.innerHTML = `
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfNatureOfSurvey">Nature of Survey *</label>
                        <select id="dwgDxfNatureOfSurvey" class="form-select" required>
                            <option value="">Select nature of survey</option>
                            <option value="subdivision">Subdivision</option>
                            <option value="resurvey">Resurvey</option>
                            <option value="boundary_opening">Boundary Opening</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfCoordinateSystem">Coordinate System *</label>
                        <select id="dwgDxfCoordinateSystem" class="form-select" required>
                            <option value="">Select Coordinate System</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfDistrict">District *</label>
                        <select id="dwgDxfDistrict" class="form-select" required>
                            <option value="">Select District</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfCounty">County</label>
                        <input type="text" id="dwgDxfCounty" class="form-input" placeholder="Enter county">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfBlockNumber">Block Number</label>
                        <input type="text" id="dwgDxfBlockNumber" class="form-input" placeholder="Enter block number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfPlotNumber">Plot Number</label>
                        <input type="text" id="dwgDxfPlotNumber" class="form-input" placeholder="Enter plot number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSurveyor">Surveyor *</label>
                        <input type="text" id="dwgDxfSurveyor" class="form-input" placeholder="Enter surveyor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSupervisor">Supervisor *</label>
                        <input type="text" id="dwgDxfSupervisor" class="form-input" placeholder="Enter supervisor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfCompany">Company</label>
                        <input type="text" id="dwgDxfCompany" class="form-input" placeholder="Enter company name">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSurveyDate">Survey Date</label>
                        <input type="date" id="dwgDxfSurveyDate" class="form-input">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSurveyMethod">Survey Method</label>
                        <select id="dwgDxfSurveyMethod" class="form-select">
                            <option value="">Select Method</option>
                            <option value="GPS">GPS</option>
                            <option value="Total Station">Total Station</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfAccuracyStandard">Accuracy Standard</label>
                        <input type="text" id="dwgDxfAccuracyStandard" class="form-input" placeholder="Enter accuracy standard">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfReferenceNumber">Reference Number</label>
                        <input type="text" id="dwgDxfReferenceNumber" class="form-input" placeholder="Enter reference number">
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSurveyStatus">Survey Status</label>
                        <select id="dwgDxfSurveyStatus" class="form-select">
                            <option value="">Select Status</option>
                            <option value="Completed">Completed</option>
                            <option value="In Progress">In Progress</option>
                            <option value="Pending">Pending</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfAdditionalInfo">Additional Information</label>
                        <textarea id="dwgDxfAdditionalInfo" class="form-input" rows="3" placeholder="Enter additional information"></textarea>
                    </div>
                `;
                } else if (nature === 'other') {
                    container.innerHTML = `
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfProjectName">Project Name *</label>
                        <input type="text" id="dwgDxfProjectName" class="form-input" placeholder="Enter project name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfCoordinateSystem">Coordinate System *</label>
                        <select id="dwgDxfCoordinateSystem" class="form-select" required>
                            <option value="">Select Coordinate System</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSurveyor">Surveyor *</label>
                        <input type="text" id="dwgDxfSurveyor" class="form-input" placeholder="Enter surveyor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfSupervisor">Supervisor *</label>
                        <input type="text" id="dwgDxfSupervisor" class="form-input" placeholder="Enter supervisor name" required>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfDistrict">District *</label>
                        <select id="dwgDxfDistrict" class="form-select" required>
                            <option value="">Select District</option>
                        </select>
                    </div>
                    <div class="dynamic-field-group form-group">
                        <label for="dwgDxfAdditionalInfo">Additional Information</label>
                        <textarea id="dwgDxfAdditionalInfo" class="form-input" rows="3" placeholder="Enter additional information"></textarea>
                    </div>
                `;
                }

                // Populate district dropdowns
                const districtSelects = container.querySelectorAll('#dwgDxfDistrict');
                if (districtSelects.length > 0) {
                    let districts = null;
                    try {
                        districts = (typeof window.UGANDA_DISTRICTS !== 'undefined' ? window.UGANDA_DISTRICTS : null);
                    } catch (e) {
                        districts = null;
                    }
                    if (districts && Array.isArray(districts)) {
                        districtSelects.forEach(select => {
                            districts.forEach(district => {
                                const option = document.createElement('option');
                                option.value = district;
                                option.textContent = district;
                                select.appendChild(option);
                            });
                        });
                    } else {
                        console.warn('Project Library: UGANDA_DISTRICTS not available for dwgDxfDistrict dropdown');
                    }
                }

                // Populate coordinate system dropdowns
                const crsSelects = container.querySelectorAll('#dwgDxfCoordinateSystem');
                if (crsSelects.length > 0) {
                    const crsSystems = typeof UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? UGANDA_COORDINATE_SYSTEMS : (typeof window.UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? window.UGANDA_COORDINATE_SYSTEMS : null);
                    if (crsSystems && Array.isArray(crsSystems)) {
                        crsSelects.forEach(select => {
                            crsSystems.forEach(crs => {
                                const option = document.createElement('option');
                                option.value = crs.value;
                                option.textContent = crs.label;
                                select.appendChild(option);
                            });
                        });
                    } else {
                        console.warn('Project Library: UGANDA_COORDINATE_SYSTEMS not available for dwgDxfCoordinateSystem dropdown');
                    }
                }
            }

            // Save File/CSV Project
            async function saveFileCsvProject() {
                if (!projectLibraryState.selectedProjectCoordinate) {
                    showToast('Please select project location first', 'error');
                    return;
                }

                const fileInput = document.getElementById('fileCsvInput');
                if (!fileInput.files.length) {
                    showToast('Please select a file to upload', 'error');
                    return;
                }

                const file = fileInput.files[0];
                const client = document.getElementById('fileCsvClient').value.trim();
                const nature = document.getElementById('fileCsvNature').value;

                if (!client || !nature) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                // Get current user
                let currentUser = null;
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    currentUser = user;
                } catch (error) {
                    console.error('Error getting user:', error);
                    showToast('Authentication error. Please refresh the page.', 'error');
                    return;
                }

                if (!currentUser) {
                    showToast('You must be logged in to upload projects', 'error');
                    return;
                }

                // Determine file type
                const fileType = file.name.endsWith('.csv') ? 'csv' : 'file';

                // Prepare file path
                const folder = 'files';
                const timestamp = Date.now();
                const filePath = `${folder}/${timestamp}_${file.name}`;

                // Show progress
                const progressBar = document.getElementById('fileCsvProgressBar');
                const progressContainer = document.getElementById('fileCsvUploadProgress');
                const statusDiv = document.getElementById('fileCsvUploadStatus');
                const saveBtn = document.getElementById('fileCsvSaveBtn');

                progressContainer.style.display = 'block';
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';

                try {
                    // Upload file to Supabase storage
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('uploads')
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false
                        });

                    if (uploadError) {
                        throw uploadError;
                    }

                    // Collect form data
                    const formData = {
                        file_name: file.name,
                        file_path: filePath,
                        file_type: fileType,
                        nature: nature,
                        client: client,
                        latitude: projectLibraryState.selectedProjectCoordinate.lat,
                        longitude: projectLibraryState.selectedProjectCoordinate.lon,
                        uploaded_by: currentUser.id
                    };

                    // Add nature-specific fields
                    if (nature === 'control_points') {
                        formData.project_name = document.getElementById('fileCsvProjectName')?.value || null;
                        formData.project_code = document.getElementById('fileCsvProjectCode')?.value || null;
                        formData.district = document.getElementById('fileCsvDistrict')?.value || null;
                        formData.surveyor = document.getElementById('fileCsvSurveyor')?.value || null;
                        formData.supervisor = document.getElementById('fileCsvSupervisor')?.value || null;
                        formData.survey_date = document.getElementById('fileCsvSurveyDate')?.value || null;
                        formData.datum = document.getElementById('fileCsvDatum')?.value || null;
                        formData.accuracy_level = document.getElementById('fileCsvAccuracyLevel')?.value || null;
                        formData.number_of_points = parseInt(document.getElementById('fileCsvNumberOfPoints')?.value) || null;
                        formData.additional_info = document.getElementById('fileCsvAdditionalInfo')?.value || null;
                    } else if (nature === 'jrj') {
                        formData.district = document.getElementById('fileCsvDistrict')?.value || null;
                        formData.county = document.getElementById('fileCsvCounty')?.value || null;
                        formData.block_number = document.getElementById('fileCsvBlockNumber')?.value || null;
                        formData.plot_number = document.getElementById('fileCsvPlotNumber')?.value || null;
                        formData.surveyor = document.getElementById('fileCsvSurveyor')?.value || null;
                        formData.supervisor = document.getElementById('fileCsvSupervisor')?.value || null;
                        formData.company = document.getElementById('fileCsvCompany')?.value || null;
                        formData.survey_date = document.getElementById('fileCsvSurveyDate')?.value || new Date().toISOString().split('T')[0];
                        formData.coordinate_system = document.getElementById('fileCsvCoordinateSystem')?.value || null;
                        formData.parish = document.getElementById('fileCsvParish')?.value || null;
                        formData.village = document.getElementById('fileCsvVillage')?.value || null;
                        formData.land_use_type = document.getElementById('fileCsvLandUseType')?.value || null;
                        formData.reference_number = document.getElementById('fileCsvReferenceNumber')?.value || null;
                        formData.additional_info = document.getElementById('fileCsvAdditionalInfo')?.value || null;
                    } else if (nature === 'other') {
                        formData.project_name = document.getElementById('fileCsvProjectName')?.value || null;
                        formData.coordinate_system = document.getElementById('fileCsvCoordinateSystem')?.value || null;
                        formData.district = document.getElementById('fileCsvDistrict')?.value || null;
                        formData.surveyor = document.getElementById('fileCsvSurveyor')?.value || null;
                        formData.supervisor = document.getElementById('fileCsvSupervisor')?.value || null;
                        formData.additional_info = document.getElementById('fileCsvAdditionalInfo')?.value || null;
                    }

                    // Save metadata to database
                    const { data: dbData, error: dbError } = await supabase
                        .from('project_files')
                        .insert([formData])
                        .select();

                    if (dbError) {
                        throw dbError;
                    }

                    // Success
                    showToast('Project uploaded successfully!', 'success');

                    // Reset form
                    resetFileCsvForm();

                } catch (error) {
                    console.error('Upload error:', error);
                    statusDiv.textContent = error.message || 'Upload failed. Please try again.';
                    statusDiv.className = 'upload-status error';
                    statusDiv.style.display = 'block';
                    showToast('Upload failed: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    progressContainer.style.display = 'none';
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = '<i class="fas fa-save"></i> Save & Upload';
                }
            }

            // Save DWG/DXF Project
            async function saveDwgDxfProject() {
                if (!projectLibraryState.selectedProjectCoordinate) {
                    showToast('Please select project location first', 'error');
                    return;
                }

                const fileInput = document.getElementById('dwgDxfInput');
                if (!fileInput.files.length) {
                    showToast('Please select a file to upload', 'error');
                    return;
                }

                const file = fileInput.files[0];
                const client = document.getElementById('dwgDxfClient').value.trim();
                const nature = document.getElementById('dwgDxfNature').value;

                if (!client || !nature) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }

                // Get current user
                let currentUser = null;
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    currentUser = user;
                } catch (error) {
                    console.error('Error getting user:', error);
                    showToast('Authentication error. Please refresh the page.', 'error');
                    return;
                }

                if (!currentUser) {
                    showToast('You must be logged in to upload projects', 'error');
                    return;
                }

                // Determine file type
                const fileType = file.name.endsWith('.dwg') ? 'dwg' : 'dxf';

                // Prepare file path
                const folder = 'drawings';
                const timestamp = Date.now();
                const filePath = `${folder}/${timestamp}_${file.name}`;

                // Show progress
                const progressBar = document.getElementById('dwgDxfProgressBar');
                const progressContainer = document.getElementById('dwgDxfUploadProgress');
                const statusDiv = document.getElementById('dwgDxfUploadStatus');
                const saveBtn = document.getElementById('dwgDxfSaveBtn');

                progressContainer.style.display = 'block';
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';

                try {
                    // Upload file to Supabase storage
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('uploads')
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false
                        });

                    if (uploadError) {
                        throw uploadError;
                    }

                    // Collect form data
                    const formData = {
                        file_name: file.name,
                        file_path: filePath,
                        file_type: fileType,
                        nature: nature,
                        client: client,
                        latitude: projectLibraryState.selectedProjectCoordinate.lat,
                        longitude: projectLibraryState.selectedProjectCoordinate.lon,
                        uploaded_by: currentUser.id
                    };

                    // Add nature-specific fields
                    if (nature === 'land_survey') {
                        formData.nature_of_survey = document.getElementById('dwgDxfNatureOfSurvey')?.value || null;
                        formData.coordinate_system = document.getElementById('dwgDxfCoordinateSystem')?.value || null;
                        formData.district = document.getElementById('dwgDxfDistrict')?.value || null;
                        formData.county = document.getElementById('dwgDxfCounty')?.value || null;
                        formData.block_number = document.getElementById('dwgDxfBlockNumber')?.value || null;
                        formData.plot_number = document.getElementById('dwgDxfPlotNumber')?.value || null;
                        formData.surveyor = document.getElementById('dwgDxfSurveyor')?.value || null;
                        formData.supervisor = document.getElementById('dwgDxfSupervisor')?.value || null;
                        formData.company = document.getElementById('dwgDxfCompany')?.value || null;
                        formData.survey_date = document.getElementById('dwgDxfSurveyDate')?.value || null;
                        formData.survey_method = document.getElementById('dwgDxfSurveyMethod')?.value || null;
                        formData.accuracy_standard = document.getElementById('dwgDxfAccuracyStandard')?.value || null;
                        formData.reference_number = document.getElementById('dwgDxfReferenceNumber')?.value || null;
                        formData.survey_status = document.getElementById('dwgDxfSurveyStatus')?.value || null;
                        formData.additional_info = document.getElementById('dwgDxfAdditionalInfo')?.value || null;
                    } else if (nature === 'other') {
                        formData.project_name = document.getElementById('dwgDxfProjectName')?.value || null;
                        formData.coordinate_system = document.getElementById('dwgDxfCoordinateSystem')?.value || null;
                        formData.surveyor = document.getElementById('dwgDxfSurveyor')?.value || null;
                        formData.supervisor = document.getElementById('dwgDxfSupervisor')?.value || null;
                        formData.district = document.getElementById('dwgDxfDistrict')?.value || null;
                        formData.additional_info = document.getElementById('dwgDxfAdditionalInfo')?.value || null;
                    }

                    // Save metadata to database
                    const { data: dbData, error: dbError } = await supabase
                        .from('project_drawings')
                        .insert([formData])
                        .select();

                    if (dbError) {
                        throw dbError;
                    }

                    // Success
                    showToast('Project uploaded successfully!', 'success');

                    // Reset form
                    resetDwgDxfForm();

                } catch (error) {
                    console.error('Upload error:', error);
                    statusDiv.textContent = error.message || 'Upload failed. Please try again.';
                    statusDiv.className = 'upload-status error';
                    statusDiv.style.display = 'block';
                    showToast('Upload failed: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    progressContainer.style.display = 'none';
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = '<i class="fas fa-save"></i> Save & Upload';
                }
            }

            // Reset File/CSV Form
            function resetFileCsvForm() {
                document.getElementById('fileCsvClient').value = '';
                document.getElementById('fileCsvNature').value = '';
                document.getElementById('fileCsvInput').value = '';
                document.getElementById('fileCsvFileName').textContent = '';
                document.getElementById('fileCsvDynamicFields').innerHTML = '';
                document.getElementById('fileCsvCoords').style.display = 'none';

                // Remove pin
                if (projectLibraryState.currentProjectPin) {
                    projectPinsSource.removeFeature(projectLibraryState.currentProjectPin);
                    projectLibraryState.currentProjectPin = null;
                }

                projectLibraryState.selectedProjectCoordinate = null;
                projectLibraryState.projectLocationSelected = false;

                const formContainer = document.getElementById('fileCsvFormContainer');
                formContainer.style.opacity = '0.5';
                formContainer.style.pointerEvents = 'none';
                document.getElementById('fileCsvSaveBtn').disabled = true;
            }

            // Reset DWG/DXF Form
            function resetDwgDxfForm() {
                document.getElementById('dwgDxfClient').value = '';
                document.getElementById('dwgDxfNature').value = '';
                document.getElementById('dwgDxfInput').value = '';
                document.getElementById('dwgDxfFileName').textContent = '';
                document.getElementById('dwgDxfDynamicFields').innerHTML = '';
                document.getElementById('dwgDxfCoords').style.display = 'none';

                // Remove pin
                if (projectLibraryState.currentProjectPin) {
                    projectPinsSource.removeFeature(projectLibraryState.currentProjectPin);
                    projectLibraryState.currentProjectPin = null;
                }

                projectLibraryState.selectedProjectCoordinate = null;
                projectLibraryState.projectLocationSelected = false;

                const formContainer = document.getElementById('dwgDxfFormContainer');
                formContainer.style.opacity = '0.5';
                formContainer.style.pointerEvents = 'none';
                document.getElementById('dwgDxfSaveBtn').disabled = true;
            }

            // Perform Project Search
            async function performProjectSearch(type) {
                const nature = document.getElementById('searchNature').value;
                const client = document.getElementById('searchClient').value.trim();
                const district = document.getElementById('searchDistrict').value;
                const county = document.getElementById('searchCounty').value.trim();
                const blockNumber = document.getElementById('searchBlockNumber').value.trim();
                const plotNumber = document.getElementById('searchPlotNumber').value.trim();
                const projectName = document.getElementById('searchProjectName').value.trim();
                const surveyor = document.getElementById('searchSurveyor').value.trim();
                const coordinateSystem = document.getElementById('searchCoordinateSystem').value;
                const dateFrom = document.getElementById('searchDateFrom').value;
                const dateTo = document.getElementById('searchDateTo').value;
                const sortBy = document.getElementById('searchSortBy').value;

                const tableName = type === 'files' ? 'project_files' : 'project_drawings';

                // Build query
                let query = supabase.from(tableName).select('*');

                if (nature) query = query.eq('nature', nature);
                if (client) query = query.ilike('client', `%${client}%`);
                if (district) query = query.eq('district', district);
                if (county) query = query.ilike('county', `%${county}%`);
                if (blockNumber) query = query.ilike('block_number', `%${blockNumber}%`);
                if (plotNumber) query = query.ilike('plot_number', `%${plotNumber}%`);
                if (projectName) query = query.ilike('project_name', `%${projectName}%`);
                if (surveyor) query = query.ilike('surveyor', `%${surveyor}%`);
                if (coordinateSystem) query = query.eq('coordinate_system', coordinateSystem);
                if (dateFrom) query = query.gte('uploaded_at', dateFrom);
                if (dateTo) query = query.lte('uploaded_at', dateTo);

                // Apply sorting
                if (sortBy) {
                    const [column, order] = sortBy.split(' ');
                    query = query.order(column, { ascending: order === 'ASC' });
                } else {
                    query = query.order('uploaded_at', { ascending: false });
                }

                try {
                    const { data, error } = await query;

                    if (error) throw error;

                    displaySearchResults(data || [], type);
                    plotProjectsOnMap(data || [], type);

                } catch (error) {
                    console.error('Search error:', error);
                    showToast('Search failed: ' + error.message, 'error');
                }
            }

            // Display Search Results
            function displaySearchResults(results, type) {
                const resultsList = document.getElementById('resultsList');
                const resultsCount = document.getElementById('resultsCount');

                resultsCount.textContent = `${results.length} ${results.length === 1 ? 'project' : 'projects'} found`;

                if (results.length === 0) {
                    resultsList.innerHTML = '<p class="no-results">No projects found matching your criteria.</p>';
                    return;
                }

                resultsList.innerHTML = results.map((project, index) => {
                    const projectName = project.project_name || project.file_name || 'Unnamed Project';
                    const district = project.district || 'N/A';
                    const uploadedDate = new Date(project.uploaded_at).toLocaleDateString();

                    return `
                    <div class="project-result-item" data-index="${index}" data-project-id="${project.id}">
                        <h4>${projectName}</h4>
                        <div class="result-meta">
                            <div><strong>Client:</strong> ${project.client}</div>
                            <div><strong>District:</strong> ${district}</div>
                            <div><strong>Uploaded:</strong> ${uploadedDate}</div>
                            ${project.surveyor ? `<div><strong>Surveyor:</strong> ${project.surveyor}</div>` : ''}
                        </div>
                        <div class="result-actions">
                            <button class="result-action-btn view" onclick="viewProjectDetails('${project.id}', '${type}')">
                                <i class="fas fa-eye"></i> View
                            </button>
                            <button class="result-action-btn download" onclick="downloadProjectFile('${project.id}', '${type}')">
                                <i class="fas fa-download"></i> Download
                            </button>
                            <button class="result-action-btn map" onclick="zoomToProject('${project.id}', '${type}')">
                                <i class="fas fa-map-marker-alt"></i> Map
                            </button>
                        </div>
                    </div>
                `;
                }).join('');
            }

            // Plot Projects on Map
            function plotProjectsOnMap(projects, type) {
                // Clear existing project pins (except temporary)
                const features = projectPinsSource.getFeatures();
                features.forEach(feature => {
                    if (!feature.get('isTemporary')) {
                        projectPinsSource.removeFeature(feature);
                    }
                });

                // Add pins for each project
                projects.forEach(project => {
                    const coordinate = ol.proj.fromLonLat([project.longitude, project.latitude]);
                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        nature: project.nature,
                        label: project.project_name || project.file_name,
                        projectId: project.id,
                        projectType: type
                    });
                    projectPinsSource.addFeature(feature);
                });
            }

            // Zoom to Project
            async function zoomToProject(projectId, type) {
                const tableName = type === 'files' ? 'project_files' : 'project_drawings';

                try {
                    // Check if projectPinsSource exists
                    if (typeof projectPinsSource === 'undefined' || !projectPinsSource) {
                        console.error('Project pins source not available');
                        showToast('Map layer not initialized', 'error');
                        return;
                    }

                    const { data, error } = await supabase
                        .from(tableName)
                        .select('latitude, longitude, file_name, project_name, nature')
                        .eq('id', projectId)
                        .single();

                    if (error || !data) {
                        console.error('Error fetching project:', error);
                        showToast('Project location not found', 'error');
                        return;
                    }

                    if (!data.latitude || !data.longitude) {
                        showToast('Project location coordinates not available', 'error');
                        return;
                    }

                    console.log('Zooming to project:', {
                        projectId: projectId,
                        lat: data.latitude,
                        lng: data.longitude,
                        name: data.project_name || data.file_name
                    });

                    const coordinate = ol.proj.fromLonLat([data.longitude, data.latitude]);

                    // Remove any existing pin for this project
                    const existingFeatures = projectPinsSource.getFeatures();
                    existingFeatures.forEach(feature => {
                        if (feature.get('projectId') === projectId) {
                            projectPinsSource.removeFeature(feature);
                        }
                    });

                    // Ensure layer is visible
                    if (projectPinsLayer) {
                        projectPinsLayer.setVisible(true);
                        console.log('Project pins layer is visible');
                    } else {
                        console.error('Project pins layer not found');
                    }

                    // Determine color based on nature
                    const nature = data.nature || 'other';
                    let color = '#3498db'; // Default blue
                    if (nature === 'control_points') color = '#3498db'; // Blue
                    else if (nature === 'jrj') color = '#27ae60'; // Green
                    else if (nature === 'land_survey') color = '#e74c3c'; // Red
                    else color = '#95a5a6'; // Gray for other

                    // Create a more visible pin style
                    const pinStyle = new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 12,
                            fill: new ol.style.Fill({
                                color: color + 'CC'
                            }),
                            stroke: new ol.style.Stroke({
                                color: color,
                                width: 3
                            })
                        }),
                        text: new ol.style.Text({
                            text: data.project_name || data.file_name || 'Project',
                            offsetY: -25,
                            font: 'bold 12px sans-serif',
                            fill: new ol.style.Fill({ color: color }),
                            stroke: new ol.style.Stroke({ color: 'white', width: 3 }),
                            overflow: true
                        })
                    });

                    // Add pin for this project with explicit style
                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(coordinate),
                        nature: nature,
                        label: data.project_name || data.file_name || 'Project',
                        projectId: projectId,
                        projectType: type,
                        isHighlighted: true
                    });

                    // Set explicit style on the feature
                    feature.setStyle(pinStyle);

                    // Add feature to source
                    projectPinsSource.addFeature(feature);

                    console.log('Pin added to map:', {
                        coordinate: coordinate,
                        lonLat: [data.longitude, data.latitude],
                        featureId: feature.getId(),
                        nature: feature.get('nature'),
                        label: feature.get('label'),
                        featuresCount: projectPinsSource.getFeatures().length
                    });

                    // Force map to update and render
                    map.updateSize();
                    map.render();

                    // Zoom to location with a slight delay to ensure pin is rendered
                    setTimeout(() => {
                        map.getView().animate({
                            center: coordinate,
                            zoom: 16,
                            duration: 1500
                        }, function () {
                            // After animation, ensure pin is still visible
                            map.render();
                            console.log('Animation complete, pin should be visible');
                        });
                    }, 100);

                    showToast('Zoomed to project location', 'success');
                } catch (error) {
                    console.error('Error zooming to project:', error);
                    showToast('Error zooming to project: ' + error.message, 'error');
                }
            }

            // View Project Details
            async function viewProjectDetails(projectId, type) {
                const tableName = type === 'files' ? 'project_files' : 'project_drawings';

                try {
                    const { data, error } = await supabase
                        .from(tableName)
                        .select('*')
                        .eq('id', projectId)
                        .single();

                    if (error || !data) {
                        showToast('Project details not found', 'error');
                        return;
                    }

                    // Create or get modal element
                    let modal = document.getElementById('projectDetailsModal');
                    if (!modal) {
                        modal = document.createElement('div');
                        modal.id = 'projectDetailsModal';
                        modal.className = 'modal';
                        modal.innerHTML = `
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3><i class="fas fa-folder-open"></i> Project Details</h3>
                                <button class="close-modal" onclick="closeModal('projectDetailsModal')">&times;</button>
                            </div>
                            <div class="modal-body" id="projectDetailsContent">
                                <!-- Content will be inserted here -->
                            </div>
                            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" style="width: auto; min-width: 100px;" onclick="closeModal('projectDetailsModal')">Close</button>
                                <button class="btn btn-primary" id="viewOnMapBtn" style="width: auto; min-width: 150px;" onclick="closeModal('projectDetailsModal'); zoomToProject('${projectId}', '${type}');">
                                    <i class="fas fa-map-marker-alt"></i> View on Map
                                </button>
                            </div>
                        </div>
                    `;
                        document.body.appendChild(modal);

                        // Close modal when clicking outside
                        modal.addEventListener('click', function (e) {
                            if (e.target === modal) {
                                closeModal('projectDetailsModal');
                            }
                        });
                    }

                    // Format the data for display
                    const formatValue = (value) => value || 'N/A';
                    const formatDate = (dateString) => {
                        if (!dateString) return 'N/A';
                        return new Date(dateString).toLocaleString();
                    };

                    const content = document.getElementById('projectDetailsContent');
                    content.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <h4 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Project Information</h4>
                            <p><strong>Project Name:</strong> ${formatValue(data.project_name || data.file_name)}</p>
                            <p><strong>File Name:</strong> ${formatValue(data.file_name)}</p>
                            <p><strong>File Type:</strong> ${formatValue(data.file_type)}</p>
                            <p><strong>Nature:</strong> ${formatValue(data.nature)}</p>
                            <p><strong>Client:</strong> ${formatValue(data.client)}</p>
                            <p><strong>Project Code:</strong> ${formatValue(data.project_code)}</p>
                        </div>
                        <div>
                            <h4 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Location Information</h4>
                            <p><strong>District:</strong> ${formatValue(data.district)}</p>
                            <p><strong>County:</strong> ${formatValue(data.county)}</p>
                            <p><strong>Block Number:</strong> ${formatValue(data.block_number)}</p>
                            <p><strong>Plot Number:</strong> ${formatValue(data.plot_number)}</p>
                            <p><strong>Parish:</strong> ${formatValue(data.parish)}</p>
                            <p><strong>Village:</strong> ${formatValue(data.village)}</p>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <h4 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Survey Information</h4>
                            <p><strong>Surveyor:</strong> ${formatValue(data.surveyor)}</p>
                            <p><strong>Supervisor:</strong> ${formatValue(data.supervisor)}</p>
                            <p><strong>Company:</strong> ${formatValue(data.company)}</p>
                            <p><strong>Survey Date:</strong> ${formatValue(data.survey_date)}</p>
                            <p><strong>Coordinate System:</strong> ${formatValue(data.coordinate_system)}</p>
                            <p><strong>Datum:</strong> ${formatValue(data.datum)}</p>
                        </div>
                        <div>
                            <h4 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Technical Details</h4>
                            <p><strong>Accuracy Level:</strong> ${formatValue(data.accuracy_level)}</p>
                            <p><strong>Number of Points:</strong> ${formatValue(data.number_of_points)}</p>
                            <p><strong>Land Use Type:</strong> ${formatValue(data.land_use_type)}</p>
                            <p><strong>Reference Number:</strong> ${formatValue(data.reference_number)}</p>
                            <p><strong>Latitude:</strong> ${formatValue(data.latitude)}</p>
                            <p><strong>Longitude:</strong> ${formatValue(data.longitude)}</p>
                        </div>
                    </div>
                    ${data.additional_info ? `
                        <div style="margin-top: 20px;">
                            <h4 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">Additional Information</h4>
                            <p style="white-space: pre-wrap;">${data.additional_info}</p>
                        </div>
                    ` : ''}
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; color: #7f8c8d; font-size: 0.9rem;">
                        <p><strong>Uploaded:</strong> ${formatDate(data.uploaded_at)}</p>
                    </div>
                `;

                    // Update the View on Map button with correct projectId
                    const viewOnMapBtn = document.getElementById('viewOnMapBtn');
                    if (viewOnMapBtn) {
                        viewOnMapBtn.setAttribute('onclick', `closeModal('projectDetailsModal'); zoomToProject('${projectId}', '${type}');`);
                    }

                    // Show modal
                    openModal('projectDetailsModal');

                } catch (error) {
                    console.error('Error loading project details:', error);
                    showToast('Error loading project details: ' + error.message, 'error');
                }
            }

            // Download Project File
            async function downloadProjectFile(projectId, type) {
                const tableName = type === 'files' ? 'project_files' : 'project_drawings';

                try {
                    const { data, error } = await supabase
                        .from(tableName)
                        .select('file_path, file_name')
                        .eq('id', projectId)
                        .single();

                    if (error || !data) {
                        showToast('File not found', 'error');
                        return;
                    }

                    // Get download URL
                    const { data: urlData } = supabase.storage
                        .from('uploads')
                        .getPublicUrl(data.file_path);

                    // Create download link
                    const link = document.createElement('a');
                    link.href = urlData.publicUrl;
                    link.download = data.file_name;
                    link.click();

                    showToast('Download started', 'success');

                } catch (error) {
                    console.error('Download error:', error);
                    showToast('Download failed: ' + error.message, 'error');
                }
            }

            // Initialize Project Library
            function initializeProjectLibrary() {
                console.log('Project Library: Starting initialization...');

                try {
                    // Populate search form dropdowns
                    const searchNature = document.getElementById('searchNature');
                    if (searchNature) {
                        // Function to populate nature dropdown based on type
                        const populateNatureDropdown = (type) => {
                            searchNature.innerHTML = '<option value="">All Types</option>';
                            if (type === 'files') {
                                searchNature.innerHTML += '<option value="control_points">Control Points</option>';
                                searchNature.innerHTML += '<option value="jrj">JRJ</option>';
                                searchNature.innerHTML += '<option value="other">Other</option>';
                            } else if (type === 'drawings') {
                                searchNature.innerHTML += '<option value="land_survey">Land Survey</option>';
                                searchNature.innerHTML += '<option value="other">Other Project</option>';
                            }
                        };

                        // Set initial based on active tab
                        const activeTab = document.querySelector('.project-search-tab.active');
                        const initialType = activeTab ? activeTab.getAttribute('data-search-type') : 'files';
                        populateNatureDropdown(initialType);

                        // Update when tab changes
                        const searchTabs = document.querySelectorAll('.project-search-tab');
                        searchTabs.forEach(tab => {
                            tab.addEventListener('click', function () {
                                const searchType = this.getAttribute('data-search-type');
                                populateNatureDropdown(searchType);
                            });
                        });

                        console.log('Project Library: Nature dropdown populated');
                    }

                    const searchDistrict = document.getElementById('searchDistrict');
                    if (searchDistrict) {
                        let districts = null;
                        try {
                            districts = (typeof window.UGANDA_DISTRICTS !== 'undefined' ? window.UGANDA_DISTRICTS : null);
                        } catch (e) {
                            districts = null;
                        }
                        if (districts && Array.isArray(districts)) {
                            districts.forEach(district => {
                                const option = document.createElement('option');
                                option.value = district;
                                option.textContent = district;
                                searchDistrict.appendChild(option);
                            });
                            console.log('Project Library: Districts populated');
                        } else {
                            console.warn('Project Library: UGANDA_DISTRICTS not available, skipping district population');
                        }
                    } else {
                        console.warn('Project Library: searchDistrict element not found');
                    }

                    const searchCoordinateSystem = document.getElementById('searchCoordinateSystem');
                    if (searchCoordinateSystem) {
                        const crsSystems = typeof UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? UGANDA_COORDINATE_SYSTEMS : (typeof window.UGANDA_COORDINATE_SYSTEMS !== 'undefined' ? window.UGANDA_COORDINATE_SYSTEMS : null);
                        if (crsSystems && Array.isArray(crsSystems)) {
                            crsSystems.forEach(crs => {
                                const option = document.createElement('option');
                                option.value = crs.value;
                                option.textContent = crs.label;
                                searchCoordinateSystem.appendChild(option);
                            });
                            console.log('Project Library: Coordinate systems populated');
                        } else {
                            console.warn('Project Library: UGANDA_COORDINATE_SYSTEMS not available, skipping CRS population');
                        }
                    } else {
                        console.warn('Project Library: searchCoordinateSystem element not found');
                    }

                    // Location button handlers
                    const fileCsvLocationBtn = document.getElementById('fileCsvLocationBtn');
                    if (fileCsvLocationBtn) {
                        fileCsvLocationBtn.addEventListener('click', function () {
                            handleLocationButtonClick('fileCsv');
                        });
                        console.log('Project Library: File/CSV location button handler attached');
                    }

                    const dwgDxfLocationBtn = document.getElementById('dwgDxfLocationBtn');
                    if (dwgDxfLocationBtn) {
                        dwgDxfLocationBtn.addEventListener('click', function () {
                            handleLocationButtonClick('dwgDxf');
                        });
                        console.log('Project Library: DWG/DXF location button handler attached');
                    }

                    // File upload handlers
                    const fileCsvBrowse = document.getElementById('fileCsvBrowse');
                    const fileCsvInput = document.getElementById('fileCsvInput');
                    if (fileCsvBrowse && fileCsvInput) {
                        fileCsvBrowse.addEventListener('click', () => fileCsvInput.click());
                        fileCsvInput.addEventListener('change', function () {
                            if (this.files.length) {
                                const fileNameDisplay = document.getElementById('fileCsvFileName');
                                if (fileNameDisplay) {
                                    fileNameDisplay.textContent = this.files[0].name;
                                }
                            }
                        });
                        console.log('Project Library: File/CSV upload handlers attached');
                    } else {
                        console.warn('Project Library: fileCsvBrowse or fileCsvInput not found');
                    }

                    const dwgDxfBrowse = document.getElementById('dwgDxfBrowse');
                    const dwgDxfInput = document.getElementById('dwgDxfInput');
                    if (dwgDxfBrowse && dwgDxfInput) {
                        dwgDxfBrowse.addEventListener('click', () => dwgDxfInput.click());
                        dwgDxfInput.addEventListener('change', function () {
                            if (this.files.length) {
                                const fileNameDisplay = document.getElementById('dwgDxfFileName');
                                if (fileNameDisplay) {
                                    fileNameDisplay.textContent = this.files[0].name;
                                }
                            }
                        });
                        console.log('Project Library: DWG/DXF upload handlers attached');
                    } else {
                        console.warn('Project Library: dwgDxfBrowse or dwgDxfInput not found');
                    }

                    // Nature dropdown change handlers
                    const fileCsvNature = document.getElementById('fileCsvNature');
                    if (fileCsvNature) {
                        fileCsvNature.addEventListener('change', function () {
                            if (typeof updateFileCsvFields === 'function') {
                                updateFileCsvFields(this.value);
                            }
                        });
                        console.log('Project Library: File/CSV nature handler attached');
                    }

                    const dwgDxfNature = document.getElementById('dwgDxfNature');
                    if (dwgDxfNature) {
                        dwgDxfNature.addEventListener('change', function () {
                            if (typeof updateDwgDxfFields === 'function') {
                                updateDwgDxfFields(this.value);
                            }
                        });
                        console.log('Project Library: DWG/DXF nature handler attached');
                    }

                    // Save button handlers
                    const fileCsvSaveBtn = document.getElementById('fileCsvSaveBtn');
                    if (fileCsvSaveBtn) {
                        fileCsvSaveBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof saveFileCsvProject === 'function') {
                                saveFileCsvProject();
                            } else {
                                console.error('Project Library: saveFileCsvProject function not found');
                            }
                        });
                        console.log('Project Library: File/CSV save button handler attached');
                    }

                    const dwgDxfSaveBtn = document.getElementById('dwgDxfSaveBtn');
                    if (dwgDxfSaveBtn) {
                        dwgDxfSaveBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof saveDwgDxfProject === 'function') {
                                saveDwgDxfProject();
                            } else {
                                console.error('Project Library: saveDwgDxfProject function not found');
                            }
                        });
                        console.log('Project Library: DWG/DXF save button handler attached');
                    }

                    // Cancel button handlers
                    const fileCsvCancelBtn = document.getElementById('fileCsvCancelBtn');
                    if (fileCsvCancelBtn) {
                        fileCsvCancelBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof resetFileCsvForm === 'function') {
                                resetFileCsvForm();
                            }
                        });
                    }

                    const dwgDxfCancelBtn = document.getElementById('dwgDxfCancelBtn');
                    if (dwgDxfCancelBtn) {
                        dwgDxfCancelBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof resetDwgDxfForm === 'function') {
                                resetDwgDxfForm();
                            }
                        });
                    }

                    // Project Library button
                    const projectLibraryBtn = document.getElementById('projectLibraryBtn');
                    const projectLibraryPanel = document.getElementById('projectLibraryPanel');
                    const closeProjectLibrary = document.getElementById('closeProjectLibrary');

                    if (projectLibraryBtn && projectLibraryPanel) {
                        projectLibraryBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            const mainContent = document.querySelector('.main-content');
                            if (projectLibraryPanel.classList.contains('active')) {
                                projectLibraryPanel.classList.remove('active');
                                if (mainContent) mainContent.classList.remove('panel-open');
                            } else {
                                // Close other panels first
                                document.querySelectorAll('.project-library-panel, .polygon-import-panel, .parcel-search-panel').forEach(p => p.classList.remove('active'));
                                projectLibraryPanel.classList.add('active');
                                if (mainContent) mainContent.classList.add('panel-open');
                            }
                        });
                        console.log('Project Library: Panel toggle button handler attached');
                    } else {
                        console.warn('Project Library: projectLibraryBtn or projectLibraryPanel not found');
                    }

                    if (closeProjectLibrary && projectLibraryPanel) {
                        closeProjectLibrary.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            projectLibraryPanel.classList.remove('active');
                            const mainContent = document.querySelector('.main-content');
                            if (mainContent) mainContent.classList.remove('panel-open');
                        });
                        console.log('Project Library: Close button handler attached');
                    }

                    // Search tab handlers
                    const searchTabs = document.querySelectorAll('.project-search-tab');
                    if (searchTabs.length > 0) {
                        searchTabs.forEach(tab => {
                            tab.addEventListener('click', function (e) {
                                e.preventDefault();
                                e.stopPropagation();
                                searchTabs.forEach(t => t.classList.remove('active'));
                                this.classList.add('active');
                            });
                        });
                        console.log('Project Library: Search tabs handlers attached');
                    }

                    // Search button
                    const projectSearchBtn = document.getElementById('projectSearchBtn');
                    if (projectSearchBtn) {
                        projectSearchBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            const activeTab = document.querySelector('.project-search-tab.active');
                            const searchType = activeTab ? activeTab.getAttribute('data-search-type') : 'files';
                            if (typeof performProjectSearch === 'function') {
                                performProjectSearch(searchType);
                            } else {
                                console.error('Project Library: performProjectSearch function not found');
                            }
                        });
                        console.log('Project Library: Search button handler attached');
                    }

                    // Reset search button
                    const projectSearchResetBtn = document.getElementById('projectSearchResetBtn');
                    if (projectSearchResetBtn) {
                        projectSearchResetBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            const searchNature = document.getElementById('searchNature');
                            const searchClient = document.getElementById('searchClient');
                            const searchDistrict = document.getElementById('searchDistrict');
                            const searchCounty = document.getElementById('searchCounty');
                            const searchBlockNumber = document.getElementById('searchBlockNumber');
                            const searchPlotNumber = document.getElementById('searchPlotNumber');
                            const searchProjectName = document.getElementById('searchProjectName');
                            const searchSurveyor = document.getElementById('searchSurveyor');
                            const searchCoordinateSystem = document.getElementById('searchCoordinateSystem');
                            const searchDateFrom = document.getElementById('searchDateFrom');
                            const searchDateTo = document.getElementById('searchDateTo');
                            const searchSortBy = document.getElementById('searchSortBy');
                            const resultsList = document.getElementById('resultsList');
                            const resultsCount = document.getElementById('resultsCount');

                            if (searchNature) searchNature.value = '';
                            if (searchClient) searchClient.value = '';
                            if (searchDistrict) searchDistrict.value = '';
                            if (searchCounty) searchCounty.value = '';
                            if (searchBlockNumber) searchBlockNumber.value = '';
                            if (searchPlotNumber) searchPlotNumber.value = '';
                            if (searchProjectName) searchProjectName.value = '';
                            if (searchSurveyor) searchSurveyor.value = '';
                            if (searchCoordinateSystem) searchCoordinateSystem.value = '';
                            if (searchDateFrom) searchDateFrom.value = '';
                            if (searchDateTo) searchDateTo.value = '';
                            if (searchSortBy) searchSortBy.value = 'uploaded_at DESC';
                            if (resultsList) resultsList.innerHTML = '<p class="no-results">Use the search form above to find projects.</p>';
                            if (resultsCount) resultsCount.textContent = 'No results';
                            if (typeof projectPinsSource !== 'undefined' && projectPinsSource) {
                                projectPinsSource.clear();
                            }
                        });
                        console.log('Project Library: Reset button handler attached');
                    }

                    // Start location selection when tabs are clicked
                    const gspnetTabs = document.querySelectorAll('.gspnet-tab');
                    if (gspnetTabs.length > 0) {
                        gspnetTabs.forEach(tab => {
                            tab.addEventListener('click', function (e) {
                                const targetTab = this.getAttribute('data-tab');
                                if (targetTab === 'file-csv-upload') {
                                    if (typeof startLocationSelection === 'function') {
                                        startLocationSelection('fileCsv');
                                    }
                                } else if (targetTab === 'dwg-dxf-upload') {
                                    if (typeof startLocationSelection === 'function') {
                                        startLocationSelection('dwgDxf');
                                    }
                                } else {
                                    if (typeof stopLocationSelection === 'function') {
                                        stopLocationSelection();
                                    }
                                }
                            });
                        });
                        console.log('Project Library: GSP.NET tabs handlers attached');
                    }

                    console.log('Project Library: All event listeners attached successfully');
                } catch (error) {
                    console.error('Project Library: Error during initialization:', error);
                }
            }

            // Initialize when DOM is ready and dependencies are loaded
            function initProjectLibraryWhenReady() {
                waitForDependencies(() => {
                    console.log('Project Library: Dependencies loaded, initializing...');
                    try {
                        initializeProjectLibrary();
                        console.log('Project Library: Initialization complete');
                    } catch (error) {
                        console.error('Project Library: Initialization error:', error);
                    }
                });
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initProjectLibraryWhenReady);
            } else {
                initProjectLibraryWhenReady();
            }
        </script>

        <!-- Quality Flags Side Panel -->
        <div class="quality-flags-dock" id="qualityFlagsDock" aria-hidden="true">
            <div class="dock-header">
                <h3><i class="fas fa-flag-checkered"></i> Quality Flags</h3>
                <button class="dock-close" id="qualityFlagsClose">&times;</button>
            </div>
            <div class="dock-body">
                <!-- Tab Selection -->
                <div class="quality-tabs">
                    <button class="quality-tab active" data-tab="flag" id="flagTabBtn">
                        <i class="fas fa-flag"></i> Flag Parcel
                    </button>
                    <button class="quality-tab" data-tab="check" id="checkTabBtn">
                        <i class="fas fa-search"></i> Check Flags
                    </button>
                </div>

                <!-- Flag Parcel Section -->
                <div class="quality-section active" id="flagSection">
                    <div class="section-header">
                        <h4>Flag a Parcel</h4>
                        <p class="section-description">Report data quality issues or verify data accuracy</p>
                    </div>

                    <form id="flagParcelForm">
                        <div class="form-group">
                            <label for="flagDistrict">District <span class="required">*</span></label>
                            <select id="flagDistrict" class="form-select" required>
                                <option value="">Select District</option>
                                <!-- Populated dynamically -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="flagCounty">County</label>
                            <input type="text" id="flagCounty" class="form-input" placeholder="Enter county name">
                        </div>

                        <div class="form-group">
                            <label for="parcelType">Parcel Type</label>
                            <div class="radio-group">
                                <label class="radio-label">
                                    <input type="radio" name="parcelType" value="titled" checked>
                                    <span>Titled (Block & Plot)</span>
                                </label>
                                <label class="radio-label">
                                    <input type="radio" name="parcelType" value="untitled">
                                    <span>Untitled (Other)</span>
                                </label>
                            </div>
                        </div>

                        <div class="form-group" id="blockPlotGroup">
                            <div class="form-row">
                                <div class="form-col">
                                    <label for="flagBlock">Block</label>
                                    <input type="text" id="flagBlock" class="form-input" placeholder="e.g., 123">
                                </div>
                                <div class="form-col">
                                    <label for="flagPlot">Plot</label>
                                    <input type="text" id="flagPlot" class="form-input" placeholder="e.g., 456">
                                </div>
                            </div>
                        </div>

                        <div class="form-group" id="otherParcelGroup" style="display: none;">
                            <label for="otherParcelInfo">Other Parcel Information</label>
                            <input type="text" id="otherParcelInfo" class="form-input"
                                placeholder="Describe the parcel location">
                        </div>

                        <div class="form-group">
                            <label>Select Location on Map <span class="required">*</span></label>
                            <button type="button" class="btn btn-secondary" id="selectOnMapBtn">
                                <i class="fas fa-map-marker-alt"></i> Select on Map
                            </button>
                            <div id="selectedLocationInfo" class="location-info" style="display: none;">
                                <i class="fas fa-check-circle"></i> Location selected
                                <span id="selectedCoordinates"></span>
                            </div>
                            <button type="button" class="btn btn-danger btn-sm" id="cancelSelectionBtn"
                                style="display: none;">
                                <i class="fas fa-times"></i> Cancel Selection
                            </button>
                        </div>

                        <div class="form-group">
                            <label for="flagType">Flag Type <span class="required">*</span></label>
                            <select id="flagType" class="form-select" required>
                                <option value="">Select Flag Type</option>
                                <option value="red">Bad/Untrusted Data</option>
                                <option value="yellow">Needs Review</option>
                                <option value="green">Verified/Trusted Data</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="reporterName">Your Name <span class="required">*</span></label>
                            <input type="text" id="reporterName" class="form-input" required
                                placeholder="Enter your full name">
                        </div>

                        <div class="form-group">
                            <label for="reporterContact">Contact (Phone or Email) <span
                                    class="required">*</span></label>
                            <input type="text" id="reporterContact" class="form-input" required
                                placeholder="Phone: +256... or Email: name@example.com">
                            <small class="form-help">Enter phone number or email address</small>
                        </div>

                        <div class="form-group">
                            <label for="flagReason">Reason for Flagging <span class="required">*</span></label>
                            <textarea id="flagReason" class="form-textarea" rows="4" required
                                placeholder="Explain why you are flagging this parcel (max 1000 characters)"
                                maxlength="1000"></textarea>
                            <small class="form-help"><span id="reasonCharCount">0</span>/1000 characters</small>
                        </div>

                        <button type="submit" class="btn btn-primary" id="submitFlagBtn">
                            <i class="fas fa-flag"></i> Submit Flag
                        </button>
                    </form>
                </div>

                <!-- Check Flags Section -->
                <div class="quality-section" id="checkSection">
                    <div class="section-header">
                        <h4>Check Flags</h4>
                        <p class="section-description">Search and view flagged parcels</p>
                    </div>

                    <!-- Filters -->
                    <div class="filters-section">
                        <div class="form-group">
                            <label for="checkDistrict">District</label>
                            <select id="checkDistrict" class="form-select">
                                <option value="">All Districts</option>
                                <!-- Populated dynamically -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="checkCounty">County</label>
                            <input type="text" id="checkCounty" class="form-input" placeholder="Filter by county name">
                        </div>

                        <div class="form-group">
                            <label for="checkFlagType">Flag Type</label>
                            <select id="checkFlagType" class="form-select">
                                <option value="">All Types</option>
                                <option value="red">Bad/Untrusted</option>
                                <option value="yellow">Needs Review</option>
                                <option value="green">Verified/Trusted</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="dateRange">Date Range</label>
                            <div class="form-row">
                                <input type="date" id="dateFrom" class="form-input">
                                <input type="date" id="dateTo" class="form-input">
                            </div>
                        </div>

                        <button type="button" class="btn btn-primary" id="searchFlagsBtn">
                            <i class="fas fa-search"></i> Search Flags
                        </button>
                        <button type="button" class="btn btn-secondary" id="clearFiltersBtn">
                            <i class="fas fa-times"></i> Clear Filters
                        </button>
                    </div>

                    <!-- Statistics -->
                    <div class="statistics-section" id="statisticsSection" style="display: none;">
                        <h5>Statistics</h5>
                        <div class="stats-grid">
                            <div class="stat-item red">
                                <span class="stat-value" id="statRed">0</span>
                                <span class="stat-label">Bad Data</span>
                            </div>
                            <div class="stat-item yellow">
                                <span class="stat-value" id="statYellow">0</span>
                                <span class="stat-label">Needs Review</span>
                            </div>
                            <div class="stat-item green">
                                <span class="stat-value" id="statGreen">0</span>
                                <span class="stat-label">Verified</span>
                            </div>
                        </div>
                    </div>

                    <!-- Flags List -->
                    <div class="flags-list-container">
                        <div id="flagsList" class="flags-list">
                            <div class="empty-state">
                                <i class="fas fa-search"></i>
                                <p>Use filters above to search for flags</p>
                            </div>
                        </div>
                        <div id="flagsLoading" class="loading-state" style="display: none;">
                            <i class="fas fa-spinner fa-spin"></i> Loading flags...
                        </div>
                    </div>

                    <!-- Export Options -->
                    <div class="export-section" id="exportSection" style="display: none;">
                        <button type="button" class="btn btn-success" id="exportCSVBtn">
                            <i class="fas fa-file-csv"></i> Export CSV
                        </button>
                        <button type="button" class="btn btn-success" id="exportPDFBtn">
                            <i class="fas fa-file-pdf"></i> Export PDF
                        </button>
                    </div>
                </div>

                <!-- Flag Detail View (shown when flag is selected) -->
                <div class="quality-section" id="flagDetailSection" style="display: none;">
                    <div class="flag-detail-header">
                        <button type="button" class="btn-back" id="backToListBtn">
                            <i class="fas fa-arrow-left"></i> Back to List
                        </button>
                        <h4 id="flagDetailTitle">Flag Details</h4>
                    </div>
                    <div id="flagDetailContent" class="flag-detail-content">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- SYMBOLS LIBRARY SIDE PANEL -->
        <!-- ============================================ -->
        <style>
            .symbols-library-dock {
                position: fixed;
                top: 0;
                right: 0;
                width: 400px;
                height: 100vh;
                background: white;
                box-shadow: -2px 0 10px rgba(0, 0, 0, 0.15);
                z-index: 9999;
                overflow-y: auto;
            }

            .symbols-library-dock .dock-header {
                background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                color: white;
                padding: 15px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid #1d4ed8;
            }

            .symbols-library-dock .dock-header h3 {
                margin: 0;
                font-size: 18px;
                font-weight: 600;
            }

            .symbols-library-dock .dock-close {
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: white;
                font-size: 24px;
                width: 32px;
                height: 32px;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }

            .symbols-library-dock .dock-close:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .symbols-library-dock .dock-body {
                padding: 0;
            }

            .symbols-tabs {
                display: flex;
                background: #f3f4f6;
                border-bottom: 2px solid #e5e7eb;
                overflow-x: auto;
            }

            .symbols-tab {
                flex: 1;
                padding: 12px 8px;
                background: transparent;
                border: none;
                border-bottom: 3px solid transparent;
                font-size: 12px;
                font-weight: 500;
                color: #6b7280;
                cursor: pointer;
                transition: all 0.2s;
                white-space: nowrap;
            }

            .symbols-tab:hover {
                background: rgba(59, 130, 246, 0.1);
                color: #3b82f6;
            }

            .symbols-tab.active {
                background: white;
                color: #3b82f6;
                border-bottom-color: #3b82f6;
            }

            .symbols-tab i {
                margin-right: 4px;
            }

            .symbols-tab-content {
                min-height: 300px;
            }

            .draw-tool-btn,
            .action-btn {
                width: 100%;
                padding: 10px;
                margin: 5px 0;
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 14px;
                cursor: pointer;
                transition: background 0.2s;
            }

            .draw-tool-btn:hover,
            .action-btn:hover {
                background: #2563eb;
            }

            .draw-tool-btn i,
            .action-btn i {
                margin-right: 6px;
            }
        </style>

        <div class="symbols-library-dock" id="symbolsLibraryDock" style="display: none;">
            <div class="dock-header">
                <h3><i class="fas fa-map-marked-alt"></i> Symbols Library</h3>
                <button class="dock-close" id="symbolsLibraryClose">&times;</button>
            </div>
            <div class="dock-body">
                <!-- Tab Selection -->
                <div class="symbols-tabs">
                    <button class="symbols-tab active" data-tab="catalog" id="catalogTabBtn">
                        <i class="fas fa-th"></i> Catalog
                    </button>
                    <button class="symbols-tab" data-tab="draw" id="drawTabBtn">
                        <i class="fas fa-pen"></i> Draw
                    </button>
                    <button class="symbols-tab" data-tab="myfeatures" id="myfeaturesTabBtn">
                        <i class="fas fa-layer-group"></i> My Features
                    </button>
                    <button class="symbols-tab" data-tab="flags" id="flagsTabBtn">
                        <i class="fas fa-flag"></i> Flags
                    </button>
                    <button class="symbols-tab" data-tab="legend" id="legendTabBtn">
                        <i class="fas fa-list"></i> Legend
                    </button>
                </div>

                <!-- Tab Content Areas -->

                <!-- Catalog Tab -->
                <div class="symbols-tab-content active" id="catalogTab">
                    <div style="padding: 10px;">
                        <p style="color: #6b7280; font-size: 14px;">Loading symbols...</p>
                    </div>
                </div>

                <!-- Draw Tab -->
                <div class="symbols-tab-content" id="drawTab" style="display: none;">
                    <div style="padding: 10px;">
                        <h4 style="margin-top: 0;">Draw Features</h4>
                        <p style="font-size: 13px; color: #6b7280;">Select a symbol from the Catalog tab, then choose a
                            drawing tool:</p>

                        <div style="margin: 15px 0;">
                            <button id="drawPointBtn" class="draw-tool-btn">
                                <i class="fas fa-map-pin"></i> Draw Point
                            </button>
                            <button id="drawLineBtn" class="draw-tool-btn">
                                <i class="fas fa-minus"></i> Draw Line
                            </button>
                            <button id="drawPolygonBtn" class="draw-tool-btn">
                                <i class="fas fa-draw-polygon"></i> Draw Polygon
                            </button>
                            <button id="stopDrawBtn" class="draw-tool-btn" style="background: #dc2626;">
                                <i class="fas fa-stop"></i> Stop Drawing
                            </button>
                        </div>

                        <div id="drawFormContainer"></div>
                    </div>
                </div>

                <!-- My Features Tab -->
                <div class="symbols-tab-content" id="myfeaturesTab" style="display: none;">
                    <div style="padding: 10px;">
                        <h4 style="margin-top: 0;">My Features</h4>
                        <div style="margin-bottom: 15px;">
                            <button id="loadFeaturesBtn" class="action-btn">
                                <i class="fas fa-download"></i> Load Features
                            </button>
                            <label style="display: block; margin-top: 10px;">
                                <input type="checkbox" id="autoLoadToggle" />
                                <span style="margin-left: 5px; font-size: 13px;">Auto-load on map move</span>
                            </label>
                        </div>
                        <div id="myFeaturesListContainer">
                            <p style="color: #6b7280; font-size: 13px;">Click "Load Features" to see your features.</p>
                        </div>
                    </div>
                </div>

                <!-- Flags Tab -->
                <div class="symbols-tab-content" id="flagsTab" style="display: none;">
                    <div style="padding: 10px;">
                        <h4 style="margin-top: 0;">Flagged Features</h4>
                        <p style="font-size: 13px; color: #6b7280;">View and manage flagged features (coming soon in v1)
                        </p>
                    </div>
                </div>

                <!-- Legend Tab -->
                <div class="symbols-tab-content" id="legendTab" style="display: none;">
                    <div style="padding: 10px;">
                        <h4 style="margin-top: 0;">Legend</h4>
                        <button id="exportLegendBtn" class="action-btn">
                            <i class="fas fa-file-pdf"></i> Export Legend PDF
                        </button>
                        <p style="font-size: 13px; color: #6b7280; margin-top: 10px;">Export a PDF showing all symbols
                            you've used (coming soon in v1)</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- LAND CLERK REGISTRATION MODAL -->
        <!-- ============================================ -->
        <div id="clerkModal" class="clerk-modal" style="display: none;">
            <div class="clerk-modal-content">
                <div class="clerk-header">
                    <h2>🏛️ Land Registration System</h2>
                    <button class="clerk-close" id="closeClerkModal">&times;</button>
                </div>

                <div class="clerk-tabs">
                    <button class="clerk-tab active" data-tab="register">Register New</button>
                    <button class="clerk-tab" data-tab="transfer">Transfer</button>
                    <button class="clerk-tab" data-tab="search">Search</button>
                </div>

                <div id="clerkContent" class="clerk-content">
                    <!-- Content loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- SYMBOLS LIBRARY MODULE IMPORT -->
        <!-- ============================================ -->
        <script type="module">
            import { initSymbolsLibrary } from './symbols-library.js';

            // Initialize when DOM is ready and map is available
            function initSymbols() {
                // Wait for map and supabaseClient to be available
                if (typeof map !== 'undefined' && typeof supabaseClient !== 'undefined') {
                    console.log('Initializing Symbols Library...');
                    initSymbolsLibrary(map, supabaseClient);

                    // Setup dock toggle handlers
                    setupSymbolsLibraryDock();
                } else {
                    // Retry after a short delay
                    setTimeout(initSymbols, 500);
                }
            }

            function setupSymbolsLibraryDock() {
                const dock = document.getElementById('symbolsLibraryDock');
                const closeBtn = document.getElementById('symbolsLibraryClose');
                const toggleBtn = document.getElementById('symbolsLibraryToggleBtn');

                // Toggle button
                if (toggleBtn) {
                    toggleBtn.onclick = () => {
                        if (dock.style.display === 'none') {
                            dock.style.display = 'block';
                        } else {
                            dock.style.display = 'none';
                        }
                    };
                }

                // Close button
                if (closeBtn) {
                    closeBtn.onclick = () => {
                        dock.style.display = 'none';
                    };
                }

                // Tab switching
                const tabButtons = document.querySelectorAll('.symbols-tab');
                const tabContents = document.querySelectorAll('.symbols-tab-content');

                tabButtons.forEach(btn => {
                    btn.onclick = () => {
                        const targetTab = btn.dataset.tab;

                        // Remove active class from all tabs and contents
                        tabButtons.forEach(b => b.classList.remove('active'));
                        tabContents.forEach(c => {
                            c.classList.remove('active');
                            c.style.display = 'none';
                        });

                        // Add active class to clicked tab and show content
                        btn.classList.add('active');
                        const targetContent = document.getElementById(targetTab + 'Tab');
                        if (targetContent) {
                            targetContent.classList.add('active');
                            targetContent.style.display = 'block';
                        }
                    };
                });

                console.log('Symbols Library dock handlers attached');
            }

            // Start initialization
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initSymbols);
            } else {
                initSymbols();
            }
        </script>

        <!-- Symbols Library Module -->
        <script type="module">
            console.log('[SYMBOLS] Module script started');

            import { initSymbolsLibrary } from './symbols-library.js';

            console.log('[SYMBOLS] Module imported successfully');

            // Wait for map to be ready
            function initSymbolsLibraryWhenReady() {
                console.log('[SYMBOLS] Checking for map and supabase...', {
                    hasMap: typeof map !== 'undefined',
                    mapValue: typeof map !== 'undefined' ? 'exists' : 'undefined',
                    hasWindowSupabase: typeof window.supabaseClient !== 'undefined',
                    supabaseValue: typeof window.supabaseClient !== 'undefined' ? 'exists' : 'undefined'
                });

                if (typeof map !== 'undefined' && map &&
                    typeof window.supabaseClient !== 'undefined' && window.supabaseClient) {
                    console.log('[SYMBOLS] Initializing Symbols Library...');
                    initSymbolsLibrary(map, window.supabaseClient).catch(error => {
                        console.error('[SYMBOLS] Failed to initialize:', error);
                    });
                } else {
                    console.log('[SYMBOLS] Waiting for dependencies... retrying in 100ms');
                    setTimeout(initSymbolsLibraryWhenReady, 100);
                }
            }

            // Start initialization when DOM is ready
            console.log('[SYMBOLS] Document ready state:', document.readyState);
            if (document.readyState === 'loading') {
                console.log('[SYMBOLS] Waiting for DOMContentLoaded');
                document.addEventListener('DOMContentLoaded', initSymbolsLibraryWhenReady);
            } else {
                console.log('[SYMBOLS] DOM already loaded, starting init');
                initSymbolsLibraryWhenReady();
            }
        </script>

</body>

</html>